{"code": "def sum(k):\n    ret = 0\n    pw = 10\n    len = 1\n    while 1 == 1:\n        cur = min(pw - 1, k)\n        prev = pw; prev = prev // 10\n        ret += (cur - prev + 1) * len\n        if (pw - 1 >= k):\n            break\n        len += 1\n        pw *= 10\n    return ret\n\n\nw, m, k = map(int, input().split())\nlo = 0\nhi = int(1e18)\nwhile hi - lo > 1:\n    md = (lo + hi); md = md // 2\n    c = sum(m + md - 1); c = c - sum(m - 1)\n    if c * k <= w:\n        lo = md\n    else:\n        hi = md\nprint(lo)\n", "id": "AssignUnfoldding_sample_from_codeforces_373_B_to_0", "old_id": "codeforces_373_B"}
{"code": "princess = int(input())\ndragon = int(input())\nt = int(input())\nf = int(input())\nc = int(input())\nif dragon <= princess:\n    print(0)\n    exit(0)\nresult = 0\nposition = t; position = position * princess\nposition += princess * position / (dragon - princess)\nwhile position < c:\n    result += 1\n    position += princess * position / dragon\n    position += princess * f\n    position += princess * position / (dragon - princess)\nprint(result)\n", "id": "AssignUnfoldding_sample_from_codeforces_148_B_to_1", "old_id": "codeforces_148_B"}
{"code": "import numpy as np\nN = int(input())\nA = np.fromiter(map(int, input().split()), np.int64)\nresult = 0\nfor b in range(60):\n    bs = int(((A >> b) & 1).sum())\n    result = (result + bs * (N - bs) * (1 << b)); result = result % 1000000007\nprint(result)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC147_D_to_2", "old_id": "atcoder_ABC147_D"}
{"code": "mod = 10 ** 9; mod = mod + 7\nn, k = map(int, input().split())\ncoef = []\nfor i in range(1, int(n ** 0.5) + 1):\n    coef.append((n // i) - (n // (i + 1)))\ncoef += [1] * (n - sum(coef))\ncoef = coef[:: - 1]\nnn = len(coef)\ndp = [[0] * nn for _ in range(k + 1)]\ndp[0][0] = 1\nfor i in range(1, k + 1):\n    tmp = 0\n    for j in range(nn - 1, - 1, - 1):\n        tmp += dp[i - 1][(nn - 1) - j]\n        tmp %= mod\n        dp[i][j] = coef[j]; dp[i][j] = dp[i][j] * tmp\n        dp[i][j] %= mod\nprint(sum(dp[k]) % mod)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC132_F_to_3", "old_id": "atcoder_ABC132_F"}
{"code": "N, K = map(int, input().split())\nS = input()\naaaa = False\nif K >= 15:\n    aaaa = True\nelif 2 ** K >= N:\n    aaaa = True\nif aaaa:\n    print(min(S) * N)\n    exit()\n\n\ndef get_last_dict(s_str):\n    U = s_str; U = U + s_str[:: - 1]\n    c = min(s_str)\n    p = U.index(c)\n    minindex = p\n    p += 1\n    while p <= N:\n        if U[p] == c:\n            if check_normal_dict(U, minindex, p):\n                minindex = p\n        p += 1\n    return U[minindex: minindex + N]\n\n\ndef check_normal_dict(u, pointer1, pointer2):\n    for i in range(N):\n        if u[pointer1 + i] > u[pointer2 + i]:\n            return True\n        elif u[pointer1 + i] < u[pointer2 + i]:\n            return False\n    return False\n\n\nS = get_last_dict(S)\nif K == 1:\n    print(S)\nelse:\n    count = 0\n    for c in S:\n        if c == S[0]:\n            count += 1\n        else:\n            break\n    if count * (2 ** (K - 1)) >= N:\n        print(S[0] * N)\n    else:\n        S = S[0] * (count * ((2 ** (K - 1)) - 1)) + S\n        print(S[0: N])\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC037_E_to_4", "old_id": "atcoder_AGC037_E"}
{"code": "mod = 10 ** 9; mod = mod + 7\nn = int(input())\nc = list(map(int, input().split()))\nc.sort(reverse=True)\nb = pow(2, 2 * n - 2, mod)\na = 2 * b; a = a % mod\nans = 0\nfor i in range(n):\n    ans += c[i] * (a + i * b)\n    ans %= mod\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC150_E_to_5", "old_id": "atcoder_ABC150_E"}
{"code": "v1, v2 = input().split()\nt, d = input().split()\nv1 = int(v1)\nv2 = int(v2)\nt = int(t)\nd = int(d)\na = 1\nv = v1\ndistance = 0\nfor i in range(t):\n    if v - v2 > (t - i - 1) * d:\n        a *= - 1\n        v = (t - i - 1) * d; v = v + v2\n    distance += v\n    v += a * d\nprint(distance)\n", "id": "AssignUnfoldding_sample_from_codeforces_534_B_to_6", "old_id": "codeforces_534_B"}
{"code": "import sys\nimport math\nimport collections\nimport heapq\nimport itertools\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while a % b > 0:\n        a, b = b, a % b\n    return b\n\n\ndef solve():\n    s = input()\n    t = \"\"\n    i = 0\n    while i < len(s):\n        if s[i] == \"A\":\n            t += \"A\"\n            i += 1\n        elif s[i] == \"B\":\n            if i < len(s) - 1:\n                if s[i + 1] == \"C\":\n                    t += \"D\"\n                    i += 2\n                else:\n                    t += \"X\"\n                    i += 1\n            else:\n                t += \"X\"\n                i += 1\n        else:\n            t += \"X\"\n            i += 1\n    total = 0\n    numA = 0\n    for i in range(len(t)):\n        if t[i] == \"X\":\n            numA = 0\n        else:\n            if t[i] == \"A\":\n                numA += 1\n            else:\n                total += numA\n    print(total)\n    INF = 10; INF = INF ** 25\n    mod = 7; mod = mod + 10 ** 9\n    return 0\n\n\nif __name__ == \"__main__\":\n    solve()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC034_B_to_7", "old_id": "atcoder_AGC034_B"}
{"code": "a, at = map(int, input().split())\nb, bt = map(int, input().split())\nt1, t2 = map(int, input().split(':'))\nst = t2; st = st + (t1 - 5) * 60\nfin = st; fin = fin + at\nnow = 0\nans = 0\nwhile now < fin and now < 1140:\n    if now + bt > st:\n        ans += 1\n    now += b\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_665_A_to_8", "old_id": "codeforces_665_A"}
{"code": "import sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(* (MAP() for _ in range(n)))\n\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9; mod = mod + 7\nN, M = MAP()\nballs = [[1, 0] for _ in range(N)]\nballs[0] = [0, 1]\nfor _ in range(M):\n    x, y = MAP()\n    w_x, r_x = balls[x - 1]\n    w_y, r_y = balls[y - 1]\n    if w_x >= 1 and r_x >= 1:\n        balls[x - 1][0] -= 1\n        balls[y - 1][1] += 1\n    elif w_x == 0:\n        balls[x - 1][1] -= 1\n        balls[y - 1][1] += 1\n    else:\n        balls[x - 1][0] -= 1\n        balls[y - 1][0] += 1\nans = 0\nfor i in range(N):\n    if balls[i][1]:\n        ans += 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC002_B_to_9", "old_id": "atcoder_AGC002_B"}
{"code": "def get_nums(num, t):\n    return [t // num + 1 if i in range(t % num) else t // num for i in range(num)]\n\n\nn, k, l, r, sa, sk = map(int, input().split())\nans = get_nums(k, sk); ans = ans + get_nums(n - k, sa - sk)\nprint(' '.join(map(str, ans)))\n", "id": "AssignUnfoldding_sample_from_codeforces_369_B_to_10", "old_id": "codeforces_369_B"}
{"code": "import sys\ninput = sys.stdin.readline\nn, s = map(int, input().split())\nc = 0\nfor _ in range(n):\n    f, t = map(int, input().split())\n    x = t; x = x - (s - f)\n    if x > c:\n        c = x\nprint(s + c)\n", "id": "AssignUnfoldding_sample_from_codeforces_608_A_to_11", "old_id": "codeforces_608_A"}
{"code": "import sys\ninput = sys.stdin.readline\na, b = input()[: - 1].split()\nx = max(len(a), len(b))\na = a.rjust(x, '0')\nb = b.ljust(x, '0')\ns = ''\nc = 0\nfor i in range(x):\n    d = int(b[i]) + int(a[x - i - 1]); d = d + c\n    if d > 9:\n        s += str(d)[1]\n        c = 1\n    else:\n        s += str(d)\n        c = 0\nif c == 1:\n    s += '1'\nprint(int(s[:: - 1]))\n", "id": "AssignUnfoldding_sample_from_codeforces_171_A_to_12", "old_id": "codeforces_171_A"}
{"code": "cookies = [int(x) for x in input().split()]\nleftOver = cookies[0]; leftOver = leftOver - cookies[2]\ntakahashi = max(0, leftOver)\nprint(str(takahashi) + ' ' +\n      (str(cookies[1]) if takahashi > 0 else str(max(0, cookies[1] - abs(leftOver)))))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC149_B_to_13", "old_id": "atcoder_ABC149_B"}
{"code": "N = int(input())\nA = [int(input()) * N + i for i in range(N)]\nA.sort()\ncnt = 0\nfor i in range(N):\n    d = (A[i] % N); d = d % 2\n    if d % 2 != i % 2:\n        cnt += 1\nprint(cnt // 2)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC003_C_to_14", "old_id": "atcoder_AGC003_C"}
{"code": "p = input().split(\" \")\nx1 = int(p[0])\ny1 = int(p[1])\nx2 = int(p[2])\ny2 = int(p[3])\nDIF1 = x2; DIF1 = DIF1 - x1\nDIF2 = y2; DIF2 = DIF2 - y1\nx3 = x2; x3 = x3 - DIF2\ny3 = y2; y3 = y3 + DIF1\nx4 = x1; x4 = x4 - DIF2\ny4 = y1; y4 = y4 + DIF1\nprint(str(x3) + \" \" + str(y3) + \" \" + str(x4) + \" \" + str(y4))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC108_B_to_15", "old_id": "atcoder_ABC108_B"}
{"code": "def gcd(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef ruiseki_lr(array):\n    def op(a, b): return gcd(a, b)\n    e = 0\n    n = len(array)\n    left = [e]; left = left * (n + 1)\n    right = [e]; right = right * (n + 1)\n    for i in range(n):\n        left[i + 1] = op(left[i], array[i])\n    for i in reversed(range(n)):\n        right[i] = op(right[i + 1], array[i])\n    return left, right\n\n\nn = int(input())\na = list(map(int, input().split()))\nleft, right = ruiseki_lr(a)\nans = 0\nfor i in range(n):\n    ans = max(gcd(left[i], right[i + 1]), ans)\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC125_C_to_16", "old_id": "atcoder_ABC125_C"}
{"code": "def rememberTheNumber(nums, i, operations, ans):\n    if i >= 3:\n        return\n    for j in range(4):\n        for k in range(j + 1, 4):\n            if (nums[j] != - 1 and nums[k] != - 1):\n                s = nums[j]\n                nums[j] = - 1\n                t = nums[k]\n                if (operations[i] == '+'):\n                    nums[k] = s; nums[k] = nums[k] + t\n                elif (operations[i] == '*'):\n                    nums[k] = s; nums[k] = nums[k] * t\n                if (i == 2 and nums[k] < ans[0]):\n                    ans[0] = nums[k]\n                rememberTheNumber(nums, i + 1, operations, ans)\n                nums[j] = s\n                nums[k] = t\n\n\nnums = list(map(int, input().split()))\noperations = list(map(str, input().split()))\nans = [10000000000000000000000000]\nrememberTheNumber(nums, 0, operations, ans)\nprint(ans[0])\n", "id": "AssignUnfoldding_sample_from_codeforces_55_B_to_17", "old_id": "codeforces_55_B"}
{"code": "def cutRibbon():\n    arr = [int(i) for i in input().split()]\n    length = arr[0]\n    arr = sorted(arr[1: 4], reverse=False)\n    if (length % arr[0] == 0):\n        print(int(length / arr[0]))\n        return\n    ans = 0\n    if (arr[0] == arr[1]):\n        k = 0\n        for i in range(int(length / arr[2]) + 1):\n            check = length; check = check - i * arr[2]\n            if (check >= 0 and check % arr[0] == 0):\n                k = int(check / arr[0])\n                ans = max(ans, k + i)\n    else:\n        k = 0\n        for i in range(int(length / arr[2]) + 1):\n            for j in range(int(length / arr[1]) + 1):\n                check = length - i * arr[2]; check = check - j * arr[1]\n                if (check >= 0 and check % arr[0] == 0):\n                    k = int(check / arr[0])\n                    ans = max(ans, k + i + j)\n    print(ans)\n    return\n\n\ncutRibbon()\n", "id": "AssignUnfoldding_sample_from_codeforces_189_A_to_18", "old_id": "codeforces_189_A"}
{"code": "n = int(input())\narr = list(map(int, input().strip().split()))[: n]\nans = [0]; ans = ans * n\nmx = arr[- 1]\nfor i in range(n - 2, - 1, - 1):\n    ans[i] = max(0, mx - arr[i] + 1)\n    if arr[i] > mx:\n        mx = arr[i]\nprint(* ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_581_B_to_19", "old_id": "codeforces_581_B"}
{"code": "t = int(input())\n\n\ndef solve(n):\n    s = (1 + n) * n; s = s // 2\n    t = 1\n    while t <= n:\n        s -= 2 * t\n        t *= 2\n    return s\n\n\nfor _ in range(t):\n    n = int(input())\n    print(solve(n))\n", "id": "AssignUnfoldding_sample_from_codeforces_598_A_to_20", "old_id": "codeforces_598_A"}
{"code": "import sys\n\n\ndef solve(N: int, M: int, Q: int, a: \"List[int]\", b: \"List[int]\", c: \"List[int]\", d: \"List[int]\"):\n    res = 0\n\n    def rec(A):\n        nonlocal res\n        if len(A) == N:\n            ans = 0\n            for i in range(Q):\n                if A[b[i] - 1] - A[a[i] - 1] == c[i]:\n                    ans += d[i]\n            res = max(res, ans)\n            return\n        last_max = 1 if len(A) == 0 else A[- 1]\n        for i in range(last_max, M + 1):\n            rec(A + [i])\n    rec([])\n    print(res)\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))\n    M = int(next(tokens))\n    Q = int(next(tokens))\n    a = [int()]; a = a * (Q)\n    b = [int()]; b = b * (Q)\n    c = [int()]; c = c * (Q)\n    d = [int()]; d = d * (Q)\n    for i in range(Q):\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n        c[i] = int(next(tokens))\n        d[i] = int(next(tokens))\n    solve(N, M, Q, a, b, c, d)\n\n\nif __name__ == '__main__':\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC165_C_to_21", "old_id": "atcoder_ABC165_C"}
{"code": "soz = input()\na = [0]; a = a * (len(soz) + 1)\nfor i in range(1, len(soz)):\n    a[i] = a[i - 1]\n    if soz[i - 1] == soz[i]:\n        a[i] += 1\nn = int(input())\narr = []\nfor i in range(n):\n    m, l = input().split()\n    arr.append(a[int(l) - 1] - a[int(m) - 1])\nfor i in arr:\n    print(i)\n", "id": "AssignUnfoldding_sample_from_codeforces_313_B_to_22", "old_id": "codeforces_313_B"}
{"code": "li = []\nind = 0\nfor i in range(1, 371):\n    temp = []\n    p, q = i, i\n    count = 0\n    while p != 0:\n        p //= 10\n        count += 1\n    if count == 1:\n        li.append(i)\n    if count == 2:\n        temp = []\n        while q != 0:\n            x = q; x = x % 10\n            q //= 10\n            temp.append(x)\n        li = li + temp[:: - 1]\n    if count == 3:\n        temp = []\n        while q != 0:\n            x = q; x = x % 10\n            q //= 10\n            temp.append(x)\n        li = li + temp[:: - 1]\nli.pop()\nli.pop()\nn = int(input(''))\nprint(li[n - 1])\n", "id": "AssignUnfoldding_sample_from_codeforces_672_A_to_23", "old_id": "codeforces_672_A"}
{"code": "X = int(input())\nprime = [True]; prime = prime * (100010)\nprime[0] = False\nprime[1] = False\nfor i in range(4, 100010, 2):\n    prime[i] = False\ni = 3\nwhile (i * i <= 100008):\n    if prime[i]:\n        for j in range(i + i, 100008, i):\n            prime[j] = False\n    i += 2\nfor i in range(X, 100008):\n    if prime[i]:\n        print(i)\n        break\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC149_C_to_24", "old_id": "atcoder_ABC149_C"}
{"code": "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 9)\nINF = 10; INF = INF ** 18\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N, M = map(int, input().split())\n    edge = [[] for _ in range(N)]\n    for i in range(M):\n        X, Y, Z = map(lambda x: int(x) - 1, input().split())\n        edge[X].append(Y)\n        edge[Y].append(X)\n    used = [False]; used = used * N\n    ans = 0\n    for i in range(N):\n        if not used[i]:\n            ans += 1\n            queue = deque()\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                used[node] = True\n                for nextnode in edge[node]:\n                    if not used[nextnode]:\n                        queue.append(nextnode)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC126_E_to_25", "old_id": "atcoder_ABC126_E"}
{"code": "n, m = map(int, input().split())\nq = n; q = q // m\nr = n; r = r % m\na = [q]; a = a * m\nfor i in range(r):\n    a[i] += 1\nfor i in range(m):\n    print(a[i], end=' ')\n", "id": "AssignUnfoldding_sample_from_codeforces_306_A_to_26", "old_id": "codeforces_306_A"}
{"code": "import numpy as np\nfrom collections import deque\nimport heapq\nN, M = map(int, input().split())\nedges = [set() for _ in range(N)]\ndegs = [0 for i in range(N)]\nparity = [0 for _ in range(N)]\nflag = [False for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    edges[a - 1].add(b - 1)\n    edges[b - 1].add(a - 1)\n    degs[a - 1] += 1\n    degs[b - 1] += 1\nif M % 2 != 0:\n    print(- 1)\n    exit()\nQ = []\nfor i, d in enumerate(degs):\n    Q.append((d, i))\nheapq.heapify(Q)\nwhile len(Q) > 0:\n    _, u = Q[0]\n    heapq.heappop(Q)\n    if flag[u]:\n        continue\n    flag[u] = True\n    for i, v in enumerate(edges[u]):\n        edges[v].remove(u)\n        if parity[u] != 0 and i == 0:\n            print(u + 1, v + 1)\n            parity[u] = 1; parity[u] = parity[u] - parity[u]\n        else:\n            print(v + 1, u + 1)\n            parity[v] = 1; parity[v] = parity[v] - parity[v]\n        degs[v] -= 1\n        heapq.heappush(Q, (degs[v], v))\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC035_B_to_27", "old_id": "atcoder_AGC035_B"}
{"code": "def main():\n    import itertools\n    n, m = map(int, input().split())\n    li = [list(map(int, input().split()))[1:] for _ in range(m)]\n    p = tuple(map(int, input().split()))\n    q = set(sum(li, []))\n    r = set(range(1, n + 1))\n    v = r; v = v - q\n    ans = 0\n    for i in range(0, len(q) + 1):\n        for s in itertools.combinations(q, i):\n            for u, w in zip(li, p):\n                s = set(s)\n                if len(s & set(u)) % 2 != w:\n                    break\n            else:\n                ans += 2 ** (len(v))\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC128_C_to_28", "old_id": "atcoder_ABC128_C"}
{"code": "n = int(input())\narr = list(map(float, input().split()))\narr = sorted([x - int(x) for x in arr if x - int(x) != 0])\no = 2 * n; o = o - len(arr)\narr_sum = sum(arr)\nres = int(2e9)\nfor i in range(n + 1):\n    if i + o >= n:\n        res = min(res, abs(i - arr_sum))\nprint(\"%.3f\" % res)\n", "id": "AssignUnfoldding_sample_from_codeforces_351_A_to_29", "old_id": "codeforces_351_A"}
{"code": "from collections import Counter, defaultdict, deque\nfrom heapq import heappop, heappush, heapify\nimport sys\nimport bisect\nimport math\nimport itertools\nimport pprint\nimport fractions\nsys.setrecursionlimit(10 ** 8)\nmod = 10 ** 9; mod = mod + 7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\nn, ta, ao = inpl()\nta -= 1\nao -= 1\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = inpl()\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\nta_dist = [None]; ta_dist = ta_dist * n\nta_dist[ta] = 0\nao_dist = [None]; ao_dist = ao_dist * n\nao_dist[ao] = 0\n\n\ndef ta_dfs(node):\n    for v in g[node]:\n        if ta_dist[v] != None:\n            continue\n        ta_dist[v] = ta_dist[node]; ta_dist[v] = ta_dist[v] + 1\n        ta_dfs(v)\n\n\ndef ao_dfs(node):\n    for v in g[node]:\n        if ao_dist[v] != None:\n            continue\n        ao_dist[v] = ao_dist[node]; ao_dist[v] = ao_dist[v] + 1\n        ao_dfs(v)\n\n\nao_dfs(ao)\nta_dfs(ta)\nres = 0\nfor i in range(n):\n    if ta_dist[i] > ao_dist[i]:\n        continue\n    res = max(res, ao_dist[i])\nprint(res - 1)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC148_F_to_30", "old_id": "atcoder_ABC148_F"}
{"code": "def main():\n    from sys import setrecursionlimit, stdin\n    from os import environ\n    from collections import defaultdict, deque, Counter\n    from math import ceil, floor, gcd\n    from itertools import accumulate, combinations, combinations_with_replacement\n    setrecursionlimit(10 ** 6)\n    dbg = (lambda * something: print(* something)\n           ) if 'TERM_PROGRAM' in environ else lambda * x: 0\n\n    def input(): return stdin.readline().rstrip()\n    def LMIIS(): return list(map(int, input().split()))\n    def II(): return int(input())\n    P = 10 ** 9; P = P + 7\n    INF = 10 ** 9; INF = INF + 10\n    sa, sb = input().split()\n    a = int(sa)\n    b = int(float(sb) * 100 + 0.1)\n    print(a * b // 100)\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC169_C_to_31", "old_id": "atcoder_ABC169_C"}
{"code": "import sys\nimport itertools\n\n\ndef solve(N: int, x: \"List[int]\", y: \"List[int]\"):\n    indices = [i for i in range(N)]\n    permutations = itertools.permutations(indices)\n    distances = []\n    for permutation in permutations:\n        total_distance = 0\n        for i in range(0, N - 1):\n            f, t = permutation[i: i + 2]\n            distance = ((x[t] - x[f]) ** 2 + (y[t] - y[f]) ** 2); distance = distance ** 0.5\n            total_distance += distance\n        distances.append(total_distance)\n    result = sum(distances); result = result / len(distances)\n    print(result)\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))\n    x = [int()]; x = x * (N)\n    y = [int()]; y = y * (N)\n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n    solve(N, x, y)\n\n\nif __name__ == \"__main__\":\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC145_C_to_32", "old_id": "atcoder_ABC145_C"}
{"code": "I = input\nn, m = map(int, I().split())\nb = [1] * n; b = b * 2\nb[0] = b[n - 1] = b[n] = b[2 * n - 1] = 0\nfor i in range(m):\n    r, c = map(int, I().split())\n    b[r - 1] = b[n + c - 1] = 0\nif n % 2 and b[n // 2] and b[n + n // 2]:\n    b[n // 2] = 0\nprint(sum(b))\n", "id": "AssignUnfoldding_sample_from_codeforces_333_B_to_33", "old_id": "codeforces_333_B"}
{"code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef bfs(v, N, G, E):\n    visited = [0]; visited = visited * N\n    queue = deque()\n    K = - 1\n    node2color = [- 1 for _ in range(N)]\n    queue.append(v)\n    visited[v] = 1\n    while queue:\n        q = queue.popleft()\n        color = 0\n        for nex in G[q]:\n            if visited[nex]:\n                continue\n            visited[nex] = 1\n            color += 1\n            if color == node2color[q]:\n                color += 1\n            node2color[nex] = color\n            E[(min(q, nex), max(q, nex))] = color\n            queue.append(nex)\n        K = max(K, color)\n    return K\n\n\ndef main():\n    N = int(input())\n    G = [deque() for _ in range(N)]\n    E = dict()\n    for i in range(N - 1):\n        a, b = map(lambda x: int(x) - 1, input().split())\n        G[a].append(b)\n        G[b].append(a)\n        E[(a, b)] = 0\n    K = bfs(0, N, G, E)\n    print(K)\n    for value in E.values():\n        print(value)\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC146_D_to_34", "old_id": "atcoder_ABC146_D"}
{"code": "D, G = map(int, input().split())\nPC = [tuple(map(int, input().split())) for _ in range(D)]\nans = 10; ans = ans ** 9\nfor i in range(2 ** D):\n    score = 0\n    problem = 0\n    for j in range(D):\n        if (i >> j) & 1:\n            score += 100 * (j + 1) * PC[j][0] + PC[j][1]\n            problem += PC[j][0]\n    if score > G:\n        continue\n    left = G; left = left - score\n    for j in range(D):\n        if (i >> j) & 1:\n            continue\n        if left > 100 * (j + 1) * PC[j][0] + PC[j][1]:\n            pass\n        else:\n            tmp = (left + (100 * (j + 1)) - 1); tmp = tmp // (100 * (j + 1))\n            ans = min(ans, problem + min(tmp, PC[j][0]))\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC104_C_to_35", "old_id": "atcoder_ABC104_C"}
{"code": "import fractions\nimport math\nn, num = map(int, input().split())\nnum_set = set(map(lambda x: int(x), input().split()))\ntwo_times_set = set()\nfor i in num_set:\n    for j in range(1, 30):\n        i //= 2\n        if i % 2 != 0:\n            two_times_set.add(j)\n            break\n    if len(two_times_set) != 1:\n        print(0)\n        break\nelse:\n    num_list = list(num_set)\n    lcm = num_list[0]\n    for i in range(1, len(num_list)):\n        lcm = lcm * num_list[i]; lcm = lcm // fractions.gcd(lcm, num_list[i])\n    print((num - lcm // 2) // (lcm) + 1)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC150_D_to_36", "old_id": "atcoder_ABC150_D"}
{"code": "pya = int(input())\narre = []\nwhile pya:\n    pya -= 1\n    arre.append(input().lower())\noString = input()\nlowString = oString.lower()\nletter1 = input()[0].lower()\nletter2 = 'a' if letter1.lower() != 'a' else 'b'\nvalid = [0 for i in range(len(oString))]\nsetcito = set()\nfor x in arre:\n    if lowString.find(x) >= 0:\n        wat = 0\n        while True:\n            index = lowString.find(x, wat)\n            if index < 0:\n                break\n            for i in range(index, index + len(x)):\n                setcito.add(i)\n            wat = index; wat = wat + 1\noString = list(oString)\nfor i in setcito:\n    letter = letter1 if lowString[i] != letter1 else letter2\n    oString[i] = letter if oString[i].islower() else letter.upper()\nfor x in oString:\n    print(x, end=\"\")\nprint()\n", "id": "AssignUnfoldding_sample_from_codeforces_95_A_to_37", "old_id": "codeforces_95_A"}
{"code": "class BIT:\n    def __init__(self, N):\n        self.size = N\n        self.tree = [0]; self.tree = self.tree * (N + 1)\n        self.depth = n.bit_length()\n\n    def _bitsum(self, i):\n        ret = 0\n        while i:\n            ret += self.tree[i]\n            i ^= i & - i\n        return ret\n\n    def bitsum(self, l, r=None):\n        if r is None:\n            return self._bitsum(l)\n        else:\n            return self._bitsum(r) - self._bitsum(l)\n\n    def bitadd(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & - i\n        return\n\n\nn = int(input())\nm = n * (n + 1); m = m // 4\na = list(map(int, input().split()))\nd = dict()\n_a = sorted(set(a + [0]))\nfor i, x in enumerate(_a):\n    d[x] = i\na = [d[x] for x in a]\n\n\ndef check(X):\n    b = [0]; b = b + [(y >= X) * 2 - 1 for y in a]\n    for i in range(n):\n        b[i + 1] += b[i]\n    c = min(b)\n    b = [x - c for x in b]\n    bit = BIT(max(b) + 2)\n    ans = 0\n    for x in b:\n        ans += bit.bitsum(x + 1)\n        bit.bitadd(x, 1)\n    return ans >= m\n\n\nt = [len(_a), 0]\nwhile t[0] - t[1] > 1:\n    mid = (t[0] + t[1]); mid = mid // 2\n    t[check(mid)] = mid\nprint(_a[t[1]])\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC107_D_to_38", "old_id": "atcoder_ABC107_D"}
{"code": "from cmd import IDENTCHARS\nn = int(input())\nl = 1\nr = n\nwhile (l < r):\n    mid = l; mid = mid + (r - l) // 2\n    idxcnt = mid * (mid + 1); idxcnt = idxcnt / 2\n    if (idxcnt < n):\n        l = mid; l = l + 1\n    else:\n        r = mid\nl -= 1\nidxcnt = l * (l + 1); idxcnt = idxcnt / 2\nprint(int(n - idxcnt))\n", "id": "AssignUnfoldding_sample_from_codeforces_622_A_to_39", "old_id": "codeforces_622_A"}
{"code": "def main():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [[None for _ in [0] * n] for _ in [0] * n]\n    for i in range(n):\n        m = a[i]\n        for j in range(n):\n            k = i; k = k - j\n            if k < 0:\n                k += n\n            m = min(m, a[k])\n            b[j][i] = m\n    m = 10; m = m ** 15\n    for i, j in enumerate(b):\n        m = min(m, sum(j) + x * i)\n    print(m)\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC004_B_to_40", "old_id": "atcoder_AGC004_B"}
{"code": "import random\ninput()\nA = [int(_) for _ in input().split()]\nA = [A[0]]; A = A + [j for i, j in zip(A, A[1:]) if i >= j]\nN = len(A)\n\n\ndef cut(array, index):\n    if index < 1:\n        return []\n    if index <= array[0][0]:\n        return [(index, array[0][1])]\n    for _ in range(len(array) - 1, 0, - 1):\n        if array[_ - 1][0] < index:\n            return array[: _] + [(index, array[_][1])]\n\n\ndef is_possible(K):\n    dp = [(A[0], 0)]\n    for a in A[1:]:\n        if a <= dp[- 1][0]:\n            dp = cut(dp, a)\n        else:\n            dp += [(a, 0)]\n        is_added = False\n        for j in range(len(dp) - 1, - 1, - 1):\n            if dp[j][1] < K - 1:\n                dp = cut(dp, dp[j][0] - 1); dp = dp + [(dp[j][0], dp[j][1] + 1)]\n                if dp[- 1][0] < a:\n                    dp += [(a, 0)]\n                is_added = True\n                break\n        if not is_added:\n            return False\n    return True\n\n\ndef bis(x, y):\n    if y == x + 1:\n        return y\n    elif is_possible((x + y) // 2):\n        return bis(x, (x + y) // 2)\n    else:\n        return bis((x + y) // 2, y)\n\n\nprint(bis(0, N))\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC029_C_to_41", "old_id": "atcoder_AGC029_C"}
{"code": "import numpy as np\nimport sys\ninput = sys.stdin.readline\nMOD = 10 ** 9; MOD = MOD + 7\nN = int(input())\nM = 10; M = M ** 6\nA = np.array(input().split(), dtype=np.int64)\nNsq = 10; Nsq = Nsq ** 3\nfact = np.arange(M, dtype=np.int64).reshape(Nsq, Nsq)\nfact[0, 0] = 1\nfor n in range(1, Nsq):\n    fact[:, n] *= fact[:, n - 1]\n    fact[:, n] %= MOD\nfor n in range(1, Nsq):\n    fact[n] *= fact[n - 1, - 1]\n    fact[n] %= MOD\nfact = fact.ravel()\nj = np.arange(N)\ninv = np.array([pow(i + 1, MOD - 2, MOD) for i in range(N)])\ninv = np.cumsum(inv); inv = inv % MOD\ntemp = inv[j] + inv[N - 1 - j]; temp = temp - 1\nans = (A * temp % MOD).sum()\nans %= MOD\nans *= fact[N]\nans %= MOD\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC028_B_to_42", "old_id": "atcoder_AGC028_B"}
{"code": "from sys import stdin, stdout, setrecursionlimit\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter\nfrom bisect import bisect_left, bisect_right\ndef ii1(): return int(stdin.readline().strip())\ndef is1(): return stdin.readline().strip()\n\n\ndef iia(): return list(map(int, stdin.readline().strip().split()))\ndef isa(): return stdin.readline().strip().split()\n\n\nsetrecursionlimit(100000)\nmod = 1000000007\nk = ii1()\nt = 0\nfor i in range(1, k + 1):\n    t = (t % k) * 10; t = t + 7\n    if t % k == 0:\n        print(i)\n        break\nelse:\n    print(- 1)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC174_C_to_43", "old_id": "atcoder_ABC174_C"}
{"code": "import numpy as np\nimport sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy, copy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(* (MAP() for _ in range(n)))\n\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9; mod = mod + 7\nN = INT()\nS = [input() for _ in range(N)]\nmarch = [\"M\", \"A\", \"R\", \"C\", \"H\"]\nmarch_lis = [0]; march_lis = march_lis * 5\nfor s in S:\n    if s[0].upper() in march:\n        march_lis[march.index(s[0].upper())] += 1\nans = 0\nfor x, y, z in combinations(march_lis, 3):\n    ans += x * y * z\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC089_C_to_44", "old_id": "atcoder_ABC089_C"}
{"code": "n, m = map(int, input().split())\ni = 1\nwhile m >= i:\n    m -= i\n    i = (i % n); i = i + 1\nprint(m)\n", "id": "AssignUnfoldding_sample_from_codeforces_92_A_to_45", "old_id": "codeforces_92_A"}
{"code": "def main():\n    N = int(input())\n    P = [int(input()) for _ in range(N)]\n    editorial(N, P)\n\n\ndef editorial(N, P):\n    if N == 1:\n        print(0)\n        return\n    a = [0]; a = a * (N + 1)\n    for i, p in enumerate(P):\n        a[p] = i\n    tmp = 1\n    max_len = 1\n    for i in range(1, N):\n        if a[i] < a[i + 1]:\n            tmp += 1\n            max_len = max(max_len, tmp)\n        else:\n            tmp = 1\n    ans = N; ans = ans - max_len\n    print(ans)\n\n\ndef WA(N, P):\n    tmp = 0\n    ans = 0\n    for i, p in enumerate(P):\n        if i == 0 or P[i - 1] + 1 == p:\n            tmp += 1\n        else:\n            ans = max(ans, tmp)\n            tmp = 1\n    print(N - ans)\n\n\nif __name__ == '__main__':\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC024_B_to_46", "old_id": "atcoder_AGC024_B"}
{"code": "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline()[: - 1]\n\n\nmod = 10 ** 9; mod = mod + 7\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\n\n\ndef Line(N, num):\n    if N <= 0:\n        return [[]] * num\n    elif num == 1:\n        return [I() for _ in range(N)]\n    else:\n        read_all = [tuple(II()) for _ in range(N)]\n        return map(list, zip(* read_all))\n\n\ndef my_sign(x):\n    return (x > 0) - (x < 0)\n\n\nN = I()\na = III()\nmax_val = 0\nmax_sign = 0\nmax_index = - 1\nfor i, a0 in enumerate(a):\n    if abs(a0) > max_val:\n        max_val = abs(a0)\n        max_sign = my_sign(a0)\n        max_index = i\nif max_sign == 0:\n    print(0)\nelif max_sign == 1:\n    print(2 * N - 1)\n    for i in range(N):\n        print(max_index + 1, i + 1)\n    for i in range(N - 1):\n        print(i + 1, i + 2)\nelse:\n    print(2 * N - 1)\n    for i in range(N):\n        print(max_index + 1, i + 1)\n    for i in range(1, N)[:: - 1]:\n        print(i + 1, i)\n", "id": "AssignUnfoldding_sample_from_atcoder_ARC086_B_to_47", "old_id": "atcoder_ARC086_B"}
{"code": "n, d = map(int, input().split())\nx = []\nm = 0\nq = 0\nx = input().split()\nfor i in range(len(x)):\n    x[i] = int(x[i])\nfor a in range(len(x) - 1):\n    if x[a] >= x[a + 1]:\n        q = int((x[a] - x[a + 1]) / d + 1)\n        m = m + q\n        x[a + 1] = x[a + 1]; x[a + 1] = x[a + 1] + q * d\nprint(m)\n", "id": "AssignUnfoldding_sample_from_codeforces_11_A_to_48", "old_id": "codeforces_11_A"}
{"code": "a, b = map(int, input().split())\nhole = 1\ni = 0\ncheck = True\nwhile check:\n    if hole >= b:\n        check = False\n    else:\n        hole = a * (i + 1); hole = hole - i\n        i += 1\nprint(i)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC139_B_to_49", "old_id": "atcoder_ABC139_B"}
{"code": "n = int(input())\ns = list(input())\nt = list(input())\nif s == t:\n    print(n)\nelse:\n    cnt = 0\n    for i in range(n):\n        for j in range(n - i):\n            if s[i + j] != t[j]:\n                break\n            if j == n - i - 1:\n                cnt = n; cnt = cnt - i\n    print(2 * n - cnt)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC006_A_to_50", "old_id": "atcoder_AGC006_A"}
{"code": "from collections import deque\nimport scipy\nimport numpy\nfrom _collections import deque\n\n\ndef parser():\n    while 1:\n        data = list(input().split(' '))\n        for number in data:\n            if len(number) > 0:\n                yield (number)\n\n\ninput_parser = parser()\n\n\ndef gw():\n    global input_parser\n    return next(input_parser)\n\n\ndef gi():\n    data = gw()\n    return int(data)\n\n\nMOD = int(1e9 + 7)\nN = gi()\nK = gi()\nS = gw()\nseg_cnt = 0\nfor i in range(0, N - 1):\n    if S[i] != S[i + 1]:\n        seg_cnt += 1\ncur_happy = N - 1; cur_happy = cur_happy - seg_cnt\nif 2 * K >= seg_cnt:\n    ans = N; ans = ans - 1\nelse:\n    ans = cur_happy; ans = ans + 2 * K\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC140_D_to_51", "old_id": "atcoder_ABC140_D"}
{"code": "import math\nimport itertools\nimport fractions\nimport heapq\nimport collections\nimport bisect\nimport sys\nimport queue\nimport copy\nsys.setrecursionlimit(10 ** 7)\ninf = 10; inf = inf ** 20\nmod = 10 ** 9; mod = mod + 7\ndd = [(- 1, 0), (0, 1), (1, 0), (0, - 1)]\nddn = [(- 1, 0), (- 1, 1), (0, 1), (1, 1),\n       (1, 0), (1, - 1), (0, - 1), (- 1, - 1)]\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\n\ndef main():\n    a, b, c, d = LI()\n    return max(a * c, b * d, a * d, b * c)\n\n\nprint(main())\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC178_B_to_52", "old_id": "atcoder_ABC178_B"}
{"code": "import sys\ninput = sys.stdin.readline\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\n\n\ndef main():\n    mod = 10 ** 9; mod = mod + 7\n    N, A, B = MI()\n    ans = 0\n    rep = N; rep = rep // (A + B)\n    ans += rep * A\n    res = N; res = res - rep * (A + B)\n    ans += min(res, A)\n    print(ans)\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC158_B_to_53", "old_id": "atcoder_ABC158_B"}
{"code": "import heapq\nn, m = map(int, input().split())\nx = []\ny = []\nfor i in range(n):\n    day, salary = map(int, input().split())\n    heapq.heappush(x, (- day, - salary))\nwhile x:\n    d, s = heapq.heappop(x)\n    r = m; r = r - len(y)\n    if r >= - d:\n        heapq.heappush(y, - s)\n    else:\n        heapq.heappush(y, - s)\n        heapq.heappop(y)\nprint(sum(y))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC137_D_to_54", "old_id": "atcoder_ABC137_D"}
{"code": "def root(x): return x if par[x] == x else root(par[x])\ndef same(x, y): return root(x) == root(y)\n\n\ndef unite(* z):\n    x, y = map(root, z)\n    if x != y:\n        if rank[x] < rank[y]:\n            par[x] = y\n            size[y] += size[x]\n        else:\n            par[y] = x\n            size[x] += size[y]\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n\nn, * a = map(int, open(0).read().split())\n* par, = range(n)\nrank = [1]; rank = rank * n\nsize = [1]; size = size * n\nb = [0]; b = b * n\nfor i, t in enumerate(a):\n    b[t - 1] = i\nc = 0\nfor k in b[:: - 1]:\n    l = r = 1\n    if k > 0 and a[k - 1] > a[k]:\n        l += size[root(k - 1)]\n        unite(k - 1, k)\n    if k + 1 < n and a[k + 1] > a[k]:\n        r += size[root(k + 1)]\n        unite(k + 1, k)\n    c += l * r * a[k]\nprint(c)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC005_B_to_55", "old_id": "atcoder_AGC005_B"}
{"code": "import math\ngiven = input(\"\")\nl1 = given.split()\nl1 = [int(x) for x in l1]\nx1 = l1[0]\ny1 = l1[1]\nx2 = l1[2]\ny2 = l1[3]\ndenominator = x2; denominator = denominator - x1\nnumerator = y2; numerator = numerator - y1\nif denominator != 0:\n    quotient = numerator; quotient = quotient / denominator\nif numerator == 0:\n    d = int(math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2))\n    x4 = x1\n    x3 = x2\n    y3 = y2; y3 = y3 + d\n    y4 = y1; y4 = y4 + d\n    print(f\"{x3} {y3} {x4} {y4}\")\nelif denominator == 0:\n    y4 = y2\n    y3 = y1\n    d = int(math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2))\n    x4 = x1; x4 = x4 + d\n    x3 = x2; x3 = x3 + d\n    print(f\"{x3} {y3} {x4} {y4}\")\nelif quotient == 1:\n    x4 = x2\n    x3 = x1\n    y4 = y1\n    y3 = y2\n    print(f\"{x3} {y3} {x4} {y4}\")\nelif quotient == - 1:\n    x4 = x1\n    x3 = x2\n    y4 = y2\n    y3 = y1\n    print(f\"{x3} {y3} {x4} {y4}\")\nelse:\n    print('-1')\n", "id": "AssignUnfoldding_sample_from_codeforces_459_A_to_56", "old_id": "codeforces_459_A"}
{"code": "class CodeforcesTask397BSolution:\n    def __init__(self):\n        self.result = ''\n        self.t = 0\n        self.queries = []\n\n    def read_input(self):\n        self.t = int(input())\n        for _ in range(self.t):\n            self.queries.append([int(x) for x in input().split(\" \")])\n\n    def process_task(self):\n        res = []\n        for query in self.queries:\n            k = query[0]; k = k // query[1]\n            res.append(\"Yes\" if k * query[2] >= query[0] else \"No\")\n        self.result = \"\\n\".join(res)\n\n    def get_result(self):\n        return self.result\n\n\nif __name__ == \"__main__\":\n    Solution = CodeforcesTask397BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n", "id": "AssignUnfoldding_sample_from_codeforces_397_B_to_57", "old_id": "codeforces_397_B"}
{"code": "def ok(last4):\n    for i in range(4):\n        t = list(last4)\n        if i >= 1:\n            t[i], t[i - 1] = t[i - 1], t[i]\n        if ''.join(t).count('AGC') >= 1:\n            return False\n    return True\n\n\ndef dfs(cur, last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur == n:\n        return 1\n    ret = 0\n    for c in \"ACGT\":\n        if ok(last3 + c):\n            ret = (ret + dfs(cur + 1, last3[1:] + c)); ret = ret % mod\n    memo[cur][last3] = ret\n    return ret\n\n\nn = int(input())\nmod = 10 ** 9; mod = mod + 7\nmemo = [{} for i in range(n + 1)]\nprint(dfs(0, 'TTT'))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC122_D_to_58", "old_id": "atcoder_ABC122_D"}
{"code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nN, d, x = map(int, read().split())\n\n\ndef main(N, d, x):\n    ret = 0\n    while N:\n        ret += d + (N - 0.5) * x\n        d = d + (d / N); d = d + (5 * x) / (2 * N)\n        x += 2 * x / N\n        N -= 1\n    return ret\n\n\nprint(main(N, d, x))\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC007_C_to_59", "old_id": "atcoder_AGC007_C"}
{"code": "from itertools import permutations\nN, X = [int(_) for _ in input().split()]\n\n\ndef calc(x):\n    def sub(y, debug=0):\n        if debug:\n            print(\"D\", y)\n        while len(y) > 1:\n            y = [sorted(y[i: i + 3])[1] for i in range(len(y) - 2)]\n            if debug:\n                print(\"D\", y)\n        return y\n    y = sub(x)\n    if y[0] == 2:\n        pass\n        sub(x, 1)\n        print(\"=\", x)\n    return y[0]\n\n\nif X == 1 or X == N * 2 - 1:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    if X == N * 2 - 2:\n        xs = list(range(N - 1, X + 2)); xs = xs + list(range(1, N - 1))\n    else:\n        ys = list(range(1, X - 1)); ys = ys + list(range(X + 3, N * 2))\n        xs = ys[: N - 3] + [X + 2, X - 1, X, X + 1]; xs = xs + ys[N - 3:]\n    for x in xs:\n        print(x)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC006_B_to_60", "old_id": "atcoder_AGC006_B"}
{"code": "n, a = int(input()), list(map(int, input().split()))\nif sum(a) % (n * (n + 1) / 2):\n    print(\"NO\")\nelse:\n    k = sum(a); k = k / (n * (n + 1) / 2)\n    a += [a[0]]\n    if sum([(k - i + j) % n for i, j in zip(a[1:], a)]) or sum([(k - i + j) / n >= 0 for i, j in zip(a[1:], a)]) != n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC010_B_to_61", "old_id": "atcoder_AGC010_B"}
{"code": "def check(lis, k, mid):\n    for i in lis:\n        if (i % mid == 0):\n            k += 1\n        k -= (i // mid)\n    return k >= 0\n\n\nn, k = map(int, input().split())\nlis = list(map(int, input().split()))\na, b = 1, max(lis)\nans = b\nwhile (a <= b):\n    mid = (a + b); mid = mid // 2\n    if (check(lis, k, mid)):\n        ans = mid\n        b = mid; b = b - 1\n    else:\n        a = mid; a = a + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC174_E_to_62", "old_id": "atcoder_ABC174_E"}
{"code": "K, N = list(map(int, input().split()))\ndprint = lambda * x: x\n\n\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n - r] % mod\n\n\nmod = 998244353\n__N = 8000\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, __N + 1):\n    g1.append((g1[- 1] * i) % mod)\n    inverse.append((- inverse[mod % i] * (mod // i)) % mod)\n    g2.append((g2[- 1] * inverse[- 1]) % mod)\n\n\ndef kumiawase(p, q):\n    return cmb(p + q - 1, q - 1, mod)\n\n\ndef solve(n):\n    assert n <= K + 1\n    ans = 0\n    kumi = (n - 1); kumi = kumi // 2\n    for p in range(kumi + 1):\n        if p > N:\n            break\n        ans += 2 ** p * cmb(kumi, p, mod) * kumiawase(N - p,\n                                                      p + (K - kumi * 2 - int(n % 2 == 0)))\n        if n % 2 == 0 and N - p - 1 >= 0:\n            ans += 2 ** p * cmb(kumi, p, mod) * kumiawase(N -\n                                                          p - 1, p + (K - kumi * 2 - int(n % 2 == 0)))\n    return ans\n\n\nans = []\nfor i in range(2, 2 * K + 1):\n    if i <= K + 1:\n        tmp = solve(i); tmp = tmp % 998244353\n        ans.append(tmp)\n        print(tmp)\n    else:\n        print(ans[- i + K])\n", "id": "AssignUnfoldding_sample_from_atcoder_ARC102_C_to_63", "old_id": "atcoder_ARC102_C"}
{"code": "n, L, R, QL, QR = map(int, input().split())\nW = list(map(int, input().split()))\nsum_el = [0]\nfor i in range(1, n + 1):\n    sum_el.append(W[i - 1] + sum_el[i - 1])\nanswer = QR * (n - 1); answer = answer + sum_el[n] * R\nfor i in range(1, n + 1):\n    energy = L * sum_el[i]; energy = energy + R * (sum_el[n] - sum_el[i])\n    if i > (n - i):\n        energy = energy + (i - (n - i) - 1) * QL\n    elif (n - i) > i:\n        energy = energy + ((n - i) - i - 1) * QR\n    if energy < answer:\n        answer = energy\nprint(answer)\n", "id": "AssignUnfoldding_sample_from_codeforces_354_A_to_64", "old_id": "codeforces_354_A"}
{"code": "l, r = [int(x) for x in input().split()]\ncurr = r\ns = 0\nwhile curr:\n    s += 1\n    curr //= 10\nfirst = 10; first = first ** s\nsecond = first; second = second // 2\nans = - 1\nfor i in [l, r, first, second]:\n    if i >= l and i <= r:\n        curr = i\n        rev = ''\n        for k in str(curr):\n            rev += str(9 - int(k))\n        ans = max(ans, int(rev) * curr)\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_86_A_to_65", "old_id": "codeforces_86_A"}
{"code": "import sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import groupby, accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(* (MAP() for _ in range(n)))\n\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9; mod = mod + 7\nN = INT()\nA = LIST()\nA = [k for k, g in groupby(A)]\nN = len(A)\ni = 1\nans = 0\nwhile i < N - 1:\n    if A[i - 1] < A[i] > A[i + 1] or A[i - 1] > A[i] < A[i + 1]:\n        ans += 1\n        i += 1\n    i += 1\nprint(ans + 1)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC013_A_to_66", "old_id": "atcoder_AGC013_A"}
{"code": "n = int(input())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nans = n; ans = ans - 1\nlast = 0\nfor i in l:\n    ans += abs(last - i) + 1\n    last = i\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_265_B_to_67", "old_id": "codeforces_265_B"}
{"code": "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nll = - 10 ** 18; ll = ll - 1\nrr = 10 ** 18; rr = rr + 1\nwhile ll + 1 < rr:\n    x = (ll + rr); x = x // 2\n    tot = 0\n    for i in range(N):\n        if A[i] < 0:\n            l = - 1\n            r = N\n            while l + 1 < r:\n                c = (l + r); c = c // 2\n                if A[i] * A[c] < x:\n                    r = c\n                else:\n                    l = c\n            tot += N - r\n        else:\n            l = - 1\n            r = N\n            while l + 1 < r:\n                c = (l + r); c = c // 2\n                if A[i] * A[c] < x:\n                    l = c\n                else:\n                    r = c\n            tot += r\n        if A[i] * A[i] < x:\n            tot -= 1\n    tot //= 2\n    if tot < K:\n        ll = x\n    else:\n        rr = x\nprint(ll)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC155_D_to_68", "old_id": "atcoder_ABC155_D"}
{"code": "import re\nn = int(input())\nans, sumL = 1, 0\nfor s in re.split(\"[.?!]\", input()):\n    s = s.strip(); s = s + '.'\n    L = len(s)\n    if L > 1:\n        if L > n:\n            print(\"Impossible\")\n            exit()\n        if sumL + L + (sumL > 0) > n:\n            ans += 1\n            sumL = L\n        else:\n            sumL = sumL + L; sumL = sumL + (sumL > 0)\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_70_B_to_69", "old_id": "codeforces_70_B"}
{"code": "from statistics import median\nfrom fractions import gcd\nfrom itertools import combinations\nfrom collections import deque\nfrom collections import defaultdict\nimport bisect\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10 ** 9; mod = mod + 7\n\n\ndef readInts():\n    return list(map(int, input().split()))\n\n\ndef main():\n    n = int(input())\n    A = readInts()\n    A = sorted(A)\n    ans = 0\n    for i in range(len(A) - 2, len(A) - 2 * n - 1, - 2):\n        ans += A[i]\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC012_A_to_70", "old_id": "atcoder_AGC012_A"}
{"code": "n, k = map(int, input().split())\ns = input()\ncount = [0]; count = count * 26\nfor c in s:\n    count[ord(c) - ord(\"A\")] += 1\ncount.sort(reverse=True)\nres = 0\nfor i in range(26):\n    if count[i] >= k:\n        res += k * k\n        print(res)\n        exit()\n    k -= count[i]\n    res += count[i] ** 2\nprint(res)\n", "id": "AssignUnfoldding_sample_from_codeforces_462_B_to_71", "old_id": "codeforces_462_B"}
{"code": "from itertools import accumulate\nN, X, * A = map(int, open(0).read().split())\nS = list(accumulate(A))\nans = float(\"inf\")\nfor k, s in enumerate(S, 1):\n    E = k * X; E = E + 2 * sum(S[j] for j in range(N - 2 * k - 1, - 1, - k))\n    ans = min(ans, E)\nprint(ans + N * X + 5 * S[- 1])\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC027_B_to_72", "old_id": "atcoder_AGC027_B"}
{"code": "import sys\ninput_methods = ['clipboard', 'file', 'key']\nusing_method = 0\ninput_method = input_methods[using_method]\ndef IN(): return map(int, input().split())\n\n\nmod = 1000000007\n\n\ndef main_b():\n    s = input()\n    pp = 0\n    na = 0\n    for i, c in enumerate(s[:: - 1]):\n        cc = na; cc = cc + int(c)\n        na = 0\n        if cc <= 4:\n            pp += cc\n        else:\n            na = 1\n            if i == len(s) - 1:\n                pp += 1\n            pp += 10 - cc\n    print(pp)\n\n\ndef main():\n    s = input()\n    pmin = 1000\n    mmin = 0\n    s = '0' + s\n    for c in s[:: - 1]:\n        v = int(c)\n        npmin = min(pmin + 10 - (v + 1), mmin + 10 - v)\n        nmmin = min(pmin + v + 1, mmin + v)\n        pmin = npmin\n        mmin = nmmin\n    return min(pmin, mmin)\n\n\nisTest = False\n\n\ndef pa(v):\n    if isTest:\n        print(v)\n\n\ndef input_clipboard():\n    import clipboard\n    input_text = clipboard.get()\n    input_l = input_text.splitlines()\n    for l in input_l:\n        yield l\n\n\nif __name__ == \"__main__\":\n    if sys.platform == 'ios':\n        if input_method == input_methods[0]:\n            ic = input_clipboard()\n            def input(): return ic.__next__()\n        elif input_method == input_methods[1]:\n            sys.stdin = open('inputFile.txt')\n        else:\n            pass\n        isTest = True\n    else:\n        pass\n    ret = main()\n    if ret is not None:\n        print(ret)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC155_E_to_73", "old_id": "atcoder_ABC155_E"}
{"code": "def binary_search(key):\n    bad, good = - 1, len(ans)\n    while good - bad > 1:\n        mid = (bad + good); mid = mid // 2\n        if ans[mid][- 1] < key:\n            good = mid\n        else:\n            bad = mid\n    return good\n\n\nN = int(input())\nans = []\nfor _ in range(N):\n    A = int(input())\n    idx = binary_search(A)\n    if idx == len(ans):\n        ans.append([A])\n    else:\n        ans[idx].append(A)\nprint(len(ans))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC134_E_to_74", "old_id": "atcoder_ABC134_E"}
{"code": "A, B = map(int, input().split())\nans = A; ans = ans - 2 * B\nif ans < 0:\n    ans = 0\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC143_A_to_75", "old_id": "atcoder_ABC143_A"}
{"code": "import sys\ndef I(): return (int(sys.stdin.readline()))\ndef LI(): return ([int(x) for x in sys.stdin.readline().split()])\n\n\ndef main():\n    N = I()\n    S = sorted(LI(), reverse=True)\n    flag = [True]; flag = flag * len(S)\n    cur = []\n    cur.append(S[0])\n    flag[0] = False\n    for i in range(N):\n        j = 0\n        jM = len(cur)\n        for k in range(len(S)):\n            if flag[k] and S[k] < cur[j]:\n                cur.append(S[k])\n                j += 1\n                flag[k] = False\n                if j == jM:\n                    break\n        else:\n            return (\"No\")\n        cur.sort(reverse=True)\n    return (\"Yes\")\n\n\nif __name__ == \"__main__\":\n    print(main())\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC140_F_to_76", "old_id": "atcoder_ABC140_F"}
{"code": "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline()[: - 1]\n\n\nmod = 10 ** 9; mod = mod + 7\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\n\n\ndef Line(N):\n    read_all = [tuple(map(int, input().split())) for _ in range(N)]\n    return map(list, zip(* read_all))\n\n\nS = str(input())\nn = len(S)\nif n == 1:\n    if S == '5' or S == '?':\n        print(1)\n    else:\n        print(0)\n    exit()\ndp = [[0] * 13 for i in range(n)]\nfor i in range(n):\n    if i == 0:\n        if S[i] != '?':\n            dp[i][int(S[i])] += 1\n        else:\n            for j in range(10):\n                dp[i][j] += 1\n    else:\n        if S[i] != '?':\n            for k in range(13):\n                dp[i][(k * 10 + int(S[i])) % 13] += dp[i - 1][k]\n        else:\n            for j in range(10):\n                for k in range(13):\n                    dp[i][(k * 10 + j) % 13] += dp[i - 1][k]\n        for k in range(13):\n            dp[i][k] %= mod\nprint(dp[n - 1][5])\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC135_D_to_77", "old_id": "atcoder_ABC135_D"}
{"code": "from collections import deque\nfrom collections import Counter\nfrom itertools import product, permutations, combinations\nfrom operator import itemgetter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_left, bisect_right, bisect\nfrom fractions import gcd\nfrom math import ceil, floor, sqrt, cos, sin, pi, factorial\nimport sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9; MOD = MOD + 7\n\n\ndef main():\n    s = input()\n    if len(set(s)) == 1:\n        print(0)\n        sys.exit()\n    a = Counter(s)\n    ans = min(a.values()); ans = ans * 2\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC120_C_to_78", "old_id": "atcoder_ABC120_C"}
{"code": "from fractions import gcd\n\n\ndef lcm(a, b):\n    return a * b / gcd(a, b)\n\n\nMOD = 10 ** 9; MOD = MOD + 7\nN = int(input())\nA = list(map(int, input().split()))\n_lcm = 1\nfor a in A:\n    _lcm = _lcm * a; _lcm = _lcm // gcd(_lcm, a)\nans = _lcm * sum([pow(s, MOD - 2, MOD) for s in A]); ans = ans % MOD\nprint(int(ans % MOD))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC152_E_to_79", "old_id": "atcoder_ABC152_E"}
{"code": "n, m = map(int, input().split())\nif n < 1:\n    if m < 1:\n        print(n, m)\n        quit()\n    print(\"Impossible\")\n    quit()\nif m > n:\n    min = m\n    max = n + m; max = max - 1\n    print(min, max)\nif m <= n:\n    min = n\n    max = n + m; max = max - 1\n    if m == 0:\n        max = n\n    print(min, max)\n", "id": "AssignUnfoldding_sample_from_codeforces_190_A_to_80", "old_id": "codeforces_190_A"}
{"code": "import math\nfrom functools import reduce\nfrom collections import deque, Counter\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef get_nums_l():\n    return [int(s) for s in input().split(\" \")]\n\n\ndef get_nums_n(n):\n    return [int(input()) for _ in range(n)]\n\n\ndef get_all_int():\n    return map(int, open(0).read().split())\n\n\ndef rangeI(it, l, r):\n    for i, e in enumerate(it):\n        if l <= i < r:\n            yield e\n        elif l >= r:\n            break\n\n\ndef log(* args):\n    print(\"DEBUG:\", * args, file=sys.stderr)\n\n\nINF = 999999999999999999999999\nMOD = 10 ** 9; MOD = MOD + 7\nn = int(input())\nif n == 1:\n    print(0)\n    exit()\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n    if len(arr) == 0:\n        arr.append((n, 1))\n    return arr\n\n\nfac_ = prime_factorize(n)\nfac = Counter(fac_)\nans = 0\nfor p, e in fac.items():\n    x = e\n    for i in range(1, 99999999):\n        if x >= i:\n            x -= i\n            ans += 1\n        else:\n            break\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC169_D_to_81", "old_id": "atcoder_ABC169_D"}
{"code": "n = int(input())\nx = list(int(i) for i in input().split())\na = []\nb = []\nfor i in range(0, n):\n    if i % 2 == 0:\n        a.append(x[i])\n    else:\n        b.append(x[i])\ncnta = [0]; cnta = cnta * (100002 + 1)\ncntb = [0]; cntb = cntb * (100002 + 1)\nvala = 0\nvala1 = 0\nmaxCnta = 0\nmaxCnta1 = 0\nfor i in a:\n    cnta[i] += 1\nfor i in a:\n    if maxCnta < cnta[i]:\n        vala = i\n        maxCnta = cnta[i]\nfor i in a:\n    if maxCnta1 < cnta[i] and vala != i:\n        maxCnta1 = cnta[i]\n        vala1 = i\nvalb = 0\nvalb1 = 0\nmaxCntb = 0\nmaxCntb1 = 0\nfor i in b:\n    cntb[i] += 1\nfor i in b:\n    if maxCntb < cntb[i]:\n        valb = i\n        maxCntb = cntb[i]\nfor i in b:\n    if maxCntb1 < cntb[i] and valb != i:\n        maxCntb1 = cntb[i]\n        valb1 = i\nif valb != vala:\n    res = 0\n    for i in a:\n        if i != vala:\n            res += 1\n    for i in b:\n        if i != valb:\n            res += 1\n    print(res)\nelse:\n    resa = 0\n    resb = 0\n    resa1 = 0\n    resb1 = 0\n    for i in a:\n        if i != vala:\n            resa += 1\n        if i != vala1:\n            resa1 += 1\n    for i in b:\n        if i != valb:\n            resb += 1\n        if i != valb1:\n            resb1 += 1\n    print(min(resa + resb1, resa1 + resb))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC111_C_to_82", "old_id": "atcoder_ABC111_C"}
{"code": "import sys\nN, K = map(int, input().split())\nlst = list(map(int, input().split()))\nlst_p = []\nlst_m = []\nfor i in range(N):\n    if lst[i] == 0:\n        K -= 1\n    if lst[i] > 0:\n        lst_p += [lst[i]]\n    elif lst[i] < 0:\n        lst_m += [lst[i]]\np = 0\nm = 0\nx, y = 0, len(lst_m) - 1\nlastx = len(lst_p)\nlasty = len(lst_m)\n\n\ndef check(k):\n    ans = 10; ans = ans ** 9\n    for j in range(0, k + 1):\n        if j > lastx or k - j > lasty:\n            pass\n        else:\n            if j == 0:\n                p = 0\n            else:\n                p = lst_p[j - 1]\n            if k - j == 0:\n                m = 0\n            else:\n                m = lst_m[lasty - (k - j)]\n            ans = min(ans, 2 * p + abs(m), p + 2 * abs(m))\n    return ans\n\n\nprint(check(K))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC107_C_to_83", "old_id": "atcoder_ABC107_C"}
{"code": "mod = 10 ** 9; mod = mod + 7\nl = input()\nn = len(l)\ndp = [[0] * 2 for _ in range(n + 1)]\ndp[0][0] = 1\nfor i, c in enumerate(l):\n    if c == '0':\n        dp[i + 1][0] += dp[i][0]\n        dp[i + 1][1] += dp[i][1] * 3\n    else:\n        dp[i + 1][0] += dp[i][0] * 2\n        dp[i + 1][1] += dp[i][0]\n        dp[i + 1][1] += dp[i][1] * 3\n    dp[i + 1][0] %= mod\n    dp[i + 1][1] %= mod\nprint((dp[n][0] + dp[n][1]) % mod)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC129_E_to_84", "old_id": "atcoder_ABC129_E"}
{"code": "N = int(input())\nA = list(map(int, input().split()))\nmn, mx = N + 1, - 1\nfor i in range(N):\n    if (i + 1 != A[i]):\n        mn = min(mn, i)\n        mx = max(mx, i)\nif (mx == - 1):\n    print('0 0')\nelse:\n    A = A[: mn] + A[mn: (mx + 1)][:: - 1]; A = A + A[(mx + 1):]\n    if (sorted(A) == A):\n        print(mn + 1, mx + 1)\n    else:\n        print('0 0')\n", "id": "AssignUnfoldding_sample_from_codeforces_56_B_to_85", "old_id": "codeforces_56_B"}
{"code": "import sys\nfrom collections import deque\ninput = sys.stdin.buffer.readline\nN = int(input())\nadj = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\nque = deque()\nque.append(1)\nseen = [0]; seen = seen * (N + 1)\nseen[1] = 1\npar = [0]; par = par * (N + 1)\nchild_num = [0]; child_num = child_num * (N + 1)\nwhile que:\n    v = que.popleft()\n    for u in adj[v]:\n        if seen[u] == 0:\n            seen[u] = 1\n            par[u] = v\n            child_num[v] += 1\n            que.append(u)\nseq = deque()\nfor i in range(1, N + 1):\n    if child_num[i] == 0:\n        seq.append(i)\nwhile seq:\n    c = seq.pop()\n    seen[c] = 0\n    if seen[par[c]] == 0:\n        print('First')\n        exit()\n    seen[par[c]] = 0\n    child_num[par[par[c]]] -= 1\n    if child_num[par[par[c]]] == 0:\n        seq.append(par[par[c]])\nprint('Second')\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC014_D_to_86", "old_id": "atcoder_AGC014_D"}
{"code": "import queue\nn, b = list(map(int, input().split()))\n\n\nclass Task:\n    def __init__(self, time: int, duration: int, index: int) -> None:\n        super().__init__()\n        self.time = time\n        self.duration = duration\n        self.index = index\n\n\nremaining = queue.Queue()\nrunning = False\nfinish_time = 0\n\n\ndef run_task(remaining: queue.Queue, finish_time: int):\n    task_to_run = remaining.get()\n    finish_time = max(finish_time, task_to_run.time); finish_time = finish_time + task_to_run.duration\n    result[task_to_run.index] = finish_time\n    return finish_time, result\n\n\nresult = {}\nfor i in range(n):\n    time, duration = list(map(int, input().split()))\n    task = Task(time, duration, index=i)\n    result.update({i: 0})\n    if task.time > finish_time and remaining.empty():\n        running = True\n        finish_time = task.time; finish_time = finish_time + task.duration\n        result[i] = finish_time\n    else:\n        if task.time >= finish_time and not remaining.empty():\n            finish_time, result = run_task(\n                remaining=remaining, finish_time=finish_time)\n        if remaining.qsize() < b:\n            remaining.put(task)\n        else:\n            result[i] = - 1\nwhile not remaining.empty():\n    finish_time, result = run_task(\n        remaining=remaining, finish_time=finish_time)\nfor key in result:\n    print(result.get(key))\n", "id": "AssignUnfoldding_sample_from_codeforces_644_B_to_87", "old_id": "codeforces_644_B"}
{"code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 7)\ngraph = defaultdict(list)\nN, K = map(int, input().split())\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\nmod = 10 ** 9; mod = mod + 7\n\n\ndef dfs(fro, to, f):\n    caseNum = f\n    colorNum = K - 1 if f == K else K - 2\n    for u in graph[fro]:\n        if u == to:\n            continue\n        pat = dfs(u, fro, colorNum)\n        if pat == 0:\n            caseNum = 0\n            break\n        caseNum = caseNum * pat; caseNum = caseNum % mod\n        colorNum -= 1\n    return caseNum\n\n\nans = dfs(0, - 1, K)\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC133_E_to_88", "old_id": "atcoder_ABC133_E"}
{"code": "import sys\ninput = sys.stdin.readline\nN = 368\nm = [0]; m = m * N\nf = [0]; f = f * N\nfor i in range(int(input())):\n    x, a, b = input()[: - 1].split()\n    a = int(a)\n    b = int(b); b = b + 1\n    if x == 'M':\n        m[a] += 2\n        m[b] -= 2\n    else:\n        f[a] += 2\n        f[b] -= 2\na, b, c = 0, 0, 0\nfor i in range(N):\n    a += m[i]\n    b += f[i]\n    if min(a, b) > c:\n        c = min(a, b)\nprint(c)\n", "id": "AssignUnfoldding_sample_from_codeforces_629_B_to_89", "old_id": "codeforces_629_B"}
{"code": "import sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import sqrt, hypot, factorial, pi, sin, cos, radians\nif sys.version_info.minor >= 5:\n    from math import gcd\nelse:\n    from fractions import gcd\nfrom heapq import heappop, heappush, heapify, heappushpop\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom functools import reduce, partial\nfrom fractions import Fraction\nfrom string import ascii_lowercase, ascii_uppercase, digits\ndef input(): return sys.stdin.readline().strip()\ndef ceil(a, b=1): return int(- (- a // b))\ndef round(x): return int((x * 2 + 1) // 2)\ndef fermat(x, y, MOD): return x * pow(y, MOD - 2, MOD) % MOD\ndef lcm(x, y): return (x * y) // gcd(x, y)\ndef lcm_list(nums): return reduce(lcm, nums, initial=1)\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\n\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9; MOD = MOD + 7\nq, h, s, d = MAP()\nn = INT()\nbest1L = min(q * 4, h * 2, s)\nbest2L = min(d, best1L * 2)\nif n % 2 == 0:\n    print(best2L * (n // 2))\nelse:\n    print(best2L * (n // 2) + best1L)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC019_A_to_90", "old_id": "atcoder_AGC019_A"}
{"code": "n = int(input())\ninput_array = []\nfor i in range(n):\n    S, R, H, C = map(int, input().split())\n    input_array.append((S, R, H, C))\noutdated = []\nfor i in range(n):\n    for j in range(n):\n        if (input_array[i][0] < input_array[j][0] and input_array[i][1] < input_array[j][1] and input_array[i][2] < input_array[j][2]):\n            outdated.append(input_array[i])\noutdated = set(outdated)\nminimum_cost = 100000\ninput_number = 0\nfor i in range(n):\n    current_item = input_array[i]\n    cost = current_item[3]\n    if (current_item not in outdated and cost < minimum_cost):\n        minimum_cost = current_item[3]\n        input_number = i; input_number = input_number + 1\nprint(input_number)\n", "id": "AssignUnfoldding_sample_from_codeforces_106_B_to_91", "old_id": "codeforces_106_B"}
{"code": "t, m = map(int, input().split())\nalocuente = [0]; alocuente = alocuente * m\nind = 1\nfor i in range(t):\n    op = input().split()\n    if op[0] == 'alloc':\n        pos = 0\n        for j in range(m):\n            if alocuente[j] == 0:\n                pos += 1\n                if pos == int(op[1]):\n                    alocuente[j - int(op[1]) + 1: j + 1] = [ind]; alocuente[j - int(op[1]) + 1: j + 1] = alocuente[j - int(op[1]) + 1: j + 1] * int(op[1])\n                    print(ind)\n                    ind += 1\n                    break\n            else:\n                pos = 0\n        else:\n            print(\"NULL\")\n    if op[0] == 'erase':\n        pos = 0\n        if int(op[1]) not in alocuente or int(op[1]) == 0:\n            print('ILLEGAL_ERASE_ARGUMENT')\n        else:\n            for j in range(m):\n                if int(op[1]) > 0 and alocuente[j] == int(op[1]):\n                    alocuente[j] = 0\n    if op[0] == \"defragment\":\n        cnt = 0\n        cnt = alocuente.count(0)\n        alocuente = [j for j in alocuente if j != 0]\n        for j in range(cnt):\n            alocuente.append(0)\n", "id": "AssignUnfoldding_sample_from_codeforces_7_B_to_92", "old_id": "codeforces_7_B"}
{"code": "def solve_case():\n    n, m = map(int, input().split())\n    count = [None]; count = count * n\n    for i in range(n):\n        count[i] = [0]; count[i] = count[i] * n\n    ans = - 1\n    for k in range(m):\n        x, y = map(int, input().split())\n        x -= 1\n        y -= 1\n        found = False\n        for i in range(x - 2, x + 1):\n            for j in range(y - 2, y + 1):\n                if i >= 0 and i < n and j >= 0 and j < n:\n                    count[i][j] += 1\n                    if count[i][j] == 9:\n                        found = True\n        if found:\n            ans = k; ans = ans + 1\n            break\n    print(ans)\n\n\nsolve_case()\n", "id": "AssignUnfoldding_sample_from_codeforces_203_B_to_93", "old_id": "codeforces_203_B"}
{"code": "n = int(input())\nt = [0]; t = t + list(map(int, input().split()))\na = [0]; a = a + list(map(int, input().split()))\nans, cnt = [], [0 for i in range(n + 1)]\nfor i in a:\n    cnt[i] += 1\nfor i in range(1, n + 1):\n    if t[i] == 1:\n        crt = [i]\n        x = a[i]\n        while cnt[x] == 1:\n            crt.append(x)\n            x = a[x]\n        if len(crt) > len(ans):\n            ans = crt[:]\nans.reverse()\nprint(len(ans))\nprint(' '.join(map(str, ans)))\n", "id": "AssignUnfoldding_sample_from_codeforces_350_B_to_94", "old_id": "codeforces_350_B"}
{"code": "n = int(input())\na = list(map(int, input().split()))\nb = [0]; b = b * n\nfor i in range(n):\n    b[a[i] - 1] = i\nres = 0\nfor i in range(1, n):\n    res += abs(b[i] - b[i - 1])\nprint(res)\n", "id": "AssignUnfoldding_sample_from_codeforces_612_B_to_95", "old_id": "codeforces_612_B"}
{"code": "from sys import stdin\nfrom collections import Counter\nimport numpy as np\nN, M = [int(x) for x in stdin.readline().split()]\nA = np.array([int(a) for a in stdin.readline().split()], dtype=np.int64)\ncum_remainders = (np.hstack([0, A]) % M).cumsum(); cum_remainders = cum_remainders % M\nremainder_counts = Counter(cum_remainders)\ncombinations = 0\nfor count in remainder_counts.values():\n    combinations += count * (count - 1) // 2\nprint(combinations)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC105_D_to_96", "old_id": "atcoder_ABC105_D"}
{"code": "ip = input()\nst = \"\"\nif len(ip) != 1:\n    if ip[0] == \"9\":\n        st = \"9\"\n        ip = ip[1:]\n    for i in ip:\n        if int(i) > 4:\n            n = 9; n = n - int(i)\n            st += str(n)\n        else:\n            st += i\nelse:\n    st = ip\nprint(int(st))\n", "id": "AssignUnfoldding_sample_from_codeforces_514_A_to_97", "old_id": "codeforces_514_A"}
{"code": "import math\nimport string\nimport itertools\nimport fractions\nimport heapq\nimport collections\nimport re\nimport array\nimport bisect\nimport sys\nimport random\nimport time\nimport copy\nimport functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10; inf = inf ** 20\neps = 1.0; eps = eps / 10 ** 10\nmod = 10 ** 9; mod = mod + 7\ndd = [(- 1, 0), (0, 1), (1, 0), (0, - 1)]\nddn = [(- 1, 0), (- 1, 1), (0, 1), (1, 1),\n       (1, 0), (1, - 1), (0, - 1), (- 1, - 1)]\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n    k = I()\n    l = 0\n    for c in s:\n        if c != '1':\n            break\n        l += 1\n    if l >= k:\n        return 1\n    return s[l]\n\n\nprint(main())\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC106_C_to_98", "old_id": "atcoder_ABC106_C"}
{"code": "def resolve():\n    n = int(input())\n    low = []\n    high = []\n    for i in range(n):\n        a, b = map(int, input().split())\n        low.append(a)\n        high.append(b)\n    low.sort()\n    high.sort()\n    if n % 2:\n        print(high[(n + 1) // 2 - 1] - low[(n + 1) // 2 - 1] + 1)\n    else:\n        hh = (high[(n) // 2 - 1] + high[(n) // 2]); hh = hh / 2\n        ll = (low[(n) // 2 - 1] + low[(n) // 2]); ll = ll / 2\n        print(int((hh - ll) * 2) + 1)\n\n\nif __name__ == \"__main__\":\n    resolve()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC169_E_to_99", "old_id": "atcoder_ABC169_E"}
{"code": "n = int(input())\nl = [0 for _ in range(1000010)]\ndp = [0 for _ in range(1000010)]\nfor i in range(n):\n    a, b = map(int, input().split())\n    l[a] = b\nif l[0] > 0:\n    dp[0] = 1\nmx = 0\nfor i in range(1, 1000010):\n    if (l[i] == 0):\n        dp[i] = dp[i - 1]\n    else:\n        if (l[i] >= i):\n            dp[i] = 1\n        else:\n            dp[i] = dp[i - l[i] - 1]; dp[i] = dp[i] + 1\n    if (dp[i] > mx):\n        mx = dp[i]\nprint(n - mx)\n", "id": "AssignUnfoldding_sample_from_codeforces_607_A_to_100", "old_id": "codeforces_607_A"}
{"code": "from math import atan2, pi\nN, * XY = map(int, open(0).read().split())\nXY = list(zip(* [iter(XY)] * 2))\nfor i, (x, y) in enumerate(XY):\n    D = sorted(atan2(X - x, Y - y) for j, (X, Y) in enumerate(XY) if j != i)\n    D.append(D[0] + 2 * pi)\n    ans = 0\n    for a, b in zip(D, D[1:]):\n        if b - a >= pi:\n            ans = (b - a); ans = ans - pi\n    print(ans / (2 * pi))\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC021_B_to_101", "old_id": "atcoder_AGC021_B"}
{"code": "import sys\nfrom operator import itemgetter\ninput = sys.stdin.readline\nTIME = 0\nVAL = 1\nN, T = [int(a) for a in input().split()]\ntime_value = [(- 1, - 1)]; time_value = time_value + [None] * (N)\nfor i in range(1, N + 1):\n    time_value[i] = tuple(int(a) for a in input().split())\ntime_value.sort(key=itemgetter(VAL))\ndp = [[- 1] * T for _ in range(N + 1)]\nfor t in range(0, T):\n    dp[0][t] = 0\nfor n in range(1, N + 1):\n    dp[n][0] = 0\n    for t in range(1, T):\n        if time_value[n][TIME] > t:\n            dp[n][t] = dp[n - 1][t]\n        else:\n            dp[n][t] = max(dp[n - 1][t], time_value[n][VAL] +\n                           dp[n - 1][t - time_value[n][TIME]])\nval_acum = time_value[N][VAL]\nt = T; t = t - 1\nmax_val = val_acum; max_val = max_val + dp[N - 1][t]\nfor n in range(N - 1, 0, - 1):\n    val_acum += time_value[n][VAL]\n    t -= time_value[n + 1][TIME]\n    if t < 0:\n        break\n    else:\n        max_val = max(max_val, val_acum + dp[n - 1][t])\nprint(max_val)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC145_E_to_102", "old_id": "atcoder_ABC145_E"}
