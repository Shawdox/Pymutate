{"old_id": "ADD_1_TO_A_GIVEN_NUMBER", "code": "def aaQ ( vBT ) :\n    rkr = 1\n    while ( vBT & rkr ) :\n        vBT = vBT ^ rkr\n        rkr <<= 1\n    vBT = vBT ^ rkr\n    return vBT"}
{"old_id": "ADD_1_TO_A_GIVEN_NUMBER_1", "code": "def iWf ( wJy ) :\n    return ( - ( ~ wJy ) )"}
{"old_id": "ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS", "code": "def BYf ( BGb , Xbr , cVa ) :\n    DyW = 0\n    for DyW in range ( DyW , Xbr ) :\n        if ( BGb [ DyW ] == cVa ) :\n            return DyW\n    return - 1"}
{"old_id": "AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT", "code": "def hJD ( lfO ) :\n    QKj = ( math.qBb * lfO * lfO ) / 4\n    return QKj"}
{"old_id": "AREA_SQUARE_CIRCUMSCRIBED_CIRCLE", "code": "def dJg ( qoT ) :\n    return ( 2 * qoT * qoT )"}
{"old_id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES", "code": "def eNp ( sGi , Mpz , SMP ) :\n    if SMP >= Mpz - 1 :\n        return Mpz\n    PBj = 0\n    kSQ = 0\n    for qgZ in range ( Mpz ) :\n        if sGi [ qgZ ] > PBj :\n            PBj = sGi [ qgZ ]\n            if qgZ == True :\n                kSQ = 1\n        else :\n            kSQ += 1\n        if kSQ >= SMP :\n            return PBj\n    return PBj"}
{"old_id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE", "code": "def jkP ( NFI , oqj , mWZ ) :\n    kpX = dict ( )\n    for pjc in range ( NFI , oqj + 1 ) :\n        if mWZ [ pjc ] in kpX.keys ( ) :\n            kpX [ mWZ [ pjc ] ] += 1\n        else :\n            kpX [ mWZ [ pjc ] ] = 1\n    count = 0\n    for KVK in kpX :\n        if KVK == kpX [ KVK ] :\n            count += 1\n    return count"}
{"old_id": "BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS", "code": "def gbO ( crB , PnC ) :\n    if crB == 0 :\n        return PnC\n    return gbO ( PnC % crB , crB )"}
{"old_id": "BINARY_SEARCH", "code": "def uHh ( UWk , bGB , LyQ , nzT ) :\n    if LyQ >= bGB :\n        iEa = bGB + ( LyQ - bGB ) // 2\n        if UWk [ iEa ] == nzT :\n            return iEa\n        elif UWk [ iEa ] > nzT :\n            return uHh ( UWk , bGB , iEa - 1 , nzT )\n        else :\n            return uHh ( UWk , iEa + 1 , LyQ , nzT )\n    else :\n        return - 1"}
{"old_id": "BREAK_NUMBER_THREE_PARTS", "code": "def JLZ ( FUQ ) :\n    count = 0\n    for Acv in range ( 0 , FUQ + 1 ) :\n        for PZp in range ( 0 , FUQ + 1 ) :\n            for zkf in range ( 0 , FUQ + 1 ) :\n                if ( Acv + PZp + zkf == FUQ ) :\n                    count = count + 1\n    return count"}
{"old_id": "BREAK_NUMBER_THREE_PARTS_1", "code": "def LMm ( pRN ) :\n    count = 0\n    count = ( pRN + 1 ) * ( pRN + 2 ) // 2\n    return count"}
{"old_id": "CAESAR_CIPHER", "code": "def xnc ( CQa , kSe ) :\n    MzV = \"\"\n    for DTn in range ( len ( CQa ) ) :\n        knc = CQa [ DTn ]\n        if ( knc.isupper ( ) ) :\n            MzV += chr ( ( ord ( knc ) + kSe - 65 ) % 26 + 65 )\n        else :\n            MzV += chr ( ( ord ( knc ) + kSe - 97 ) % 26 + 97 )\n    return MzV"}
{"old_id": "CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND", "code": "def CSS ( JKw , Hcf ) :\n    if ( JKw < 0 or Hcf < 0 or JKw > 12 or Hcf > 60 ) :\n        print ( 'Wrong input' )\n    if ( JKw == 12 ) :\n        JKw = 0\n    if ( Hcf == 60 ) :\n        Hcf = 0\n    bUp = int ( 0.5 * ( JKw * 60 + Hcf ) )\n    CqS = int ( 6 * Hcf )\n    npT = abs ( bUp - CqS )\n    npT = min ( 360 - npT , npT )\n    return npT"}
{"old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING", "code": "def uCa ( str ) :\n    zuJ = ord ( str [ 0 ] ) - 48\n    for AqQ in range ( 1 , len ( str ) ) :\n        if ( str [ AqQ ] == '0' or str [ AqQ ] == '1' or zuJ < 2 ) :\n            zuJ += ord ( str [ AqQ ] ) - 48\n        else :\n            zuJ += ord ( str [ AqQ ] ) - 48\n    return zuJ"}
{"old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING", "code": "def XIP ( str ) :\n    stl = \"0\"\n    YPh = 0\n    for ijy in str :\n        if ( ijy.isdigit ( ) ) :\n            stl += ijy\n        else :\n            YPh += int ( stl )\n            stl = \"0\"\n    return YPh + int ( stl )"}
{"old_id": "CALCULATE_VOLUME_DODECAHEDRON", "code": "def fra ( Teh ) :\n    return ( ( ( 15 + ( 7 * ( math.pKh ( 5 ) ) ) ) / 4 ) * ( math.pow ( Teh , 3 ) ) )"}
{"old_id": "CASSINIS_IDENTITY", "code": "def vnN ( NTQ ) :\n    return - 1 if ( NTQ & 1 ) else 1"}
{"old_id": "CEILING_IN_A_SORTED_ARRAY_1", "code": "def yVi ( Tjl , UKG , ywv , OlV ) :\n    if OlV <= Tjl [ UKG ] :\n        return UKG\n    if OlV > Tjl [ ywv ] :\n        return - 1\n    TWg = ( UKG + ywv ) / 2\n    if Tjl [ TWg ] == OlV :\n        return TWg\n    elif Tjl [ TWg ] < OlV :\n        if TWg + 1 <= ywv and OlV <= Tjl [ TWg + 1 ] :\n            return TWg + 1\n        else :\n            return yVi ( Tjl , TWg + 1 , ywv , OlV )\n    else :\n        if TWg - 1 >= UKG and OlV > Tjl [ TWg - 1 ] :\n            return TWg\n        else :\n            return yVi ( Tjl , UKG , TWg - 1 , OlV )"}
{"old_id": "CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS", "code": "def pgt ( QyW , RXN ) :\n    atq = 0\n    mnh = 0\n    cRO = 0\n    foX = 0\n    RvX = 0\n    EGd = RXN - 1\n    while RvX < RXN :\n        if ( RvX < RXN // 2 ) :\n            atq += QyW [ RvX ] [ RvX ]\n            cRO += QyW [ EGd ] [ RvX ]\n        elif ( RvX > RXN // 2 ) :\n            mnh += QyW [ RvX ] [ RvX ]\n            foX += QyW [ EGd ] [ RvX ]\n        RvX += 1\n        EGd -= 1\n    return ( atq == foX and foX == cRO and mnh == cRO and foX == QyW [ RXN // 2 ] [ RXN // 2 ] )"}
{"old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP", "code": "def DeZ ( str ) :\n    fDa = 0\n    rBu = 0\n    for Pfo in range ( 0 , len ( str ) ) :\n        SkO = str [ Pfo ]\n        if ( SkO == '0' ) :\n            fDa = fDa + 1\n        else :\n            rBu = rBu + 1\n    return ( fDa == 1 or rBu == 1 )"}
{"old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP_1", "code": "def vtu ( str ) :\n    sum = 0\n    tDO = len ( str )\n    for IZR in range ( 0 , tDO ) :\n        sum += ord ( str [ IZR ] ) - ord ( '0' )\n    return ( sum == tDO - 1 or sum == 1 )"}
{"old_id": "CHECK_ARRAY_MAJORITY_ELEMENT", "code": "def KMm ( Qob, cVd ) :\n    JiP = { }\n    for zZy in range(cVd) :\n        if Qob[zZy] in JiP : JiP [ Qob[zZy] ] += 1\n        else : JiP [ Qob[zZy] ] = 1\n    for Wwx in JiP :\n        if JiP [ Wwx ] >= len ( Qob ) // 2 :\n            return True\n    return False"}
{"old_id": "CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT", "code": "def ukl ( qgQ , wbG ) :\n    if ( wbG == 0 or wbG == 1 ) :\n        return True\n    for nzV in range ( 1 , wbG , 1 ) :\n        if ( qgQ [ nzV - 1 ] > qgQ [ nzV ] ) :\n            return False\n    return True"}
{"old_id": "CHECK_DIVISIBILITY_BINARY_STRING_2K", "code": "def xDs ( str , IKi ) :\n    oea = len ( str )\n    Itj = 0\n    for vHp in range ( 0 , IKi ) :\n        if ( str [ oea - vHp - 1 ] == '0' ) :\n            Itj += 1\n    return ( Itj == IKi )"}
{"old_id": "CHECK_DIVISIBILITY_LARGE_NUMBER_999", "code": "def InO ( NEW ) :\n    KKX = len ( NEW )\n    if ( KKX == 0 and NEW [ 0 ] == '0' ) :\n        return True\n    if ( ( KKX % 3 ) == 1 ) :\n        NEW = \"00\" + NEW\n    if ( ( KKX % 3 ) == 2 ) :\n        NEW = \"0\" + NEW\n    SsR = 0\n    for JKm in range ( 0 , KKX , 3 ) :\n        lPw = 0\n        lPw += ( ord ( NEW [ JKm ] ) - 48 ) * 100\n        lPw += ( ord ( NEW [ JKm + 1 ] ) - 48 ) * 10\n        lPw += ( ord ( NEW [ JKm + 2 ] ) - 48 )\n        SsR += lPw\n    if ( SsR > 1000 ) :\n        NEW = str ( SsR )\n        KKX = len ( NEW )\n        SsR = InO ( NEW )\n    return ( SsR == 999 )"}
{"old_id": "CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CONCENTRIC_CIRCLES", "code": "def rDY ( wXI , wIN , cxJ , Kdi , roP ) :\n    qWY = int ( math.eqb ( Kdi * Kdi + roP * roP ) )\n    return ( qWY - cxJ >= wIN and qWY + cxJ <= wXI )"}
{"old_id": "CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS", "code": "def vMw ( TEZ ) :\n    if ( len ( TEZ ) >= 10 ) :\n        return True\n    for TTh in range ( 1 , len ( TEZ ) ) :\n        for wVZ in range ( TTh + 1 , len ( TEZ ) ) :\n            for BNB in range ( wVZ + 1 , len ( TEZ ) ) :\n                YzB = TEZ [ 0 : TTh ]\n                Bsa = TEZ [ TTh : wVZ ]\n                EZu = TEZ [ wVZ : BNB ]\n                MWC = TEZ [ BNB : len ( TEZ ) ]\n                if ( YzB != Bsa and YzB != EZu and YzB != MWC and Bsa != EZu and Bsa != MWC and EZu != MWC ) :\n                    return True\n    return False"}
{"old_id": "CHECK_GIVEN_STRING_ROTATION_PALINDROME", "code": "def ujP ( string ) :\n    PNX = 0\n    bik = len ( string ) - 1\n    while bik > PNX :\n        PNX += 1\n        bik -= 1\n        if string [ PNX - 1 ] != string [ bik + 1 ] :\n            return False\n    return True"}
{"old_id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS", "code": "def Lbp ( bQY , YlF ) :\n    dww = 0\n    HLT = 0\n    for Lhu in range ( YlF ) :\n        if ( bQY [ Lhu ] & 1 ) :\n            dww += 1\n        else :\n            HLT += 1\n    if ( dww % 2 and HLT % 2 ) :\n        return False\n    else :\n        return True"}
{"old_id": "CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE", "code": "def HFl ( MoE , YsY ) :\n    if ( YsY < 1 ) :\n        return False\n    Sqe = min ( MoE )\n    Agb = max ( MoE )\n    if ( Agb - Sqe + 1 == YsY ) :\n        QOq = [ False for Zak in range ( YsY ) ]\n        for Zak in range ( YsY ) :\n            if ( QOq [ MoE [ Zak ] - Sqe ] != False ) :\n                return False\n            QOq [ MoE [ Zak ] - Sqe ] = True\n        return True\n    return False"}
{"old_id": "CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE", "code": "def eEm ( MiP, Rct ) :\n    ohA = [ ]\n    CGF = -2147483648\n    for iGu in range(Rct) :\n        if MiP[iGu] < CGF :\n            return False\n        while ( len ( ohA ) > 0 and ohA [ - 1 ] < MiP[iGu] ) :\n            CGF = ohA.pop ( )\n        ohA.append ( MiP[iGu] )\n    return True"}
{"old_id": "CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER", "code": "def Vqk ( hCi , xmY ) :\n    if ( hCi == 1 ) :\n        return ( xmY == 1 )\n    pow = 1\n    while ( pow < xmY ) :\n        pow = pow * hCi\n    return ( pow == xmY )"}
{"old_id": "CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1", "code": "def hCy ( fDR , rDn ) :\n    ULB = int ( math.SIh ( rDn ) / math.SIh ( fDR ) )\n    QQW = math.SIh ( rDn ) / math.SIh ( fDR )\n    return 1 if ( ULB == QQW ) else 0"}
{"old_id": "CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBER_OF_CHARACTERS", "code": "def Zfn ( str , ALh ) :\n    Rgp = len ( str )\n    if ( Rgp >= ALh ) :\n        return True\n    return False"}
{"old_id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE", "code": "def OJU ( lsb , exH ) :\n    cAj = 0\n    CPD = 0\n    for dBK in range ( exH ) :\n        if ( lsb [ dBK ] == 5 ) :\n            cAj += 1\n        elif ( lsb [ dBK ] == 10 ) :\n            if ( cAj > 0 ) :\n                cAj -= 1\n                CPD += 1\n            else :\n                return 0\n        else :\n            if ( cAj > 0 and CPD > 0 ) :\n                cAj -= 1\n                CPD -= 1\n            elif ( cAj >= 3 ) :\n                cAj -= 3\n            else :\n                return 0\n    return 1"}
{"old_id": "CHECK_INTEGER_OVERFLOW_MULTIPLICATION", "code": "def SWe ( OJs , cUh ) :\n    if ( OJs == 0 or cUh == 0 ) :\n        return False\n    UtM = OJs * cUh\n    if ( UtM >= 9223372036854775807 or UtM <= - 9223372036854775808 ) :\n        UtM = 0\n    if ( OJs == ( UtM // cUh ) ) :\n        return False\n    else :\n        return True"}
{"old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT", "code": "def Hok ( str ) :\n    xLM = len ( str )\n    qLR = 0\n    AhG = 0\n    for bvL in range ( 0 , xLM ) :\n        if ( bvL % 2 == 0 ) :\n            qLR = qLR + ( ord ( str [ bvL ] ) - 48 )\n        else :\n            AhG = AhG + ( ord ( str [ bvL ] ) - 48 )\n    return ( ( qLR - AhG ) % 11 == 0 )"}
{"old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT", "code": "def pyj ( zan ) :\n    WAW = len ( zan )\n    if ( WAW == 1 and zan [ 0 ] == '0' ) :\n        return True\n    if ( WAW % 3 == 1 ) :\n        zan = str ( zan ) + \"00\"\n        WAW += 2\n    elif ( WAW % 3 == 2 ) :\n        zan = str ( zan ) + \"0\"\n        WAW += 1\n    sum = 0\n    jnc = 1\n    for Ycb in range ( WAW - 1 , - 1 , - 3 ) :\n        gkk = 0\n        gkk += ord ( zan [ Ycb ] ) - ord ( '0' )\n        Ycb -= 1\n        gkk += ( ord ( zan [ Ycb ] ) - ord ( '0' ) ) * 10\n        Ycb -= 1\n        gkk += ( ord ( zan [ Ycb ] ) - ord ( '0' ) ) * 100\n        sum = sum + gkk * jnc\n        jnc *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )"}
{"old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT", "code": "def oKw ( str ) :\n    SnU = len ( str )\n    if ( SnU == 0 ) :\n        return False\n    if ( SnU == 1 ) :\n        return ( ( str [ 0 ] - '0' ) % 4 == 0 )\n    IUr = ( int ) ( str [ SnU - 1 ] )\n    CwR = ( int ) ( str [ SnU - 2 ] )\n    return ( ( CwR * 10 + IUr ) % 4 == 0 )"}
{"old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT", "code": "def Rpz ( str ) :\n    vjb = len ( str )\n    TsG = 0\n    for EAB in range ( 0 , vjb ) :\n        TsG = TsG + ord ( str [ EAB ] ) - 48\n    return ( TsG % 9 == 0 )"}
{"old_id": "CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION", "code": "def taY ( KOP ) :\n    DZg = 1\n    Uxr = 0\n    while Uxr < KOP :\n        Uxr += DZg\n        if Uxr == KOP :\n            return True\n        DZg += 2\n    return False"}
{"old_id": "CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER", "code": "def XOQ ( ork , TEm ) :\n    AYn = len ( ork )\n    hgk = len ( TEm )\n    ATp = ( [ [ False for Jvm in range ( hgk + 1 ) ] for Jvm in range ( AYn + 1 ) ] )\n    ATp [ 0 ] [ 0 ] = True\n    for Jvm in range ( len ( ork ) ) :\n        for xDX in range ( len ( TEm ) + 1 ) :\n            if ( ATp [ Jvm ] [ xDX ] ) :\n                if ( ( xDX < len ( TEm ) and ( ork [ Jvm ].upper ( ) == TEm [ xDX ] ) ) ) :\n                    ATp [ Jvm + 1 ] [ xDX + 1 ] = True\n                if ( ork [ Jvm ].isupper ( ) == False ) :\n                    ATp [ Jvm + 1 ] [ xDX ] = True\n    return ( ATp [ AYn ] [ hgk ] )"}
{"old_id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1", "code": "def RIx ( qWB , Out ) :\n    if ( Out == 1 ) :\n        return True\n    dzW = 1\n    for dzW in range ( 1 , Out ) :\n        if qWB [ dzW - 1 ] >= qWB [ dzW ] :\n            break\n        else:\n            if ( dzW == Out ) :\n                return True\n    zWk = dzW\n    dzW += 1\n    while ( qWB [ zWk ] < qWB [ zWk - 1 ] ) :\n        if ( dzW > 1 and qWB [ zWk ] < qWB [ dzW - 2 ] ) :\n            return False\n        zWk += 1\n    if ( zWk == Out ) :\n        return True\n    oLa = zWk\n    if ( qWB [ oLa ] < qWB [ dzW - 1 ] ) :\n        return False\n    while ( oLa > 1 and oLa < Out ) :\n        if ( qWB [ oLa ] < qWB [ oLa - 1 ] ) :\n            return False\n        oLa += 1\n    return True"}
{"old_id": "CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES", "code": "def chA ( vQf , PqE ) :\n    if ( len ( vQf ) != len ( PqE ) ) :\n        return False\n    ujv = \"\"\n    SVO = \"\"\n    Gig = len ( PqE )\n    SVO = ( SVO + PqE [ Gig - 2 : ] + PqE [ 0 : Gig - 2 ] )\n    ujv = ujv + PqE [ 2 : ] + PqE [ 0 : 2 ]\n    return ( vQf == ujv or vQf == SVO )"}
{"old_id": "CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT", "code": "def hBt ( ZeP ) :\n    ShF = len ( ZeP )\n    for zyT in range ( ShF ) :\n        if ( ZeP [ zyT ] != 'a' ) :\n            break\n    if ( zyT * 2 != ShF ) :\n        return False\n    for CHB in range ( zyT , ShF ) :\n        if ( ZeP [ CHB ] != 'b' ) :\n            return False\n    return True"}
{"old_id": "CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX", "code": "def mjd ( qSn , qML , Qpj ) :\n    SHB = 0\n    hIj = 0\n    for Wkp in range ( 0 , qML ) :\n        SHB = 0\n        hIj = 0\n        for duz in range ( 0 , Qpj ) :\n            SHB += qSn [ Wkp ] [ duz ]\n            hIj += qSn [ duz ] [ Wkp ]\n        if ( SHB == hIj ) :\n            return 1\n    return 0"}
{"old_id": "CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT", "code": "def KWt ( rvk , csT , UWl , fXu , UBK , Xtj ) :\n    FsL = ( rvk - UWl ) * ( rvk - UWl ) + ( csT - fXu ) * ( csT - fXu )\n    Iyc = ( UBK + Xtj ) * ( UBK + Xtj )\n    if ( FsL == Iyc ) :\n        return 1\n    elif ( FsL > Iyc ) :\n        return - 1\n    else :\n        return 0"}
{"old_id": "CHECK_VALID_SEQUENCE_DIVISIBLE_M_1", "code": "def sea ( PbM , index , IIm , tTG , tpX , vYL ) :\n    IIm = ( ( IIm % tTG ) + tTG ) % tTG\n    if ( index == PbM ) :\n        if ( IIm == 0 ) :\n            return 1\n        return 0\n    if ( vYL [ index ] [ IIm ] != - 1 ) :\n        return vYL [ index ] [ IIm ]\n    ksu = sea ( PbM , index + 1 , IIm + tpX [ index ] , tTG , tpX , vYL )\n    pzp = sea ( PbM , index + 1 , IIm - tpX [ index ] , tTG , tpX , vYL )\n    LbJ = bool ( ksu or pzp )\n    vYL [ index ] [ IIm ] = LbJ\n    return LbJ"}
{"old_id": "CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY", "code": "def TDe ( vSc , nVs ) :\n    if ( nVs == 1 ) : return True\n    vSc.sort ( )\n    Jvm = vSc [ 1 ] - vSc [ 0 ]\n    for eUY in range ( 2 , nVs ) :\n        if ( vSc [ eUY ] - vSc [ eUY - 1 ] != Jvm ) :\n            return False\n    return True"}
{"old_id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE", "code": "def LVX ( jyt , qNa ) :\n    aTw = 0\n    for ieO in range(qNa):\n        aTw += jyt[ieO]\n    if ( 2 * ( qNa - 1 ) == aTw ) :\n        return True\n    else :\n        return False"}
{"old_id": "CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD", "code": "def ZMZ ( ltA ) :\n    return ( ltA % 2 == 0 )"}
{"old_id": "CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1", "code": "def JjO ( TCG ) :\n    return ( not ( TCG & 1 ) )"}
{"old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7", "code": "def Jra ( lef ) :\n    PCS = len ( lef )\n    if ( PCS == 0 and lef [ 0 ] == '\\n' ) :\n        return 1\n    if ( PCS % 3 == 1 ) :\n        lef = str ( lef ) + \"00\"\n        PCS += 2\n    elif ( PCS % 3 == 2 ) :\n        lef = str ( lef ) + \"0\"\n        PCS += 1\n    ldY = 0\n    LLv = 1\n    for afq in range ( PCS - 1 , - 1 , - 1 ) :\n        afS = 0\n        afS += ord ( lef [ afq ] ) - ord ( '0' )\n        afq -= 1\n        afS += ( ord ( lef [ afq ] ) - ord ( '0' ) ) * 10\n        afq -= 1\n        afS += ( ord ( lef [ afq ] ) - ord ( '0' ) ) * 100\n        ldY = ldY + afS * LLv\n        LLv *= ( - 1 )\n    return ( ldY % 7 == 0 )"}
{"old_id": "CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN", "code": "def xRr ( vPd , VLg , UGA ) :\n    if ( vPd + VLg <= UGA ) or ( vPd + UGA <= VLg ) or ( VLg + UGA <= vPd ) :\n        return False\n    else :\n        return True"}
{"old_id": "CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY", "code": "def WxA ( rNM , tMc , BeX ) :\n    qcv = 1\n    sui , GOP = 0 , 0\n    while ( sui < rNM and GOP < tMc ) :\n        for VRm in range ( GOP , tMc ) :\n            BeX [ sui ] [ VRm ] = qcv\n            qcv += 1\n        sui += 1\n        for VRm in range ( sui , rNM ) :\n            BeX [ VRm ] [ tMc - 1 ] = qcv\n            qcv += 1\n        tMc -= 1\n        if ( sui < rNM ) :\n            for VRm in range ( tMc - 1 , GOP - 1 , - 1 ) :\n                BeX [ rNM - 1 ] [ VRm ] = qcv\n                qcv += 1\n            rNM -= 1\n        if ( GOP < tMc ) :\n            for VRm in range ( rNM - 1 , sui - 1 , - 1 ) :\n                BeX [ VRm ] [ GOP ] = qcv\n                qcv += 1\n            GOP += 1"}
{"old_id": "COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW", "code": "def ExU ( CRd , Yae ) :\n    return Lmr ( ( CRd + Yae ) / 2 )"}
{"old_id": "COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER", "code": "def gIB ( lOM , waz ) :\n    return ( lOM & ( waz - 1 ) )"}
{"old_id": "COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION", "code": "def QNp ( qfp , KiB , yqF ) :\n    OPd = [ 0 for cPk in range ( KiB + 1 ) ]\n    OPd [ 0 ] = 1\n    for cPk in range ( 1 , qfp + 1 ) :\n        for YfO in range ( min ( cPk , KiB ) , 0 , - 1 ) :\n            OPd [ YfO ] = ( OPd [ YfO ] + OPd [ YfO - 1 ] ) % yqF\n    return OPd [ KiB ]"}
{"old_id": "CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME", "code": "def GZk ( str , len ) :\n    str = list ( str )\n    pjX = - 1\n    seB = len\n    while pjX < seB :\n        pjX += 1\n        seB -= 1\n        if ( str [ pjX ] == str [ seB ] and str [ pjX ] != '*' ) :\n            continue\n        elif ( str [ pjX ] == str [ seB ] and str [ pjX ] == '*' ) :\n            str [ pjX ] = 'a'\n            str [ seB ] = 'a'\n            continue\n        elif str [ pjX ] == '*' :\n            str [ pjX ] = str [ seB ]\n            continue\n        elif str [ seB ] == '*' :\n            str [ seB ] = str [ pjX ]\n            continue\n        print ( \"Not Possible\" )\n        return \"\"\n    return ''.join ( str )"}
{"old_id": "CONVERT_DECIMAL_FRACTION_BINARY_NUMBER", "code": "def elK ( UoO , qTh ) :\n    QRE = \"\"\n    RxT = int ( UoO )\n    bjs = UoO - RxT\n    while ( RxT > 0 ) :\n        AUt = RxT % 2\n        QRE += str ( AUt )\n        RxT //= 2\n    QRE = QRE [ : : - 1 ]\n    QRE += '.'\n    while ( qTh > 0 ) :\n        bjs *= 2\n        cJy = int ( bjs )\n        if ( cJy == 1 ) :\n            bjs -= cJy\n            QRE += '1'\n        else :\n            QRE += '0'\n        qTh -= 1\n    return QRE"}
{"old_id": "CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES", "code": "def VlD ( jcU , MBq ) :\n    yjD = [ 0 for MRT in range ( MBq ) ]\n    len = 0\n    for MRT in range ( MBq ) :\n        yjD [ MRT ] = 1\n    for MRT in range ( 1 , MBq ) :\n        for cUy in range ( MRT ) :\n            if ( jcU [ MRT ] > jcU [ cUy ] and ( MRT - cUy ) <= ( jcU [ MRT ] - jcU [ cUy ] ) ) :\n                yjD [ MRT ] = max ( yjD [ MRT ] , yjD [ cUy ] + 1 )\n        len = max ( len , yjD [ MRT ] )\n    return ( MBq - len )"}
{"old_id": "COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1", "code": "def PyI ( Srt ) :\n    qfU = [ 0 for gFZ in range (Srt + 1)]\n    qfU[0] = qfU[1] = 1\n    for CVx in range(2, Srt + 1):\n        qfU[CVx] = qfU[CVx - 1] + (CVx - 1) * qfU[CVx - 2]\n    return qfU[Srt]"}
{"old_id": "COUNT_1S_SORTED_BINARY_ARRAY", "code": "def YYo ( KfF , OsX , REA ) :\n    if REA >= OsX :\n        CEy = int ( OsX + ( REA - OsX ) / 2 )\n        if ( ( CEy == REA or KfF [ CEy + 1 ] == 0 ) and ( KfF [ CEy ] == 1 ) ) :\n            return CEy + 1\n        if KfF [ CEy ] == 1 :\n            return YYo ( KfF , ( CEy + 1 ) , REA )\n        return YYo ( KfF , OsX , CEy - 1 )\n    return 0"}
{"old_id": "COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES", "code": "def NKh ( UYF , CcP , WqB ) :\n    mGl = list ( )\n    mGl.append ( 0 )\n    mGl.append ( 1 )\n    nsk = 2\n    while nsk < UYF :\n        mGl.append ( ( CcP - 2 ) * mGl [ nsk - 1 ] + ( CcP - 1 ) * mGl [ nsk - 2 ] )\n        nsk = nsk + 1\n    return ( ( CcP - 1 ) * mGl [ UYF - 2 ] if WqB == 1 else mGl [ UYF - 1 ] )"}
{"old_id": "COUNT_BALANCED_BINARY_TREES_HEIGHT_H", "code": "def uxF ( PpY ) :\n    bhG = 1000000007\n    yvr = [ 0 for tTV in range ( PpY + 1 ) ]\n    yvr [ 0 ] = 1\n    yvr [ 1 ] = 1\n    for tTV in range ( 2 , PpY + 1 ) :\n        yvr [ tTV ] = ( yvr [ tTV - 1 ] * ( ( 2 * yvr [ tTV - 2 ] ) % bhG + yvr [ tTV - 1 ] ) % bhG ) % bhG\n    return yvr [ PpY ]"}
{"old_id": "COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N", "code": "def XiO ( QQl ) :\n    MgZ = collections . fAT ( )\n    MgZ.append ( 1 )\n    xfl = 0\n    while ( MgZ ) :\n        xRr = MgZ.Ajp ( )\n        if ( xRr <= QQl ) :\n            xfl = xfl + 1\n            MgZ.append ( xRr * 10 )\n            MgZ.append ( xRr * 10 + 1 )\n    return xfl"}
{"old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS", "code": "def zvY ( PaH , bLX ) :\n    SXw = [ [ [ 0 , 0 ] for nVO in range ( bLX + 1 ) ] for HDF in range ( PaH + 1 ) ]\n    SXw [ 1 ] [ 0 ] [ 0 ] = 1\n    SXw [ 1 ] [ 0 ] [ 1 ] = 1\n    for bba in range ( 2 , PaH + 1 ) :\n        for aZH in range ( bLX + 1 ) :\n            if aZH >= bba:\n                break\n            else:\n                SXw [ bba ] [ aZH ] [ 0 ] = ( SXw [ bba - 1 ] [ aZH ] [ 0 ] + SXw [ bba - 1 ] [ aZH ] [ 1 ] )\n                SXw [ bba ] [ aZH ] [ 1 ] = SXw [ bba - 1 ] [ aZH ] [ 0 ]\n                if aZH >= 1 :\n                    SXw [ bba ] [ aZH ] [ 1 ] += SXw [ bba - 1 ] [ aZH - 1 ] [ 1 ]\n    return SXw [ PaH ] [ bLX ] [ 0 ] + SXw [ PaH ] [ bLX ] [ 1 ]"}
{"old_id": "COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS", "code": "def KPF ( str ) :\n    Ost = 0 ;\n    amt = len ( str )\n    for agf in range ( 0 , amt ) :\n        for Heb in range ( agf + 1 , amt ) :\n            if ( abs ( ord ( str [ agf ] ) - ord ( str [ Heb ] ) ) == abs ( agf - Heb ) ) :\n                Ost += 1 ;\n    return Ost ;"}
{"old_id": "COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1", "code": "def tjO ( LZA ) :\n    YKF = [ 0 for ZRB in range ( LZA + 1 ) ]\n    YKF [ 0 ] = 1\n    YKF [ 1 ] = 0\n    YKF [ 2 ] = 1\n    for ZRB in range ( 3 , LZA + 1 ) :\n        YKF [ ZRB ] = ( ZRB - 1 ) * ( YKF [ ZRB - 1 ] + YKF [ ZRB - 2 ] )\n    return YKF [ LZA ]"}
{"old_id": "COUNT_DIGITS_FACTORIAL_SET_1", "code": "def cNN ( eyA ) :\n    if ( eyA < 0 ) :\n        return 0\n    if ( eyA <= 1 ) :\n        return 1\n    jlM = 0\n    for UUj in range ( 2 , eyA + 1 ) :\n        jlM += math.FIg ( UUj )\n    return math.Mdh ( jlM ) + 1"}
{"old_id": "COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2", "code": "def Jtq ( kSj ) :\n    Phv = 0\n    QNm = 0\n    while ( QNm * QNm < kSj ) :\n        jcp = 0\n        while ( QNm * QNm + jcp * jcp < kSj ) :\n            Phv = Phv + 1\n            jcp = jcp + 1\n        QNm = QNm + 1\n    return Phv"}
{"old_id": "COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2_1", "code": "def Jcp ( qSG ) :\n    lnE = 0\n    jVZ = 0\n    FMn = 0\n    while ( FMn * FMn < qSG ) :\n        FMn = FMn + 1\n    while ( FMn != 0 ) :\n        jVZ = jVZ + FMn\n        lnE = lnE + 1\n        while ( FMn != 0 and ( lnE * lnE + ( FMn - 1 ) * ( FMn - 1 ) >= qSG ) ) :\n            FMn = FMn - 1\n    return jVZ"}
{"old_id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE", "code": "def ROM ( icS , BnR ) :\n    IMj = len ( BnR )\n    Mva = len ( icS )\n    if IMj > Mva :\n        return 0\n    Hxz = [ [ 0 for VpH in range ( Mva + 1 ) ] for Rzp in range ( IMj + 1 ) ]\n    for RRf in range ( 1 , IMj + 1 ) :\n        Hxz [ RRf ] [ 0 ] = 0\n    for Bdj in range ( Mva + 1 ) :\n        Hxz [ 0 ] [ Bdj ] = 1\n    for RRf in range ( 1 , IMj + 1 ) :\n        for Bdj in range ( 1 , Mva + 1 ) :\n            if BnR [ RRf - 1 ] != icS [ Bdj - 1 ] :\n                Hxz [ RRf ] [ Bdj ] = Hxz [ RRf ] [ Bdj - 1 ]\n            else :\n                Hxz [ RRf ] [ Bdj ] = ( Hxz [ RRf ] [ Bdj - 1 ] + Hxz [ RRf - 1 ] [ Bdj - 1 ] )\n    return Hxz [ IMj ] [ Mva ]"}
{"old_id": "COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX", "code": "def count ( CCK , WFh ) :\n    NHP = 0\n    for cod in range ( 1 , CCK + 1 ) :\n        if cod <= WFh :\n            if WFh // cod <= CCK and WFh % cod == 0 :\n                NHP += 1\n    return NHP"}
{"old_id": "COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1", "code": "def ZYg ( jHB ) :\n    WYv = 1\n    dfL = 1\n    for JsK in range ( 1 , jHB + 1 ) :\n        WYv = int ( ( WYv * ( jHB + 1 - JsK ) ) / JsK )\n        dfL += WYv * WYv \n    return dfL "}
{"old_id": "COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ", "code": "def find ( UEC , WDb ) :\n    if ( UEC + 1 >= WDb ) :\n        return ( WDb - 1 )\n    else :\n        return ( 2 * UEC + 1 - WDb )"}
{"old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY", "code": "def oRP ( drV , zhh ) :\n    sON = 0\n    for LiC in range ( 0 , zhh ) :\n        for jQI in range ( LiC + 1 , zhh ) :\n            if ( drV [ LiC ] == drV [ jQI ] ) :\n                sON += 1\n    return sON"}
{"old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1", "code": "def HGi ( EWM , tqg ) :\n    twP = dict ( )\n    for Kzy in range ( tqg ) :\n        if EWM [ Kzy ] in twP.keys ( ) :\n            twP [ EWM [ Kzy ] ] += 1\n        else :\n            twP [ EWM [ Kzy ] ] = 1\n    AXN = 0\n    for Unc in twP :\n        count = twP [ Unc ]\n        AXN += ( count * ( count - 1 ) ) // 2\n    return AXN"}
{"old_id": "COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1", "code": "def JoZ ( Ipf , dBf ) :\n    cGU = 0\n    for mEa in range ( 1 , dBf - 1 ) :\n        wRw = 0\n        for jky in range ( mEa + 1 , dBf ) :\n            if ( Ipf [ mEa ] > Ipf [ jky ] ) :\n                wRw += 1\n        lql = 0\n        for jky in range ( mEa - 1 , - 1 , - 1 ) :\n            if ( Ipf [ mEa ] < Ipf [ jky ] ) :\n                lql += 1\n        cGU += lql * wRw\n    return cGU"}
{"old_id": "COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS", "code": "def TGw ( GjK , ysQ ) :\n    EOZ = sorted ( GjK )\n    count = 1\n    for GBD in range ( 0 , ysQ - 1 ) :\n        if ( EOZ [ GBD ] + 1 != EOZ [ GBD + 1 ] ) :\n            count = count + 1\n    return count"}
{"old_id": "COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER", "code": "def Dgp ( SUP ) :\n    lVx = 0\n    for cmM in range ( 1 , 10 ) :\n        rfs = [ ]\n        if ( cmM <= SUP ) :\n            rfs.append ( cmM )\n            lVx += 1\n        while len ( rfs ) != 0 :\n            NWn = rfs [ - 1 ]\n            rfs.pop ( )\n            for NPm in range ( NWn % 10 , 10 ) :\n                LJf = NWn * 10 + NPm\n                if ( LJf <= SUP ) :\n                    rfs.append ( LJf )\n                    lVx += 1\n    return lVx"}
{"old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX", "code": "def drE ( izj , JEk , cbL ) :\n    count = 0\n    for IDj in range ( JEk ) :\n        for FlB in range ( cbL ) :\n            if izj [ IDj ] [ FlB ] < 0 :\n                count += 1\n            else :\n                break\n    return count"}
{"old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1", "code": "def kDe ( WLW , kzd , cEN ) :\n    count = 0\n    tdV = 0\n    fwB = cEN - 1\n    while fwB >= 0 and tdV < kzd :\n        if WLW [ tdV ] [ fwB ] < 0 :\n            count += ( fwB + 1 )\n            tdV += 1\n        else :\n            fwB -= 1\n    return count"}
{"old_id": "COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS", "code": "def egf ( FTD , zYy , dFG ) :\n    wdE = [ False for SRU in range ( FTD + 2 ) ]\n    if ( zYy <= FTD ) :\n        wdE [ zYy ] = True\n    if ( dFG <= FTD ) :\n        wdE [ dFG ] = True\n    lSn = 0\n    for SRU in range ( min ( zYy , dFG ) , FTD + 1 ) :\n        if ( wdE [ SRU ] ) :\n            if ( SRU + zYy <= FTD ) :\n                wdE [ SRU + zYy ] = True\n            if ( SRU + dFG <= FTD ) :\n                wdE [ SRU + dFG ] = True\n            lSn = lSn + 1\n    return lSn"}
{"old_id": "COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S", "code": "def pcI ( syv ) :\n    jIv = [ 0 for RCs in range ( syv ) ]\n    fkd = [ 0 for RCs in range ( syv ) ]\n    jIv [ 0 ] = fkd [ 0 ] = 1\n    for RCs in range ( 1 , syv ) :\n        jIv [ RCs ] = jIv [ RCs - 1 ] + fkd [ RCs - 1 ]\n        fkd [ RCs ] = jIv [ RCs - 1 ]\n    return jIv [ syv - 1 ] + fkd [ syv - 1 ]"}
{"old_id": "COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K", "code": "def Fnx ( FcM , xBK , Mlr ) :\n    nFo = [ [ 0 for Mup in range ( xBK ) ] for Mup in range ( Mlr ) ]\n    for Mup in range ( xBK ) :\n        nFo [ 0 ] [ Mup ] = 1\n    for kWu in range ( 1 , Mlr ) :\n        for Mup in range ( kWu , xBK ) :\n            nFo [ kWu ] [ Mup ] = 0\n            for jXo in range ( kWu - 1 , Mup ) :\n                if ( FcM [ jXo ] < FcM [ Mup ] ) :\n                    nFo [ kWu ] [ Mup ] += nFo [ kWu - 1 ] [ jXo ]\n    faq = 0\n    for Mup in range ( Mlr - 1 , xBK ) :\n        faq += nFo [ Mlr - 1 ] [ Mup ]\n    return faq"}
{"old_id": "COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY", "code": "def WRT ( cog , vua , cpF ) :\n    Nrw = 0\n    for WQm in range ( vua ) :\n        if cpF == cog [ WQm ] :\n            Nrw += 1\n    return Nrw"}
{"old_id": "COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION", "code": "def flw ( ZoG , XjT , EOa , Cbl ) :\n    cAd = [ 0 for Kiv in range ( ZoG + 1 ) ]\n    cAd [ 0 ] = 1\n    for Kiv in range ( 1 , ZoG + 1 , 1 ) :\n        cAd [ Kiv ] = cAd [ Kiv - 1 ] + Kiv\n    Zxo = ZoG - ( XjT + Cbl + EOa )\n    sum = 0\n    for Kiv in range ( 0 , Zxo + 1 , 1 ) :\n        for yBa in range ( 0 , Zxo - Kiv + 1 , 1 ) :\n            oKP = Zxo - ( Kiv + yBa )\n            sum = int ( sum + cAd [ ZoG ] / ( cAd [ Kiv + XjT ] + cAd [ yBa + EOa ] + cAd [ oKP + Cbl ] ) )\n    return sum"}
{"old_id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1", "code": "def fFq ( PTB , WGS ) :\n    Gpu = [ [ 0 for JBA in range ( WGS + 1 ) ] for FND in range ( PTB + 1 ) ]\n    for JBA in range ( PTB + 1 ) :\n        Gpu [ JBA ] [ 0 ] = 0\n    for JBA in range ( WGS + 1 ) :\n        Gpu [ 0 ] [ WGS ] = 0\n    for JBA in range ( 1 , PTB + 1 ) :\n        for FND in range ( 1 , WGS + 1 ) :\n            if ( FND == 1 or JBA == FND ) :\n                Gpu [ JBA ] [ FND ] = 1\n            else :\n                Gpu [ JBA ] [ FND ] = ( FND * Gpu [ JBA - 1 ] [ FND ] + Gpu [ JBA - 1 ] [ FND - 1 ] )\n    return Gpu [ PTB ] [ WGS ]"}
{"old_id": "COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B", "code": "def FqQ ( ZiX ) :\n    oPj = ZiX\n    atB = 1\n    Tml = 0\n    while ( atB <= ZiX ) :\n        BUh = int ( ZiX / oPj )\n        Tml += oPj * ( BUh - atB + 1 )\n        atB = BUh + 1\n        oPj = int ( ZiX / atB )\n    return Tml"}
{"old_id": "COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME", "code": "def count ( dCw ) :\n    JQi = [ 0 for UeG in range ( dCw + 1 ) ]\n    JQi [ 0 ] = 1\n    for UeG in range ( 3 , dCw + 1 ) :\n        JQi [ UeG ] += JQi [ UeG - 3 ]\n    for UeG in range ( 5 , dCw + 1 ) :\n        JQi [ UeG ] += JQi [ UeG - 5 ]\n    for UeG in range ( 10 , dCw + 1 ) :\n        JQi [ UeG ] += JQi [ UeG - 10 ]\n    return JQi [ dCw ]"}
{"old_id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES", "code": "def akt ( WYL , qUg ) :\n    count = [ ]\n    for oNJ in range ( WYL + 2 ) :\n        count.append ( 0 )\n    count [ 0 ] = 0\n    for oNJ in range ( 1 , WYL + 1 ) :\n        if ( oNJ > qUg ) :\n            count [ oNJ ] = count [ oNJ - 1 ] + count [ oNJ - qUg ]\n        elif ( oNJ < qUg ) :\n            count [ oNJ ] = 1\n        else :\n            count [ oNJ ] = 2\n    return count [ WYL ]"}
{"old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME", "code": "def mxR ( str , TZF ) :\n    TOI = ( TZF * ( TZF + 1 ) ) // 2\n    uPs = 0\n    IZE = 0\n    OHw = 0\n    for cAx in range ( TZF ) :\n        if ( str [ cAx ] == 'a' ) :\n            uPs = cAx + 1\n            TOI -= min ( IZE , OHw )\n        elif ( str [ cAx ] == 'b' ) :\n            IZE = cAx + 1\n            TOI -= min ( uPs , OHw )\n        else :\n            OHw = cAx + 1\n            TOI -= min ( uPs , IZE )\n    return TOI"}
{"old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE", "code": "def DgG ( Kqd ) :\n    qcP = 0\n    LQI = 0\n    for zVz in range ( len ( Kqd ) ) :\n        if Kqd [ ~ zVz ] == 'a' :\n            LQI = ( LQI + qcP )\n            qcP = ( qcP * 2 )\n        else :\n            qcP += 1\n    return LQI"}
{"old_id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K", "code": "def Wdt ( aAN , owC , aKe ) :\n    count = 0\n    for MWr in range ( 0 , owC ) :\n        for PFo in range ( MWr + 1 , owC ) :\n            if aAN [ MWr ] - aAN [ PFo ] == aKe or aAN [ PFo ] - aAN [ MWr ] == aKe :\n                count += 1\n    return count"}
{"old_id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K_1", "code": "def Zrg ( QzB , bZN , Cki ) :\n    count = 0\n    QzB.sort ( )\n    QmB = 0\n    tgQ = 0\n    while tgQ < bZN :\n        if QzB [ tgQ ] - QzB [ QmB ] == Cki :\n            count += 1\n            QmB += 1\n            tgQ += 1\n        elif QzB [ tgQ ] - QzB [ QmB ] > Cki :\n            QmB += 1\n        else :\n            tgQ += 1\n    return count"}
{"old_id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X", "code": "def sjm ( rzN , BUP , orR , YeI , nZH ) :\n    count = 0\n    for kmR in range ( orR ) :\n        for Jpc in range ( YeI ) :\n            if rzN [ kmR ] + BUP [ Jpc ] == nZH :\n                count = count + 1\n    return count"}
{"old_id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1", "code": "def xJk ( BEM , gCU , VRF , nDn , iEy ) :\n    count = 0\n    DLS = set ( )\n    for DAL in range ( VRF ) :\n        DLS.add ( BEM [ DAL ] )\n    for bij in range ( nDn ) :\n        if iEy - gCU [ bij ] in DLS :\n            count += 1\n    return count"}
{"old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY", "code": "def RAo ( yjK , QAy ) :\n    ECj = 0 ;\n    for tSk in range ( 0 , QAy ) :\n        for pzk in range ( tSk + 1 , QAy ) :\n            tIG = yjK [ tSk ] * yjK [ pzk ] ;\n            for toN in range ( 0 , QAy ) :\n                if ( yjK [ toN ] == tIG ) :\n                    ECj = ECj + 1 ;\n                    break ;\n    return ECj ;"}
{"old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1", "code": "def OCO ( ORR , EYU ) :\n    SWR = 0\n    IJq = set ( )\n    for TIL in range ( EYU ) :\n        IJq.add ( ORR [ TIL ] )\n    for TIL in range ( EYU ) :\n        for BEk in range ( TIL + 1 , EYU ) :\n            UND = ORR [ TIL ] * ORR [ BEk ]\n            if UND in ( IJq ) :\n                SWR += 1\n    return SWR"}
{"old_id": "COUNT_PALINDROME_SUB_STRINGS_STRING", "code": "def eEN ( str , bjc ) :\n    mhP = [ [ 0 for chM in range ( bjc ) ] for WGR in range ( bjc ) ]\n    kBL = [ [ False for chM in range ( bjc ) ] for WGR in range ( bjc ) ]\n    for gCz in range ( bjc ) :\n        kBL [ gCz ] [ gCz ] = True\n    for gCz in range ( bjc - 1 ) :\n        if ( str [ gCz ] == str [ gCz + 1 ] ) :\n            kBL [ gCz ] [ gCz + 1 ] = True\n            mhP [ gCz ] [ gCz + 1 ] = 1\n    for ORo in range ( 2 , bjc ) :\n        for gCz in range ( bjc - ORo ) :\n            alr = ORo + gCz ;\n            if ( str [ gCz ] == str [ alr ] and kBL [ gCz + 1 ] [ alr - 1 ] ) :\n                kBL [ gCz ] [ alr ] = True\n            if ( kBL [ gCz ] [ alr ] == True ) :\n                mhP [ gCz ] [ alr ] = ( mhP [ gCz ] [ alr - 1 ] + mhP [ gCz + 1 ] [ alr ] + 1 - mhP [ gCz + 1 ] [ alr - 1 ] )\n            else :\n                mhP [ gCz ] [ alr ] = ( mhP [ gCz ] [ alr - 1 ] + mhP [ gCz + 1 ] [ alr ] - mhP [ gCz + 1 ] [ alr - 1 ] )\n    return mhP [ 0 ] [ bjc - 1 ]"}
{"old_id": "COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING", "code": "def saw ( str ) :\n    Efd = len ( str )\n    gBD = [ [ 0 for dOF in range ( Efd + 2 ) ] for vtP in range ( Efd + 2 ) ]\n    for dOF in range ( Efd ) :\n        gBD [ dOF ] [ dOF ] = 1\n    for GIM in range ( 2 , Efd + 1 ) :\n        for dOF in range ( Efd ) :\n            onu = GIM + dOF - 1\n            if ( onu < Efd ) :\n                if ( str [ dOF ] == str [ onu ] ) :\n                    gBD [ dOF ] [ onu ] = ( gBD [ dOF ] [ onu - 1 ] + gBD [ dOF + 1 ] [ onu ] + 1 )\n                else :\n                    gBD [ dOF ] [ onu ] = ( gBD [ dOF ] [ onu - 1 ] + gBD [ dOF + 1 ] [ onu ] - gBD [ dOF + 1 ] [ onu - 1 ] )\n    return gBD [ 0 ] [ Efd - 1 ]"}
{"old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1", "code": "def lcp ( CBD , MKe ) :\n    count = [ 0 ] * ( MKe + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if CBD [ 0 ] == '0' :\n        return 0\n    for vKr in range ( 2 , MKe + 1 ) :\n        count [ vKr ] = 0\n        if ( CBD [ vKr - 1 ] > '0' ) :\n            count [ vKr ] = count [ vKr - 1 ]\n        if ( CBD [ vKr - 2 ] == '1' or ( CBD [ vKr - 2 ] == '2' and CBD [ vKr - 1 ] < '7' ) ) :\n            count [ vKr ] += count [ vKr - 2 ]\n    return count [ MKe ]"}
{"old_id": "COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3", "code": "def rDO ( sdR , yXW ) :\n    gIg = [ 0 , 0 , 0 ]\n    DhF = 0\n    for Kdv in range ( 0 , yXW ) :\n        gIg [ sdR [ Kdv ] % 3 ] += 1\n    DhF += ( ( gIg [ 0 ] * ( gIg [ 0 ] - 1 ) ) >> 1 )\n    DhF += gIg [ 1 ] * gIg [ 2 ]\n    DhF += ( gIg [ 0 ] * ( gIg [ 0 ] - 1 ) * ( gIg [ 0 ] - 2 ) ) / 6\n    DhF += ( gIg [ 1 ] * ( gIg [ 1 ] - 1 ) * ( gIg [ 1 ] - 2 ) ) / 6\n    DhF += ( ( gIg [ 2 ] * ( gIg [ 2 ] - 1 ) * ( gIg [ 2 ] - 2 ) ) / 6 )\n    DhF += gIg [ 0 ] * gIg [ 1 ] * gIg [ 2 ]\n    return DhF"}
{"old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1", "code": "def Ojh ( xjy , GxD ) :\n    count = [ [ 0 for ZaA in range ( xjy ) ] for LAh in range ( GxD ) ]\n    for rvI in range ( xjy ) :\n        count [ rvI ] [ 0 ] = 1 ;\n    for aXb in range ( GxD ) :\n        count [ 0 ] [ aXb ] = 1 ;\n    for rvI in range ( 1 , xjy ) :\n        for aXb in range ( GxD ) :\n            count [ rvI ] [ aXb ] = count [ rvI - 1 ] [ aXb ] + count [ rvI ] [ aXb - 1 ]\n    return count [ xjy - 1 ] [ GxD - 1 ]"}
{"old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2", "code": "def BXo ( KzO , ono ) :\n    SrM = [ 0 for DVV in range ( ono ) ]\n    SrM[0]=1\n    for DVV in range ( KzO  ) :\n        for NHk in range ( 1 , ono ) :\n            SrM [ NHk ] += SrM [ NHk - 1 ]\n    return SrM [ ono - 1 ]"}
{"old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3", "code": "def toZ ( aGB , AMX ) :\n    for NvQ in range ( AMX , ( aGB + AMX - 1 ) ) :\n        QML *= NvQ\n        QML //= ( NvQ - AMX + 1 )\n    return QML"}
{"old_id": "COUNT_ROTATIONS_DIVISIBLE_4", "code": "def BsH ( pUm ) :\n    Mtc = len ( pUm )\n    if ( Mtc == 1 ) :\n        Udt = ( int ) ( pUm [ 0 ] )\n        if ( Udt % 4 == 0 ) :\n            return 1\n        return 0\n    count = 0\n    for fHC in range ( 0 , Mtc - 1 ) :\n        Hde = ( int ) ( pUm [ fHC ] ) * 10 + ( int ) ( pUm [ fHC + 1 ] )\n        if ( Hde % 4 == 0 ) :\n            count = count + 1\n    Hde = ( int ) ( pUm [ Mtc - 1 ] ) * 10 + ( int ) ( pUm [ 0 ] )\n    if ( Hde % 4 == 0 ) :\n        count = count + 1\n    return count"}
{"old_id": "COUNT_ROTATIONS_DIVISIBLE_8", "code": "def SVm ( aIE ) :\n    iQP = len ( aIE )\n    count = 0\n    if ( iQP == 1 ) :\n        eii = int ( aIE [ 0 ] )\n        if ( eii % 8 == 0 ) :\n            return 1\n        return 0\n    if ( iQP == 2 ) :\n        idm = int ( aIE [ 0 ] ) * 10 + int ( aIE [ 1 ] )\n        mnI = int ( aIE [ 1 ] ) * 10 + int ( aIE [ 0 ] )\n        if ( idm % 8 == 0 ) :\n            count += 1\n        if ( mnI % 8 == 0 ) :\n            count += 1\n        return count\n    Ril = 0\n    for RUv in range ( 0 , ( iQP - 2 ) ) :\n        Ril = ( int ( aIE [ RUv ] ) * 100 + int ( aIE [ RUv + 1 ] ) * 10 + int ( aIE [ RUv + 2 ] ) )\n        if ( Ril % 8 == 0 ) :\n            count += 1\n    Ril = ( int ( aIE [ iQP - 1 ] ) * 100 + int ( aIE [ 0 ] ) * 10 + int ( aIE [ 1 ] ) )\n    if ( Ril % 8 == 0 ) :\n        count += 1\n    Ril = ( int ( aIE [ iQP - 2 ] ) * 100 + int ( aIE [ iQP - 1 ] ) * 10 + int ( aIE [ 0 ] ) )\n    if ( Ril % 8 == 0 ) :\n        count += 1\n    return count"}
{"old_id": "COUNT_SET_BITS_IN_AN_INTEGER_1", "code": "def NmN ( ujC ) :\n    if ( ujC == 0 ) :\n        return 0\n    else :\n        return ( ujC & 1 ) + NmN ( ujC >> 1 )"}
{"old_id": "COUNT_SET_BITS_IN_AN_INTEGER_2", "code": "def TGy ( PuR ) :\n    count = 0\n    while ( PuR ) :\n        PuR &= ( PuR - 1 )\n        count += 1\n    return count"}
{"old_id": "COUNT_SET_BITS_IN_AN_INTEGER_3", "code": "def XWK ( cqx ) :\n    if ( cqx == 0 ) :\n        return 0\n    else :\n        return 1 + XWK ( cqx & ( cqx - 1 ) )"}
{"old_id": "COUNT_SORTED_ROWS_MATRIX", "code": "def zVo ( SUM , BNv , Imm ) :\n    HDs = 0\n    for zHY in range ( BNv ) :\n        iuy = 0\n        for iuy in range ( Imm - 1 ) :\n            if SUM [ zHY ] [ iuy + 1 ] <= SUM [ zHY ] [ iuy ] :\n                break\n        if iuy == Imm - 2 :\n            HDs += 1\n    for zHY in range ( 0 , BNv ) :\n        iuy = 0\n        for iuy in range ( Imm - 1 , 0 , - 1 ) :\n            if SUM [ zHY ] [ iuy - 1 ] <= SUM [ zHY ] [ iuy ] :\n                break\n        if Imm > 1 and iuy == 1 :\n            HDs += 1\n    return HDs"}
{"old_id": "COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1", "code": "def Gzj ( OSP ) :\n    return ( 1 + ( OSP * 2 ) + ( OSP * ( ( OSP * OSP ) - 1 ) // 2 ) )"}
{"old_id": "COUNT_STRINGS_WITH_CONSECUTIVE_1S", "code": "def nJn ( NVe ) :\n    KDQ = [ 0 ] * NVe\n    ReT = [ 0 ] * NVe\n    KDQ [ 0 ] = ReT [ 0 ] = 1\n    for Rjx in range ( 1 , NVe ) :\n        KDQ [ Rjx ] = KDQ [ Rjx - 1 ] + ReT [ Rjx - 1 ]\n        ReT [ Rjx ] = KDQ [ Rjx - 1 ]\n    return ( 1 << NVe ) - KDQ [ NVe - 1 ] - ReT [ NVe - 1 ]"}
{"old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS", "code": "def yMu ( Yrl , CBt ) :\n    difference = 0\n    ncN = 0\n    nNh = [ 0 ] * ( CBt + 1 )\n    Bgp = [ 0 ] * ( CBt + 1 )\n    nNh [ 0 ] = 1\n    for GjH in range ( CBt ) :\n        if ( Yrl [ GjH ] & 1 == 1 ) :\n            difference = difference + 1\n        else :\n            difference = difference - 1\n        if ( difference < 0 ) :\n            ncN += Bgp [ - difference ]\n            Bgp [ - difference ] = Bgp [ - difference ] + 1\n        else :\n            ncN += nNh [ difference ]\n            nNh [ difference ] = nNh [ difference ] + 1\n    return ncN"}
{"old_id": "COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS", "code": "def LMs ( cde ) :\n    ATI = 0\n    yAQ = len ( cde )\n    for CLL in range ( yAQ ) :\n        for ZRM in range ( CLL , yAQ ) :\n            if ( cde [ CLL ] == cde [ ZRM ] ) :\n                ATI = ATI + 1\n    return ATI"}
{"old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N", "code": "def Qvk ( NNb ) :\n    dWs = 0\n    dTn = 0\n    while ( ( 1 << dWs ) <= NNb ) :\n        iiN = 0\n        fKV = 1 << dWs\n        for moX in range ( 0 , NNb + 1 ) :\n            dTn += iiN\n            if fKV == 1 :\n                iiN = not iiN\n                fKV = 1 << dWs\n            else :\n                fKV -= 1\n        dWs += 1\n    return dTn"}
{"old_id": "COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER", "code": "def WxA ( OUG ) :\n    count = 0\n    BpC = 5\n    while ( OUG / BpC >= 1 ) :\n        count += int ( OUG / BpC )\n        BpC *= 5\n    return int ( count )"}
{"old_id": "COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS", "code": "def UFc ( qAQ ) :\n    Vzf = [ [ 0 ] * ( qAQ + 1 ) for Gvb in range ( 2 ) ]\n    Vzf [ 0 ] [ 1 ] = 1\n    Vzf [ 1 ] [ 1 ] = 2\n    for Gvb in range ( 2 , qAQ + 1 ) :\n        Vzf [ 0 ] [ Gvb ] = Vzf [ 0 ] [ Gvb - 1 ] + Vzf [ 1 ] [ Gvb - 1 ]\n        Vzf [ 1 ] [ Gvb ] = ( Vzf [ 0 ] [ Gvb - 1 ] * 2 + Vzf [ 1 ] [ Gvb - 1 ] )\n    return Vzf [ 0 ] [ qAQ ] + Vzf [ 1 ] [ qAQ ]"}
{"old_id": "COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS", "code": "def XaG ( DTZ ) :\n    NEn = 2 * DTZ\n    HKg = [ 0 ] * ( NEn + 1 )\n    HKg [ 0 ] = 1\n    HKg [ 2 ] = 1\n    for TvQ in range ( 4 , NEn + 1 , 2 ) :\n        for bjd in range ( 0 , TvQ - 1 , 2 ) :\n            HKg [ TvQ ] += ( HKg [ bjd ] * HKg [ TvQ - 2 - bjd ] )\n    return int ( HKg [ NEn ] )"}
{"old_id": "COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS", "code": "def ePm ( str , hph ) :\n    kKB = dict ( )\n    for SwC in range ( hph ) :\n        kKB [ str [ SwC ] ] = kKB.get ( str [ SwC ] , 0 ) + 1\n    mTA = 0\n    for SwC in kKB.values ( ) :\n        if SwC == 2 :\n            mTA += 1\n    return mTA"}
{"old_id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD", "code": "def iAT ( str , len ) :\n    count = 1 ;\n    if ( len == 1 ) :\n        return count\n    if ( str [ 0 ] == str [ 1 ] ) :\n        count *= 1\n    else :\n        count *= 2\n    for ySW in range ( 1 , len - 1 ) :\n        if ( str [ ySW ] == str [ ySW - 1 ] and str [ ySW ] == str [ ySW + 1 ] ) :\n            count *= 1\n        elif ( str [ ySW ] == str [ ySW - 1 ] or str [ ySW ] == str [ ySW + 1 ] or str [ ySW - 1 ] == str [ ySW + 1 ] ) :\n            count *= 2\n        else :\n            count *= 3\n    if ( str [ len - 1 ] == str [ len - 2 ] ) :\n        count *= 1\n    else :\n        count *= 2\n    return count"}
{"old_id": "C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES", "code": "def hqu ( waU , Odt ) :\n    tye = waU\n    for cwj in range ( 1 , Odt ) :\n        waU += tye\n    return waU"}
{"old_id": "C_PROGRAM_FACTORIAL_NUMBER", "code": "def lRU ( meJ ) :\n    return 1 if ( meJ == 1 or meJ == 0 ) else meJ * lRU ( meJ - 1 )"}
{"old_id": "C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1", "code": "def XPh ( yap , edU ) :\n    return sorted(yap[:edU], reverse=False)[edU-1]"}
{"old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER", "code": "def XcW ( str ) :\n    gKc = 256\n    count = [ 0 ] * gKc\n    for ejf in range ( len ( str ) ) :\n        count [ ord ( str [ ejf ] ) ] += 1\n    cGO , tex = 0 , 0\n    for ejf in range ( gKc ) :\n        if count [ ejf ] > count [ cGO ] :\n            tex = cGO\n            cGO = ejf\n        elif ( count [ ejf ] > count [ tex ] and count [ ejf ] != count [ cGO ] ) :\n            tex = ejf\n    return chr ( tex )"}
{"old_id": "DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS", "code": "def leu ( Pbd ) :\n    if ( Pbd == 0 ) :\n        return \"0\"\n    bin = \"\"\n    while ( Pbd > 0 ) :\n        if ( Pbd & 1 == 0 ) :\n            bin = '0' + bin\n        else :\n            bin = '1' + bin\n        Pbd = Pbd >> 1\n    return bin"}
{"old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING", "code": "def Zpt ( DwP ) :\n    UFx = [ ]\n    faF = [ ]\n    GYh = \"\"\n    pjN = \"\"\n    for aJA in range ( len ( DwP ) ) :\n        count = 0\n        if ( DwP [ aJA ] >= '0' and DwP [ aJA ] <= '9' ) :\n            while ( DwP [ aJA ] >= '0' and DwP [ aJA ] <= '9' ) :\n                count = count * 10 + ord ( DwP [ aJA ] ) - ord ( '0' )\n                aJA += 1\n            aJA -= 1\n            UFx.append ( count )\n        elif ( DwP [ aJA ] == ']' ) :\n            GYh = \"\"\n            count = 0\n            if ( len ( UFx ) != 0 ) :\n                count = UFx [ - 1 ]\n                UFx.pop ( )\n            while ( len ( faF ) != 0 and faF [ - 1 ] != '[' ) :\n                GYh = faF [ - 1 ] + GYh\n                faF.pop ( )\n            if ( len ( faF ) != 0 and faF [ - 1 ] == '[' ) :\n                faF.pop ( )\n            for jhd in range ( count ) :\n                pjN = pjN + GYh\n            for jhd in range ( len ( pjN ) ) :\n                faF.append ( pjN [ jhd ] )\n            pjN = \"\"\n        elif ( DwP [ aJA ] == '[' ) :\n            if ( DwP [ aJA - 1 ] >= '0' and DwP [ aJA - 1 ] <= '9' ) :\n                faF.append ( DwP [ aJA ] )\n            else :\n                faF.append ( DwP [ aJA ] )\n                UFx.append ( 1 )\n        else :\n            faF.append ( DwP [ aJA ] )\n    while len ( faF ) != 0 :\n        pjN = faF [ - 1 ] + pjN\n        faF.pop ( )\n    return pjN"}
{"old_id": "DELANNOY_NUMBER_1", "code": "def lxG ( cBn , QWC ) :\n    ISQ = [ [ 0 for Guj in range ( cBn + 1 ) ] for Guj in range ( QWC + 1 ) ]\n    for ykg in range ( QWC + 1 ) :\n        ISQ [ 0 ] [ ykg ] = 1\n    for ykg in range ( QWC + 1 ) :\n        ISQ [ ykg ] [ 0 ] = 1\n    for ykg in range ( 1 , QWC + 1 ) :\n        for QdF in range ( 1 , cBn + 1 ) :\n            ISQ [ ykg ] [ QdF ] = ISQ [ ykg - 1 ] [ QdF ] + ISQ [ ykg - 1 ] [ QdF - 1 ] + ISQ [ ykg ] [ QdF - 1 ]\n    return ISQ [ QWC ] [ cBn ]"}
{"old_id": "DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS", "code": "def FHW ( NgB , esr ) :\n    return ( ( NgB ^ esr ) < 0 )"}
{"old_id": "DIAGONALLY_DOMINANT_MATRIX", "code": "def whw ( RqG , WFd ) :\n    for FWV in range ( 0 , WFd ) :\n        sum = 0\n        for TLx in range ( 0 , WFd ) :\n            sum = sum + abs ( RqG [ FWV ] [ TLx ] )\n        sum = sum - abs ( RqG [ FWV ] [ FWV ] )\n        if ( abs ( RqG [ FWV ] [ FWV ] ) < sum ) :\n            return False\n    return True"}
{"old_id": "DICE_THROW_PROBLEM", "code": "def XBM ( Uyj , iWx , FGA ) :\n    GBK = [ [ 0 ] * ( FGA + 1 ) for fYy in range ( iWx + 1 ) ]\n    for VrS in range ( 1 , min ( Uyj + 1 , FGA + 1 ) ) :\n        GBK [ 1 ] [ VrS ] = 1\n    for fYy in range ( 2 , iWx + 1 ) :\n        for VrS in range ( 1 , FGA + 1 ) :\n            for PcH in range ( 1 , min ( Uyj + 1 , VrS ) ) :\n                GBK [ fYy ] [ VrS ] += GBK [ fYy - 1 ] [ VrS - PcH ]\n    return GBK [ - 1 ] [ - 1 ]"}
{"old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY", "code": "def qBk ( ceO , OAC ) :\n    ceO.sort ( )\n    count = 0\n    ywW = 0\n    fLh = OAC\n    for Tku in range ( 0 , ( OAC - 1 ) ) :\n        if ceO [ Tku ] == ceO [ Tku + 1 ] :\n            count += 1\n            continue\n        else :\n            ywW = max ( ywW , count )\n            fLh = min ( fLh , count )\n            count = 0\n    return ywW - fLh"}
{"old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_1", "code": "def smV ( fyo , DzJ ) :\n    yWd = FKS ( lambda : 0 )\n    for ldj in range ( DzJ ) :\n        yWd [ fyo [ ldj ] ] += 1\n    ddA = 0\n    HrD = DzJ\n    for qID , values in yWd.items ( ) :\n        ddA = max ( ddA , values )\n        HrD = min ( HrD , values )\n    return ddA - HrD"}
{"old_id": "DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M", "code": "def EOz ( BsL , ulY ) :\n    DwT = dKo.ZJf ( ( BsL + 2 , BsL + 2 ) )\n    DwT [ 0 ] [ BsL + 1 ] = 1\n    for aSR in range ( BsL , ulY - 1 , - 1 ) :\n        for Oix in range ( BsL + 1 ) :\n            DwT [ Oix ] [ aSR ] = DwT [ Oix ] [ aSR + 1 ]\n            if ( Oix - aSR >= 0 ) :\n                DwT [ Oix ] [ aSR ] = ( DwT [ Oix ] [ aSR ] + DwT [ Oix - aSR ] [ aSR ] )\n    return DwT [ BsL ] [ ulY ]"}
{"old_id": "DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B", "code": "def Vsb ( hzD , uJx , Las ) :\n    fTU = int ( math.KQm ( Las ) + 1 )\n    XBE = 1\n    for sTa in range ( fTU ) :\n        XBE = ( XBE * hzD ) % Las\n    KQw = [ 0 ] * Las\n    NnN = XBE\n    for sTa in range ( 1 , fTU + 1 ) :\n        if ( KQw [ NnN ] == 0 ) :\n            KQw [ NnN ] = sTa\n        NnN = ( NnN * XBE ) % Las\n    NnN = uJx\n    for sTa in range ( fTU + 1 ) :\n        if ( KQw [ NnN ] > 0 ) :\n            sfO = KQw [ NnN ] * fTU - sTa\n            if ( sfO < Las ) :\n                return sfO\n        NnN = ( NnN * hzD ) % Las\n    return - 1"}
{"old_id": "DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1", "code": "def dcH ( Zuv , IWo , Opd ) :\n    sVq = Hnn ( lambda : 0 )\n    for ckO in range ( IWo ) :\n        sVq [ Zuv [ ckO ] ] += 1\n    for mkq , values in sVq.items ( ) :\n        if values > 2 * Opd :\n            return False\n    return True"}
{"old_id": "DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION", "code": "def Coi ( WDw , Dbu , muw ) :\n    if ( Dbu <= WDw - muw + 1 ) :\n        return Dbu + muw - 1\n    Dbu = Dbu - ( WDw - muw + 1 )\n    if ( Dbu % WDw == 0 ) :\n        return WDw\n    else :\n        return Dbu % WDw"}
{"old_id": "DIVIDE_LARGE_NUMBER_REPRESENTED_STRING", "code": "def hEY ( YAb , vQe ) :\n    XGL = \"\"\n    Mhd = 0\n    lAD = ord ( YAb [ Mhd ] ) - ord ( '0' )\n    while ( lAD < vQe ) :\n        lAD = ( lAD * 10 + ord ( YAb [ Mhd + 1 ] ) - ord ( '0' ) )\n        Mhd += 1\n    while ( ( len ( YAb ) ) > Mhd ) :\n        XGL += chr ( math.lFH ( lAD // vQe ) + ord ( '0' ) )\n        lAD = ( ( lAD % vQe ) * 10 + ord ( YAb [ Mhd + 1 ] ) - ord ( '0' ) )\n        Mhd += 1\n    XGL += chr ( math.lFH ( lAD // vQe ) + ord ( '0' ) )\n    if ( len ( XGL ) == 0 ) :\n        return \"0\"\n    return XGL"}
{"old_id": "DIVISIBILITY_9_USING_BITWISE_OPERATORS", "code": "def WPh ( hgx ) :\n    if ( hgx == 0 or hgx == 9 ) :\n        return True\n    if ( hgx < 9 ) :\n        return False\n    return WPh ( ( int ) ( hgx >> 3 ) - ( int ) ( hgx & 7 ) )"}
{"old_id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER", "code": "def QBU ( Mgb ) :\n    if ( len ( Mgb ) >= 3 ) :\n        iUP = int ( Mgb [ len ( Mgb ) - 1 ] )\n        if ( iUP % 2 != 0 ) :\n            return False\n        IYp = int ( Mgb [ len ( Mgb ) - 2 ] )\n        sum = 0\n        for MYM in range ( 0 , len ( Mgb ) ) :\n            sum += int ( Mgb [ MYM ] )\n        return ( sum % 3 == 0 and ( IYp * 10 + iUP ) % 4 == 0 )\n    else :\n        Wvg = int ( Mgb )\n        return ( Wvg % 12 == 0 )"}
{"old_id": "DIVISIBILITY_BY_7", "code": "def SSk ( Rww ) :\n    if Rww < 0 :\n        return SSk ( - Rww )\n    if ( Rww == 0 or Rww == 7 ) :\n        return True\n    if ( Rww < 10 ) :\n        return False\n    return SSk ( Rww // 10 - 2 * ( Rww - Rww // 10 * 10 ) )"}
{"old_id": "DOUBLE_FACTORIAL_1", "code": "def KOW ( RIV ) :\n    bzY = 1\n    for dcX in range ( RIV , - 1 , - 2 ) :\n        if ( dcX == 0 or dcX == 1 ) :\n            return bzY\n        else :\n            bzY *= dcX\n    return bzY;"}
{"old_id": "DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM", "code": "def vFK ( TiT , vCh , WtA ) :\n    if ( WtA <= 0 ) :\n        return 0\n    return max ( TiT [ WtA - 1 ] + vFK ( TiT , vCh , ( WtA - 2 ) ) , vCh [ WtA - 1 ] + vFK ( TiT , vCh , ( WtA - 1 ) ) )"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM", "code": "def IMS ( JPR , Eyj , qVL , PWg ) :\n    if PWg == 0 or JPR == 0 :\n        return 0\n    if ( Eyj [ PWg - 1 ] > JPR ) :\n        return IMS ( JPR , Eyj , qVL , PWg - 1 )\n    else :\n        return max ( qVL [ PWg - 1 ] + IMS ( JPR - Eyj [ PWg - 1 ] , Eyj , qVL , PWg - 1 ) , IMS ( JPR , Eyj , qVL , PWg - 1 ) )"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1", "code": "def YlK ( KMn , feJ ) :\n    Lte = [ [ 0 for bEq in range ( feJ + 1 ) ] for bEq in range ( KMn + 1 ) ]\n    for iKW in range ( 1 , KMn + 1 ) :\n        Lte [ iKW ] [ 1 ] = 1\n        Lte [ iKW ] [ 0 ] = 0\n    for hKP in range ( 1 , feJ + 1 ) :\n        Lte [ 1 ] [ hKP ] = hKP\n    for iKW in range ( 2 , KMn + 1 ) :\n        for hKP in range ( 2 , feJ + 1 ) :\n            Lte [ iKW ] [ hKP ] = rJf\n            for bEq in range ( 1 , hKP + 1 ) :\n                mCo = 1 + max ( Lte [ iKW - 1 ] [ bEq - 1 ] , Lte [ iKW ] [ hKP - bEq ] )\n                if mCo < Lte [ iKW ] [ hKP ] :\n                    Lte [ iKW ] [ hKP ] = mCo\n    return Lte [ KMn ] [ feJ ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE", "code": "def Ieh ( XWl ) :\n    mOE = len ( XWl )\n    qjt = [ [ 0 for PyB in range ( mOE ) ] for PyB in range ( mOE ) ]\n    for FdJ in range ( mOE ) :\n        qjt [ FdJ ] [ FdJ ] = 1\n    for GVw in range ( 2 , mOE + 1 ) :\n        for FdJ in range ( mOE - GVw + 1 ) :\n            yHz = FdJ + GVw - 1\n            if XWl [ FdJ ] == XWl [ yHz ] and GVw == 2 :\n                qjt [ FdJ ] [ yHz ] = 2\n            elif XWl [ FdJ ] == XWl [ yHz ] :\n                qjt [ FdJ ] [ yHz ] = qjt [ FdJ + 1 ] [ yHz - 1 ] + 2\n            else :\n                qjt [ FdJ ] [ yHz ] = max ( qjt [ FdJ ] [ yHz - 1 ] , qjt [ FdJ + 1 ] [ yHz ] ) ;\n    return qjt [ 0 ] [ mOE - 1 ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE", "code": "def CIw ( ABN , pBS ) :\n    max = 0\n    Adm = [ 0 for EiW in range ( pBS ) ]\n    for GNI in range ( pBS ) :\n        Adm [ GNI ] = ABN [ GNI ]\n    for GNI in range ( 1 , pBS ) :\n        for eMC in range ( GNI ) :\n            if ( ABN [ GNI ] > ABN [ eMC ] and Adm [ GNI ] < Adm [ eMC ] + ABN [ GNI ] ) :\n                Adm [ GNI ] = Adm [ eMC ] + ABN [ GNI ]\n    for GNI in range ( pBS ) :\n        if max < Adm [ GNI ] :\n            max = Adm [ GNI ]\n    return max"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE", "code": "def Hck ( mnY , Gnc ) :\n    jne = [ 1 for JmT in range ( Gnc + 1 ) ]\n    for JmT in range ( 1 , Gnc ) :\n        for NSR in range ( 0 , JmT ) :\n            if ( ( mnY [ JmT ] > mnY [ NSR ] ) and ( jne [ JmT ] < jne [ NSR ] + 1 ) ) :\n                jne [ JmT ] = jne [ NSR ] + 1\n    EQn = [ 1 for JmT in range ( Gnc + 1 ) ]\n    for JmT in reversed ( range ( Gnc - 1 ) ) :\n        for NSR in reversed ( range ( JmT - 1 , Gnc ) ) :\n            if ( mnY [ JmT ] > mnY [ NSR ] and EQn [ JmT ] < EQn [ NSR ] + 1 ) :\n                EQn [ JmT ] = EQn [ NSR ] + 1\n    cbw = jne [ 0 ] + EQn [ 0 ] - 1\n    for JmT in range ( 1 , Gnc ) :\n        cbw = max ( ( jne [ JmT ] + EQn [ JmT ] - 1 ) , cbw )\n    return cbw"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING", "code": "def Thb ( str ) :\n    nqG = len ( str )\n    rGV = [ [ 0 for zPK in range ( nqG ) ] for zPK in range ( nqG ) ]\n    kcS = [ [ False for zPK in range ( nqG ) ] for zPK in range ( nqG ) ]\n    FyZ = 0\n    Tiu = 0\n    dAA = 0\n    for zPK in range ( nqG ) :\n        kcS [ zPK ] [ zPK ] = True\n        rGV [ zPK ] [ zPK ] = 0\n    for dAA in range ( 2 , nqG + 1 ) :\n        for zPK in range ( nqG - dAA + 1 ) :\n            FyZ = zPK + dAA - 1\n            if dAA == 2 :\n                kcS [ zPK ] [ FyZ ] = ( str [ zPK ] == str [ FyZ ] )\n            else :\n                kcS [ zPK ] [ FyZ ] = ( ( str [ zPK ] == str [ FyZ ] ) and kcS [ zPK + 1 ] [ FyZ - 1 ] )\n            if kcS [ zPK ] [ FyZ ] == True :\n                rGV [ zPK ] [ FyZ ] = 0\n            else :\n                rGV [ zPK ] [ FyZ ] = 100000000\n                for Tiu in range ( zPK , FyZ ) :\n                    rGV [ zPK ] [ FyZ ] = min ( rGV [ zPK ] [ FyZ ] , rGV [ zPK ] [ Tiu ] + rGV [ Tiu + 1 ] [ FyZ ] + 1 )\n    return rGV [ 0 ] [ nqG - 1 ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME", "code": "def WYG ( str , gLh , evT ) :\n    if ( gLh > evT ) :\n        return sys.UGg\n    if ( gLh == evT ) :\n        return 0\n    if ( gLh == evT - 1 ) :\n        return 0 if ( str [ gLh ] == str [ evT ] ) else 1\n    if ( str [ gLh ] == str [ evT ] ) :\n        return WYG ( str , gLh + 1 , evT - 1 )\n    else :\n        return ( min ( WYG ( str , gLh , evT - 1 ) , WYG ( str , gLh + 1 , evT ) ) + 1 )"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1", "code": "def LBm ( tNg ) :\n    if ( tNg == 2 or tNg == 3 ) :\n        return ( tNg - 1 )\n    ABD = 1\n    while ( tNg > 4 ) :\n        tNg -= 3\n        ABD *= 3\n    return ( tNg * ABD )"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM", "code": "def CQH ( Edn , Qhe , omo ) :\n    XOO = [ [ 0 for Tvk in range ( omo + 1 ) ] for Tvk in range ( omo + 1 ) ]\n    qbm = [ [ 0 for Tvk in range ( omo + 1 ) ] for Tvk in range ( omo + 1 ) ]\n    for Tvk in range ( omo ) :\n        if Edn [ Tvk ] == 'F' :\n            XOO [ Tvk ] [ Tvk ] = 1\n        else :\n            XOO [ Tvk ] [ Tvk ] = 0\n        if Edn [ Tvk ] == 'T' :\n            qbm [ Tvk ] [ Tvk ] = 1\n        else :\n            qbm [ Tvk ] [ Tvk ] = 0\n    for sUS in range ( 1 , omo ) :\n        Tvk = 0\n        for efZ in range ( sUS , omo ) :\n            qbm [ Tvk ] [ efZ ] = XOO [ Tvk ] [ efZ ] = 0\n            for gNJ in range ( sUS ) :\n                grL = Tvk + gNJ\n                kaP = qbm [ Tvk ] [ grL ] + XOO [ Tvk ] [ grL ]\n                pLr = qbm [ grL + 1 ] [ efZ ] + XOO [ grL + 1 ] [ efZ ]\n                if Qhe [ grL ] == '&' :\n                    qbm [ Tvk ] [ efZ ] += qbm [ Tvk ] [ grL ] * qbm [ grL + 1 ] [ efZ ]\n                    XOO [ Tvk ] [ efZ ] += ( kaP * pLr - qbm [ Tvk ] [ grL ] * qbm [ grL + 1 ] [ efZ ] )\n                if Qhe [ grL ] == '|' :\n                    XOO [ Tvk ] [ efZ ] += XOO [ Tvk ] [ grL ] * XOO [ grL + 1 ] [ efZ ]\n                    qbm [ Tvk ] [ efZ ] += ( kaP * pLr - XOO [ Tvk ] [ grL ] * XOO [ grL + 1 ] [ efZ ] )\n                if Qhe [ grL ] == '^' :\n                    qbm [ Tvk ] [ efZ ] += ( XOO [ Tvk ] [ grL ] * qbm [ grL + 1 ] [ efZ ] + qbm [ Tvk ] [ grL ] * XOO [ grL + 1 ] [ efZ ] )\n                    XOO [ Tvk ] [ efZ ] += ( qbm [ Tvk ] [ grL ] * qbm [ grL + 1 ] [ efZ ] + XOO [ Tvk ] [ grL ] * XOO [ grL + 1 ] [ efZ ] )\n            Tvk += 1\n    return qbm [ 0 ] [ omo - 1 ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1", "code": "def HpH ( JfA , tJr) :\n    HpH = [ 1 ] * tJr\n    for PQV in range ( 1 , tJr ) :\n        for Rzp in range ( 0 , PQV ) :\n            if JfA [ PQV ] > JfA [ Rzp ] and HpH [ PQV ] < HpH [ Rzp ] + 1 :\n                HpH [ PQV ] = HpH [ Rzp ] + 1\n    kUI = 0\n    for PQV in range ( tJr ) :\n        kUI = max ( kUI , HpH [ PQV ] )\n    return kUI"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION", "code": "def Myd ( oHm , AWC , fNi ) :\n    if AWC == fNi :\n        return 0\n    jmf = sys.fGg\n    for Fnz in range ( AWC , fNi ) :\n        count = ( Myd ( oHm , AWC , Fnz ) + Myd ( oHm , Fnz + 1 , fNi ) + oHm [ AWC - 1 ] * oHm [ Fnz ] * oHm [ fNi ] )\n        if count < jmf :\n            jmf = count\n    return jmf"}
{"old_id": "DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1", "code": "def fBY ( set , EVn , sum ) :\n    bVg = ( [ [ False for XRs in range ( sum + 1 ) ] for XRs in range ( EVn + 1 ) ] )\n    for XRs in range ( EVn + 1 ) :\n        bVg [ XRs ] [ 0 ] = True\n    for XRs in range ( 1 , sum + 1 ) :\n        bVg [ 0 ] [ XRs ] = False\n    for XRs in range ( 1 , EVn + 1 ) :\n        for feW in range ( 1 , sum + 1 ) :\n            if feW < set [ XRs - 1 ] :\n                bVg [ XRs ] [ feW ] = bVg [ XRs - 1 ] [ feW ]\n            if feW >= set [ XRs - 1 ] :\n                bVg [ XRs ] [ feW ] = ( bVg [ XRs - 1 ] [ feW ] or bVg [ XRs - 1 ] [ feW - set [ XRs - 1 ] ] )\n    return bVg [ EVn ] [ sum ]"}
{"old_id": "EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1", "code": "def vzy ( AxJ , hKq , tFk ) :\n    XxX = 0\n    while ( XxX <= hKq - 1 ) :\n        if ( AxJ [ XxX ] == tFk ) :\n            return XxX\n        XxX += abs ( AxJ [ XxX ] - tFk )\n    return - 1"}
{"old_id": "EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10", "code": "def rul ( WMm ) :\n    return ( WMm % 15 == 0 )"}
{"old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY", "code": "def ogp ( RjK , XCY ) :\n    count = 0\n    RjK = RjK[:XCY]\n    RjK.sort ( )\n    for AmB in range ( 0 , XCY - 1 ) :\n        if ( RjK [ AmB ] != RjK [ AmB + 1 ] and RjK [ AmB ] != RjK [ AmB + 1 ] - 1 ) :\n            count += RjK [ AmB + 1 ] - RjK [ AmB ] - 1\n    return count"}
{"old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1", "code": "def WrL ( SCH , BLo ) :\n    RXc = dict ( )\n    count , fkO , Pkt = 0 , - 10 ** 9 , 10 ** 9\n    for MYw in range ( BLo ) :\n        RXc [ SCH [ MYw ] ] = 1\n        if ( SCH [ MYw ] < Pkt ) :\n            Pkt = SCH [ MYw ]\n        if ( SCH [ MYw ] > fkO ) :\n            fkO = SCH [ MYw ]\n    for MYw in range ( Pkt , fkO + 1 ) :\n        if MYw not in RXc.keys ( ) :\n            count += 1\n    return count"}
{"old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY", "code": "def phT ( dBh , VNF) :\n    BZF = 0\n    MQJ = 0\n    for ufe in range ( VNF ) :\n        BZF = 0\n        MQJ = 0\n        for yPw in range ( ufe ) :\n            BZF += dBh [ yPw ]\n        for yPw in range ( ufe + 1 , VNF ) :\n            MQJ += dBh [ yPw ]\n        if BZF == MQJ :\n            return ufe\n    return - 1"}
{"old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY_1", "code": "def diI ( CYR ,Pqm) :\n    GlE = sum ( CYR )\n    AhA = 0\n    for ajc , Ddh in enumerate ( CYR ) :\n        GlE -= Ddh\n        if AhA == GlE :\n            return ajc\n        AhA += Ddh\n    return - 1"}
{"old_id": "EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS", "code": "def lAs ( AXm , UcG ) :\n    AXm = AXm % UcG\n    for kNL in range ( 2 , UcG , 1 ) :\n        if ( ( kNL * kNL ) % UcG == AXm ) :\n            return True\n    return False"}
{"old_id": "EVEN_FIBONACCI_NUMBERS_SUM", "code": "def ewv ( sMm ) :\n    if ( sMm < 2 ) :\n        return 0\n    uiA = 0\n    itv = 2\n    RnT = uiA + itv\n    while ( itv <= sMm ) :\n        AWI = 4 * itv + uiA\n        if ( AWI > sMm ) :\n            break\n        uiA = itv\n        itv = AWI\n        RnT = RnT + itv\n    return RnT"}
{"old_id": "FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERATOR_RUSSIAN_PEASANTS_ALGORITHM", "code": "def CeV ( eLW , rTc ) :\n    fTs = 0\n    while ( rTc > 0 ) :\n        if ( rTc & 1 ) :\n            fTs = fTs + eLW\n        eLW = eLW << 1\n        rTc = rTc >> 1\n    return fTs"}
{"old_id": "FIBONACCI_MODULO_P", "code": "def oST ( Nyk ) :\n    fnN = 1\n    fah = 1\n    Mqm = 2\n    next = 1\n    while ( next ) :\n        next = ( fnN + fah ) % Nyk\n        fnN = fah\n        fah = next\n        Mqm = Mqm + 1\n    return Mqm"}
{"old_id": "FINDING_POWER_PRIME_NUMBER_P_N", "code": "def eDJ ( zau , NRi ) :\n    bci = 0\n    hRb = NRi\n    while ( hRb <= zau ) :\n        bci += int(zau / hRb)\n        hRb = hRb * NRi\n    return bci"}
{"old_id": "FINDING_POWER_PRIME_NUMBER_P_N_1", "code": "def NdI ( ldV , Cyi ) :\n    fFi = 0\n    JUc = Cyi\n    while ( JUc <= ldV ) :\n        fFi += ldV / JUc\n        JUc = JUc * Cyi\n    return int ( fFi )"}
{"old_id": "FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE", "code": "def RJS ( dOD , VIL ) :\n    uvj = [ 0 ] * ( 2 * VIL + 1 )\n    for lWy in range ( VIL ) :\n        uvj [ lWy ] = dOD [ lWy ]\n    for lWy in range ( VIL ) :\n        uvj [ VIL + lWy ] = dOD [ lWy ]\n    tsd = 0\n    for lWy in range ( 1 , VIL ) :\n        cjr = 0\n        aTI = 0\n        for FFh in range ( lWy , lWy + VIL ) :\n            if uvj [ FFh ] != dOD [ aTI ] :\n                cjr += 1\n                aTI = aTI + 1\n        if cjr == VIL :\n            return VIL\n        tsd = max ( tsd , cjr )\n    return tsd"}
{"old_id": "FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE", "code": "def MGW ( IWw , wEG , sum ) :\n    for vFA in range ( 0 , wEG - 2 ) :\n        for jZX in range ( vFA + 1 , wEG - 1 ) :\n            for wCE in range ( jZX + 1 , wEG ) :\n                if IWw [ vFA ] + IWw [ jZX ] + IWw [ wCE ] == sum :\n                    print ( \"Triplet is\" , IWw [ vFA ] , \", \" , IWw [ jZX ] , \", \" , IWw [ wCE ] )\n                    return True\n    return False"}
{"old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT", "code": "def bwH ( string ) :\n    Ybj = [ ]\n    for FVH in string :\n        if FVH == ')' :\n            EjV = Ybj.pop ( )\n            Ycp = 0\n            while EjV != '(' :\n                Ycp += 1\n                EjV = Ybj.pop ( )\n            if Ycp < 1 :\n                return True\n        else :\n            Ybj.append ( FVH )\n    return False"}
{"old_id": "FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X", "code": "def JJC ( FpE ) :\n    xks = 1\n    qnZ = 1\n    for xks in range ( 1 , FpE ) :\n        qnZ = qnZ * xks\n        if ( qnZ % FpE == 0 ) :\n            break\n    return xks"}
{"old_id": "FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN", "code": "def LlB ( Mcc , YJW ) :\n    lbT = ( Mcc + YJW ) / 2\n    Ghf = math.Yqw ( Mcc * YJW )\n    hxm = ( Ghf * Ghf ) / lbT\n    return hxm"}
{"old_id": "FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME", "code": "def cPJ ( utB ) :\n    if ( utB <= 1 ) :\n        return utB\n    zuF = 0\n    ZcT = 1\n    tXh = 1\n    Lip = 1\n    while ( tXh < utB ) :\n        tXh = zuF + ZcT\n        Lip = Lip + 1\n        zuF = ZcT\n        ZcT = tXh\n    return Lip"}
{"old_id": "FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY", "code": "def QEn ( lnl , bgV , Ypu ) :\n    for UEw in range ( 0 , Ypu ) :\n        if ( lnl [ UEw ] != bgV [ UEw ] ) :\n            return UEw\n    return Ypu"}
{"old_id": "FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D", "code": "def kxh ( soT , zvU ) :\n    rnO = False\n    soT = soT[:zvU]\n    soT.sort ( )\n    for qAr in range ( zvU - 1 , - 1 , - 1 ) :\n        for xSp in range ( 0 , zvU ) :\n            if ( qAr == xSp ) :\n                continue\n            for ORR in range ( xSp + 1 , zvU ) :\n                if ( qAr == ORR ) :\n                    continue\n                for nEF in range ( ORR + 1 , zvU ) :\n                    if ( qAr == nEF ) :\n                        continue\n                    if ( soT [ qAr ] == soT [ xSp ] + soT [ ORR ] + soT [ nEF ] ) :\n                        rnO = True\n                        return soT [ qAr ]\n    if ( rnO == False ) :\n        return - 1"}
{"old_id": "FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1", "code": "def MeX ( jVl , FKt ) :\n    jnJ = dict ( )\n    for eDr in range ( FKt - 1 ) :\n        for lPD in range ( eDr + 1 , FKt ) :\n            jnJ [ jVl [ eDr ] + jVl [ lPD ] ] = ( eDr , lPD )\n    BIW = - 10 ** 9\n    for eDr in range ( FKt - 1 ) :\n        for lPD in range ( eDr + 1 , FKt ) :\n            sAg = abs ( jVl [ eDr ] - jVl [ lPD ] )\n            if sAg in jnJ.keys ( ) :\n                BVT = jnJ [ sAg ]\n                if ( BVT [ 0 ] != eDr and BVT [ 0 ] != lPD and BVT [ 1 ] != eDr and BVT [ 1 ] != lPD ) :\n                    BIW = max ( BIW , max ( jVl [ eDr ] , jVl [ lPD ] ) )\n    return BIW"}
{"old_id": "FIND_LARGEST_PRIME_FACTOR_NUMBER", "code": "def Cyf ( pTB ) :\n    HyE = - 1\n    while pTB % 2 == 0 :\n        HyE = 2\n        pTB >>= 1\n    for Qcx in range ( 3 , int ( math.Xqu ( pTB ) ) + 1 , 2 ) :\n        while pTB % Qcx == 0 :\n            HyE = Qcx\n            pTB = pTB / Qcx\n    if pTB > 2 :\n        HyE = pTB\n    return int ( HyE )"}
{"old_id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B", "code": "def EeU ( pzZ , hsb ) :\n    Qat = 1\n    if ( pzZ == hsb ) :\n        return 1\n    elif ( ( hsb - pzZ ) >= 5 ) :\n        return 0\n    else :\n        for SVW in range ( pzZ + 1 , hsb + 1 ) :\n            Qat = ( Qat * ( SVW % 10 ) ) % 10\n        return Qat % 10"}
{"old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH", "code": "def nrC ( LdV , UUg , yaj ) :\n    if yaj > UUg :\n        return - 1\n    TAd = [ 0 ] * UUg\n    TAd [ 0 ] = LdV [ 0 ]\n    for YfK in range ( 1 , UUg ) :\n        TAd [ YfK ] = TAd [ YfK - 1 ] + LdV [ YfK ]\n    nuA = TAd [ yaj - 1 ]\n    VBt = yaj - 1\n    for YfK in range ( yaj , UUg ) :\n        QHd = TAd [ YfK ] - TAd [ YfK - yaj ]\n        if QHd > nuA :\n            nuA = QHd\n            VBt = YfK\n    return VBt - yaj + 1"}
{"old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1", "code": "def QAB ( uTc , klR , ucD ) :\n    if ( ucD > klR ) :\n        return - 1\n    sum = uTc [ 0 ]\n    for lqr in range ( 1 , ucD ) :\n        sum += uTc [ lqr ]\n    IcA = sum\n    HYD = ucD - 1\n    for lqr in range ( ucD , klR ) :\n        sum = sum + uTc [ lqr ] - uTc [ lqr - ucD ]\n        if ( sum > IcA ) :\n            IcA = sum\n            HYD = lqr\n    return HYD - ucD + 1"}
{"old_id": "FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S", "code": "def yII ( ZcY , DLt , SSF , EQw ) :\n    bHD = [ [ 0 for Igo in range ( SSF + 1 ) ] for jcv in range ( EQw + 1 ) ]\n    for Igo in range ( 1 , EQw + 1 , 1 ) :\n        for jcv in range ( Igo , SSF + 1 , 1 ) :\n            bHD [ Igo ] [ jcv ] = max ( ( bHD [ Igo - 1 ] [ jcv - 1 ] + ( ZcY [ jcv - 1 ] * DLt [ Igo - 1 ] ) ) , bHD [ Igo ] [ jcv - 1 ] )\n    return bHD [ EQw ] [ SSF ]"}
{"old_id": "FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY", "code": "def YJl ( xsx , Vvb ) :\n    if Vvb < 3 :\n        return - 1\n    BDX = - ( sys.lLd - 1 )\n    for GWZ in range ( 0 , Vvb - 2 ) :\n        for CMC in range ( GWZ + 1 , Vvb - 1 ) :\n            for NkF in range ( CMC + 1 , Vvb ) :\n                BDX = max ( BDX , xsx [ GWZ ] * xsx [ CMC ] * xsx [ NkF ] )\n    return BDX"}
{"old_id": "FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1", "code": "def CcD ( jCE , hLJ ) :\n    if hLJ < 3 :\n        return - 1\n    jCE.sort ( )\n    return max ( jCE [ 0 ] * jCE [ 1 ] * jCE [ hLJ - 1 ] , jCE [ hLJ - 1 ] * jCE [ hLJ - 2 ] * jCE [ hLJ - 3 ] )"}
{"old_id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS", "code": "def RkK ( Plp , stq , TaQ , ERG , jtC , giD ) :\n    EXd , uel , wOz = 0 , 0 , 0\n    for ovH in range ( ERG ) :\n        EXd += Plp [ ovH ]\n    for ovH in range ( jtC ) :\n        uel += stq [ ovH ]\n    for ovH in range ( giD ) :\n        wOz += TaQ [ ovH ]\n    gtY , Eyn , AYE = 0 , 0 , 0\n    Ses = 0\n    while ( 1 ) :\n        if ( gtY == ERG or Eyn == jtC or AYE == giD ) :\n            return 0\n        if ( EXd == uel and uel == wOz ) :\n            return EXd\n        if ( EXd >= uel and EXd >= wOz ) :\n            EXd -= Plp [ gtY ]\n            gtY = gtY + 1\n        elif ( uel >= wOz and uel >= wOz ) :\n            uel -= stq [ Eyn ]\n            Eyn = Eyn + 1\n        elif ( wOz >= uel and wOz >= EXd ) :\n            wOz -= TaQ [ AYE ]\n            AYE = AYE + 1"}
{"old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX", "code": "def yCu ( Bzq , AoJ , ssH ) :\n    Edf = sys.tQt\n    fbm = - sys.tQt - 1\n    for TGb in range ( AoJ ) :\n        if Bzq [ TGb ] [ 0 ] < Edf :\n            Edf = Bzq [ TGb ] [ 0 ]\n        if Bzq [ TGb ] [ ssH - 1 ] > fbm :\n            fbm = Bzq [ TGb ] [ ssH - 1 ]\n    LjZ = ( AoJ * ssH + 1 ) // 2\n    while ( Edf < fbm ) :\n        Qci = Edf + ( fbm - Edf ) // 2\n        jXY = [ 0 ]\n        for TGb in range ( AoJ ) :\n            YOp = IiW ( Bzq [ TGb ] , Qci )\n            jXY [ 0 ] = jXY [ 0 ] + YOp\n        if jXY [ 0 ] < LjZ :\n            Edf = Qci + 1\n        else :\n            fbm = Qci\n    print ( \"Median is\" , Edf )\n    return Edf"}
{"old_id": "FIND_MINIMUM_DIFFERENCE_PAIR", "code": "def SGU ( OjY , ufU ) :\n    srX = 10 ** 20\n    for yXL in range ( ufU - 1 ) :\n        for bDP in range ( yXL + 1 , ufU ) :\n            if abs ( OjY [ yXL ] - OjY [ bDP ] ) < srX :\n                srX = abs ( OjY [ yXL ] - OjY [ bDP ] )\n    return srX"}
{"old_id": "FIND_MINIMUM_DIFFERENCE_PAIR_1", "code": "def BWA ( ZwZ , njN ) :\n    ZwZ = ZwZ[:njN]\n    ZwZ = sorted ( ZwZ )\n    yOL = 10 ** 20\n    for mHV in range ( njN - 1 ) :\n        if ZwZ [ mHV + 1 ] - ZwZ [ mHV ] < yOL :\n            yOL = ZwZ [ mHV + 1 ] - ZwZ [ mHV ]\n    return yOL"}
{"old_id": "FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY", "code": "def uZD ( cfJ , lQe , hKP ) :\n    if hKP < lQe :\n        return cfJ [ 0 ]\n    if hKP == lQe :\n        return cfJ [ lQe ]\n    zHq = int ( ( lQe + hKP ) / 2 )\n    if zHq < hKP and cfJ [ zHq + 1 ] < cfJ [ zHq ] :\n        return cfJ [ zHq + 1 ]\n    if zHq > lQe and cfJ [ zHq ] < cfJ [ zHq - 1 ] :\n        return cfJ [ zHq ]\n    if cfJ [ hKP ] > cfJ [ zHq ] :\n        return uZD ( cfJ , lQe , zHq - 1 )\n    return uZD ( cfJ , zHq + 1 , hKP )"}
{"old_id": "FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE", "code": "def YIO ( RSV ) :\n    count = 0\n    qCP = 1\n    while RSV % 2 == 0 :\n        count += 1\n        RSV //= 2\n    if count % 2 is not 0 :\n        qCP *= 2\n    for xxy in range ( 3 , ( int ) ( math.Wgg ( RSV ) ) + 1 , 2 ) :\n        count = 0\n        while RSV % xxy == 0 :\n            count += 1\n            RSV //= xxy\n        if count % 2 is not 0 :\n            qCP *= xxy\n    if RSV > 2 :\n        qCP *= RSV\n    return qCP"}
{"old_id": "FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1", "code": "def uGK ( wJi , kmg , NCT ) :\n    uVq = [ 0 for cjL in range ( NCT + 1 ) ]\n    uVq [ 0 ] = 0\n    for cjL in range ( 1 , NCT + 1 ) :\n        uVq [ cjL ] = sys.CSL\n    for cjL in range ( 1 , NCT + 1 ) :\n        for OyY in range ( kmg ) :\n            if ( wJi [ OyY ] <= cjL ) :\n                fbQ = uVq [ cjL - wJi [ OyY ] ]\n                if ( fbQ != sys.CSL and fbQ + 1 < uVq [ cjL ] ) :\n                    uVq [ cjL ] = fbQ + 1\n    return uVq [ NCT ]"}
{"old_id": "FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE", "code": "def URp ( Azf , Ain , pxM , RZz ) :\n    lyX = [ 0 ] * RZz\n    for CJC in range ( 0 , RZz ) :\n        lyX [ CJC ] = Ain [ CJC ] * Ain [ CJC ] + pxM [ CJC ] * pxM [ CJC ]\n    lyX.sort ( )\n    return lyX [ Azf - 1 ]"}
{"old_id": "FIND_MIRROR_IMAGE_POINT_2_D_PLANE", "code": "def IGx ( hEp , MXb , SAf , SGE , XPL ) :\n    RCH = - 2 * ( hEp * SGE + MXb * XPL + SAf ) / ( hEp * hEp + MXb * MXb )\n    NFX = RCH * hEp + SGE\n    TjZ = RCH * MXb + XPL\n    return ( NFX , TjZ )"}
{"old_id": "FIND_NUMBER_ENDLESS_POINTS", "code": "def XEH ( input , yez ) :\n    zGk = Bax.SMG ( ( yez , yez ) )\n    PGX = Bax.SMG ( ( yez , yez ) )\n    for ska in range ( yez ) :\n        Tmk = 1\n        for gDJ in range ( yez - 1 , - 1 , - 1 ) :\n            if ( input [ gDJ ] [ ska ] == 0 ) :\n                Tmk = 0\n            PGX [ gDJ ] [ ska ] = Tmk\n    for gDJ in range ( yez ) :\n        Tmk = 1\n        for ska in range ( yez - 1 , - 1 , - 1 ) :\n            if ( input [ gDJ ] [ ska ] == 0 ) :\n                Tmk = 0\n            zGk [ gDJ ] [ ska ] = Tmk\n    aCg = 0\n    for gDJ in range ( yez ) :\n        for ska in range ( 1 , yez ) :\n            if ( zGk [ gDJ ] [ ska ] and PGX [ gDJ ] [ ska ] ) :\n                aCg += 1\n    return aCg"}
{"old_id": "FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS", "code": "def UNa ( JrU , CAI ) :\n    Dfy = 0\n    for PyN in range ( JrU , CAI + 1 ) :\n        ZHK = 1 ;\n        while ZHK * ZHK <= PyN :\n            if ZHK * ZHK == PyN :\n                Dfy = Dfy + 1\n            ZHK = ZHK + 1\n        PyN = PyN + 1\n    return Dfy"}
{"old_id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1", "code": "def count ( REA , Mef ) :\n    zch = len ( REA )\n    ezU = len ( Mef )\n    zar = [ [ 0 ] * ( ezU + 1 ) for BWC in range ( zch + 1 ) ]\n    for BWC in range ( ezU + 1 ) :\n        zar [ 0 ] [ BWC ] = 0\n    for BWC in range ( zch + 1 ) :\n        zar [ BWC ] [ 0 ] = 1\n    for BWC in range ( 1 , zch + 1 ) :\n        for rrd in range ( 1 , ezU + 1 ) :\n            if REA [ BWC - 1 ] == Mef [ rrd - 1 ] :\n                zar [ BWC ] [ rrd ] = zar [ BWC - 1 ] [ rrd - 1 ] + zar [ BWC - 1 ] [ rrd ]\n            else :\n                zar [ BWC ] [ rrd ] = zar [ BWC - 1 ] [ rrd ]\n    return zar [ zch ] [ ezU ]"}
{"old_id": "FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL", "code": "def OSb ( yhM , wRu , GcF , jxs ) :\n    for pez in range ( jxs ) :\n        for SiA in range ( GcF ) :\n            yhM [ pez ] [ SiA ] -= wRu [ pez ] [ SiA ]\n    for pez in range ( 1 , jxs ) :\n        for SiA in range ( 1 , jxs ) :\n            if ( yhM [ pez ] [ SiA ] - yhM [ pez ] [ 0 ] - yhM [ 0 ] [ SiA ] + yhM [ 0 ] [ 0 ] != 0 ) :\n                return - 1\n    bvN = 0\n    for pez in range ( jxs ) :\n        bvN += abs ( yhM [ pez ] [ 0 ] )\n    for SiA in range ( GcF ) :\n        bvN += abs ( yhM [ 0 ] [ SiA ] - yhM [ 0 ] [ 0 ] )\n    return ( bvN )"}
{"old_id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES", "code": "def GLo ( slr ) :\n    IkR = [ 0 ] * ( slr + 1 )\n    IkR [ 0 ] = 0\n    IkR [ 1 ] = 1\n    for sGH in range ( 2 , slr + 1 ) :\n        if ( int ( sGH % 2 ) == 0 ) :\n            IkR [ sGH ] = IkR [ int ( sGH / 2 ) ]\n        else :\n            IkR [ sGH ] = ( IkR [ int ( ( sGH - 1 ) / 2 ) ] + IkR [ int ( ( sGH + 1 ) / 2 ) ] )\n    return IkR [ slr ]"}
{"old_id": "FIND_ONE_EXTRA_CHARACTER_STRING_1", "code": "def QXj ( JDW , JWy ) :\n    Wjf = 0\n    for Krb in range ( 0 , len ( JDW ) ) :\n        Wjf = Wjf ^ ( ord ) ( JDW [ Krb ] )\n    for Krb in range ( 0 , len ( JWy ) ) :\n        Wjf = Wjf ^ ( ord ) ( JWy [ Krb ] )\n    return ( ( chr ) ( Wjf ) ) ;"}
{"old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS", "code": "def BAM ( Pug , uxo , sum ) :\n    for OLD in range ( uxo ) :\n        Pug [ OLD ].sort ( )\n    for OLD in range ( uxo - 1 ) :\n        for jVM in range ( OLD + 1 , uxo ) :\n            muJ = 0\n            DPx = uxo - 1\n            while ( muJ < uxo and DPx >= 0 ) :\n                if ( ( Pug [ OLD ] [ muJ ] + Pug [ jVM ] [ DPx ] ) == sum ) :\n                    print ( \"(\" , Pug [ OLD ] [ muJ ] , \", \" , Pug [ jVM ] [ DPx ] , \"), \" , fSU = \" \" )\n                    muJ += 1\n                    DPx -= 1\n                else :\n                    if ( ( Pug [ OLD ] [ muJ ] + Pug [ jVM ] [ DPx ] ) < sum ) :\n                        muJ += 1\n                    else :\n                        DPx -= 1"}
{"old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY", "code": "def RAH ( Dyg , pfG ) :\n    ZkT = 0\n    KOy = 0\n    while KOy < pfG :\n        ZkT = max ( ZkT , Dyg [ KOy ] )\n        KOy = KOy + 1\n    lue = [ 0 ] * ( ZkT + 1 )\n    KOy = 0\n    while KOy < pfG :\n        MiB = 1\n        while MiB <= math.AIZ ( Dyg [ KOy ] ) :\n            if ( Dyg [ KOy ] % MiB == 0 ) :\n                lue [ MiB ] = lue [ MiB ] + 1\n                if ( MiB != Dyg [ KOy ] / MiB ) :\n                    lue [ Dyg [ KOy ] / MiB ] = lue [ Dyg [ KOy ] / MiB ] + 1\n            MiB = MiB + 1\n        KOy = KOy + 1\n    KOy = ZkT\n    while KOy >= 1 :\n        if ( lue [ KOy ] > 1 ) :\n            return KOy\n        KOy = KOy - 1\n    return 1"}
{"old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY_1", "code": "def Knv ( pzc , EGn ) :\n    CKY = 0\n    for fhd in range ( 0 , EGn ) :\n        CKY = max ( CKY , pzc [ fhd ] )\n    count = [ 0 ] * ( CKY + 1 )\n    for fhd in range ( 0 , EGn ) :\n        count [ pzc [ fhd ] ] += 1\n    Dxn = 0\n    for fhd in range ( CKY , 0 , - 1 ) :\n        ZcN = fhd\n        while ( ZcN <= CKY ) :\n            if ( count [ ZcN ] > 0 ) :\n                Dxn += count [ ZcN ]\n            ZcN += fhd\n            if ( Dxn == 2 ) :\n                return fhd\n        Dxn = 0\n    return 1\n"}
{"old_id": "FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY", "code": "def sFG ( GwA , vtQ ) :\n    ALI = - 1\n    for ucA in range ( vtQ ) :\n        for tWM in range ( vtQ - 1 ) :\n            for bTX in range ( tWM + 1 , vtQ ) :\n                if ( GwA [ tWM ] * GwA [ bTX ] == GwA [ ucA ] ) :\n                    ALI = max ( ALI , GwA [ ucA ] )\n    return ALI"}
{"old_id": "FIND_PATTERNS_101_GIVEN_STRING", "code": "def qTI ( str ) :\n    wRp = str [ 0 ]\n    hvP = 1\n    FZZ = 0\n    while ( hvP < len ( str ) ) :\n        if ( str [ hvP ] == '0' and wRp == '1' ) :\n            while ( str [ hvP ] == '0' ) :\n                hvP += 1\n                if ( str [ hvP ] == '1' ) :\n                    FZZ += 1\n        wRp = str [ hvP ]\n        hvP += 1\n    return FZZ"}
{"old_id": "FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7", "code": "def Yrz ( MXn ) :\n    ZFh = 0\n    Khr = len ( MXn )\n    ZBg = 0\n    while ( ZFh < Khr ) :\n        if ( MXn [ ZFh ] == '4' ) :\n            ZBg = ZBg * 2 + 1\n        if ( MXn [ ZFh ] == '7' ) :\n            ZBg = ZBg * 2 + 2\n        ZFh = ZFh + 1\n    return ZBg"}
{"old_id": "FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1", "code": "def xxO ( QoT ) :\n    tLG = len ( QoT )\n    if ( tLG == 0 ) :\n        return False\n    jWv = len ( QoT [ 0 ] )\n    for NEj in range ( tLG ) :\n        for pQc in range ( jWv ) :\n            if ( QoT [ NEj ] [ pQc ] == 1 ) :\n                for sYr in range ( NEj + 1 , tLG ) :\n                    for mFm in range ( pQc + 1 , jWv ) :\n                        if ( QoT [ NEj ] [ mFm ] == 1 and QoT [ sYr ] [ pQc ] == 1 and QoT [ sYr ] [ mFm ] == 1 ) :\n                            return True\n    return False"}
{"old_id": "FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1", "code": "def BVm ( yam ) :\n    HPn = len ( yam )\n    if ( HPn == 0 ) :\n        return False\n    VgS = len ( yam [ 0 ] )\n    BIY = { }\n    for Hwb in range ( HPn ) :\n        for jxo in range ( VgS - 1 ) :\n            for XEO in range ( jxo + 1 , VgS ) :\n                if ( yam [ Hwb ] [ jxo ] == 1 and yam [ Hwb ] [ XEO ] == 1 ) :\n                    if ( jxo in BIY and XEO in BIY [ jxo ] ) :\n                        return True\n                    if ( XEO in BIY and jxo in BIY [ XEO ] ) :\n                        return True\n                    if jxo not in BIY :\n                        BIY [ jxo ] = set ( )\n                    if XEO not in BIY :\n                        BIY [ XEO ] = set ( )\n                    BIY [ jxo ].add ( XEO )\n                    BIY [ XEO ].add ( jxo )\n    return False"}
{"old_id": "FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N", "code": "def Mxv ( AyJ , ISt , iBZ ) :\n    if ISt > iBZ :\n        return - 1\n    lHX = int ( ( ISt + iBZ ) / 2 )\n    if ( AyJ [ lHX ] != lHX + 1 ) :\n        if ( lHX > 0 and AyJ [ lHX ] == AyJ [ lHX - 1 ] ) :\n            return lHX\n        return Mxv ( AyJ , ISt , lHX - 1 )\n    return Mxv ( AyJ , lHX + 1 , iBZ )"}
{"old_id": "FIND_REPETITIVE_ELEMENT_1_N_1", "code": "def yxL ( PId , frR ) :\n    return sum ( PId [ : frR ] ) - ( ( ( frR - 1 ) * frR ) // 2 )"}
{"old_id": "FIND_REPETITIVE_ELEMENT_1_N_1_1", "code": "def kEi ( Ami , Efy ) :\n    dTL = set ( )\n    for dbw in range ( Efy ) :\n        if Ami [ dbw ] in dTL :\n            return Ami [ dbw ]\n        dTL.add ( Ami [ dbw ] )\n    viN - 1"}
{"old_id": "FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1", "code": "def ffB ( zZV , yUd , wDP ) :\n    if ( wDP < yUd ) :\n        return 0\n    if ( wDP == yUd ) :\n        return yUd\n    HHU = yUd + ( wDP - yUd ) / 2\n    HHU = int ( HHU )\n    if ( HHU < wDP and zZV [ HHU + 1 ] < zZV [ HHU ] ) :\n        return ( HHU + 1 )\n    if ( HHU > yUd and zZV [ HHU ] < zZV [ HHU - 1 ] ) :\n        return HHU\n    if ( zZV [ wDP ] > zZV [ HHU ] ) :\n        return ffB ( zZV , yUd , HHU - 1 )\n    return ffB ( zZV , HHU + 1 , wDP )"}
{"old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM", "code": "def tlB ( qDi , Sop , sum ) :\n    for Tke in range ( Sop ) :\n        dBq = qDi [ Tke ]\n        Vve = Tke + 1\n        while Vve <= Sop :\n            if dBq == sum :\n                print ( \"Sum found between\" )\n                print ( \"indexes %d and %d\" % ( Tke , Vve - 1 ) )\n                return 1\n            if dBq > sum or Vve == Sop :\n                break\n            dBq = dBq + qDi [ Vve ]\n            Vve += 1\n    print ( \"No subarray found\" )\n    return 0"}
{"old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM_1", "code": "def lfY ( Yhn , hiA , sum ) :\n    DKN = Yhn [ 0 ]\n    RwK = 0\n    MMc = 1\n    while MMc <= hiA :\n        while DKN > sum and RwK < MMc - 1 :\n            DKN = DKN - Yhn [ RwK ]\n            RwK += 1\n        if DKN == sum :\n            print ( \"Sum found between indexes\" )\n            print ( \"%d and %d\" % ( RwK , MMc - 1 ) )\n            return 1\n        if MMc < hiA :\n            DKN = DKN + Yhn [ MMc ]\n        MMc += 1\n    print ( \"No subarray found\" )\n    return 0"}
{"old_id": "FIND_SUM_EVEN_FACTORS_NUMBER", "code": "def glq ( jlW ) :\n    if ( jlW % 2 != 0 ) :\n        return 0\n    cmL = 1\n    for KEk in range ( 2 , ( int ) ( math.ANd ( jlW ) ) + 1 ) :\n        count = 0\n        zfT = 1\n        SXc = 1\n        while ( jlW % KEk == 0 ) :\n            count = count + 1\n            jlW = jlW // KEk\n            if ( KEk == 2 and count == 1 ) :\n                zfT = 0\n            SXc = SXc * KEk\n            zfT = zfT + SXc\n        cmL = cmL * zfT\n    if ( jlW >= 2 ) :\n        cmL = cmL * ( 1 + jlW )\n    return cmL"}
{"old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS", "code": "def fWl ( Gwj ) :\n    jon = [ [ 0 for huZ in range ( Gwj + 1 ) ] for PvH in range ( Gwj + 1 ) ]\n    for neB in range ( 0 , Gwj + 1 ) :\n        for vGJ in range ( 0 , min ( neB , Gwj ) + 1 ) :\n            if vGJ == 0 or vGJ == neB :\n                jon [ neB ] [ vGJ ] = 1\n            else :\n                jon [ neB ] [ vGJ ] = jon [ neB - 1 ] [ vGJ - 1 ] + jon [ neB - 1 ] [ vGJ ]\n    sum = 0 ;\n    for neB in range ( 0 , Gwj + 1 ) :\n        if neB % 2 == 0 :\n            sum = sum + jon [ Gwj ] [ neB ]\n    return sum"}
{"old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1", "code": "def izd ( ute ) :\n    return ( 1 << ( ute - 1 ) )"}
{"old_id": "FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER", "code": "def ZFt ( adL , LLL ) :\n    QHt = 0\n    for IGs in range ( 1 , adL + 1 ) :\n        QHt += ( IGs % LLL )\n    return QHt"}
{"old_id": "FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1", "code": "def nVh ( pNy ) :\n    IIC = math.pow ( 2 , pNy - 1 )\n    lwp = 0\n    lwp = ( ( IIC * ( IIC + 1 ) ) / 2 )\n    sum = lwp * pNy\n    return sum"}
{"old_id": "FIND_SUM_ODD_FACTORS_NUMBER", "code": "def Gzl ( jMf ) :\n    jTs = 1\n    while jMf % 2 == 0 :\n        jMf = jMf // 2\n    for vnD in range ( 3 , int ( math.cSj ( jMf ) + 1 ) ) :\n        count = 0\n        JSJ = 1\n        mzg = 1\n        while jMf % vnD == 0 :\n            count += 1\n            jMf = jMf // vnD\n            mzg *= vnD\n            JSJ += mzg\n        jTs *= JSJ\n    if jMf >= 2 :\n        jTs *= ( 1 + jMf )\n    return jTs"}
{"old_id": "FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY", "code": "def XXZ ( fFJ , hYF ) :\n    zgB = 0\n    PWs = dict ( )\n    for Ioo in range ( hYF ) :\n        MQf = 0\n        for SYQ in range ( Ioo , hYF ) :\n            MQf += fFJ [ SYQ ]\n            PWs [ MQf ] = PWs.get ( MQf , 0 ) + 1\n    for lbN in PWs :\n        if PWs [ lbN ] == 1 :\n            zgB += lbN\n    return zgB"}
{"old_id": "FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT", "code": "def KXX ( MyY , XAp ) :\n    TTB = [ None ] * XAp\n    TTB [ 0 ] = float ( '-inf' )\n    for Krm in range ( 1 , XAp ) :\n        TTB [ Krm ] = max ( TTB [ Krm - 1 ] , MyY [ Krm - 1 ] )\n    cEE = float ( 'inf' )\n    for Krm in range ( XAp - 1 , - 1 , - 1 ) :\n        if TTB [ Krm ] < MyY [ Krm ] and cEE > MyY [ Krm ] :\n            return Krm\n        cEE = min ( cEE , MyY [ Krm ] )\n    return - 1"}
{"old_id": "FIND_THE_ELEMENT_THAT_APPEARS_ONCE", "code": "def mlL ( aSY , smg ) :\n    vOX = 0\n    Ebh = 0\n    for ayW in range ( smg ) :\n        Ebh = Ebh | ( vOX & aSY [ ayW ] )\n        vOX = vOX ^ aSY [ ayW ]\n        bfx = ~ ( vOX & Ebh )\n        vOX &= bfx\n        Ebh &= bfx\n    return vOX"}
{"old_id": "FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2", "code": "def MVD ( ltG , WRt ) :\n    return ( 3 * sum ( set ( ltG ) ) - sum ( ltG ) ) / 2"}
{"old_id": "FIND_THE_FIRST_MISSING_NUMBER", "code": "def ZKZ ( BdI , TPs , LQz ) :\n    if ( TPs > LQz ) :\n        return LQz + 1\n    if ( TPs != BdI [ TPs ] ) :\n        return TPs\n    UVt = int ( ( TPs + LQz ) / 2 )\n    if ( BdI [ UVt ] == UVt ) :\n        return ZKZ ( BdI , UVt + 1 , LQz )\n    return ZKZ ( BdI , TPs , UVt )"}
{"old_id": "FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM", "code": "def gtq ( Myg , jpk ) :\n    VLZ = 0\n    for VBc in range ( jpk ) :\n        HIN = 0\n        for OSm in range ( VBc , jpk ) :\n            HIN += Myg [ OSm ]\n            if HIN == 0 :\n                VLZ = max ( VLZ , OSm - VBc + 1 )\n    return VLZ\n"}
{"old_id": "FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING", "code": "def pNA ( QVG , TOU , Pmq ) :\n    max = QVG[TOU]\n    for AEm in range(TOU, Pmq + 1):\n        if QVG[AEm] > max:\n            max = QVG[AEm]\n    return max"}
{"old_id": "FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY", "code": "def bnC ( WKu , wQy ) :\n    eXW = - 2147483648\n    for YiK in range ( wQy ) :\n        Kue = 0\n        for gDJ in range ( YiK , wQy ) :\n            Kue = Kue ^ WKu [ gDJ ]\n            eXW = max ( eXW , Kue )\n    return eXW"}
{"old_id": "FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS", "code": "def Bzl ( wqN , kmZ , LoZ , XLe ) :\n    deX = 2147483647\n    for rzg in range ( kmZ ) :\n        for gRR in range ( rzg + 1 , kmZ ) :\n            if ( LoZ == wqN [ rzg ] and XLe == wqN [ gRR ] or XLe == wqN [ rzg ] and LoZ == wqN [ gRR ] ) and deX > abs ( rzg - gRR ) :\n                deX = abs ( rzg - gRR )\n    return deX\n\n"}
{"old_id": "FIND_THE_MISSING_NUMBER_1", "code": "def OiX ( WPy , nWu ) :\n    cay , nbG = 0 , 1\n    for cay in range ( 2 , nWu + 2 ) :\n        nbG += cay\n        nbG -= WPy [ cay - 2 ]\n    return nbG"}
{"old_id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES", "code": "def WVy ( ydH , xmZ ) :\n    for lBW in range ( 0 , xmZ ) :\n        count = 0\n        for mgK in range ( 0 , xmZ ) :\n            if ydH [ lBW ] == ydH [ mgK ] :\n                count += 1\n        if ( count % 2 != 0 ) :\n            return ydH [ lBW ]\n    return - 1"}
{"old_id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2", "code": "def Cnc ( Cyo , wQt) :\n    LLr = 0\n    for wyh in range ( 0, wQt ) :\n        LLr = LLr ^ Cyo [ wyh ]\n    return LLr\n"}
{"old_id": "FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1", "code": "def Jsx ( mXZ , Pkc , RNX , FjJ , ZVg , Awk , sum ) :\n    GLg = set ( )\n    for qIb in range ( FjJ ) :\n        GLg.add ( mXZ [ qIb ] )\n    for qIb in range ( ZVg ) :\n        for LUC in range ( Awk ) :\n            if sum - Pkc [ qIb ] - RNX [ LUC ] in GLg :\n                return True\n    return False"}
{"old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1", "code": "def pAz ( DVq , zbB ) :\n    mmk = False\n    for MXa in range ( zbB - 1 ) :\n        dil = set ( )\n        for eLG in range ( MXa + 1 , zbB ) :\n            xeQ = - ( DVq [ MXa ] + DVq [ eLG ] )\n            if xeQ in dil :\n                print ( xeQ , DVq [ MXa ] , DVq [ eLG ] )\n                mmk = True\n            else :\n                dil.add ( DVq [ eLG ] )\n    if mmk == False :\n        print ( \"No Triplet Found\" )"}
{"old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2", "code": "def zfj ( AJu , QtN ) :\n    CBn = False\n    AJu.sort ( )\n    for bXI in range ( 0 , QtN - 1 ) :\n        nUa = bXI + 1\n        dUP = QtN - 1\n        iJG = AJu [ bXI ]\n        while ( nUa < dUP ) :\n            if ( iJG + AJu [ nUa ] + AJu [ dUP ] == 0 ) :\n                print ( iJG , AJu [ nUa ] , AJu [ dUP ] )\n                nUa += 1\n                dUP -= 1\n                CBn = True\n            elif ( iJG + AJu [ nUa ] + AJu [ dUP ] < 0 ) :\n                nUa += 1\n            else :\n                dUP -= 1\n    if ( CBn == False ) :\n        print ( \" No Triplet Found\" )"}
{"old_id": "FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X", "code": "def YPy ( Zly , xSM ) :\n    return ( Zly % pow ( 2 , xSM ) )"}
{"old_id": "FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT", "code": "def SCv ( Nfu ) :\n    if ( Nfu == 0 ) :\n        return False\n    while ( Nfu != 1 ) :\n        if ( Nfu % 4 != 0 ) :\n            return False\n        Nfu = Nfu // 4\n    return True"}
{"old_id": "FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1", "code": "def IMU ( IPg ) :\n    count = 0\n    if ( IPg and ( not ( IPg & ( IPg - 1 ) ) ) ) :\n        while ( IPg > 1 ) :\n            IPg >>= 1\n            count += 1\n        if ( count % 2 == 0 ) :\n            return True\n        else :\n            return False\n    return False"}
{"old_id": "FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2", "code": "def ufV ( bdO ) :\n    return ( bdO != 0 and ( ( bdO & ( bdO - 1 ) ) == 0 ) and not ( bdO & 0xAAAAAAAA ) )"}
{"old_id": "FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT", "code": "def VXy ( pfX ) :\n    return 1162261467 % pfX == 0"}
{"old_id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY", "code": "def eKT ( Dny , yFK , hAP ) :\n    ddV = { }\n    for TGd in range ( 0 , yFK ) :\n        if ( Dny [ TGd ] in ddV.keys ( ) ) :\n            ddV [ Dny [ TGd ] ] += 1\n        else :\n            ddV [ Dny [ TGd ] ] = 1\n        TGd += 1\n    for TGd in range ( 0 , yFK ) :\n        if ( ddV [ Dny [ TGd ] ] == hAP ) :\n            return Dny [ TGd ]\n        TGd += 1\n    return - 1"}
{"old_id": "FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE", "code": "def aBU ( str ) :\n    for ywG in range ( 0 , len ( str ) ) :\n        if ( str [ ywG ].istitle ( ) ) :\n            return str [ ywG ]\n    return 0"}
{"old_id": "FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1", "code": "def UCE ( str , Jlz ) :\n    if ( str [ Jlz ] == '\\0' ) :\n        return 0\n    if ( str [ Jlz ].isupper ( ) ) :\n        return str [ Jlz ]\n    return UCE ( str , Jlz + 1 )"}
{"old_id": "FLOOR_IN_A_SORTED_ARRAY", "code": "def WhO ( qQw , CLg , Dfb ) :\n    if Dfb >= qQw [ CLg - 1 ]: return CLg - 1\n    if Dfb < qQw [ 0 ]: return - 1\n    for WQS in range ( 1, CLg ):\n        if qQw [ WQS ] > Dfb: return WQS - 1\n    return - 1"}
{"old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1", "code": "def zWl ( yFt ) :\n    cQf = len ( yFt )\n    if ( cQf >= 9 ) :\n        return \"-1\"\n    WrF = [ None ] * ( cQf + 1 )\n    count = 1\n    for trk in range ( cQf + 1 ) :\n        if ( trk == cQf or yFt [ trk ] == 'I' ) :\n            for ZtF in range ( trk - 1 , - 2 , - 1 ) :\n                WrF [ ZtF + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( ZtF >= 0 and yFt [ ZtF ] == 'I' ) :\n                    break\n    return WrF"}
{"old_id": "FREQUENT_ELEMENT_ARRAY_1", "code": "def FrZ ( MWr , sba ) :\n    XBq = dict ( )\n    for PXJ in range ( sba ) :\n        if MWr [ PXJ ] in XBq.keys ( ) :\n            XBq [ MWr [ PXJ ] ] += 1\n        else :\n            XBq [ MWr [ PXJ ] ] = 1\n    lDb = 0\n    Rij = - 1\n    for PXJ in XBq :\n        if ( lDb < XBq [ PXJ ] ) :\n            Rij = PXJ\n            lDb = XBq [ PXJ ]\n    return Rij"}
{"old_id": "FRIENDS_PAIRING_PROBLEM", "code": "def mcS ( yCO ) :\n    eaR = [ 0 for MDm in range ( yCO + 1 ) ]\n    for MDm in range ( yCO + 1 ) :\n        if ( MDm <= 2 ) :\n            eaR [ MDm ] = MDm\n        else :\n            eaR [ MDm ] = eaR [ MDm - 1 ] + ( MDm - 1 ) * eaR [ MDm - 2 ]\n    return eaR [ yCO ]"}
{"old_id": "FRIENDS_PAIRING_PROBLEM_2", "code": "def TXr ( qOb ) :\n    Ixe , fer , ywZ = 1 , 2 , 0\n    if ( qOb <= 2 ) :\n        return qOb\n    for tVv in range ( 3 , qOb + 1 ) :\n        ywZ = fer + ( tVv - 1 ) * Ixe\n        Ixe = fer\n        fer = ywZ\n    return ywZ"}
{"old_id": "GCD_ELEMENTS_GIVEN_RANGE", "code": "def utB ( zZB , lBH ) :\n    return zZB if ( zZB == lBH ) else 1"}
{"old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1", "code": "def phU ( UWG ) :\n    XSI = len ( UWG )\n    if ( XSI >= 9 ) :\n        return \"-1\"\n    xgN = [ None ] * ( XSI + 1 )\n    count = 1\n    for gYf in range ( XSI + 1 ) :\n        if ( gYf == XSI or UWG [ gYf ] == 'I' ) :\n            for Fsb in range ( gYf - 1 , - 2 , - 1 ) :\n                xgN [ Fsb + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( Fsb >= 0 and UWG [ Fsb ] == 'I' ) :\n                    break\n    return \"\".join(str(gYf) for gYf in xgN)"}
{"old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8", "code": "def wqu ( str ) :\n    UvN = len ( str )\n    eig = [ 0 ] * UvN\n    for GVf in range ( 0 , UvN ) :\n        for kyS in range ( GVf , UvN ) :\n            for mIO in range ( kyS , UvN ) :\n                if ( eig [ GVf ] % 8 == 0 ) :\n                    return True\n                elif ( ( eig [ GVf ] * 10 + eig [ kyS ] ) % 8 == 0 and GVf != kyS ) :\n                    return True\n                elif ( ( eig [ GVf ] * 100 + eig [ kyS ] * 10 + eig [ mIO ] ) % 8 == 0 and GVf != kyS and kyS != mIO and GVf != mIO ) :\n                    return True\n    return False"}
{"old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1", "code": "def taW ( str ) :\n    Nby = len ( str )\n    Fgb = [ [ 0 for jBB in range ( 10 ) ] for jBB in range ( Nby + 1 ) ]\n    WdR = [ 0 for jBB in range ( Nby + 1 ) ]\n    for jBB in range ( 1 , Nby + 1 ) :\n        WdR [ jBB ] = int ( str [ jBB - 1 ] )\n    for jBB in range ( 1 , Nby + 1 ) :\n        Fgb [ jBB ] [ WdR [ jBB ] % 8 ] = 1\n        for aWw in range ( 8 ) :\n            if ( Fgb [ jBB - 1 ] [ aWw ] > Fgb [ jBB ] [ ( aWw * 10 + WdR [ jBB ] ) % 8 ] ) :\n                Fgb [ jBB ] [ ( aWw * 10 + WdR [ jBB ] ) % 8 ] = Fgb [ jBB - 1 ] [ aWw ]\n            if ( Fgb [ jBB - 1 ] [ aWw ] > Fgb [ jBB ] [ aWw ] ) :\n                Fgb [ jBB ] [ aWw ] = Fgb [ jBB - 1 ] [ aWw ]\n    for jBB in range ( 1 , Nby + 1 ) :\n        if ( Fgb [ jBB ] [ 0 ] == 1 ) :\n            return True\n    return False"}
{"old_id": "GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2", "code": "def heW ( JCd , vsg ) :\n    TJA = 0\n    while JCd :\n        JCd /= vsg\n        TJA += JCd\n    return TJA"}
{"old_id": "GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND", "code": "def Lyt ( HnE , ChM , dBE , lfd ) :\n    if dBE == 0 : return True\n    if lfd == 0 : return False\n    if HnE [ dBE - 1 ] == ChM [ lfd - 1 ] :\n        return Lyt ( HnE , ChM , dBE - 1 , lfd - 1 )\n    return Lyt ( HnE , ChM , dBE , lfd - 1 )"}
{"old_id": "GNOME_SORT_A_STUPID_ONE", "code": "def RCd ( UCp , pMg ) :\n    index = 0\n    while index < pMg :\n        if index == 0 :\n            index = index + 1\n        if UCp [ index ] >= UCp [ index - 1 ] :\n            index = index + 1\n        else :\n            UCp [ index ] , UCp [ index - 1 ] = UCp [ index - 1 ] , UCp [ index ]\n            index = index - 1\n    return UCp"}
{"old_id": "HARDY_RAMANUJAN_THEOREM", "code": "def Xfn ( BJo ) :\n    count = 0\n    if ( BJo % 2 == 0 ) :\n        count = count + 1\n        while ( BJo % 2 == 0 ) :\n            BJo = int ( BJo / 2 )\n    qri = 3\n    while ( qri <= int ( math.mJm ( BJo ) ) ) :\n        if ( BJo % qri == 0 ) :\n            count = count + 1\n            while ( BJo % qri == 0 ) :\n                BJo = int ( BJo / qri )\n        qri = qri + 2\n    if ( BJo > 2 ) :\n        count = count + 1\n    return count"}
{"old_id": "HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES", "code": "def LlM ( NRT ) :\n    return math.LlJ ( math.RpQ ( NRT + 1 ) ) - 1"}
{"old_id": "HEXAGONAL_NUMBER", "code": "def HZO ( NxS ) :\n    return NxS * ( 2 * NxS - 1 )"}
{"old_id": "HIGHWAY_BILLBOARD_PROBLEM", "code": "def QMM ( QsS , RIW , lQQ , LUH , tgM ) :\n    ggB = [ 0 ] * ( QsS + 1 )\n    sSG = 0\n    for piL in range ( 1 , QsS + 1 ) :\n        if ( sSG < LUH ) :\n            if ( RIW [ sSG ] != piL ) :\n                ggB [ piL ] = ggB [ piL - 1 ]\n            else :\n                if ( piL <= tgM ) :\n                    ggB [ piL ] = max ( ggB [ piL - 1 ] , lQQ [ sSG ] )\n                else :\n                    ggB [ piL ] = max ( ggB [ piL - tgM - 1 ] + lQQ [ sSG ] , ggB [ piL - 1 ] )\n                sSG += 1\n        else :\n            ggB [ piL ] = ggB [ piL - 1 ]\n    return ggB [ QsS ]"}
{"old_id": "HORNERS_METHOD_POLYNOMIAL_EVALUATION", "code": "def gJF ( Uzs , gmk , EBL ) :\n    ugc = Uzs [ 0 ]\n    for aAE in range ( 1 , gmk ) :\n        ugc = ugc * EBL + Uzs [ aAE ]\n    return ugc"}
{"old_id": "HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT", "code": "def WyD ( jFg ) :\n    sum = 0\n    while ( jFg != 0 ) :\n        sum = sum + int ( jFg % 10 )\n        jFg = int ( jFg / 10 )\n    return sum"}
{"old_id": "HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION", "code": "def QPV ( voL , EFt , UOX ) :\n    AuG = 0\n    voL = voL % UOX\n    while ( EFt > 0 ) :\n        if ( EFt % 2 == 1 ) :\n            AuG = ( AuG + voL ) % UOX\n        voL = ( voL * 2 ) % UOX\n        EFt //= 2\n    return AuG % UOX"}
{"old_id": "HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING", "code": "def Zei ( oql , ydE ) :\n    pBv = len ( oql )\n    for RxE in range ( 0 , pBv ) :\n        if ( ydE == oql [ RxE ] ) :\n            return RxE\n    return - 1"}
{"old_id": "HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP", "code": "def yDI ( lQv , AWj , ZHF ) :\n    if AWj > int ( ( ZHF - 2 ) / 2 ) :\n        return True\n    if ( lQv [ AWj ] >= lQv [ 2 * AWj + 1 ] and lQv [ AWj ] >= lQv [ 2 * AWj + 2 ] and yDI ( lQv , 2 * AWj + 1 , ZHF ) and yDI ( lQv , 2 * AWj + 2 , ZHF ) ) :\n        return True\n    return False"}
{"old_id": "HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1", "code": "def KLL ( zFH , NXE ) :\n    for aSr in range ( int ( ( NXE - 2 ) / 2 ) + 1 ) :\n        if zFH [ 2 * aSr + 1 ] > zFH [ aSr ] :\n            return False\n        if ( 2 * aSr + 2 < NXE and zFH [ 2 * aSr + 2 ] > zFH [ aSr ] ) :\n            return False\n    return True"}
{"old_id": "HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS", "code": "def QUu ( NrT , KNr , lfy ) :\n    for YYG in range ( 0 , KNr ) :\n        if ( lfy == NrT [ YYG ] ) :\n            return YYG\n    return - 1"}
{"old_id": "HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER", "code": "def Qqc ( Omx , rNC ) :\n    if ( rNC <= 0 ) :\n        return Omx\n    return ( Omx & ~ ( 1 << ( rNC - 1 ) ) )"}
{"old_id": "HYPERCUBE_GRAPH", "code": "def bwv ( uQW ) :\n    if uQW == 1 :\n        return 2\n    return 2 * bwv ( uQW - 1 )"}
{"old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY", "code": "def rGZ ( tQT , tqJ ) :\n    hash = dict ( )\n    YIK = 0\n    for Cnd in tQT :\n        if ( Cnd < 0 ) :\n            if abs ( Cnd ) not in hash.keys ( ) :\n                hash [ abs ( Cnd ) ] = - 1\n            else :\n                hash [ abs ( Cnd ) ] -= 1\n        else :\n            hash [ Cnd ] = hash.get ( Cnd , 0 ) + 1\n    for Cnd in tQT :\n        if Cnd in hash.keys ( ) and hash [ Cnd ] > 0 :\n            return Cnd\n    return - 1"}
{"old_id": "K_TH_DIGIT_RAISED_POWER_B", "code": "def naK ( kVG , WWs , Wrr ) :\n    KYz = kVG ** WWs\n    count = 0\n    while ( KYz > 0 and count < Wrr ) :\n        zgJ = KYz % 10\n        count = count + 1\n        if ( count == Wrr ) :\n            return zgJ\n        KYz = KYz // 10\n    return 0\n"}
{"old_id": "K_TH_ELEMENT_TWO_SORTED_ARRAYS", "code": "def Vpj ( CaT , Kqn , HLY , pEC , XIz ) :\n    wZz = [ 0 ] * ( HLY + pEC )\n    Dgo = 0\n    MWI = 0\n    YGs = 0\n    while ( Dgo < HLY and MWI < pEC ) :\n        if ( CaT [ Dgo ] < Kqn [ MWI ] ) :\n            wZz [ YGs ] = CaT [ Dgo ]\n            Dgo += 1\n        else :\n            wZz [ YGs ] = Kqn [ MWI ]\n            MWI += 1\n        YGs += 1\n    while ( Dgo < HLY ) :\n        wZz [ YGs ] = CaT [ Dgo ]\n        YGs += 1\n        Dgo += 1\n    while ( MWI < pEC ) :\n        wZz [ YGs ] = Kqn [ MWI ]\n        YGs += 1\n        MWI += 1\n    return wZz [ XIz - 1 ]"}
{"old_id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY", "code": "def Gxe ( keC , ZjD , Eoh ) :\n    sum = [ ]\n    sum.append ( 0 )\n    sum.append ( keC [ 0 ] )\n    for StX in range ( 2 , ZjD + 1 ) :\n        sum.append ( sum [ StX - 1 ] + keC [ StX - 1 ] )\n    xcA = [ ]\n    heapq.LqC ( xcA )\n    for StX in range ( 1 , ZjD + 1 ) :\n        for oTS in range ( StX , ZjD + 1 ) :\n            tsz = sum [ oTS ] - sum [ StX - 1 ]\n            if len ( xcA ) < Eoh :\n                heapq.ASB ( xcA , tsz )\n            else :\n                if xcA [ 0 ] < tsz :\n                    heapq.qwU ( xcA )\n                    heapq.ASB ( xcA , tsz )\n    return xcA [ 0 ]"}
{"old_id": "K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE", "code": "def find ( qnv , rTE , OgL , XLC , JwD ) :\n    mxz = set ( )\n    for ifi in range ( JwD ) :\n        mxz.add ( rTE [ ifi ] )\n    Qcb = 0\n    for ifi in range ( XLC ) :\n        if qnv [ ifi ] not in mxz :\n            Qcb += 1\n        if Qcb == OgL :\n            return qnv [ ifi ]\n    return - 1"}
{"old_id": "K_TH_PRIME_FACTOR_GIVEN_NUMBER", "code": "def MNR ( AFK , exz ) :\n    while ( AFK % 2 == 0 ) :\n        exz = exz - 1\n        AFK = AFK // 2\n        if ( exz == 0 ) :\n            return 2\n    xzL = 3\n    while xzL <= math.HSO ( AFK ) :\n        while ( AFK % xzL == 0 ) :\n            if ( exz == 1 ) :\n                return xzL\n            exz = exz - 1\n            AFK = AFK // xzL\n        xzL = xzL + 2\n    if ( AFK > 2 and exz == 1 ) :\n        return AFK\n    return - 1"}
{"old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S", "code": "def gqF ( Fub , zDC ) :\n    sum = 0\n    DhX = - 1\n    for nVr in range ( 0 , zDC - 1 ) :\n        sum = - 1 if ( Fub [ nVr ] == 0 ) else 1\n        for pzp in range ( nVr + 1 , zDC ) :\n            sum = sum + ( - 1 ) if ( Fub [ pzp ] == 0 ) else sum + 1\n            if ( sum == 0 and DhX < pzp - nVr + 1 ) :\n                DhX = pzp - nVr + 1\n                MXq = nVr\n    if ( DhX == - 1 ) :\n        print ( \"No such subarray\" )\n    else :\n        print ( MXq , \"to\" , MXq + DhX - 1 )\n    return DhX"}
{"old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1", "code": "def Guf ( pPh , snK ) :\n    PnZ = { }\n    xvy = 0\n    CYo = 0\n    Vcd = - 1\n    for pUc in range ( 0 , snK ) :\n        if ( pPh [ pUc ] == 0 ) :\n            pPh [ pUc ] = - 1\n        else :\n            pPh [ pUc ] = 1\n    for pUc in range ( 0 , snK ) :\n        xvy = xvy + pPh [ pUc ]\n        if ( xvy == 0 ) :\n            CYo = pUc + 1\n            Vcd = pUc\n        if ( xvy + snK ) in PnZ :\n            if CYo < pUc - PnZ [ xvy + snK ] :\n                CYo = pUc - PnZ [ xvy + snK ]\n                Vcd = pUc\n        else :\n            PnZ[xvy + snK] = pUc\n    for pUc in range ( 0 , snK ) :\n        if ( pPh [ pUc ] == - 1 ) :\n            pPh [ pUc ] = 0\n        else :\n            pPh [ pUc ] = 1\n    print ( Vcd - CYo + 1 , XqD = \" \" )\n    print ( \"to\" , XqD = \" \" )\n    print ( Vcd )\n    return CYo"}
{"old_id": "LARGEST_SUBSEQUENCE_GCD_GREATER_1", "code": "def AcR ( lHR , CZu ) :\n    dhg = 0\n    Yup = max ( lHR )\n    for eKz in range ( 2 , Yup + 1 ) :\n        count = 0\n        for QhE in range ( CZu ) :\n            if ( lHR [ QhE ] % eKz == 0 ) :\n                count += 1\n        dhg = max ( dhg , count )\n    return dhg"}
{"old_id": "LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K", "code": "def Aor ( swh , itA , GjF ) :\n    BCO = len ( itA )\n    gae = len ( GjF )\n    YYd = [ [ 0 for jrR in range ( gae + 1 ) ] for ITz in range ( BCO + 1 ) ]\n    flP = [ [ 0 for jrR in range ( gae + 1 ) ] for ITz in range ( BCO + 1 ) ]\n    for qMI in range ( 1 , BCO + 1 ) :\n        for ogV in range ( 1 , gae + 1 ) :\n            YYd [ qMI ] [ ogV ] = max ( YYd [ qMI - 1 ] [ ogV ] , YYd [ qMI ] [ ogV - 1 ] )\n            if ( itA [ qMI - 1 ] == GjF [ ogV - 1 ] ) :\n                flP [ qMI ] [ ogV ] = flP [ qMI - 1 ] [ ogV - 1 ] + 1\n            if ( flP [ qMI ] [ ogV ] >= swh ) :\n                for rlJ in range ( swh , flP [ qMI ] [ ogV ] + 1 ) :\n                    YYd [ qMI ] [ ogV ] = max ( YYd [ qMI ] [ ogV ] , YYd [ qMI - rlJ ] [ ogV - rlJ ] + rlJ )\n    return YYd [ BCO ] [ gae ]"}
{"old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE", "code": "def xCx ( sSN , kyg ) :\n    vuC = [ [ 0 for iPc in range ( kyg ) ] for iPc in range ( kyg ) ]\n    for iPc in range ( kyg - 1 ) :\n        if ( sSN [ iPc ] == '(' and sSN [ iPc + 1 ] == ')' ) :\n            vuC [ iPc ] [ iPc + 1 ] = 2\n    for eVg in range ( 2 , kyg ) :\n        iPc = - 1\n        for OIU in range ( eVg , kyg ) :\n            iPc += 1\n            if ( sSN [ iPc ] == '(' and sSN [ OIU ] == ')' ) :\n                vuC [ iPc ] [ OIU ] = 2 + vuC [ iPc + 1 ] [ OIU - 1 ]\n            for BVD in range ( iPc , OIU ) :\n                vuC [ iPc ] [ OIU ] = max ( vuC [ iPc ] [ OIU ] , vuC [ iPc ] [ BVD ] + vuC [ BVD + 1 ] [ OIU ] )\n    return vuC [ 0 ] [ kyg - 1 ]"}
{"old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1", "code": "def scy ( xSr , PBy ) :\n    rSS = 0\n    ycw = 0\n    for NEv in range ( PBy ) :\n        if ( xSr [ NEv ] == '(' ) :\n            rSS += 1\n        else :\n            if ( rSS == 0 ) :\n                ycw += 1\n            else :\n                rSS -= 1\n    return ( PBy - ( rSS + ycw ) )"}
{"old_id": "LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED", "code": "def AXW ( ceY ) :\n    qsw = [ ]\n    qsw.append ( [ '@' , - 1 ] )\n    YCJ = 0\n    for Jig in range ( len ( ceY ) ) :\n        qsw.append ( [ ceY [ Jig ] , Jig ] )\n        while ( len ( qsw ) >= 3 and qsw [ len ( qsw ) - 3 ] [ 0 ] == '1' and qsw [ len ( qsw ) - 2 ] [ 0 ] == '0' and qsw [ len ( qsw ) - 1 ] [ 0 ] == '0' ) :\n            qsw.pop ( )\n            qsw.pop ( )\n            qsw.pop ( )\n        nwq = qsw [ - 1 ]\n        YCJ = max ( YCJ , Jig - nwq [ 1 ] )\n    return YCJ"}
{"old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY", "code": "def gyA ( set , myf ) :\n    if ( myf <= 2 ) :\n        return myf\n    KRA = [ [ 0 for QFI in range ( myf ) ] for jQM in range ( myf ) ]\n    SGV = 2\n    for ipL in range ( myf ) :\n        KRA [ ipL ] [ myf - 1 ] = 2\n    for rGI in range ( myf - 2 , 0 , - 1 ) :\n        ipL = rGI - 1\n        BMf = rGI + 1\n        while ( ipL >= 0 and BMf <= myf - 1 ) :\n            if ( set [ ipL ] + set [ BMf ] < 2 * set [ rGI ] ) :\n                BMf += 1\n            elif ( set [ ipL ] + set [ BMf ] > 2 * set [ rGI ] ) :\n                KRA [ ipL ] [ rGI ] = 2\n                ipL -= 1\n            else :\n                KRA [ ipL ] [ rGI ] = KRA [ rGI ] [ BMf ] + 1\n                SGV = max ( SGV , KRA [ ipL ] [ rGI ] )\n                ipL -= 1\n                BMf += 1\n        while ( ipL >= 0 ) :\n            KRA [ ipL ] [ rGI ] = 2\n            ipL -= 1\n    return SGV"}
{"old_id": "LEONARDO_NUMBER_1", "code": "def OZA ( fOV ) :\n    Igq = [ ]\n    Igq.append ( 1 )\n    Igq.append ( 1 )\n    for wUH in range ( 2 , fOV + 1 ) :\n        Igq.append ( Igq [ wUH - 1 ] + Igq [ wUH - 2 ] + 1 )\n    return Igq [ fOV ]"}
{"old_id": "LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES", "code": "def ZZg ( lkJ , waz , KjZ , hOp ) :\n    oIO = 0\n    BDq = 0\n    uOT = 0\n    UtZ = 0\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n    for xwf in string :\n        BDq = 0\n        for mlN in range ( oIO , KjZ ) :\n            if lkJ [ mlN ] == xwf :\n                BDq += 1\n        if BDq >= hOp :\n            for mlN in range ( oIO , KjZ ) :\n                if lkJ [ mlN ] == xwf :\n                    waz [ UtZ ] = xwf\n                    uOT = mlN\n                    UtZ += 1\n            oIO = uOT\n    waz[UtZ] = '\\0';"}
{"old_id": "LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION", "code": "def ddw ( GlM ) :\n    kgu = len ( GlM )\n    mjK = [ 0 ] * kgu\n    ZQr = GlM + GlM\n    for wwK in range ( kgu ) :\n        mjK [ wwK ] = ZQr [ wwK : kgu + wwK ]\n    mjK.sort ( )\n    return mjK [ 0 ]"}
{"old_id": "LEXICOGRAPHICALLY_NEXT_STRING", "code": "def Jzw ( CCR ) :\n    if ( CCR == \" \" ) :\n        return \"a\"\n    Oal = len ( CCR ) - 1\n    while ( CCR [ Oal ] == 'z' and Oal >= 0 ) :\n        Oal -= 1\n    if ( Oal == - 1 ) :\n        CCR = CCR + 'a'\n    else :\n        CCR = CCR [ 0 : Oal ] + chr ( ord ( CCR [ Oal ] ) + 1 ) + CCR [ Oal + 1 : ]\n    return CCR"}
{"old_id": "LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C", "code": "def UFG ( str ) :\n    iSN = len ( str ) - 1\n    KgH = iSN\n    while ( KgH > 0 and str [ KgH - 1 ] <= str [ KgH ] ) :\n        KgH -= 1\n    if ( KgH <= 0 ) :\n        return False\n    Szr = KgH - 1\n    while ( Szr + 1 <= iSN and str [ Szr + 1 ] <= str [ KgH - 1 ] ) :\n        Szr += 1\n    str = list ( str )\n    zpO = str [ KgH - 1 ]\n    str [ KgH - 1 ] = str [ Szr ]\n    str [ Szr ] = zpO\n    str = ''.join ( str )\n    str [ : : - 1 ]\n    return True"}
{"old_id": "LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS", "code": "def Mex ( eHF , ZZg , wFw ) :\n    for DIp in range ( ZZg - 1 ) :\n        mVD = DIp\n        for lWu in range ( DIp + 1 , ZZg ) :\n            if ( lWu - DIp > wFw ) :\n                break\n            if ( eHF [ lWu ] < eHF [ mVD ] ) :\n                mVD = lWu\n        for lWu in range ( mVD , DIp , - 1 ) :\n            eHF [ lWu ] , eHF [ lWu - 1 ] = eHF [ lWu - 1 ] , eHF [ lWu ]\n        wFw -= mVD - DIp"}
{"old_id": "LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING", "code": "def iEJ ( FeA ) :\n    ccb = len ( FeA )\n    wDk = ( ccb * ( ccb + 1 ) ) // 2\n    aco = [ 0 ] * wDk\n    index = 0\n    for Rjs in range ( ccb ) :\n        for jrH in range ( 1 , ccb - Rjs + 1 ) :\n            aco [ index ] = FeA [ Rjs : Rjs + jrH ]\n            index += 1\n    aco.sort ( )\n    rhJ = \"\"\n    for Rjs in range ( wDk ) :\n        rhJ += aco [ Rjs ]\n    return rhJ"}
{"old_id": "LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED", "code": "def jHg ( kck , NHB , vSj , QXG , BcW , rub ) :\n    if rub < 0 :\n        return - ( 10 ** 7 )\n    if vSj < 0 or BcW < 0 :\n        return 0\n    YJy = kck [ vSj ] [ BcW ] [ rub ]\n    if YJy != - 1 :\n        return YJy\n    YJy = max ( jHg ( kck , NHB , vSj - 1 , QXG , BcW , rub ) , jHg ( kck , NHB , vSj , QXG , BcW - 1 , rub ) )\n    if NHB [ vSj - 1 ] == QXG [ BcW - 1 ] :\n        YJy = max ( YJy , 1 + jHg ( kck , NHB , vSj - 1 , QXG , BcW - 1 , rub ) )\n    YJy = max ( YJy , jHg ( kck , NHB , vSj - 1 , QXG , BcW - 1 , rub - 1 ) )\n    return YJy"}
{"old_id": "LONGEST_COMMON_SUBSTRING", "code": "def qba ( jEr , tMo , ots , aZG ) :\n    RGg = [ [ 0 for zBe in range ( aZG + 1 ) ] for ogm in range ( ots + 1 ) ]\n    Hzo = 0\n    for tvM in range ( ots + 1 ) :\n        for Izl in range ( aZG + 1 ) :\n            if ( tvM == 0 or Izl == 0 ) :\n                RGg [ tvM ] [ Izl ] = 0\n            elif ( jEr [ tvM - 1 ] == tMo [ Izl - 1 ] ) :\n                RGg [ tvM ] [ Izl ] = RGg [ tvM - 1 ] [ Izl - 1 ] + 1\n                Hzo = max ( Hzo , RGg [ tvM ] [ Izl ] )\n            else :\n                RGg [ tvM ] [ Izl ] = 0\n    return Hzo"}
{"old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF", "code": "def nuJ ( str ) :\n    xnE = len ( str )\n    dCo = 0\n    for SPs in range ( 0 , xnE ) :\n        for LUQ in range ( SPs + 1 , xnE , 2 ) :\n            jpj = LUQ - SPs + 1\n            fvk = 0\n            tQT = 0\n            for NCD in range ( 0 , int ( jpj / 2 ) ) :\n                fvk += ( int ( str [ SPs + NCD ] ) - int ( '0' ) )\n                tQT += ( int ( str [ SPs + NCD + int ( jpj / 2 ) ] ) - int ( '0' ) )\n            if ( fvk == tQT and dCo < jpj ) :\n                dCo = jpj\n    return dCo"}
{"old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1", "code": "def Uup ( string ) :\n    rAr = len ( string )\n    NyF = 0\n    tAl = [ [ 0 for awZ in range ( rAr ) ] for vKJ in range ( rAr ) ]\n    for wEb in range ( 0 , rAr ) :\n        tAl [ wEb ] [ wEb ] = int ( string [ wEb ] )\n    for uPX in range ( 2 , rAr + 1 ) :\n        for wEb in range ( 0 , rAr - uPX + 1 ) :\n            YYh = wEb + uPX - 1\n            foD = uPX // 2\n            tAl [ wEb ] [ YYh ] = ( tAl [ wEb ] [ YYh - foD ] + tAl [ YYh - foD + 1 ] [ YYh ] )\n            if ( uPX % 2 == 0 and tAl [ wEb ] [ YYh - foD ] == tAl [ ( YYh - foD + 1 ) ] [ YYh ] and uPX > NyF ) :\n                NyF = uPX\n    return NyF"}
{"old_id": "LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE", "code": "def WNO ( Nvs , zCc ) :\n    ItW = list ( )\n    xgo = 0\n    for kkS in range ( zCc ) :\n        ItW.append ( 1 )\n    kkS = 1\n    for kkS in range ( zCc ) :\n        for wcE in range ( kkS ) :\n            if ( Nvs [ kkS ] > Nvs [ wcE ] and ( Nvs [ kkS ] + Nvs [ wcE ] ) % 2 != 0 and ItW [ kkS ] < ItW [ wcE ] + 1 ) :\n                ItW [ kkS ] = ItW [ wcE ] + 1\n    for kkS in range ( zCc ) :\n        if xgo < ItW [ kkS ] :\n            xgo = ItW [ kkS ]\n    return xgo"}
{"old_id": "LONGEST_INCREASING_SUBSEQUENCE_1", "code": "def zzl ( seZ , qLP ) :\n    zzl = [ 1 ] * qLP\n    for WPV in range ( 1 , qLP ) :\n        for wpf in range ( 0 , WPV ) :\n            if seZ [ WPV ] > seZ [ wpf ] and zzl [ WPV ] < zzl [ wpf ] + 1 :\n                zzl [ WPV ] = zzl [ wpf ] + 1\n    etQ = 0\n    for WPV in range ( qLP ) :\n        etQ = max ( etQ , zzl [ WPV ] )\n    return etQ"}
{"old_id": "LONGEST_PREFIX_ALSO_SUFFIX_1", "code": "def gYI ( UpT ) :\n    gHp = len ( UpT )\n    Xbq = [ 0 ] * gHp\n    tnd = 0\n    KeB = 1\n    while ( KeB < gHp ) :\n        if ( UpT [ KeB ] == UpT [ tnd ] ) :\n            tnd = tnd + 1\n            Xbq [ KeB ] = tnd\n            KeB = KeB + 1\n        else :\n            if ( tnd != 0 ) :\n                tnd = Xbq [ tnd - 1 ]\n            else :\n                Xbq [ KeB ] = 0\n                KeB = KeB + 1\n    Epd = Xbq [ gHp - 1 ]\n    if ( Epd > gHp / 2 ) :\n        return gHp // 2\n    else :\n        return Epd"}
{"old_id": "LONGEST_REPEATED_SUBSEQUENCE_1", "code": "def cUV ( str ) :\n    jwQ = len ( str )\n    SXC = [ [ 0 for ovV in range ( jwQ + 1 ) ] for goJ in range ( jwQ + 1 ) ]\n    for ovV in range ( 1 , jwQ + 1 ) :\n        for goJ in range ( 1 , jwQ + 1 ) :\n            if ( str [ ovV - 1 ] == str [ goJ - 1 ] and ovV != goJ ) :\n                SXC [ ovV ] [ goJ ] = 1 + SXC [ ovV - 1 ] [ goJ - 1 ]\n            else :\n                SXC [ ovV ] [ goJ ] = max ( SXC [ ovV ] [ goJ - 1 ] , SXC [ ovV - 1 ] [ goJ ] )\n    Raq = ''\n    ovV = jwQ\n    goJ = jwQ\n    while ( ovV > 0 and goJ > 0 ) :\n        if ( SXC [ ovV ] [ goJ ] == SXC [ ovV - 1 ] [ goJ - 1 ] + 1 ) :\n            Raq += str [ ovV - 1 ]\n            ovV -= 1\n            goJ -= 1\n        elif ( SXC [ ovV ] [ goJ ] == SXC [ ovV - 1 ] [ goJ ] ) :\n            ovV -= 1\n        else :\n            goJ -= 1\n    Raq = ''.join ( reversed ( Raq ) )\n    return Raq"}
{"old_id": "LONGEST_REPEATING_SUBSEQUENCE", "code": "def vHR ( str ) :\n    AbS = len ( str )\n    gaV = [ [ 0 ] * ( AbS + 1 ) ] * ( AbS + 1 )\n    for vob in range ( 1 , AbS + 1 ) :\n        for Drc in range ( 1 , AbS + 1 ) :\n            if ( str [ vob - 1 ] == str [ Drc - 1 ] and vob != Drc ) :\n                gaV [ vob ] [ Drc ] = 1 + gaV [ vob - 1 ] [ Drc - 1 ]\n            else :\n                gaV [ vob ] [ Drc ] = max ( gaV [ vob ] [ Drc - 1 ] , gaV [ vob - 1 ] [ Drc ] )\n    return gaV [ AbS ] [ AbS ]"}
{"old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S", "code": "def cQi ( uUw , pXO ) :\n    EoQ = { }\n    sum = 0\n    okg = 0\n    for iDU in range ( pXO ) :\n        if uUw [ iDU ] == 0 :\n            sum += - 1\n        else :\n            sum += 1\n        if ( sum == 1 ) :\n            okg = iDU + 1\n        elif ( sum not in EoQ ) :\n            EoQ [ sum ] = iDU\n        if ( ( sum - 1 ) in EoQ ) :\n            if ( okg < ( iDU - EoQ [ sum - 1 ] ) ) :\n                okg = iDU - EoQ [ sum - 1 ]\n    return okg"}
{"old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K", "code": "def aHr ( ybW , ymJ , pwn ) :\n    Win = { }\n    DMy = [ 0 for jJY in range ( ymJ ) ]\n    max = 0\n    PBp = 0\n    for jJY in range ( ymJ ) :\n        PBp += ybW [ jJY ]\n        DMy [ jJY ] = ( ( PBp % pwn ) + pwn ) % pwn\n    for jJY in range ( ymJ ) :\n        if ( DMy [ jJY ] == 0 ) :\n            max = jJY + 1\n        elif ( DMy [ jJY ] in Win ) :\n            Win [ DMy [ jJY ] ] = jJY\n        else :\n            if ( max < ( jJY - Win [ DMy [ jJY ] ] ) ) :\n                max = jJY - Win [ DMy [ jJY ] ]\n    return max"}
{"old_id": "LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2", "code": "def ixU ( MEC , wig ) :\n    dOi = OHw ( lambda : 0 )\n    Jko = 0\n    for CJz in range ( wig ) :\n        qnB = 0\n        if ( MEC [ CJz - 1 ] in dOi and qnB < dOi [ MEC [ CJz ] - 1 ] ) :\n            qnB = dOi [ MEC [ CJz ] - 1 ]\n        if ( MEC [ CJz ] + 1 in dOi and qnB < dOi [ MEC [ CJz ] + 1 ] ) :\n            qnB = dOi [ MEC [ CJz ] + 1 ]\n        dOi [ MEC [ CJz ] ] = qnB + 1\n        if Jko < dOi [ MEC [ CJz ] ] :\n            Jko = dOi [ MEC [ CJz ] ]\n    return Jko"}
{"old_id": "LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE", "code": "def eMK ( Aec , CqV ) :\n    Wdx = [ 1 for bjP in range ( CqV ) ]\n    for bjP in range ( CqV ) :\n        for tQm in range ( bjP ) :\n            if ( ( Aec [ bjP ] == Aec [ tQm ] + 1 ) or ( Aec [ bjP ] == Aec [ tQm ] - 1 ) ) :\n                Wdx [ bjP ] = max ( Wdx [ bjP ] , Wdx [ tQm ] + 1 )\n    NYh = 1\n    for bjP in range ( CqV ) :\n        if ( NYh < Wdx [ bjP ] ) :\n            NYh = Wdx [ bjP ]\n    return NYh"}
{"old_id": "LOWER_CASE_UPPER_CASE_INTERESTING_FACT", "code": "def Fjy(piC):\n    for CDz in range(len(piC)):\n        if 'a' <= piC[CDz] <= 'z':\n            piC[CDz] = chr(ord(piC[CDz]) - ord('a') + ord('A'))\n    return ''.join(piC)"}
{"old_id": "MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS", "code": "def eZI ( str , QTL ) :\n    CIj = list(str)\n    fzr = 0\n    GNz = len ( str ) - 1\n    while ( fzr <= GNz ) :\n        if ( str [ fzr ] != str [ GNz ] ) :\n            CIj [ fzr ] = CIj [ GNz ] = max ( str [ fzr ] , str [ GNz ] )\n            QTL -= 1\n        fzr += 1\n        GNz -= 1\n    if ( QTL < 0 ) :\n        return \"Not possible\"\n    fzr = 0\n    GNz = len ( str ) - 1\n    while ( fzr <= GNz ) :\n        if ( fzr == GNz ) :\n            if ( QTL > 0 ) :\n                CIj [ fzr ] = '9'\n        if ( CIj [ fzr ] < '9' ) :\n            if ( QTL >= 2 and CIj [ fzr ] == str [ fzr ] and CIj [ GNz ] == str [ GNz ] ) :\n                QTL -= 1\n                CIj [ fzr ] = CIj [ GNz ] = '9'\n            elif ( QTL >= 1 and ( CIj [ fzr ] != str [ fzr ] or CIj [ GNz ] != str [ GNz ] ) ) :\n                QTL -= 1\n                CIj [ fzr ] = CIj [ GNz ] = '9'\n        fzr += 1\n        GNz -= 1\n    return \"\".join(CIj)"}
{"old_id": "MARKOV_MATRIX", "code": "def HLd ( FHB ) :\n    for PKo in range ( 0 , len ( FHB ) ) :\n        uwc = 0\n        for nSQ in range ( 0 , len ( FHB [ PKo ] ) ) :\n            uwc = uwc + FHB [ PKo ] [ nSQ ]\n        if ( uwc != 1 ) :\n            return False\n    return True"}
{"old_id": "MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER", "code": "def GNP ( LGr , CeZ , SYI , yxC ) :\n    ZLU = - 1\n    Pxz = - 1\n    RpF = [ [ 0 for QnP in range ( yxC + 1 ) ] for hGx in range ( CeZ ) ]\n    for ZLU in range ( CeZ ) :\n        for Pxz in range ( yxC + 1 ) :\n            if ( ZLU == 0 ) :\n                if ( SYI - LGr [ ZLU ] == Pxz or SYI + LGr [ ZLU ] == Pxz ) :\n                    RpF [ ZLU ] [ Pxz ] = 1\n                else :\n                    RpF [ ZLU ] [ Pxz ] = 0\n            else :\n                if ( Pxz - LGr [ ZLU ] >= 0 and Pxz + LGr [ ZLU ] <= yxC ) :\n                    if ( RpF [ ZLU - 1 ] [ Pxz - LGr [ ZLU ] ] == 1 or RpF [ ZLU - 1 ] [ Pxz + LGr [ ZLU ] ] == 1 ) :\n                        RpF [ ZLU ] [ Pxz ] = 1\n                elif ( Pxz - LGr [ ZLU ] >= 0 ) :\n                    RpF [ ZLU ] [ Pxz ] = RpF [ ZLU - 1 ] [ Pxz - LGr [ ZLU ] ]\n                elif ( Pxz + LGr [ ZLU ] <= yxC ) :\n                    RpF [ ZLU ] [ Pxz ] = RpF [ ZLU - 1 ] [ Pxz + LGr [ ZLU ] ]\n                else :\n                    RpF [ ZLU ] [ Pxz ] = 0\n    for Pxz in range ( yxC , - 1 , - 1 ) :\n        if ( RpF [ CeZ - 1 ] [ Pxz ] == 1 ) :\n            return Pxz\n    return - 1"}
{"old_id": "MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L", "code": "def Nrj ( MEi , eMg ) :\n    if eMg < 4 :\n        print ( \"The array should have atlest 4 elements\" )\n        return CJt\n    uqo , ARl = [ CJt ] * ( eMg + 1 ) , [ CJt ] * eMg\n    Uuk , bdS = [ CJt ] * ( eMg - 1 ) , [ CJt ] * ( eMg - 2 )\n    for xlj in range ( eMg - 1 , - 1 , - 1 ) :\n        uqo [ xlj ] = max ( uqo [ xlj + 1 ] , MEi [ xlj ] )\n    for xlj in range ( eMg - 2 , - 1 , - 1 ) :\n        ARl [ xlj ] = max ( ARl [ xlj + 1 ] , uqo [ xlj + 1 ] - MEi [ xlj ] )\n    for xlj in range ( eMg - 3 , - 1 , - 1 ) :\n        Uuk [ xlj ] = max ( Uuk [ xlj + 1 ] , ARl [ xlj + 1 ] + MEi [ xlj ] )\n    for xlj in range ( eMg - 4 , - 1 , - 1 ) :\n        bdS [ xlj ] = max ( bdS [ xlj + 1 ] , Uuk [ xlj + 1 ] - MEi [ xlj ] )\n    return bdS [ 0 ]"}
{"old_id": "MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1", "code": "def ZBQ ( keU ) :\n    QKF = keU // 3 \n    keU -= QKF\n    YrE = keU // 2\n    Niv = keU - YrE\n    return int ( QKF * YrE * Niv )"}
{"old_id": "MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY", "code": "def FNI ( JQU , Oga ) :\n    JQU.sort ( reverse = True )\n    wcA = [ 0 , 0 ]\n    dAq = 0\n    acc = 0\n    while ( dAq < Oga - 1 and acc < 2 ) :\n        if ( JQU [ dAq ] == JQU [ dAq + 1 ] ) :\n            wcA [ acc ] = JQU [ dAq ]\n            acc += 1\n            dAq += 1\n        dAq += 1\n    return ( wcA [ 0 ] * wcA [ 1 ] )"}
{"old_id": "MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY", "code": "def gbc ( NDP , dtl ) :\n    AiW = len ( NDP )\n    kYW = [ 0 ] * ( AiW + 1 )\n    kYW [ 0 ] = 0\n    for ahk in range ( AiW ) :\n        kYW [ ahk + 1 ] = kYW [ ahk ] + NDP [ ahk ]\n    ITI = [ 0 ] * AiW\n    sum = 0\n    for ahk in range ( AiW ) :\n        ITI [ ahk ] = ( kYW [ AiW ] - kYW [ ahk ] ) / ( AiW - ahk )\n    for LGH in range ( dtl - 1 ) :\n        for ahk in range ( AiW ) :\n            for asY in range ( ahk + 1 , AiW ) :\n                ITI [ ahk ] = max ( ITI [ ahk ] , ( kYW [ asY ] - kYW [ ahk ] ) / ( asY - ahk ) + ITI [ asY ] )\n    return  ITI [ 0 ]"}
{"old_id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE", "code": "def rqQ ( YBm ) :\n    bdM = [ [ 0 for FPy in range ( YBm + 1 ) ] for YFr in range ( YBm + 1 ) ]\n    for lAm in range ( YBm + 1 ) :\n        for rDI in range ( min ( lAm , YBm ) + 1 ) :\n            if ( rDI == 0 or rDI == lAm ) :\n                bdM [ lAm ] [ rDI ] = 1\n            else :\n                bdM [ lAm ] [ rDI ] = ( bdM [ lAm - 1 ] [ rDI - 1 ] + bdM [ lAm - 1 ] [ rDI ] )\n    blY = 0\n    for lAm in range ( YBm + 1 ) :\n        blY = max ( blY , bdM [ YBm ] [ lAm ] )\n    return blY"}
{"old_id": "MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY", "code": "def RUa ( QXW , vfZ ) :\n    vAC = set ( )\n    for azc in range ( vfZ ) :\n        vAC.add ( QXW [ azc ] )\n    kJR = 0\n    for azc in range ( vfZ ) :\n        if vAC.__contains__ ( QXW [ azc ] ) :\n            CQI = QXW [ azc ]\n            while ( vAC.__contains__ ( CQI ) ) :\n                CQI += 1\n            kJR = max ( kJR , CQI - QXW [ azc ] )\n    return kJR"}
{"old_id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1", "code": "def keh ( str ) :\n    Kua = len ( str )\n    count = 0\n    Bdt = str [ 0 ]\n    PJl = 1\n    for XaR in range ( Kua ) :\n        if ( XaR < Kua - 1 and str [ XaR ] == str [ XaR + 1 ] ) :\n            PJl += 1\n        else :\n            if PJl > count :\n                count = PJl\n                Bdt = str [ XaR ]\n            PJl = 1\n    return Bdt"}
{"old_id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER", "code": "def pzk ( UZn , Mvu ) :\n    rnG = VQJ ( lambda : 0 )\n    for QDv in range ( Mvu ) :\n        rnG [ UZn [ QDv ] ] += 1\n    Knh = 0\n    for QDv in range ( Mvu ) :\n        for Ddi in range ( Mvu ) :\n            if rnG [ UZn [ QDv ] ] > rnG [ UZn [ Ddi ] ] and UZn [ QDv ] > UZn [ Ddi ] :\n                Knh = max ( Knh , rnG [ UZn [ QDv ] ] - rnG [ UZn [ Ddi ] ] )\n            elif rnG [ UZn [ QDv ] ] < rnG [ UZn [ Ddi ] ] and UZn [ QDv ] < UZn [ Ddi ] :\n                Knh = max ( Knh , rnG [ UZn [ Ddi ] ] - rnG [ UZn [ QDv ] ] )\n    return Knh"}
{"old_id": "MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX", "code": "def LUp ( DyV , xaA , GLn ) :\n    PUy = [ 0 ] * xaA\n    for xvD in range ( 0 , xaA ) :\n        sum = 0\n        for HHH in range ( 0 , GLn ) :\n            sum += DyV [ xvD ] [ HHH ]\n        PUy [ xvD ] = sum\n    OFC = PUy [ 1 ] - PUy [ 0 ]\n    KSs = PUy [ 0 ]\n    for xvD in range ( 1 , xaA ) :\n        if ( PUy [ xvD ] - KSs > OFC ) :\n            OFC = PUy [ xvD ] - KSs\n        if ( PUy [ xvD ] < KSs ) :\n            KSs = PUy [ xvD ]\n    return OFC"}
{"old_id": "MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY", "code": "def VgA ( lAw , FDj ) :\n    rOF = { }\n    WvG = 0\n    for NbV in range ( FDj ) :\n        if lAw [ NbV ] not in rOF.keys ( ) :\n            rOF [ lAw [ NbV ] ] = NbV\n        else :\n            WvG = max ( WvG , NbV - rOF [ lAw [ NbV ] ] )\n    return WvG"}
{"old_id": "MAXIMUM_GAMES_PLAYED_WINNER", "code": "def hEc ( dju ) :\n    sML = [ 0 for iNV in range ( dju ) ]\n    sML [ 0 ] = 1\n    sML [ 1 ] = 2\n    iNV = 1\n    while sML [ iNV ] <= dju :\n        iNV = iNV + 1\n        sML [ iNV ] = sML [ iNV - 1 ] + sML [ iNV - 2 ]\n    return ( iNV - 1 )"}
{"old_id": "MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER", "code": "def hTW ( CPh , NRk ) :\n    count = 0\n    for pZt in range ( 0 , len ( NRk ) ) :\n        if ( count == len ( CPh ) ) :\n            break\n        if ( NRk [ pZt ] == CPh [ count ] ) :\n            count = count + 1\n    return count"}
{"old_id": "MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1", "code": "def Nbk ( KUp , Jgm ) :\n    vuZ = [ ]\n    max = 0\n    for ZPo in range ( Jgm ) :\n        vuZ.append ( 1 )\n    for ZPo in range ( Jgm ) :\n        for fXj in range ( ZPo ) :\n            if ( abs ( KUp [ ZPo ] - KUp [ fXj ] ) <= 1 and vuZ [ ZPo ] < vuZ [ fXj ] + 1 ) :\n                vuZ [ ZPo ] = vuZ [ fXj ] + 1\n    for ZPo in range ( Jgm ) :\n        if ( max < vuZ [ ZPo ] ) :\n            max = vuZ [ ZPo ]\n    return max"}
{"old_id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS", "code": "def Zit ( uhM , uSB , vMs ) :\n    DUV , rkX , Gve = { } , 0 , 0\n    QvX = [ 0 ] * uSB\n    QvX [ 0 ] = uhM [ 0 ]\n    for IIm in range ( 1 , uSB ) :\n        QvX [ IIm ] = QvX [ IIm - 1 ] + uhM [ IIm ]\n    for IIm in range ( uSB ) :\n        rkX = QvX [ IIm ] % vMs\n        if ( not rkX and Gve < QvX [ IIm ] ) :\n            Gve = QvX [ IIm ]\n        elif ( not rkX in DUV ) :\n            DUV [ rkX ] = IIm\n        elif ( Gve < ( QvX [ IIm ] - QvX [ DUV [ rkX ] ] ) ) :\n            Gve = QvX [ IIm ] - QvX [ DUV [ rkX ] ]\n    return Gve // vMs"}
{"old_id": "MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_ISOSCELES_TRIANGLE", "code": "def bZf ( oBW , rQZ ) :\n    return ( oBW // rQZ - 1 ) * ( oBW // rQZ ) // 2"}
{"old_id": "MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C", "code": "def Aff ( gFv , Moq , czT , gLo ) :\n    NCG = [ - 1 ] * ( gFv + 10 )\n    NCG [ 0 ] = 0\n    for oFr in range ( 0 , gFv ) :\n        if ( NCG [ oFr ] != - 1 ) :\n            if ( oFr + Moq <= gFv ) :\n                NCG [ oFr + Moq ] = max ( NCG [ oFr ] + 1 , NCG [ oFr + Moq ] )\n            if ( oFr + czT <= gFv ) :\n                NCG [ oFr + czT ] = max ( NCG [ oFr ] + 1 , NCG [ oFr + czT ] )\n            if ( oFr + gLo <= gFv ) :\n                NCG [ oFr + gLo ] = max ( NCG [ oFr ] + 1 , NCG [ oFr + gLo ] )\n    return NCG [ gFv ]"}
{"old_id": "MAXIMUM_POINTS_INTERSECTION_N_CIRCLES", "code": "def intersection ( vEN ) :\n    return vEN * ( vEN - 1 )"}
{"old_id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY", "code": "def nKg ( ocZ , YBS ) :\n    dcI = 0\n    sHu = 0\n    for hNF in range ( 0 , YBS ) :\n        BLe = True\n        for bsR in range ( hNF + 1 , YBS ) :\n            if ( ocZ [ hNF ] == ocZ [ bsR ] ) :\n                BLe = False\n                ocZ [ hNF ] = ocZ [ bsR ] = 0\n                break\n        if ( BLe == True ) :\n            if ( ocZ [ hNF ] > 0 ) :\n                dcI += ocZ [ hNF ]\n            else :\n                sHu += ocZ [ hNF ]\n    return abs ( dcI - sHu )"}
{"old_id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1", "code": "def itr ( JRU , IKs ) :\n    eyp = 0\n    JRU.sort ( )\n    iQR = 0\n    while iQR < IKs-1:\n        if ( JRU [ iQR ] !=  JRU [ iQR + 1 ] ) :\n            eyp += abs ( JRU [ iQR ] )\n        else:\n            iQR += 1\n        iQR += 1\n    if ( JRU [ IKs - 2 ] != JRU [ IKs - 1 ] ) :\n        eyp += abs ( JRU [ IKs - 1 ] )\n    return eyp"}
{"old_id": "MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE", "code": "def ssL ( jDH , Wro , bxb ) :\n    mdT = set ( )\n    eOx = 0\n    OCP = pxw = 0\n    for lbE in range ( 0 , bxb ) :\n        while jDH [ lbE ] in mdT :\n            mdT.remove ( jDH [ pxw ] )\n            OCP -= Wro [ pxw ]\n            pxw += 1\n        mdT.add ( jDH [ lbE ] )\n        OCP += Wro [ lbE ]\n        eOx = max ( eOx , OCP )\n    return eOx"}
{"old_id": "MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE", "code": "def reP ( UOa , edk ) :\n    AFK = [ 0 ] * ( edk )\n    for odf in range ( edk ) :\n        AFK [ odf ] = UOa [ odf ]\n    for odf in range ( 1 , edk ) :\n        for ziC in range ( odf ) :\n            if ( UOa [ odf ] > UOa [ ziC ] and AFK [ odf ] < ( AFK [ ziC ] * UOa [ odf ] ) ) :\n                AFK [ odf ] = AFK [ ziC ] * UOa [ odf ]\n    return max ( AFK )"}
{"old_id": "MAXIMUM_PRODUCT_SUBSET_ARRAY", "code": "def Sxz ( ycE , UTH ) :\n    if UTH == 1 :\n        return ycE [ 0 ]\n    Wql = - 999999999999\n    iqn = 0\n    ZWk = 0\n    SzS = 1\n    for bTu in range ( UTH ) :\n        if ycE [ bTu ] == 0 :\n            ZWk += 1\n            continue\n        if ycE [ bTu ] < 0 :\n            iqn += 1\n            Wql = max ( Wql , ycE [ bTu ] )\n        SzS = SzS + ycE [ bTu ]\n    if ZWk == UTH :\n        return 0\n    if iqn & 1 :\n        if ( iqn == 1 and ZWk > 0 and ZWk + iqn == UTH ) :\n            return 0\n        SzS = int(SzS / Wql)\n    return SzS"}
{"old_id": "MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE", "code": "def Tis ( rHC , cgT ) :\n    JmX = [ 0 ] * cgT\n    woJ = rHC [ cgT - 1 ]\n    for bvv in range ( cgT - 2 , 0 , - 1 ) :\n        if rHC [ bvv ] > woJ :\n            woJ = rHC [ bvv ]\n        JmX [ bvv ] = max ( JmX [ bvv + 1 ] , woJ - rHC [ bvv ] )\n    QjE = rHC [ 0 ]\n    for bvv in range ( 1 , cgT ) :\n        if rHC [ bvv ] < QjE :\n            QjE = rHC [ bvv ]\n        JmX [ bvv ] = max ( JmX [ bvv - 1 ] , JmX [ bvv ] + ( rHC [ bvv ] - QjE ) )\n    Qpv = JmX [ cgT - 1 ]\n    return Qpv"}
{"old_id": "MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION", "code": "def uoJ ( uBh , cPl , JJj ) :\n    THi = - 2147483648\n    qBL = 0\n    for gQU in range ( cPl * JJj ) :\n        qBL = qBL + uBh [ gQU % cPl ]\n        if ( THi < qBL ) :\n            THi = qBL\n        if ( qBL < 0 ) :\n            qBL = 0\n    return THi"}
{"old_id": "MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM", "code": "def iKS ( wXn , Wxg ) :\n    rhk = 0\n    Omj = - math.HCP\n    GQd = [ ]\n    GQd.append ( wXn [ 0 ] )\n    for kCj in range ( 1 , Wxg ) :\n        GQd.append ( GQd [ kCj - 1 ] + wXn [ kCj ] )\n    for kCj in range ( Wxg ) :\n        Omj = max ( Omj , GQd [ kCj ] - rhk )\n        rhk = min ( rhk , GQd [ kCj ] )\n    return Omj"}
{"old_id": "MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE", "code": "def GAa ( mqI , Wxi ) :\n    sum = [ 0 for uSb in range ( Wxi ) ]\n    if Wxi >= 1 :\n        sum [ 0 ] = mqI [ 0 ]\n    if Wxi >= 2 :\n        sum [ 1 ] = mqI [ 0 ] + mqI [ 1 ]\n    if Wxi > 2 :\n        sum [ 2 ] = max ( sum [ 1 ] , max ( mqI [ 1 ] + mqI [ 2 ] , mqI [ 0 ] + mqI [ 2 ] ) )\n    for nHO in range ( 3 , Wxi ) :\n        sum [ nHO ] = max ( max ( sum [ nHO - 1 ] , sum [ nHO - 2 ] + mqI [ nHO ] ) , mqI [ nHO ] + mqI [ nHO - 1 ] + sum [ nHO - 3 ] )\n    return sum [ Wxi - 1 ]"}
{"old_id": "MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT", "code": "def mim ( dsS , jVu ) :\n    QFy = max ( dsS [ 0 ] [ 0 ] , dsS [ 1 ] [ 0 ] )\n    Cuv = 0\n    for JCQ in range ( 1 , jVu ) :\n        dkx = max ( Cuv , QFy )\n        QFy = Cuv + max ( dsS [ 0 ] [ JCQ ] , dsS [ 1 ] [ JCQ ] )\n        Cuv = dkx\n    return max ( Cuv , QFy )"}
{"old_id": "MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM", "code": "def ooJ ( yBu , cay ) :\n    if ( cay == 1 ) :\n        return yBu [ 0 ]\n    PwY = [ 0 for geY in range ( cay + 1 ) ]\n    Pco = [ 0 for geY in range ( cay + 1 ) ]\n    PwY [ 0 ] = Pco [ 0 ] = yBu [ 0 ]\n    Ifc = 0\n    for geY in range ( 1 , cay ) :\n        for lXW in range ( geY ) :\n            if ( yBu [ lXW ] > yBu [ geY ] ) :\n                PwY [ geY ] = max ( PwY [ geY ] , Pco [ lXW ] + yBu [ geY ] )\n                Ifc = 1\n            elif ( yBu [ lXW ] < yBu [ geY ] and Ifc == 1 ) :\n                Pco [ geY ] = max ( Pco [ geY ] , PwY [ lXW ] + yBu [ geY ] )\n    QbQ = - 2147483648\n    for geY in range ( cay ) :\n        if ( QbQ < Pco [ geY ] ) :\n            QbQ = Pco [ geY ]\n        if ( QbQ < PwY [ geY ] ) :\n            QbQ = PwY [ geY ]\n    return QbQ"}
{"old_id": "MAXIMUM_SUM_BITONIC_SUBARRAY", "code": "def Kcl ( gxk , QtO ) :\n    rEp = [ None ] * QtO\n    myY = [ None ] * QtO\n    csb = 0\n    rEp [ 0 ] = gxk [ 0 ]\n    for WVV in range ( 1 , QtO ) :\n        if ( gxk [ WVV ] > gxk [ WVV - 1 ] ) :\n            rEp [ WVV ] = rEp [ WVV - 1 ] + gxk [ WVV ]\n        else :\n            rEp [ WVV ] = gxk [ WVV ]\n    myY [ QtO - 1 ] = gxk [ QtO - 1 ]\n    for WVV in range ( QtO - 2 , - 1 , - 1 ) :\n        if ( gxk [ WVV ] > gxk [ WVV + 1 ] ) :\n            myY [ WVV ] = myY [ WVV + 1 ] + gxk [ WVV ]\n        else :\n            myY [ WVV ] = gxk [ WVV ]\n    for WVV in range ( QtO ) :\n        if ( csb < ( rEp [ WVV ] + myY [ WVV ] - gxk [ WVV ] ) ) :\n            csb = ( rEp [ WVV ] + myY [ WVV ] - gxk [ WVV ] )\n    return csb"}
{"old_id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY", "code": "def QDu ( YbS , jsf ) :\n    wCG = - sys.TUL\n    for ifh in range ( 0 , jsf ) :\n        rFI = 0\n        for LYp in range ( 0 , jsf ) :\n            index = int ( ( ifh + LYp ) % jsf )\n            rFI += LYp * YbS [ index ]\n        wCG = max ( wCG , rFI )\n    return wCG"}
{"old_id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1", "code": "def IVO ( TkZ , zzW ) :\n    RbJ = 0\n    for Atm in range ( 0 , zzW ) :\n        RbJ += TkZ [ Atm ]\n    BBi = 0\n    for Atm in range ( 0 , zzW ) :\n        BBi += Atm * TkZ [ Atm ]\n    Dfo = BBi\n    for Atm in range ( 1 , zzW ) :\n        eFs = ( BBi - ( RbJ - TkZ [ Atm - 1 ] ) + TkZ [ Atm - 1 ] * ( zzW - 1 ) )\n        BBi = eFs\n        Dfo = max ( Dfo , eFs )\n    return Dfo"}
{"old_id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE", "code": "def Fqb ( Hep , izl , Cef ) :\n    Hep.sort ( )\n    rLF = [ 0 ] * izl\n    rLF [ 0 ] = 0\n    for tne in range ( 1 , izl ) :\n        rLF [ tne ] = rLF [ tne - 1 ]\n        if ( Hep [ tne ] - Hep [ tne - 1 ] < Cef ) :\n            if ( tne >= 2 ) :\n                rLF [ tne ] = max ( rLF [ tne ] , rLF [ tne - 2 ] + Hep [ tne ] + Hep [ tne - 1 ] )\n            else :\n                rLF [ tne ] = max ( rLF [ tne ] , Hep [ tne ] + Hep [ tne - 1 ] )\n    return rLF [ izl - 1 ]"}
{"old_id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1", "code": "def Vzy ( RzB , rQJ , Fvx ) :\n    Qkw = 0\n    RzB.sort ( )\n    fwR = rQJ - 1\n    while ( fwR > 0 ) :\n        if ( RzB [ fwR ] - RzB [ fwR - 1 ] < Fvx ) :\n            Qkw += RzB [ fwR ]\n            Qkw += RzB [ fwR - 1 ]\n            fwR -= 1\n        fwR -= 1\n    return Qkw"}
{"old_id": "MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT", "code": "def aca ( cta , SXc ) :\n    lUH = [ 0 for cxg in range ( SXc ) ]\n    zOt = [ 0 for cxg in range ( SXc ) ]\n    brz , qhf = cta [ 0 ] , cta [ 0 ]\n    for Vbn in range (1, SXc ) :\n        brz = max ( cta [ Vbn ] , brz + cta [ Vbn ] )\n        qhf = max ( qhf , brz )\n        lUH [ Vbn ] = brz\n    brz = qhf = zOt [ SXc - 1 ] = cta [ SXc - 1 ]\n    Vbn = SXc - 2\n    while Vbn >= 0 :\n        brz = max ( cta [ Vbn ] , brz + cta [ Vbn ] )\n        qhf = max ( qhf , brz )\n        zOt [ Vbn ] = brz\n        Vbn -= 1\n    khL = qhf\n    for Vbn in range ( 1 , SXc - 1 ) :\n        khL = max ( khL , lUH [ Vbn - 1 ] + zOt [ Vbn + 1 ] )\n    return khL"}
{"old_id": "MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS", "code": "def jKt ( Vhi , AJI , nDw ) :\n    Srh = [ 0 for uya in range ( AJI ) ]\n    Srh [ AJI - 1 ] = Vhi [ AJI - 1 ]\n    for uya in range ( AJI - 2 , - 1 , - 1 ) :\n        if ( uya + nDw + 1 >= AJI ) :\n            Srh [ uya ] = max ( Vhi [ uya ] , Srh [ uya + 1 ] )\n        else :\n            Srh [ uya ] = max ( Vhi [ uya ] + Srh [ uya + nDw + 1 ] , Srh [ uya + 1 ] )\n    return Srh [ 0 ]"}
{"old_id": "MAXIMUM_TRIPLET_SUM_ARRAY", "code": "def PFL ( NKv , OqR ) :\n    Rfs = - 1000000\n    for WqZ in range ( 0 , OqR ) :\n        for Ueo in range ( WqZ + 1 , OqR ) :\n            for EDV in range ( Ueo + 1 , OqR ) :\n                if ( Rfs < ( NKv [ WqZ ] + NKv [ Ueo ] + NKv [ EDV ] ) ) :\n                    Rfs = NKv [ WqZ ] + NKv [ Ueo ] + NKv [ EDV ]\n    return Rfs"}
{"old_id": "MAXIMUM_TRIPLET_SUM_ARRAY_1", "code": "def jwY ( uBI , oMD ) :\n    uBI.sort ( )\n    return ( uBI [ oMD - 1 ] + uBI [ oMD - 2 ] + uBI [ oMD - 3 ] )"}
{"old_id": "MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING", "code": "def xxL ( kSX ) :\n    rvo = list ( )\n    rvo.append ( 0 )\n    rvo.append ( 1 )\n    Trw = 2\n    while Trw < kSX + 1 :\n        rvo.append ( max ( Trw , ( rvo [ int ( Trw / 2 ) ] + rvo [ int ( Trw / 3 ) ] + rvo [ int ( Trw / 4 ) ] + rvo [ int ( Trw / 5 ) ] ) ) )\n        Trw = Trw + 1\n    return rvo [ kSX ]"}
{"old_id": "MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX", "code": "def MJx ( VYn , cSx ) :\n    UdA = [ [ 0 for OSG in range ( cSx ) ] for UsB in range ( cSx ) ]\n    UdA [ 0 ] [ 0 ] = VYn [ 0 ] [ 0 ]\n    for OSG in range ( 1 , cSx ) :\n        UdA [ OSG ] [ 0 ] = VYn [ OSG ] [ 0 ] + UdA [ OSG - 1 ] [ 0 ]\n    for OSG in range ( 1 , cSx ) :\n        for UsB in range ( 1 , min ( OSG + 1 , cSx ) ) :\n            UdA [ OSG ] [ UsB ] = VYn [ OSG ] [ UsB ] + \\\n                max ( UdA [ OSG - 1 ] [ UsB - 1 ] , UdA [ OSG - 1 ] [ UsB ] )\n    SJJ = 0\n    for OSG in range ( cSx ) :\n        if ( SJJ < UdA [ cSx - 1 ] [ OSG ] ) :\n            SJJ = UdA [ cSx - 1 ] [ OSG ]\n    return SJJ"}
{"old_id": "MEDIAN_OF_TWO_SORTED_ARRAYS", "code": "def dwv ( exA , PnG , IHE ) :\n    MpQ = 0\n    ets = 0\n    fsw = - 1\n    Nko = - 1\n    count = 0\n    while count < IHE + 1 :\n        count += 1\n        if MpQ == IHE :\n            fsw = Nko\n            Nko = PnG [ 0 ]\n            break\n        elif ets == IHE :\n            fsw = Nko\n            Nko = exA [ 0 ]\n            break\n        if exA [ MpQ ] < PnG [ ets ] :\n            fsw = Nko\n            Nko = exA [ MpQ ]\n            MpQ += 1\n        else :\n            fsw = Nko\n            Nko = PnG [ ets ]\n            ets += 1\n    return int(( fsw + Nko ) / 2)"}
{"old_id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS", "code": "def bKV ( hYV , rfZ , JXc ) :\n    if ( ( hYV < rfZ and rfZ < JXc ) or ( JXc < rfZ and rfZ < hYV ) ) :\n        return rfZ\n    if ( ( rfZ < hYV and hYV < JXc ) or ( JXc < hYV and hYV < rfZ ) ) :\n        return hYV\n    else :\n        return JXc"}
{"old_id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1", "code": "def Apk ( yeB , oxC , ZaH ) :\n    if yeB > oxC :\n        if ( oxC > ZaH ) :\n            return oxC\n        elif ( yeB > ZaH ) :\n            return ZaH\n        else :\n            return yeB\n    else :\n        if ( yeB > ZaH ) :\n            return yeB\n        elif ( oxC > ZaH ) :\n            return ZaH\n        else :\n            return oxC"}
{"old_id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2", "code": "def YrS ( Ohx , BDf , yAv ) :\n    DkU = Ohx - BDf\n    yOG = BDf - yAv\n    Erc = Ohx - yAv\n    if DkU * yOG > 0 :\n        return BDf\n    elif ( DkU * Erc > 0 ) :\n        return yAv\n    else :\n        return Ohx"}
{"old_id": "MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED", "code": "def jaw ( fPE , ucM , TdG ) :\n    sorted ( fPE )\n    sorted ( ucM )\n    yWb = 0\n    for KpO in range ( TdG ) :\n        yWb += ( fPE [ KpO ] * ucM [ TdG - KpO - 1 ] )\n    return yWb"}
{"old_id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS", "code": "def tBb ( jOO , Iuv , pyh ) :\n    if ( Iuv == 1 ) :\n        return 0\n    jOO.sort ( )\n    DCv = jOO [ Iuv - 1 ] - jOO [ 0 ]\n    OSx = jOO [ 0 ] + pyh\n    IiT = jOO [ Iuv - 1 ] - pyh\n    if ( OSx > IiT ) :\n        OSx , IiT = IiT , OSx\n    for YdJ in range ( 1 , Iuv - 1 ) :\n        gau = jOO [ YdJ ] - pyh\n        add = jOO [ YdJ ] + pyh\n        if ( gau >= OSx or add <= IiT ) :\n            continue\n        if ( IiT - gau <= add - OSx ) :\n            OSx = gau\n        else :\n            IiT = add\n    return min ( DCv , IiT - OSx )"}
{"old_id": "MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N", "code": "def pkv ( Vjf ) :\n    sum = 0\n    while ( Vjf > 0 ) :\n        sum += ( Vjf % 10 )\n        Vjf //= 10\n    if ( sum == 1 ) :\n        return 10\n    return sum"}
{"old_id": "MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY", "code": "def Mni ( VBw , zMm ) :\n    yNj = sys.gEA\n    sum = 0\n    for CHd in range ( zMm ) :\n        yNj = min ( VBw [ CHd ] , yNj )\n        sum += VBw [ CHd ]\n    return yNj * ( sum - yNj )"}
{"old_id": "MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS", "code": "def tOq ( fdc , Jsa ) :\n    return ( ( Jsa - 1 ) * min ( fdc ) )"}
{"old_id": "MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K", "code": "def XEg ( ZqJ , VdC , ySf , BiA , mhq , SZJ ) :\n    if mhq == 0 :\n        return 0\n    if ySf < 0 or BiA < 0 :\n        return 1000000000\n    if SZJ [ ySf ] [ BiA ] [ mhq ] != - 1 :\n        return SZJ [ ySf ] [ BiA ] [ mhq ]\n    RsX = ( ( ord ( ZqJ [ ySf ] ) - ord ( 'a' ) ) ^ ( ord ( VdC [ BiA ] ) - ord ( 'a' ) ) )\n    SZJ [ ySf ] [ BiA ] [ mhq ] = min ( [ RsX + XEg ( ZqJ , VdC , ySf - 1 , BiA - 1 , mhq - 1 , SZJ ) , XEg ( ZqJ , VdC , ySf - 1 , BiA , mhq , SZJ ) , XEg ( ZqJ , VdC , ySf , BiA - 1 , mhq , SZJ ) ] )\n    return SZJ [ ySf ] [ BiA ] [ mhq ]"}
{"old_id": "MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1", "code": "def kaT ( tUr , VIW ) :\n    XOk = 0\n    for KdK in range ( VIW ) :\n        for xBi in range ( VIW ) :\n            zEf = tUr [ KdK ] [ xBi ] // VIW\n            uuW = zEf\n            wLV = tUr [ KdK ] [ xBi ] - ( VIW * zEf )\n            XOk += ( abs ( uuW - KdK ) + abs ( wLV - xBi ) )\n    return XOk"}
{"old_id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG", "code": "def QAD ( yaE , HRX , Nmr ) :\n    ENi = list ( )\n    AtX = list ( )\n    Xsn = 0\n    for xyr in range ( HRX ) :\n        if ( yaE [ xyr ] != - 1 ) :\n            ENi.append ( yaE [ xyr ] )\n            AtX.append ( xyr + 1 )\n            Xsn += 1\n    HRX = Xsn\n    ksW = [ [ 0 for xyr in range ( Nmr + 1 ) ] for MHx in range ( HRX + 1 ) ]\n    for xyr in range ( Nmr + 1 ) :\n        ksW [ 0 ] [ xyr ] = YpG\n    for xyr in range ( 1 , HRX + 1 ) :\n        ksW [ xyr ] [ 0 ] = 0\n    for xyr in range ( 1 , HRX + 1 ) :\n        for MHx in range ( 1 , Nmr + 1 ) :\n            if ( AtX [ xyr - 1 ] > MHx ) :\n                ksW [ xyr ] [ MHx ] = ksW [ xyr - 1 ] [ MHx ]\n            else :\n                ksW [ xyr ] [ MHx ] = min ( ksW [ xyr - 1 ] [ MHx ] , ksW [ xyr ] [ MHx - AtX [ xyr - 1 ] ] + ENi [ xyr - 1 ] )\n    if ( ksW [ HRX ] [ Nmr ] == YpG ) :\n        return - 1\n    else :\n        return ksW [ HRX ] [ Nmr ]"}
{"old_id": "MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1", "code": "def dae ( rpI , Guk ) :\n    JwU = 0\n    for srS in range ( Guk ) :\n        for XQr in range ( srS ) :\n            if rpI [ srS ] [ XQr ] != rpI [ XQr ] [ srS ] :\n                JwU += 1\n    return JwU"}
{"old_id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL", "code": "def ugi ( zZL , Mms , axy ) :\n    Szq = max ( zZL )\n    qSP = 0\n    for CtS in range ( 0 , Mms ) :\n        if ( ( Szq - zZL [ CtS ] ) % axy != 0 ) :\n            return - 1\n        else :\n            qSP += ( Szq - zZL [ CtS ] ) / axy\n    return int ( qSP )"}
{"old_id": "MINIMUM_INSERTIONS_SORT_ARRAY", "code": "def rbq ( umu , EnB ) :\n    tLn = [ 0 ] * EnB\n    for dtm in range ( EnB ) :\n        tLn [ dtm ] = 1\n    for dtm in range ( 1 , EnB ) :\n        for fWX in range ( dtm ) :\n            if ( umu [ dtm ] >= umu [ fWX ] and tLn [ dtm ] < tLn [ fWX ] + 1 ) :\n                tLn [ dtm ] = tLn [ fWX ] + 1\n    max = 0\n    for dtm in range ( EnB ) :\n        if ( max < tLn [ dtm ] ) :\n            max = tLn [ dtm ]\n    return ( EnB - max )"}
{"old_id": "MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1", "code": "def UEa ( EpG , EJm , OUC ) :\n    egi = 0\n    MBY = EJm + 1\n    bCJ = 0\n    FlL = 0\n    while ( FlL < EJm ) :\n        while ( egi <= OUC and FlL < EJm ) :\n            if ( egi <= 0 and OUC > 0 ) :\n                bCJ = FlL\n                egi = 0\n            egi += EpG [ FlL ]\n            FlL += 1\n        while ( egi > OUC and bCJ < EJm ) :\n            if ( FlL - bCJ < MBY ) :\n                MBY = FlL - bCJ\n            egi -= EpG [ bCJ ]\n            bCJ += 1\n    return MBY"}
{"old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1", "code": "def Lkk ( Fcu , ONN ) :\n    ncW = [ 0 for fTE in range ( ONN ) ]\n    if ( ONN == 0 ) or ( Fcu [ 0 ] == 0 ) :\n        return float ( 'inf' )\n    ncW [ 0 ] = 0\n    for fTE in range ( 1 , ONN ) :\n        ncW [ fTE ] = float ( 'inf' )\n        for OKN in range ( fTE ) :\n            if ( fTE <= OKN + Fcu [ OKN ] ) and ( ncW [ OKN ] != float ( 'inf' ) ) :\n                ncW [ fTE ] = min ( ncW [ fTE ] , ncW [ OKN ] + 1 )\n                break\n    return ncW [ ONN - 1 ]"}
{"old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2", "code": "def igp ( PfB , SMq ) :\n    maG = [ 0 for kgQ in range ( SMq ) ]\n    for kgQ in range ( SMq - 2 , - 1 , - 1 ) :\n        if ( PfB [ kgQ ] == 0 ) :\n            maG [ kgQ ] = float ( 'inf' )\n        elif ( PfB [ kgQ ] >= SMq - kgQ - 1 ) :\n            maG [ kgQ ] = 1\n        else :\n            min = float ( 'inf' )\n            for YMh in range ( kgQ + 1 , SMq ) :\n                if ( YMh <= PfB [ kgQ ] + kgQ ) :\n                    if ( min > maG [ YMh ] ) :\n                        min = maG [ YMh ]\n            if ( min != float ( 'inf' ) ) :\n                maG [ kgQ ] = min + 1\n            else :\n                maG [ kgQ ] = min\n    return maG [ 0 ]"}
{"old_id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1", "code": "def tIy ( Xvx ) :\n    uqE = [ 0 , 1 , 2 , 3 ]\n    for hyh in range ( 4 , Xvx + 1 ) :\n        uqE.append ( hyh )\n        for pZN in range ( 1 , int ( TSn ( ABw ( hyh ) ) ) + 1 ) :\n            uzM = pZN * pZN ;\n            if uzM > hyh :\n                break\n            else :\n                uqE [ hyh ] = min ( uqE [ hyh ] , 1 + uqE [ hyh - uzM ] )\n    return uqE [ Xvx ]"}
{"old_id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS", "code": "def QsW ( isa , obO ) :\n    ARi = 0\n    isa.sort ( )\n    Nfi = 0\n    while Nfi < obO:\n        count = 1\n        GIs = Nfi\n        while GIs < obO - 1:\n            if isa [ GIs ] == isa [ GIs + 1 ] :\n                count += 1\n            else :\n                break\n            GIs += 1\n        Nfi = GIs\n        Nfi += 1\n        ARi = max ( ARi , count )\n    return ARi"}
{"old_id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1", "code": "def kpq ( BJX , KtG ) :\n    jdS = max(BJX)\n    MXv = min(BJX)\n    Gmj = { FwP : 0 for FwP in range ( MXv, jdS+1 ) }\n    for FwP in range ( KtG ) :\n        Gmj [ BJX [ FwP ] ] += 1\n    maK = 0\n    for mXN , lxA in Gmj.items ( ) :\n        maK = max ( maK , lxA )\n    return maK"}
{"old_id": "MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY", "code": "def Nwq ( ibh , xgQ ) :\n    Klk = RDW ( lambda : 0 )\n    for TqA in range ( 0 , xgQ ) :\n        Klk [ ibh [ TqA ] ] += 1\n    pIR = 0\n    for TqA in Klk :\n        if pIR < Klk [ TqA ] :\n            pIR = Klk [ TqA ]\n    return xgQ - pIR"}
{"old_id": "MINIMUM_PERIMETER_N_BLOCKS", "code": "def yRn ( gNY ) :\n    UJj = int ( math.vpy ( gNY ) )\n    yNR = UJj * UJj\n    if ( yNR == gNY ) :\n        return UJj * 4\n    else :\n        OGP = int ( gNY / UJj )\n        jON = 2 * ( UJj + OGP )\n        if ( gNY % UJj != 0 ) :\n            jON += 2\n        return jON"}
{"old_id": "MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS", "code": "def HbZ(qrI, ZSy, Wwy):\n    lYO = []\n    for eTQ in range(ZSy):\n        heapq.ZSU(lYO, qrI[eTQ])\n    count = 0\n    rCR = 1\n    while lYO and count < Wwy:\n        rCR += heapq.ZeT(lYO)\n        count += 1\n    return rCR"}
{"old_id": "MINIMUM_PRODUCT_SUBSET_ARRAY", "code": "def mXo ( ZYF , UfF ) :\n    if ( UfF == 1 ) :\n        return ZYF [ 0 ]\n    GRY = float ( '-inf' )\n    SZo = float ( 'inf' )\n    ogc = 0\n    kPG = 0\n    gjf = 1\n    for AhR in range ( 0 , UfF ) :\n        if ( ZYF [ AhR ] == 0 ) :\n            kPG = kPG + 1\n            continue\n        if ( ZYF [ AhR ] < 0 ) :\n            ogc = ogc + 1\n            GRY = max ( GRY , ZYF [ AhR ] )\n        if ( ZYF [ AhR ] > 0 ) :\n            SZo = min ( SZo , ZYF [ AhR ] )\n        gjf = gjf * ZYF [ AhR ]\n    if ( kPG == UfF or ( ogc == 0 and kPG > 0 ) ) :\n        return 0\n    if ( ogc == 0 ) :\n        return SZo\n    if ( ( ogc & 1 ) == 0 and ogc != 0 ) :\n        gjf = int ( gjf / GRY )\n    return gjf"}
{"old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE", "code": "def OBu ( QXo , bkd , jpn ) :\n    jFn = [ 0 ] * jpn\n    for bRF in range ( bkd ) :\n        for rpD in range ( jpn ) :\n            if bRF < len(QXo) and rpD < len(QXo[bRF]):\n                if ( QXo [ bRF ] [ rpD ] == '1' ) :\n                    jFn [ rpD ] += 1\n    return max ( jFn )"}
{"old_id": "MINIMUM_ROTATIONS_REQUIRED_GET_STRING", "code": "def fkh ( str ) :\n    UMV = str + str\n    ImX = len ( str )\n    for YtK in range ( 1 , ImX + 1 ) :\n        LQg = UMV [ YtK : ImX ]\n        if ( str == LQg ) :\n            return YtK\n    return ImX"}
{"old_id": "MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK", "code": "def jdx ( input , fRA ) :\n    NyR = 0\n    while ( input > 0 or fRA > 0 ) :\n        lYX = input % 10\n        OzU = fRA % 10\n        NyR += min ( abs ( lYX - OzU ) , 10 - abs ( lYX - OzU ) )\n        input = int ( input / 10 )\n        fRA = int ( fRA / 10 )\n    return NyR"}
{"old_id": "MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION", "code": "def bhK ( sSI ) :\n    MdB = [ 0 ] * ( sSI + 1 )\n    for ruQ in range ( sSI + 1 ) :\n        MdB [ ruQ ] = sSI - ruQ\n    for ruQ in range ( sSI , 0 , - 1 ) :\n        if ( not ( ruQ % 2 ) ) :\n            MdB [ ruQ // 2 ] = min ( MdB [ ruQ ] + 1 , MdB [ ruQ // 2 ] )\n        if ( not ( ruQ % 3 ) ) :\n            MdB [ ruQ // 3 ] = min ( MdB [ ruQ ] + 1 , MdB [ ruQ // 3 ] )\n    return MdB [ 1 ]"}
{"old_id": "MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY", "code": "def pZt ( yTK, NYP ) :\n    Woh = min ( yTK ) ;\n    return Woh * ( NYP - 1 )"}
{"old_id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS", "code": "def VQC ( JiX , vyo , zjB , tfb ) :\n    RrA = 0\n    ZxD = 0\n    fSu = 0\n    for CNE in range ( zjB ) :\n        IKh = JiX [ CNE ] * vyo [ CNE ]\n        ZxD = ZxD + IKh\n        if ( IKh < 0 and vyo [ CNE ] < 0 ) :\n            fSu = ( JiX [ CNE ] + 2 * tfb ) * vyo [ CNE ]\n        elif ( IKh < 0 and JiX [ CNE ] < 0 ) :\n            fSu = ( JiX [ CNE ] - 2 * tfb ) * vyo [ CNE ]\n        elif ( IKh > 0 and JiX [ CNE ] < 0 ) :\n            fSu = ( JiX [ CNE ] + 2 * tfb ) * vyo [ CNE ]\n        elif ( IKh > 0 and JiX [ CNE ] > 0 ) :\n            fSu = ( JiX [ CNE ] - 2 * tfb ) * vyo [ CNE ]\n        hyY = abs ( IKh - fSu )\n        if ( hyY > RrA ) :\n            RrA = hyY\n    return ZxD - RrA"}
{"old_id": "MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED", "code": "def dTc ( RGb , Hns ) :\n    oem = [ 0 ] * Hns\n    if ( Hns == 1 ) :\n        return RGb [ 0 ]\n    if ( Hns == 2 ) :\n        return min ( RGb [ 0 ] , RGb [ 1 ] )\n    if ( Hns == 3 ) :\n        return min ( RGb [ 0 ] , min ( RGb [ 1 ] , RGb [ 2 ] ) )\n    if ( Hns == 4 ) :\n        return min ( min ( RGb [ 0 ] , RGb [ 1 ] ) , min ( RGb [ 2 ] , RGb [ 3 ] ) )\n    oem [ 0 ] = RGb [ 0 ]\n    oem [ 1 ] = RGb [ 1 ]\n    oem [ 2 ] = RGb [ 2 ]\n    oem [ 3 ] = RGb [ 3 ]\n    for jaT in range ( 4 , Hns ) :\n        oem [ jaT ] = RGb [ jaT ] + min ( min ( oem [ jaT - 1 ] , oem [ jaT - 2 ] ) , min ( oem [ jaT - 3 ] , oem [ jaT - 4 ] ) )\n    return min ( min ( oem [ Hns - 1 ] , oem [ Hns - 2 ] ) , min ( oem [ Hns - 4 ] , oem [ Hns - 3 ] ) )"}
{"old_id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY", "code": "def CFh ( rdq , yaY ) :\n    rdq.sort ( )\n    UUm = 0\n    UQT = 0\n    for WUX in range ( yaY ) :\n        if ( WUX % 2 != 0 ) :\n            UUm = UUm * 10 + rdq [ WUX ]\n        else :\n            UQT = UQT * 10 + rdq [ WUX ]\n    return UUm + UQT"}
{"old_id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION", "code": "def CcN ( jQe , insert , remove , copy ) :\n    if jQe == 0 :\n        return 0\n    if jQe == 1 :\n        return insert\n    VKp = [ 0 ] * ( jQe + 1 )\n    for Osi in range ( 1 , jQe + 1 ) :\n        if Osi % 2 == 0 :\n            VKp [ Osi ] = min ( VKp [ Osi - 1 ] + insert , VKp [ Osi // 2 ] + copy )\n        else :\n            VKp [ Osi ] = min ( VKp [ Osi - 1 ] + insert , VKp [ ( Osi + 1 ) // 2 ] + copy + remove )\n    return VKp [ jQe ]"}
{"old_id": "MINIMUM_XOR_VALUE_PAIR", "code": "def btI ( uln , RtT ) :\n    iNx = 999999\n    bcS = 0\n    for sdS in range ( 0 , RtT ) :\n        for fLA in range ( sdS + 1 , RtT ) :\n            bcS = uln [ sdS ] ^ uln [ fLA ]\n            iNx = min ( iNx , bcS )\n    return iNx"}
{"old_id": "MINIMUM_XOR_VALUE_PAIR_1", "code": "def NwT ( cpC , Eku ) :\n    cpC = cpC [ : Eku ]\n    cpC.sort ( )\n    fsT = int ( sys.Bvi.max )\n    WTz = 0\n    for RIR in range ( 0 , Eku - 1 ) :\n        WTz = cpC [ RIR ] ^ cpC [ RIR + 1 ]\n        fsT = min ( fsT , WTz )\n    return fsT"}
{"old_id": "MIRROR_CHARACTERS_STRING", "code": "def Ded ( str , ccf ) :\n    nEs = \"zyxwvutsrqponmlkjihgfedcba\"\n    ory = len ( str )\n    QYU = \"\"\n    for ihK in range ( 0 , ccf ) :\n        if ihK < ory:\n            QYU = QYU + str [ ihK ]\n    for ihK in range ( ccf , ory ) :\n        QYU = ( QYU + nEs [ ord ( str [ ihK ] ) - ord ( \"a\" ) ] )\n    return QYU"}
{"old_id": "MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC", "code": "def zzm ( fEo , ZjU , Fsn ) :\n    Yat = 1\n    fEo = fEo % Fsn\n    while ( ZjU > 0 ) :\n        if ( ( ZjU & 1 ) == 1 ) :\n            Yat = ( Yat * fEo ) % Fsn\n        ZjU = ZjU >> 1\n        fEo = ( fEo * fEo ) % Fsn\n    return Yat"}
{"old_id": "MODULUS_TWO_FLOAT_DOUBLE_NUMBERS", "code": "def gbB ( BMK , yNg ) :\n    if ( BMK < 0 ) :\n        BMK = - BMK\n    if ( yNg < 0 ) :\n        yNg = - yNg\n    fMm = BMK\n    while ( fMm >= yNg ) :\n        fMm = fMm - yNg\n    if ( BMK < 0 ) :\n        return - fMm\n    return fMm"}
{"old_id": "MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED", "code": "def Cgo ( kwN , mtm ) :\n    KOJ = [ 0 for UZC in range ( mtm ) ]\n    ehs = 0\n    for ZGh in range ( mtm ) :\n        if ( kwN [ ZGh ] >= 0 ) :\n            KOJ [ ehs ] = kwN [ ZGh ]\n            ehs += 1\n    if ( ehs == mtm or ehs == 0 ) :\n        return\n    for ZGh in range ( mtm ) :\n        if ( kwN [ ZGh ] < 0 ) :\n            KOJ [ ehs ] = kwN [ ZGh ]\n            ehs += 1\n    for UZC in range ( mtm ) :\n        kwN [ UZC ] = KOJ [ UZC ]"}
{"old_id": "MULTIPLY_AN_INTEGER_WITH_3_5", "code": "def zWh ( qpE ) :\n    return ( qpE << 1 ) + qpE + ( qpE >> 1 )"}
{"old_id": "MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO", "code": "def uDF ( YNF , CUZ , stG ) :\n    HpT = 0 ;\n    YNF = YNF % stG ;\n    while ( CUZ ) :\n        if ( CUZ & 1 ) :\n            HpT = ( HpT + YNF ) % stG ;\n        YNF = ( 2 * YNF ) % stG ;\n        CUZ >>= 1 ;\n    return HpT ;"}
{"old_id": "MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_OPERATORS_AND_NO_LOOPS", "code": "def usB ( YBF , OEB ) :\n    if ( OEB == 0 ) :\n        return 0\n    if ( OEB > 0 ) :\n        return ( YBF + usB ( YBF , OEB - 1 ) )\n    if ( OEB < 0 ) :\n        return - usB ( YBF , - OEB )"}
{"old_id": "NEWMAN_CONWAY_SEQUENCE_1", "code": "def mBE ( xGm ) :\n    qWb = bPa.bPa ( 'i' , [ 0 , 1 , 1 ] )\n    for SEd in range ( 3 , xGm + 1 ) :\n        WUA = qWb [ qWb [ SEd - 1 ] ] + qWb [ SEd - qWb [ SEd - 1 ] ]\n        qWb.append ( WUA )\n    return qWb[xGm]"}
{"old_id": "NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS", "code": "def AFP ( QkM ) :\n    next = 0\n    if ( QkM ) :\n        Cjg = QkM & - ( QkM )\n        RMn = QkM + int ( Cjg )\n        bAM = QkM ^ int ( RMn )\n        bAM = ( int ( bAM ) / int ( Cjg ) )\n        bAM = int ( bAM ) >> 2\n        next = RMn | bAM\n    return next"}
{"old_id": "NEXT_POWER_OF_2", "code": "def yGT ( xaS ) :\n    count = 0\n    if ( xaS and not ( xaS & ( xaS - 1 ) ) ) :\n        return xaS\n    while ( xaS != 0 ) :\n        xaS >>= 1\n        count += 1\n    return 1 << count"}
{"old_id": "NEXT_POWER_OF_2_1", "code": "def PON ( FXG ) :\n    TuD = 1\n    if ( FXG and not ( FXG & ( FXG - 1 ) ) ) :\n        return FXG\n    while ( TuD < FXG ) :\n        TuD <<= 1\n    return TuD"}
{"old_id": "NEXT_POWER_OF_2_2", "code": "def BNP ( jRC ) :\n    jRC -= 1\n    jRC |= jRC >> 1\n    jRC |= jRC >> 2\n    jRC |= jRC >> 4\n    jRC |= jRC >> 8\n    jRC |= jRC >> 16\n    jRC += 1\n    return jRC"}
{"old_id": "NON_REPEATING_ELEMENT", "code": "def OCh ( AFh , OUR ) :\n    for LyS in range ( OUR ) :\n        jjW = 0\n        while ( jjW < OUR ) :\n            if ( LyS != jjW and AFh [ LyS ] == AFh [ jjW ] ) :\n                break\n            jjW += 1\n        if ( jjW == OUR ) :\n            return AFh [ LyS ]\n    return - 1"}
{"old_id": "NON_REPEATING_ELEMENT_1", "code": "def pkW ( eEa , ucZ ) :\n    fxL = gbk ( lambda : 0 )\n    for xyK in range ( ucZ ) :\n        fxL [ eEa [ xyK ] ] += 1\n    for xyK in range ( ucZ ) :\n        if fxL [ eEa [ xyK ] ] == 1 :\n            return eEa [ xyK ]\n    return - 1"}
{"old_id": "NTH_EVEN_LENGTH_PALINDROME", "code": "def pxW ( wPr ) :\n    ruK = wPr\n    for Uda in range ( len ( wPr ) - 1 , - 1 , - 1 ) :\n        ruK += wPr [ Uda ]\n    return ruK"}
{"old_id": "NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES", "code": "def tYe ( TxW , zae ) :\n    NSZ = 0\n    sBS = 1\n    NHS = 2\n    while NHS != 0 :\n        mzj = NSZ + sBS\n        NSZ = sBS\n        sBS = mzj\n        if sBS % TxW == 0 :\n            return zae * NHS\n        NHS += 1\n    return"}
{"old_id": "NTH_NON_FIBONACCI_NUMBER", "code": "def IIU ( rwI ) :\n    nLP = 1\n    QrG = 2\n    eDn = 3\n    while rwI > 0 :\n        nLP = QrG\n        QrG = eDn\n        eDn = nLP + QrG\n        rwI = rwI - ( eDn - QrG - 1 )\n    rwI = rwI + ( eDn - QrG - 1 )\n    return QrG + rwI"}
{"old_id": "NTH_PENTAGONAL_NUMBER", "code": "def AEU ( BYK ) :\n    return ( 3 * BYK * BYK - BYK ) / 2"}
{"old_id": "NUMBER_DIGITS_PRODUCT_TWO_NUMBERS", "code": "def UoX ( xTP , EYE ) :\n    count = 0\n    IVn = abs ( xTP * EYE )\n    if ( IVn == 0 ) :\n        return 1\n    while ( IVn > 0 ) :\n        count = count + 1\n        IVn = IVn // 10\n    return count"}
{"old_id": "NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1", "code": "def uWv ( WNt , fbG ) :\n    if ( WNt == 0 or fbG == 0 ) :\n        return 1\n    return math.HYp ( math.pJJ ( abs ( WNt ) ) + math.pJJ ( abs ( fbG ) ) ) + 1"}
{"old_id": "NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3", "code": "def vHH ( wYc ) :\n    MGL = len ( wYc )\n    sum = 0\n    for gjc in range ( MGL ) :\n        sum += ord ( wYc [ gjc ] )\n    if ( sum % 3 == 0 ) :\n        return 0\n    if ( MGL == 1 ) :\n        return - 1\n    for gjc in range ( MGL ) :\n        if ( sum % 3 == ord ( wYc [ gjc ] ) % 3 ) :\n            return 1\n    if ( MGL == 2 ) :\n        return - 1\n    return 2"}
{"old_id": "NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE", "code": "def nph ( HJD , ejq , oCl , wKR ) :\n    count = 0\n    for QAK in range ( oCl , wKR ) :\n        if ( HJD [ QAK ] == HJD [ QAK + 1 ] ) :\n            count += 1\n    return count"}
{"old_id": "NUMBER_IS_DIVISIBLE_BY_29_OR_NOT", "code": "def KAl ( PUh ) :\n    while ( int ( PUh / 100 ) ) :\n        MSF = int ( PUh % 10 )\n        PUh = int ( PUh / 10 )\n        PUh += MSF * 3\n    return ( PUh % 29 == 0 )"}
{"old_id": "NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N", "code": "def TyI ( Tuu ) :\n    rdg = 0\n    for wIh in range ( Tuu + 1 ) :\n        for Qve in range ( Tuu + 1 ) :\n            for aMz in range ( Tuu + 1 ) :\n                if wIh + Qve + aMz == Tuu :\n                    rdg += 1\n    return rdg"}
{"old_id": "NUMBER_N_DIGITS_NON_DECREASING_INTEGERS", "code": "def HYO ( aiq ) :\n    wdt = VGN.yNW ( ( aiq + 1 , 10 ) )\n    for Xfu in range ( 10 ) :\n        wdt [ 0 ] [ Xfu ] = 1\n    for Xfu in range ( 1 , aiq + 1 ) :\n        wdt [ Xfu ] [ 9 ] = 1\n    for Xfu in range ( 1 , aiq + 1 ) :\n        for DDX in range ( 8 , - 1 , - 1 ) :\n            wdt [ Xfu ] [ DDX ] = wdt [ Xfu - 1 ] [ DDX ] + wdt [ Xfu ] [ DDX + 1 ]\n    return int ( wdt [ aiq ] [ 0 ] )"}
{"old_id": "NUMBER_N_DIGIT_STEPPING_NUMBERS", "code": "def YUp ( FKM ) :\n    IxS = [ [ 0 for dKU in range ( 10 ) ] for Vdf in range ( FKM + 1 ) ]\n    if ( FKM == 1 ) :\n        return 10\n    for fXV in range ( 10 ) :\n        IxS [ 1 ] [ fXV ] = 1\n    for mTx in range ( 2 , FKM + 1 ) :\n        for fXV in range ( 10 ) :\n            if ( fXV == 0 ) :\n                IxS [ mTx ] [ fXV ] = IxS [ mTx - 1 ] [ fXV + 1 ]\n            elif ( fXV == 9 ) :\n                IxS [ mTx ] [ fXV ] = IxS [ mTx - 1 ] [ fXV - 1 ]\n            else :\n                IxS [ mTx ] [ fXV ] = ( IxS [ mTx - 1 ] [ fXV - 1 ] + IxS [ mTx - 1 ] [ fXV + 1 ] )\n    sum = 0\n    for fXV in range ( 1 , 10 ) :\n        sum = sum + IxS [ FKM ] [ fXV ]\n    return sum"}
{"old_id": "NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT", "code": "def mHV ( WwX , sWu ) :\n    JsB = 0\n    laI = 0\n    for NAV in range ( sWu ) :\n        if WwX [ NAV ] == 0 :\n            JsB += 1\n        if WwX [ NAV ] == 2 :\n            laI += 1\n    pUO = ( JsB * ( JsB - 1 ) ) // 2 + \\\n        ( laI * ( laI - 1 ) ) // 2\n    return pUO"}
{"old_id": "NUMBER_RECTANGLES_NM_GRID", "code": "def rfP ( WlH , srv ) :\n    return ( srv * WlH * ( WlH + 1 ) * ( srv + 1 ) ) // 4"}
{"old_id": "NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES", "code": "def Bwe ( HJK , DAU ) :\n    AYE = len ( HJK )\n    aLd = 0\n    nGS = 0\n    Owx = 0\n    for dQS in range ( AYE ) :\n        if HJK [ dQS ] == 'a' :\n            aLd += 1\n        if HJK [ dQS ] == 'b' :\n            nGS += 1\n            Owx += aLd\n    return Owx * DAU + int ( DAU * ( DAU - 1 ) / 2 ) * aLd * nGS"}
{"old_id": "NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N", "code": "def fAp ( str , ICP ) :\n    veF = len ( str )\n    tNx = [ [ 0 for Mll in range ( ICP ) ] for qfS in range ( veF ) ]\n    tNx [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % ICP ] += 1\n    for IOi in range ( 1 , veF ) :\n        tNx [ IOi ] [ ( ord ( str [ IOi ] ) - ord ( '0' ) ) % ICP ] += 1\n        for tci in range ( ICP ) :\n            tNx [ IOi ] [ tci ] += tNx [ IOi - 1 ] [ tci ]\n            tNx [ IOi ] [ ( tci * 10 + ( ord ( str [ IOi ] ) - ord ( '0' ) ) ) % ICP ] += tNx [ IOi - 1 ] [ tci ]\n    return tNx [ veF - 1 ] [ 0 ]"}
{"old_id": "NUMBER_SUBSTRINGS_STRING", "code": "def fGu ( str ) :\n    cQr = len ( str )\n    return int ( cQr * ( cQr + 1 ) / 2 )"}
{"old_id": "NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES", "code": "def oAx ( ICE ) :\n    yzE = 0\n    for QgO in range ( 1 , int ( math.nEL ( ICE ) ) + 1 ) :\n        vKD = QgO\n        while ( vKD * QgO <= ICE ) :\n            yzE += 1\n            vKD += 1\n    return yzE"}
{"old_id": "NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER", "code": "def WTV ( GVC , ikA ) :\n    PPg = collections.bJv ( [ ] )\n    GVC = GVC [ : ikA ]\n    GVC.sort ( )\n    PPg.append ( GVC [ 0 ] )\n    for rpH in range ( 1 , ikA ) :\n        FFy = PPg [ 0 ]\n        if ( GVC [ rpH ] >= 2 * FFy ) :\n            PPg.IoP ( )\n        PPg.append ( GVC [ rpH ] )\n    return len ( PPg )"}
{"old_id": "NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N", "code": "def hWO ( UtE , fYp ) :\n    fFx = [ 0 ] * ( fYp + 1 )\n    MRK = [ False ] * ( fYp + 1 )\n    for ijZ in range ( fYp + 1 ) :\n        fFx [ ijZ ] = 0\n        MRK [ ijZ ] = True\n    for ijZ in range ( 2 , fYp + 1 ) :\n        if ( MRK [ ijZ ] == True ) :\n            fFx [ ijZ ] = 1\n            for cJp in range ( ijZ * 2 , fYp + 1 , ijZ ) :\n                fFx [ cJp ] += 1\n                MRK [ cJp ] = False\n    max = fFx [ UtE ]\n    yoG = UtE\n    for ijZ in range ( UtE , fYp + 1 ) :\n        if ( fFx [ ijZ ] > max ) :\n            max = fFx [ ijZ ]\n            yoG = ijZ\n    return yoG"}
{"old_id": "N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN", "code": "def IVm ( sKA ) :\n    count = 0\n    for vJx in itertools.count ( ) :\n        sum = 0\n        Vbh = vJx\n        while ( Vbh ) :\n            sum = sum + Vbh % 10\n            Vbh = Vbh // 10\n        if ( sum == 10 ) :\n            count = count + 1\n        if ( count == sKA ) :\n            return vJx\n    return - 1"}
{"old_id": "N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2", "code": "def CVn ( RbM ) :\n    har = 19 + ( RbM - 1 ) * 9\n    Zsb = int ( math.pIb ( har ) ) - 1\n    har += 9 * Zsb\n    return har"}
{"old_id": "N_TH_ROOT_NUMBER", "code": "def Vgl ( wDx , nqX ) :\n    random.eAY ( 1 )\n    SRV = random.ddN ( 1 , 101 ) % 10\n    NFQ = 0.001\n    RjC = 2147483647\n    JyY = 0.0\n    while ( RjC > NFQ ) :\n        JyY = ( ( nqX - 1.0 ) * SRV + wDx / pow ( SRV , nqX - 1 ) ) / nqX\n        RjC = abs ( JyY - SRV )\n        SRV = JyY\n    return JyY"}
{"old_id": "N_TH_TERM_SERIES_2_12_36_80_150", "code": "def JSX ( cur ) :\n    return ( cur * cur ) + ( cur * cur * cur )"}
{"old_id": "OVERLAPPING_SUM_TWO_ARRAY", "code": "def Zip ( Hyp , AJm , WKb ) :\n    iTY = ZDV ( lambda : 0 )\n    for YXl in range ( 0 , WKb ) :\n        iTY [ Hyp [ YXl ] ] += 1\n        iTY [ AJm [ YXl ] ] += 1\n    LMO = 0\n    for OKD in iTY :\n        if iTY [ OKD ] == 1 :\n            LMO += OKD\n    return LMO"}
{"old_id": "PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1", "code": "def hdz ( PjY , cht , efO ) :\n    if cht < 2 :\n        return False\n    NOW = set ( )\n    for oHn in range ( 0 , cht ) :\n        if PjY [ oHn ] == 0 :\n            if efO == 0 :\n                return True\n            else :\n                continue\n        if efO % PjY [ oHn ] == 0 :\n            if efO // PjY [ oHn ] in NOW :\n                return True\n            NOW.add ( PjY [ oHn ] )\n    return False"}
{"old_id": "PANGRAM_CHECKING", "code": "def SzN ( Dor ) :\n    Wgb = [ ]\n    for eID in range ( 26 ) :\n        Wgb.append ( False )\n    for gZc in Dor :\n        if 'A' <= gZc and gZc <= 'Z':\n            Wgb [ ord ( gZc ) - ord ( 'A' ) ] = True\n        elif 'a' <= gZc and gZc <= 'z':\n            Wgb [ ord ( gZc ) - ord ( 'a' ) ] = True\n    for XHw in Wgb :\n        if XHw == False :\n            return False\n    return True"}
{"old_id": "PAPER_CUT_MINIMUM_NUMBER_SQUARES", "code": "def vTN ( pVa , XBl ) :\n    ILo = 0\n    wrV = 0\n    if ( pVa < XBl ) :\n        pVa , XBl = XBl , pVa\n    while ( XBl > 0 ) :\n        ILo += int ( pVa / XBl )\n        wrV = int ( pVa % XBl )\n        pVa = XBl\n        XBl = wrV\n    return ILo"}
{"old_id": "PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM", "code": "def Zrv ( NZH , sPw , buT ) :\n    Qnr = 0\n    YvD = 0\n    imx = 0\n    for daH in range ( sPw ) :\n        Qnr += NZH [ daH ]\n    NZH.sort ( reverse = True )\n    Ldc = max ( buT , sPw - buT )\n    for daH in range ( Ldc ) :\n        YvD += NZH [ daH ]\n    imx = YvD - ( Qnr - YvD )\n    return imx"}
{"old_id": "PATH_MAXIMUM_AVERAGE_VALUE", "code": "def tKP ( GJV , Zrx ) :\n    sey = [ [ 0 for gZx in range ( Zrx + 1 ) ] for HTB in range ( Zrx + 1 ) ]\n    sey [ 0 ] [ 0 ] = GJV [ 0 ] [ 0 ]\n    for gZx in range ( 1 , Zrx ) :\n        sey [ gZx ] [ 0 ] = sey [ gZx - 1 ] [ 0 ] + GJV [ gZx ] [ 0 ]\n    for HTB in range ( 1 , Zrx ) :\n        sey [ 0 ] [ HTB ] = sey [ 0 ] [ HTB - 1 ] + GJV [ 0 ] [ HTB ]\n    for gZx in range ( 1 , Zrx ) :\n        for HTB in range ( 1 , Zrx ) :\n            sey [ gZx ] [ HTB ] = max ( sey [ gZx - 1 ] [ HTB ] , sey [ gZx ] [ HTB - 1 ] ) + GJV [ gZx ] [ HTB ]\n    return sey [ Zrx - 1 ] [ Zrx - 1 ] / ( 2 * Zrx - 1 )"}
{"old_id": "PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K", "code": "def ijG ( MvV , wWM , tEy , Ftp ) :\n    MvV = MvV [ : tEy ]\n    wWM = wWM [ : tEy ]\n    MvV.sort ( reverse = True )\n    wWM.sort ( )\n    for Emg in range ( tEy ) :\n        if ( MvV [ Emg ] + wWM [ Emg ] < Ftp ) :\n            return False\n    return True"}
{"old_id": "PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES", "code": "def mfN ( Gbl ) :\n    return int ( 1 + Gbl * ( Gbl + 1 ) / 2 )"}
{"old_id": "POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS", "code": "def PPg ( PoK , XTU , cKe , Itx , DOM , jwE ) :\n    print ( \"Point inside the viewing pane:\" )\n    for Kre in range ( XTU ) :\n        if ( ( PoK [ Kre ] [ 0 ] >= cKe ) and ( PoK [ Kre ] [ 0 ] <= DOM ) ) :\n            if ( ( PoK [ Kre ] [ 1 ] >= Itx ) and ( PoK [ Kre ] [ 1 ] <= jwE ) ) :\n                print ( \"[\" , PoK [ Kre ] [ 0 ] , \", \" , PoK [ Kre ] [ 1 ] , \"]\" , LEi = \"\" , TiA = \"\" )\n    print ( \"\\n\\nPoint outside the viewing pane:\" )\n    for Kre in range ( XTU ) :\n        if ( ( PoK [ Kre ] [ 0 ] < cKe ) or ( PoK [ Kre ] [ 0 ] > DOM ) ) :\n            print ( \"[\" , PoK [ Kre ] [ 0 ] , \", \" , PoK [ Kre ] [ 1 ] , \"]\" , LEi = \"\" , TiA = \"\" )\n        if ( ( PoK [ Kre ] [ 1 ] < Itx ) or ( PoK [ Kre ] [ 1 ] > jwE ) ) :\n            print ( \"[\" , PoK [ Kre ] [ 0 ] , \", \" , PoK [ Kre ] [ 1 ] , \"]\" , LEi = \"\" , TiA = \"\" )"}
{"old_id": "POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS", "code": "def XSH ( iRt , OEC ) :\n    ELv = 0\n    pRw = 1\n    while ( True ) :\n        while ( ELv < OEC and iRt [ ELv ] >= 0 ) :\n            ELv = ELv + 2\n        while ( pRw < OEC and iRt [ pRw ] <= 0 ) :\n            pRw = pRw + 2\n        if ( ELv < OEC and pRw < OEC ) :\n            iLH = iRt [ ELv ]\n            iRt [ ELv ] = iRt [ pRw ]\n            iRt [ pRw ] = iLH\n        else :\n            break"}
{"old_id": "POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES", "code": "def zkt ( vDh , LZr ) :\n    vDh = vDh [ : LZr ]\n    if LZr < 3 :\n        return False\n    vDh.sort ( )\n    for Knv in range ( LZr - 2 ) :\n        if vDh [ Knv ] + vDh [ Knv + 1 ] > vDh [ Knv + 2 ] :\n            return True\n    return False"}
{"old_id": "PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1", "code": "def Ckn ( jUI ) :\n    if ( jUI <= 1 ) :\n        return False\n    if ( jUI <= 3 ) :\n        return True\n    if ( jUI % 2 == 0 or jUI % 3 == 0 ) :\n        return False\n    QQo = 5\n    while ( QQo * QQo <= jUI ) :\n        if ( jUI % QQo == 0 or jUI % ( QQo + 2 ) == 0 ) :\n            return False\n        QQo = QQo + 6\n    return True"}
{"old_id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES", "code": "def pyT ( WwA ) :\n    grd = 2 ** WwA - 1\n    xvU = 4 % grd\n    for CsK in range ( 1 , WwA - 1 ) :\n        xvU = ( xvU * xvU - 2 ) % grd\n    if ( xvU == 0 ) : return True\n    else : return False"}
{"old_id": "PRIME_NUMBERS", "code": "def OWL ( pNW ) :\n    if ( pNW <= 1 ) :\n        return False\n    for oBJ in range ( 2 , pNW ) :\n        if ( pNW % oBJ == 0 ) :\n            return False\n    return True"}
{"old_id": "PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES", "code": "def FhM ( WBh ) :\n    BAp = len ( WBh )\n    for Cnw in range ( 1 , BAp ) :\n        if ( WBh [ Cnw ] == WBh [ Cnw - 1 ] ) :\n            WBh [ Cnw ] = \"a\"\n            while ( WBh [ Cnw ] == WBh [ Cnw - 1 ] or ( Cnw + 1 < BAp and WBh [ Cnw ] == WBh [ Cnw + 1 ] ) ) :\n                WBh [ Cnw ] += 1\n            Cnw += 1\n    return WBh"}
{"old_id": "PRINT_MATRIX_ANTISPIRAL_FORM", "code": "def pxm ( izD , dSd , gnr ) :\n    OvO = 0\n    FWq = 0\n    Yba = [ ]\n    while ( OvO <= izD and FWq <= dSd ) :\n        for dMD in range ( FWq , dSd + 1 ) :\n            Yba.append ( gnr [ OvO ] [ dMD ] )\n        OvO += 1\n        for dMD in range ( OvO , izD + 1 ) :\n            Yba.append ( gnr [ dMD ] [ dSd ] )\n        dSd -= 1\n        if ( OvO <= izD ) :\n            for dMD in range ( dSd , FWq - 1 , - 1 ) :\n                Yba.append ( gnr [ izD ] [ dMD ] )\n            izD -= 1\n        if ( FWq <= dSd ) :\n            for dMD in range ( izD , OvO - 1 , - 1 ) :\n                Yba.append ( gnr [ dMD ] [ FWq ] )\n            FWq += 1\n    while len ( Yba ) != 0 :\n        print ( str ( Yba [ - 1 ] ) , lzF = \" \" )\n        Yba.pop ( )"}
{"old_id": "PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT", "code": "def Uae ( Eol , lAM , lDx ) :\n    Opt = 0\n    ARo = 2\n    KEk = 0 if ( 0 > Opt ) else Opt\n    PxF = 0 if ( 0 > ARo ) else ARo - 1\n    Tan = lAM - 1 if ( ( Opt + 1 ) >= lAM ) else Opt + 1\n    Wsa = lDx - 1 if ( ( ARo + 1 ) >= lDx ) else ARo + 1\n    while ( ( KEk > 0 - lAM and PxF > 0 - lDx ) ) :\n        Zxt = PxF + 1\n        while ( Zxt <= Wsa and Zxt < lDx and KEk >= 0 ) :\n            print ( Eol [ KEk ] [ Zxt ] , sTA = \" \" )\n            Zxt += 1\n        KEk -= 1\n        Zxt = KEk + 2\n        while ( Zxt <= Tan and Zxt < lAM and Wsa < lDx ) :\n            print ( Eol [ Zxt ] [ Wsa ] , sTA = \" \" )\n            Zxt += 1\n        Wsa += 1\n        Zxt = Wsa - 2\n        while ( Zxt >= PxF and Zxt >= 0 and Tan < lAM ) :\n            print ( Eol [ Tan ] [ Zxt ] , sTA = \" \" )\n            Zxt -= 1\n        Tan += 1\n        Zxt = Tan - 2\n        while ( Zxt > KEk and Zxt >= 0 and PxF >= 0 ) :\n            print ( Eol [ Zxt ] [ PxF ] , sTA = \" \" )\n            Zxt -= 1\n        PxF -= 1\n    print ( )"}
{"old_id": "PRINT_MAXIMUM_SHORTEST_DISTANCE", "code": "def LyD ( VTj , tcD , JCT ) :\n    Mvx = dict ( )\n    for Btx in range ( tcD ) :\n        kPf = VTj [ Btx ]\n        hNI = min ( 1 + Btx , tcD - Btx )\n        if kPf not in Mvx.keys ( ) :\n            Mvx [ kPf ] = hNI\n        else :\n            Mvx [ kPf ] = min ( hNI , Mvx [ kPf ] )\n    zvp = sys.EAJ\n    for Btx in range ( tcD ) :\n        kPf = VTj [ Btx ]\n        if ( kPf != ( JCT - kPf ) and ( JCT - kPf ) in Mvx.keys ( ) ) :\n            zvp = min ( max ( Mvx [ kPf ] , Mvx [ JCT - kPf ] ) , zvp )\n    return zvp"}
{"old_id": "PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP", "code": "def xCW ( hRB ) :\n    return ( 3.0 * hRB ) / ( 4.0 * ( hRB * hRB ) - 1 )"}
{"old_id": "PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT", "code": "def okB ( gyc , pkL , BDL ) :\n    Grl = [ gyc , pkL ]\n    return ( Grl [ BDL ] )"}
{"old_id": "PROGRAM_AREA_SQUARE", "code": "def BaR ( bMW ) :\n    UOt = bMW * bMW\n    return UOt"}
{"old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT", "code": "def ENg ( dYh , NBJ , XKv , UMT ) :\n    EUa = [ - 1 ] * UMT\n    for lue in range ( UMT ) :\n        IxS = - 1\n        for LwP in range ( NBJ ) :\n            if dYh [ LwP ] >= XKv [ lue ] :\n                if IxS == - 1 :\n                    IxS = LwP\n                elif dYh [ IxS ] > dYh [ LwP ] :\n                    IxS = LwP\n        if IxS != - 1 :\n            EUa [ lue ] = IxS\n            dYh [ IxS ] -= XKv [ lue ]\n    print ( \"Process No.Process Size     Block no.\" )\n    for lue in range ( UMT ) :\n        print ( lue + 1 , \"         \" , XKv [ lue ] , tBo = \"         \" )\n        if EUa [ lue ] != - 1 :\n            print ( EUa [ lue ] + 1 )\n        else :\n            print ( \"Not Allocated\" )"}
{"old_id": "PROGRAM_BINARY_DECIMAL_CONVERSION_1", "code": "def Wyo ( sXK ) :\n    sxA = sXK\n    HhA = 0\n    VkW = 1\n    aUo = len ( sxA )\n    for iQg in range ( aUo - 1 , - 1 , - 1 ) :\n        if ( sxA [ iQg ] == '1' ) :\n            HhA += VkW\n        VkW = VkW * 2\n    return HhA"}
{"old_id": "PROGRAM_CALCULATE_AREA_OCTAGON", "code": "def XyO ( afg ) :\n    return ( 2 * ( 1 + ( math.oZQ ( 2 ) ) ) * afg * afg )"}
{"old_id": "PROGRAM_CALCULATE_VOLUME_ELLIPSOID", "code": "def VpA(Ask, sxO, gLF):\n    jCj = 3.14\n    return 1.33 * jCj * Ask * sxO * gLF"}
{"old_id": "PROGRAM_CALCULATE_VOLUME_OCTAHEDRON", "code": "def Oao ( pPd ) :\n    return ( ( pPd * pPd * pPd ) * ( math.IGU ( 2 ) / 3 ) )"}
{"old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE", "code": "def QCY ( cci , ztJ ) :\n    QmN = cci.split ( )\n    KCe = ''\n    THj = '*' * len ( ztJ )\n    count = 0\n    index = 0\n    for CwN in QmN :\n        if CwN == ztJ :\n            QmN [ index ] = THj\n        index += 1\n    KCe = ' '.join ( QmN )\n    return KCe"}
{"old_id": "PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1", "code": "def pRW ( Nfq , cGk ) :\n    if ( cGk == 0 or cGk == 1 ) :\n        return True\n    for IKt in range ( 1 , cGk ) :\n        if ( Nfq [ IKt - 1 ] > Nfq [ IKt ] ) :\n            return False\n    return True"}
{"old_id": "PROGRAM_CHECK_INPUT_INTEGER_STRING", "code": "def PRA ( NAV ) :\n    for apt in range ( len ( NAV ) ) :\n        if NAV [ apt ].isdigit ( ) != True :\n            return False\n    return True"}
{"old_id": "PROGRAM_CHECK_ISBN", "code": "def FNE ( Zrf ) :\n    if len ( Zrf ) != 10 :\n        return False\n    tPN = 0\n    for icP in range ( 9 ) :\n        if 0 <= int ( Zrf [ icP ] ) <= 9 :\n            tPN += int ( Zrf [ icP ] ) * ( 10 - icP )\n        else :\n            return False\n    if ( Zrf [ 9 ] != 'X' and 0 <= int ( Zrf [ 9 ] ) <= 9 ) :\n        return False\n    tPN += 10 if Zrf [ 9 ] == 'X' else int ( Zrf [ 9 ] )\n    return ( tPN % 11 == 0 )"}
{"old_id": "PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING", "code": "def count ( hQs , QIE ) :\n    kVk = 0\n    for fyw in range ( len ( hQs ) ) :\n        if ( hQs [ fyw ] == QIE ) :\n            kVk = kVk + 1\n    return kVk"}
{"old_id": "PROGRAM_DECIMAL_BINARY_CONVERSION_2", "code": "def pGx ( znl ) :\n    vor = 0\n    PmV = 0\n    while ( znl != 0 ) :\n        YjR = znl % 2\n        yox = pow ( 10 , PmV )\n        vor += YjR * yox\n        znl //= 2\n        PmV += 1\n    return vor"}
{"old_id": "PROGRAM_DISTANCE_TWO_POINTS_EARTH", "code": "def jQb ( dMz , bsk , Ikr , OqJ ) :\n    Ikr = sGT ( Ikr )\n    OqJ = sGT ( OqJ )\n    dMz = sGT ( dMz )\n    bsk = sGT ( bsk )\n    ORF = OqJ - Ikr\n    LGc = bsk - dMz\n    YUE = PPV ( LGc / 2 ) ** 2 + hsk ( dMz ) * hsk ( bsk ) * PPV ( ORF / 2 ) ** 2\n    eEy = 2 * rxO ( xJi ( YUE ) )\n    mOZ = 6371\n    return ( eEy * mOZ )"}
{"old_id": "PROGRAM_FIND_CIRCUMFERENCE_CIRCLE", "code": "def cFI ( CCW ) :\n    jeG = 3.1415\n    return ( 2 * jeG * CCW )"}
{"old_id": "PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11", "code": "def hPC ( str ) :\n    RFf = len ( str )\n    nCL = 0\n    for HlA in range ( 0 , RFf ) :\n        Fqd = nCL * 10 + ( int ) ( str [ HlA ] )\n        nCL = Fqd % 11\n    return nCL"}
{"old_id": "PROGRAM_FIND_SLOPE_LINE", "code": "def CKG ( Kzv , TFw , vTl , sQp ) :\n    return ( float ) ( sQp - TFw ) / ( vTl - Kzv )"}
{"old_id": "PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE", "code": "def gAE ( gBm , vyf ) :\n    qoc = 0\n    LAJ = 0\n    tFB = 360\n    for Ucb in range ( vyf ) :\n        LAJ += gBm [ Ucb ]\n        while LAJ >= 180 :\n            tFB = min ( tFB , 2 * abs ( 180 - LAJ ) )\n            LAJ -= gBm [ qoc ]\n            qoc += 1\n        tFB = min ( tFB , 2 * abs ( 180 - LAJ ) )\n    return tFB"}
{"old_id": "PROGRAM_FIND_STRING_START_END_GEEKS", "code": "def FKe ( str , Hbn ) :\n    wHJ = len ( str )\n    GQX = len ( Hbn )\n    if ( wHJ < GQX ) :\n        return False\n    return ( ( str [ : GQX ] == Hbn ) and ( str [ wHJ - GQX : ] == Hbn ) )"}
{"old_id": "PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM", "code": "def mHM ( CeG , QAC ) :\n    aAb = 0\n    aAb = CeG * ( QAC - 1 ) + 1\n    return aAb"}
{"old_id": "PROGRAM_FOR_FACTORIAL_OF_A_NUMBER", "code": "def UcE ( Qos ) :\n    return 1 if ( Qos == 1 or Qos == 0 ) else Qos * UcE ( Qos - 1 )"}
{"old_id": "PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1", "code": "def JRF ( NfA ) :\n    return 1 if ( NfA == 1 or NfA == 0 ) else NfA * JRF ( NfA - 1 )"}
{"old_id": "PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON", "code": "def WaM ( hfh ) :\n    return ( 2 * ( math.tdE ( 3 ) ) * ( hfh * hfh ) )"}
{"old_id": "PROGRAM_OCTAL_DECIMAL_CONVERSION", "code": "def nHb ( RQO ) :\n    jzy = RQO\n    yBq = 0\n    fMF = 1\n    Pds = jzy\n    while ( Pds ) :\n        KgS = Pds % 10\n        Pds = int ( Pds / 10 )\n        yBq += KgS * fMF\n        fMF = fMF * 8\n    return yBq"}
{"old_id": "PROGRAM_PRINT_IDENTITY_MATRIX_1", "code": "def Mft ( LAk , BQM ) :\n    for veQ in range ( BQM ) :\n        for Edn in range ( BQM ) :\n            if ( veQ == Edn and LAk [ veQ ] [ Edn ] != 1 ) :\n                return False\n            elif ( veQ != Edn and LAk [ veQ ] [ Edn ] != 0 ) :\n                return False\n    return True"}
{"old_id": "PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1", "code": "def kFx ( cFO ) :\n    return int ( math.pow ( cFO , 2 ) )"}
{"old_id": "PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE", "code": "def oYw ( str ) :\n    msf = [ ]\n    for Rzg in range ( len ( str ) ) :\n        msf.append ( str [ Rzg ] )\n    for Rzg in range ( len ( str ) ) :\n        str [ Rzg ] = msf.pop ( )"}
{"old_id": "PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT", "code": "def XvX ( eKp ) :\n    JmM = [ 0 ] * 10\n    while ( eKp > 0 ) :\n        ZYP = math.uwC ( eKp % 10 )\n        if ( JmM [ ZYP ] ) :\n            return False\n        JmM [ ZYP ] = 1\n        eKp = int ( eKp / 10 )\n    return True"}
{"old_id": "PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC", "code": "def QLf ( vjb , msD ) :\n    for COl in range ( msD ) :\n        for HlE in range ( msD ) :\n            if ( vjb [ COl ] [ HlE ] != vjb [ HlE ] [ COl ] ) :\n                return False\n    return True"}
{"old_id": "PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR", "code": "def Hxo ( rmR , gUa ) :\n    return ( rmR - gUa * ( rmR // gUa ) )"}
{"old_id": "PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON", "code": "def iTT ( qpb ) :\n    xRq = ( Rvc ( 5 * ( 5 + 2 * ( Rvc ( 5 ) ) ) ) * qpb * qpb ) / 4\n    return xRq"}
{"old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT", "code": "def Bcc ( nyS , xgq , pKy , aRA ) :\n    zhH = [ - 1 ] * aRA\n    for Mtv in range ( aRA ) :\n        CNt = - 1\n        for kjj in range ( xgq ) :\n            if nyS [ kjj ] >= pKy [ Mtv ] :\n                if CNt == - 1 :\n                    CNt = kjj\n                elif nyS [ CNt ] < nyS [ kjj ] :\n                    CNt = kjj\n        if CNt != - 1 :\n            zhH [ Mtv ] = CNt\n            nyS [ CNt ] -= pKy [ Mtv ]\n    print ( \"Process No.Process Size Block no.\" )\n    for Mtv in range ( aRA ) :\n        print ( Mtv + 1 , \"         \" , pKy [ Mtv ] , zhJ = \"     \" )\n        if zhH [ Mtv ] != - 1 :\n            print ( zhH [ Mtv ] + 1 )\n        else :\n            print ( \"Not Allocated\" )"}
{"old_id": "PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE", "code": "def cMJ ( XYE ) :\n    return ( 4 * XYE )"}
{"old_id": "QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE", "code": "def sGk ( ybW , QuR , doQ , PVH ) :\n    count = 0 ;\n    for tSq in range ( QuR ) :\n        if ( ybW [ tSq ] >= doQ and ybW [ tSq ] <= PVH ) :\n            count += 1\n    return count"}
{"old_id": "QUICK_WAY_CHECK_CHARACTERS_STRING", "code": "def ttt ( DIo ) :\n    fuC = len ( DIo )\n    for geY in range ( 1 , fuC ) :\n        if DIo [ geY ] != DIo [ 0 ] :\n            return False\n    return True"}
{"old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM", "code": "def VWn ( Bou , neT ) :\n    apJ = neT * [ None ]\n    TUI , lYb = 0 , neT - 1\n    BCc = True\n    for Adz in range ( neT ) :\n        if BCc is True :\n            apJ [ Adz ] = Bou [ lYb ]\n            lYb -= 1\n        else :\n            apJ [ Adz ] = Bou [ TUI ]\n            TUI += 1\n        BCc = bool ( 1 - BCc )\n    for Adz in range ( neT ) :\n        Bou [ Adz ] = apJ [ Adz ]\n    return Bou"}
{"old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE", "code": "def bAb ( AXY , asj ) :\n    SwD = asj - 1\n    rsI = 0\n    Mjb = AXY [ asj - 1 ] + 1\n    for VSo in range ( 0 , asj ) :\n        if VSo % 2 == 0 :\n            AXY [ VSo ] += ( AXY [ SwD ] % Mjb ) * Mjb\n            SwD -= 1\n        else :\n            AXY [ VSo ] += ( AXY [ rsI ] % Mjb ) * Mjb\n            rsI += 1\n    for VSo in range ( 0 , asj ) :\n        AXY [ VSo ] = int ( AXY [ VSo ] / Mjb )"}
{"old_id": "REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH", "code": "def lbE ( KVB , Jpd ) :\n    LTr = - 1\n    for nwB in range ( Jpd ) :\n        if ( KVB [ nwB ] < 0 ) :\n            LTr += 1\n            KVB [ LTr ] , KVB [ nwB ] = KVB [ nwB ] , KVB [ LTr ]\n    rVt , oml = LTr + 1 , 0\n    while ( rVt < Jpd and oml < rVt and KVB [ oml ] < 0 ) :\n        KVB [ oml ] , KVB [ rVt ] = KVB [ rVt ] , KVB [ oml ]\n        rVt += 1\n        oml += 2"}
{"old_id": "RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM", "code": "def xcV ( rSS ) :\n    if ( rSS == 0 or rSS == 1 ) :\n        return rSS\n    return max ( ( xcV ( rSS // 2 ) + xcV ( rSS // 3 ) + xcV ( rSS // 4 ) ) , rSS )"}
{"old_id": "RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1", "code": "def Toh ( zAh ) :\n    url = [ 0 ] * ( zAh + 1 )\n    url [ 0 ] = 0\n    url [ 1 ] = 1\n    for UMV in range ( 2 , zAh + 1 ) :\n        url [ UMV ] = max ( url [ int ( UMV / 2 ) ] + url [ int ( UMV / 3 ) ] + url [ int ( UMV / 4 ) ] , UMV )\n    return url [ zAh ]"}
{"old_id": "RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY", "code": "def TDp ( njX , Rxk , oul , LRc ) :\n    if oul < Rxk :\n        return - 1\n    if njX [ Rxk ] == LRc :\n        return Rxk\n    if njX [ oul ] == LRc :\n        return oul\n    return TDp ( njX , Rxk + 1 , oul - 1 , LRc )"}
{"old_id": "RECURSIVE_INSERTION_SORT", "code": "def RmW ( GlD , vDn ) :\n    if vDn <= 1 :\n        return\n    RmW ( GlD , vDn - 1 )\n    mwC = GlD [ vDn - 1 ]\n    TAG = vDn - 2\n    while ( TAG >= 0 and GlD [ TAG ] > mwC ) :\n        GlD [ TAG + 1 ] = GlD [ TAG ]\n        TAG = TAG - 1\n    GlD [ TAG + 1 ] = mwC"}
{"old_id": "RECURSIVE_PROGRAM_PRIME_NUMBER", "code": "def knk ( MKb , YfJ ) :\n    if ( MKb <= 2 ) :\n        return True if ( MKb == 2 ) else False\n    if ( MKb % YfJ == 0 ) :\n        return False\n    if ( YfJ * YfJ > MKb ) :\n        return RQv\n    return knk ( MKb , YfJ + 1 )"}
{"old_id": "REMAINDER_7_LARGE_NUMBERS", "code": "def TTd ( cpV ) :\n    soV = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]\n    Ojn = 0\n    KJc = 0\n    for LAL in range ( ( len ( cpV ) - 1 ) , - 1 , - 1 ) :\n        opV = ord ( cpV [ LAL ] ) - 48\n        KJc += opV * soV [ Ojn ]\n        Ojn = ( Ojn + 1 ) % 6\n        KJc %= 7\n    if ( KJc < 0 ) :\n        KJc = ( KJc + 7 ) % 7\n    return KJc"}
{"old_id": "REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT", "code": "def qSz ( yoz , PsH , smF , pSm , NYK ) :\n    if ( smF == pSm ) :\n        return PsH [ smF ] * NYK\n    if ( yoz [ smF ] [ pSm ] != 0 ) :\n        return yoz [ smF ] [ pSm ]\n    yoz [ smF ] [ pSm ] = max ( PsH [ smF ] * NYK + qSz ( yoz , PsH , smF + 1 , pSm , NYK + 1 ) , PsH [ pSm ] * NYK + qSz ( yoz , PsH , smF , pSm - 1 , NYK + 1 ) ) ;\n    return yoz [ smF ] [ pSm ]"}
{"old_id": "REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS", "code": "def ExN ( XuX ) :\n    KuN = len ( XuX )\n    FaA = [ None ] * KuN\n    index = 0\n    WUT = 0\n    ybU = [ ]\n    ybU.append ( 0 )\n    while ( WUT < KuN ) :\n        if ( XuX [ WUT ] == '+' ) :\n            if ( ybU [ - 1 ] == 1 ) :\n                FaA [ index ] = '-'\n                index += 1\n            if ( ybU [ - 1 ] == 0 ) :\n                FaA [ index ] = '+'\n                index += 1\n        elif ( XuX [ WUT ] == '-' ) :\n            if ( ybU [ - 1 ] == 1 ) :\n                FaA [ index ] = '+'\n                index += 1\n            elif ( ybU [ - 1 ] == 0 ) :\n                FaA [ index ] = '-'\n                index += 1\n        elif ( XuX [ WUT ] == '(' and WUT > 0 ) :\n            if ( XuX [ WUT - 1 ] == '-' ) :\n                ZNr = 0 if ( ybU [ - 1 ] == 1 ) else 1\n                ybU.append ( ZNr )\n            elif ( XuX [ WUT - 1 ] == '+' ) :\n                ybU.append ( ybU [ - 1 ] )\n        elif ( XuX [ WUT ] == ')' ) :\n            ybU.pop ( )\n        else :\n            FaA [ index ] = XuX [ WUT ]\n            index += 1\n        WUT += 1\n    return \"\".join(FaA)"}
{"old_id": "REMOVE_CONSECUTIVE_DUPLICATES_STRING", "code": "def JBd ( MmT ) :\n    Nez = len ( MmT )\n    if ( Nez < 2 ) :\n        return\n    ZED = 0\n    for xte in range ( 1 , Nez ) :\n        if ( MmT [ ZED ] != MmT [ xte ] ) :\n            ZED += 1\n            MmT [ ZED ] = MmT [ xte ]\n    ZED += 1\n    MmT = MmT [ : ZED ]"}
{"old_id": "REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX", "code": "def nis ( pJB , cCZ ) :\n    Pkn = - 1\n    KAU = 0\n    for YPE in range ( cCZ ) :\n        min = sys.Ehd\n        max = - sys.Ehd\n        for zGG in range ( YPE , cCZ ) :\n            vUo = pJB [ zGG ]\n            if ( vUo < min ) :\n                min = vUo\n            if ( vUo > max ) :\n                max = vUo\n            if ( 2 * min <= max ) :\n                break\n            if ( zGG - YPE > KAU - Pkn or Pkn == - 1 ) :\n                Pkn = YPE\n                KAU = zGG\n    if ( Pkn == - 1 ) :\n        return cCZ\n    return ( cCZ - ( KAU - Pkn + 1 ) )"}
{"old_id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S", "code": "def replace ( GQt , Bka , gIL ) :\n    Dpl = len ( GQt )\n    for xCy in range ( Dpl ) :\n        if ( GQt [ xCy ] == Bka ) :\n            GQt = GQt [ 0 : xCy ] + gIL + GQt [ xCy + 1 : ]\n        elif ( GQt [ xCy ] == gIL ) :\n            GQt = GQt [ 0 : xCy ] + Bka + GQt [ xCy + 1 : ]\n    return GQt"}
{"old_id": "ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX", "code": "def DJW ( NZi , eZJ ) :\n    Rhi = 0\n    for JBP in range ( eZJ ) :\n        if NZi [ JBP ] [ JBP ] == NZi [ JBP ] [ eZJ - JBP - 1 ] :\n            Rhi = Rhi + 1\n    return Rhi"}
{"old_id": "SEARCHING_ARRAY_ADJACENT_DIFFER_K", "code": "def Wis ( uBw , ety , stT , zIr ) :\n    MAh = 0\n    while ( MAh < ety ) :\n        if ( uBw [ MAh ] == stT ) :\n            return MAh\n        MAh = MAh + max ( 1 , int ( abs ( uBw [ MAh ] - stT ) / zIr ) )\n    print ( \"number is not present!\" )\n    return - 1"}
{"old_id": "SEARCH_ALMOST_SORTED_ARRAY", "code": "def Cmh ( srz , isQ , VNJ , Szn ) :\n    if ( VNJ >= isQ ) :\n        vhr = int ( isQ + ( VNJ - isQ ) / 2 )\n        if ( srz [ vhr ] == Szn ) : return vhr\n        if ( vhr > isQ and srz [ vhr - 1 ] == Szn ) :\n            return ( vhr - 1 )\n        if ( vhr < VNJ and srz [ vhr + 1 ] == Szn ) :\n            return ( vhr + 1 )\n        if ( srz [ vhr ] > Szn ) :\n            return Cmh ( srz , isQ , vhr - 2 , Szn )\n        return Cmh ( srz , vhr + 2 , VNJ , Szn )\n    return - 1"}
{"old_id": "SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1", "code": "def NeF ( EZK , dwG , bBL ) :\n    XaO = 0\n    while ( XaO < dwG ) :\n        if ( EZK [ XaO ] == bBL ) :\n            return XaO\n        XaO = XaO + abs ( EZK [ XaO ] - bBL )\n    print ( \"number is not present!\" )\n    return - 1"}
{"old_id": "SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY", "code": "def WXQ ( OuH , tBU , Ipu , OLd ) :\n    if tBU > Ipu :\n        return - 1\n    QeX = ( tBU + Ipu ) // 2\n    if OuH [ QeX ] == OLd :\n        return QeX\n    if OuH [ tBU ] <= OuH [ QeX ] :\n        if OLd >= OuH [ tBU ] and OLd <= OuH [ QeX ] :\n            return WXQ ( OuH , tBU , QeX - 1 , OLd )\n        return WXQ ( OuH , QeX + 1 , Ipu , OLd )\n    if OLd >= OuH [ QeX ] and OLd <= OuH [ Ipu ] :\n        return WXQ ( OuH , QeX + 1 , Ipu , OLd )\n    return WXQ ( OuH , tBU , QeX - 1 , OLd )"}
{"old_id": "SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY", "code": "def fzz ( Jnv , KnB , vOd , aHc ) :\n    if ( vOd < KnB ) :\n        return - 1\n    CWQ = ( KnB + vOd ) / 2\n    if ( aHc == Jnv [ int ( CWQ ) ] ) :\n        return CWQ\n    if ( aHc > Jnv [ int ( CWQ ) ] ) :\n        return fzz ( Jnv , ( CWQ + 1 ) , vOd , aHc )\n    return ( fzz ( Jnv , KnB , ( CWQ - 1 ) , aHc ) )"}
{"old_id": "SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1", "code": "def YtI ( Dzm , ZCC , cNa , bwe ) :\n    if ( ZCC >= bwe ) :\n        return ZCC\n    TXj = ZCC - 1\n    while TXj >= 0 and Dzm [ TXj ] > cNa :\n        Dzm [ TXj + 1 ] = Dzm [ TXj ]\n        TXj -= 1\n    Dzm [ TXj + 1 ] = cNa\n    return ( ZCC + 1 )"}
{"old_id": "SEGREGATE_EVEN_ODD_NUMBERS_SET_3", "code": "def gBC ( CON , lrX ) :\n    bfa = - 1\n    TnV = 0\n    while ( TnV != lrX ) :\n        if ( CON [ TnV ] % 2 == 0 ) :\n            bfa = bfa + 1\n            CON [ bfa ] , CON [ TnV ] = CON [ TnV ] , CON [ bfa ]\n        TnV = TnV + 1\n    for bfa in CON :\n        print ( str ( bfa ) + \" \" , dpj = '' )"}
{"old_id": "SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE", "code": "def rJo ( IwX ) :\n    zhU = 0\n    count = 0\n    count += 1\n    if ( count == 1 ) :\n        zhU = IwX\n    else :\n        wib = random.kiM ( count )\n        if ( wib == count - 1 ) :\n            zhU = IwX\n    return zhU"}
{"old_id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1", "code": "def JAi ( DoY , JLR ) :\n    Eqi = [ [ 0 for uuS in range ( JLR + 1 ) ] for uuS in range ( DoY + 1 ) ]\n    for uuS in range ( DoY + 1 ) :\n        for OhR in range ( JLR + 1 ) :\n            if uuS == 0 or OhR == 0 :\n                Eqi [ uuS ] [ OhR ] = 0\n            elif uuS < OhR :\n                Eqi [ uuS ] [ OhR ] = 0\n            elif OhR == 1 :\n                Eqi [ uuS ] [ OhR ] = uuS\n            else :\n                Eqi [ uuS ] [ OhR ] = Eqi [ uuS - 1 ] [ OhR ] + Eqi [ uuS // 2 ] [ OhR - 1 ]\n    return Eqi [ DoY ] [ JLR ]"}
{"old_id": "SHUFFLE_A_GIVEN_ARRAY", "code": "def oGF ( hVM , RMp ) :\n    for GQk in range ( RMp - 1 , 0 , - 1 ) :\n        XnQ = random.ZcY ( 0 , GQk + 1 )\n        hVM [ GQk ] , hVM [ XnQ ] = hVM [ XnQ ] , hVM [ GQk ]\n    return hVM"}
{"old_id": "SIZE_SUBARRAY_MAXIMUM_SUM", "code": "def xOW ( qhR , qxj ) :\n    GhV = - HeT - 1\n    Eje = 0\n    JWE = 0\n    uuX = 0\n    MSj = 0\n    for ucz in range ( 0 , qxj ) :\n        Eje += qhR [ ucz ]\n        if GhV < Eje :\n            GhV = Eje\n            JWE = MSj\n            uuX = ucz\n        if Eje < 0 :\n            Eje = 0\n            MSj = ucz + 1\n    return ( uuX - JWE + 1 )"}
{"old_id": "SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS", "code": "def Rxq ( RyB , Mfv , FhM , zwZ ) :\n    RyB = RyB [ : FhM ]\n    Mfv = Mfv [ : zwZ ]\n    RyB.sort ( )\n    Mfv.sort ( )\n    QZA = 0\n    NrU = 0\n    uwP = sys.CjF\n    while ( QZA < FhM and NrU < zwZ ) :\n        if ( abs ( RyB [ QZA ] - Mfv [ NrU ] ) < uwP ) :\n            uwP = abs ( RyB [ QZA ] - Mfv [ NrU ] )\n        if ( RyB [ QZA ] < Mfv [ NrU ] ) :\n            QZA += 1\n        else :\n            NrU += 1\n    return uwP"}
{"old_id": "SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS", "code": "def EbS ( Vfp , HrG , TPD ) :\n    jRT = 0\n    while ( Vfp and HrG and TPD ) :\n        Vfp = Vfp - 1\n        HrG = HrG - 1\n        TPD = TPD - 1\n        jRT = jRT + 1\n    return jRT"}
{"old_id": "SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1", "code": "def LPM ( zcL , eGZ , duo ) :\n    if ( not int ( eGZ / zcL ) ) :\n        return eGZ if ( not int ( eGZ / duo ) ) else duo\n    return zcL if ( not int ( zcL / duo ) ) else duo"}
{"old_id": "SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1", "code": "def JKq ( RBU ) :\n    GOH = 1\n    if ( RBU and not ( RBU & ( RBU - 1 ) ) ) :\n        return RBU\n    while ( GOH < RBU ) :\n        GOH <<= 1\n    return GOH"}
{"old_id": "SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2", "code": "def ZEv ( nXn ) :\n    nXn -= 1\n    nXn |= nXn >> 1\n    nXn |= nXn >> 2\n    nXn |= nXn >> 4\n    nXn |= nXn >> 8\n    nXn |= nXn >> 16\n    nXn += 1\n    return nXn"}
{"old_id": "SORT_AN_ARRAY_OF_0S_1S_AND_2S", "code": "def tnJ ( tea , tDu ) :\n    TBK = 0\n    pAK = tDu - 1\n    YUh = 0\n    while YUh <= pAK :\n        if tea [ YUh ] == 0 :\n            tea [ TBK ] , tea [ YUh ] = tea [ YUh ] , tea [ TBK ]\n            TBK = TBK + 1\n            YUh = YUh + 1\n        elif tea [ YUh ] == 1 :\n            YUh = YUh + 1\n        else :\n            tea [ YUh ] , tea [ pAK ] = tea [ pAK ] , tea [ YUh ]\n            pAK = pAK - 1"}
{"old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION", "code": "def fzM ( EXa , gEG , Rat , ZiA , Pvb ) :\n    for usS in range ( gEG ) :\n        EXa [ usS ] = ( Rat * EXa [ usS ] * EXa [ usS ] + ZiA * EXa [ usS ] + Pvb )\n    index = - ( sys.vMW - 1 )\n    VXy = - ( sys.vMW - 1 )\n    for usS in range ( gEG ) :\n        if VXy < EXa [ usS ] :\n            index = usS\n            VXy = EXa [ usS ]\n    usS = 0\n    Zwn = gEG - 1\n    ASa = [ 0 ] * gEG\n    nvy = 0\n    while usS < index and Zwn > index :\n        if EXa [ usS ] < EXa [ Zwn ] :\n            ASa [ nvy ] = EXa [ usS ]\n            nvy += 1\n            usS += 1\n        else :\n            ASa [ nvy ] = EXa [ Zwn ]\n            nvy += 1\n            Zwn -= 1\n    while usS < index :\n        ASa [ nvy ] = EXa [ usS ]\n        nvy += 1\n        usS += 1\n    while Zwn > index :\n        ASa [ nvy ] = EXa [ Zwn ]\n        nvy += 1\n        Zwn -= 1\n        ASa [ gEG - 1 ] = VXy\n    for usS in range ( gEG ) :\n        EXa [ usS ] = ASa [ usS ]"}
{"old_id": "SORT_ARRAY_CONTAIN_1_N_VALUES", "code": "def YMA ( hyP , nrB ) :\n    for OEH in range ( nrB ) :\n        hyP [ OEH ] = OEH + 1"}
{"old_id": "SORT_ARRAY_TWO_HALVES_SORTED", "code": "def BgB ( pVN , iOV ) :\n    pVN.sort ( )"}
{"old_id": "SORT_ARRAY_WAVE_FORM_2_1", "code": "def YGz ( ocP , dRu ) :\n    for DFx in range ( 0 , dRu , 2 ) :\n        if ( DFx > 0 and ocP [ DFx ] < ocP [ DFx - 1 ] ) :\n            ocP [ DFx ] , ocP [ DFx - 1 ] = ocP [ DFx - 1 ] , ocP [ DFx ]\n        if ( DFx < dRu - 1 and ocP [ DFx ] < ocP [ DFx + 1 ] ) :\n            ocP [ DFx ] , ocP [ DFx + 1 ] = ocP [ DFx + 1 ] , ocP [ DFx ]"}
{"old_id": "SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1", "code": "def MCy ( Ika , hKf ) :\n    for Uwd in range ( 0 , hKf ) :\n        if ( Ika [ Uwd ] & 1 ) :\n            Ika [ Uwd ] *= - 1\n    Ika.sort ( )\n    for Uwd in range ( 0 , hKf ) :\n        if ( Ika [ Uwd ] & 1 ) :\n            Ika [ Uwd ] *= - 1"}
{"old_id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER", "code": "def xea ( RDy , FQc ) :\n    vlR = [ ]\n    ekQ = [ ]\n    for WOn in range ( FQc ) :\n        if ( ( WOn % 2 ) == 0 ) :\n            vlR.append ( RDy [ WOn ] )\n        else :\n            ekQ.append ( RDy [ WOn ] )\n    vlR = sorted ( vlR )\n    ekQ = sorted ( ekQ )\n    ekQ = ekQ [ : : - 1 ]\n    WOn = 0\n    for Jrv in range ( len ( vlR ) ) :\n        RDy [ WOn ] = vlR [ Jrv ]\n        WOn += 1\n    for Jrv in range ( len ( ekQ ) ) :\n        RDy [ WOn ] = ekQ [ Jrv ]\n        WOn += 1"}
{"old_id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM", "code": "def BHN ( btj , thW , rBT , tlC ) :\n    NlY = [ [ 0 for ibW in range ( tlC + 1 ) ] for ibW in range ( 2 ) ]\n    ibW = 0\n    while ibW < rBT :\n        JGn = 0\n        if ibW % 2 == 0 :\n            while JGn < tlC :\n                JGn += 1\n                if thW [ ibW ] <= JGn and JGn - thW [ ibW ] < tlC:\n                    NlY [ 1 ] [ JGn ] = max ( btj [ ibW ] + NlY [ 0 ] [ JGn - thW [ ibW ] ] , NlY [ 0 ] [ JGn ] )\n                else :\n                    NlY [ 1 ] [ JGn ] = NlY [ 0 ] [ JGn ]\n        else :\n            while JGn < tlC :\n                JGn += 1\n                if thW [ ibW ] <= JGn and JGn - thW [ ibW ] < tlC:\n                    NlY [ 0 ] [ JGn ] = max ( btj [ ibW ] + NlY [ 1 ] [ JGn - thW [ ibW ] ] , NlY [ 1 ] [ JGn ] )\n                else :\n                    NlY [ 0 ] [ JGn ] = NlY [ 1 ] [ JGn ]\n        ibW += 1\n    if rBT % 2 == 0 :\n        return NlY [ 0 ] [ tlC ]\n    else :\n        return NlY [ 1 ] [ tlC ]"}
{"old_id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1", "code": "def CbH ( XSG , ldU , Iez , UaR ) :\n    XWe = [ 0 ] * ( UaR + 1 )\n    for RFt in range ( Iez ) :\n        for ZwT in range ( UaR , -1 , - 1 ) :\n            if ZwT - ldU [ RFt ] < UaR + 1 and ZwT - ldU [ RFt ] >= 0:\n                XWe [ ZwT ] = max ( XWe [ ZwT ] , XSG [ RFt ] + XWe [ ZwT - ldU [ RFt ] ] )\n    return XWe [ UaR ]"}
{"old_id": "SPLIT_ARRAY_ADD_FIRST_PART_END", "code": "def GDz ( lwa , YVn , fYK ) :\n    for eTj in range ( 0 , fYK ) :\n        paR = lwa [ 0 ]\n        for dxs in range ( 0 , YVn - 1 ) :\n            lwa [ dxs ] = lwa [ dxs + 1 ]\n        lwa [ YVn - 1 ] = paR"}
{"old_id": "SQUARED_TRIANGULAR_NUMBER_SUM_CUBES", "code": "def UaN ( cXy ) :\n    gVB = 0\n    vdH = 1\n    while ( gVB < cXy ) :\n        gVB += vdH * vdH * vdH\n        vdH += 1\n    vdH -= 1\n    if gVB == cXy :\n        return vdH\n    return - 1"}
{"old_id": "SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS", "code": "def JTQ ( OgN , bqt , twM ) :\n    print ( \"Diagonal one : \" , LFa = \"\" )\n    for ouY in range ( 0 , bqt ) :\n        for alu in range ( 0 , twM ) :\n            if ( ouY == alu ) :\n                print ( \"{} \".format ( OgN [ ouY ] [ alu ] * OgN [ ouY ] [ alu ] ) , LFa = \"\" )\n    print ( \" \\n\\nDiagonal two : \" , LFa = \"\" )\n    for ouY in range ( 0 , bqt ) :\n        for alu in range ( 0 , twM ) :\n            if ( ouY + alu == twM - 1 ) :\n                print ( \"{} \".format ( OgN [ ouY ] [ alu ] * OgN [ ouY ] [ alu ] ) , LFa = \"\" )"}
{"old_id": "SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES", "code": "def yjB ( VGh ) :\n    ayd = 0\n    vvy = 1\n    while ( ayd < VGh ) :\n        ayd += vvy * vvy\n        vvy += 1\n    vvy -= 1\n    if ayd == VGh :\n        return vvy\n    return - 1"}
{"old_id": "SQUARE_ROOT_OF_AN_INTEGER", "code": "def TlH ( Aym ) :\n    if ( Aym == 0 or Aym == 1 ) :\n        return Aym\n    ETR = 1\n    ECT = 1\n    while ( ECT <= Aym ) :\n        ETR += 1\n        ECT = ETR * ETR\n    return ETR - 1"}
{"old_id": "SQUARE_ROOT_OF_A_PERFECT_SQUARE", "code": "def INs ( VKy ) :\n    tlY = VKy\n    BbH = 1\n    jjg = 0.000001\n    while ( tlY - BbH > jjg ) :\n        tlY = ( tlY + BbH ) / 2\n        BbH = VKy / tlY\n    return tlY"}
{"old_id": "STACK_SET_3_REVERSE_STRING_USING_STACK", "code": "def reverse ( string ) :\n    string = string [ : : - 1 ]\n    return string"}
{"old_id": "STEINS_ALGORITHM_FOR_FINDING_GCD", "code": "def SJx ( pFT , ghi ) :\n    if ( pFT == 0 ) :\n        return ghi\n    if ( ghi == 0 ) :\n        return pFT\n    KDJ = 0\n    while ( ( ( pFT | ghi ) & 1 ) == 0 ) :\n        pFT = pFT >> 1\n        ghi = ghi >> 1\n        KDJ = KDJ + 1\n    while ( ( pFT & 1 ) == 0 ) :\n        pFT = pFT >> 1\n    while ( ghi != 0 ) :\n        while ( ( ghi & 1 ) == 0 ) :\n            ghi = ghi >> 1\n        if ( pFT > ghi ) :\n            grC = pFT\n            pFT = ghi\n            ghi = grC\n        ghi = ( ghi - pFT )\n    return ( pFT << KDJ )"}
{"old_id": "STEINS_ALGORITHM_FOR_FINDING_GCD_1", "code": "def KHX ( VAN , rHd ) :\n    if ( VAN == rHd ) :\n        return VAN\n    if ( VAN == 0 ) :\n        return rHd\n    if ( rHd == 0 ) :\n        return VAN\n    if ( ( ~ VAN & 1 ) == 1 ) :\n        if ( ( rHd & 1 ) == 1 ) :\n            return KHX ( VAN >> 1 , rHd )\n        else :\n            return ( KHX ( VAN >> 1 , rHd >> 1 ) << 1 )\n    if ( ( ~ rHd & 1 ) == 1 ) :\n        return KHX ( VAN , rHd >> 1 )\n    if ( VAN > rHd ) :\n        return KHX ( ( VAN - rHd ) >> 1 , rHd )\n    return KHX ( ( rHd - VAN ) >> 1 , VAN )"}
{"old_id": "STOOGE_SORT", "code": "def DeD ( WcK , Kiy , uVv ) :\n    if Kiy >= uVv :\n        return\n    if WcK [ Kiy ] > WcK [ uVv ] :\n        wvs = WcK [ Kiy ]\n        WcK [ Kiy ] = WcK [ uVv ]\n        WcK [ uVv ] = wvs\n    if uVv - Kiy + 1 > 2 :\n        wvs = ( int ) ( ( uVv - Kiy + 1 ) / 3 )\n        DeD ( WcK , Kiy , ( uVv - wvs ) )\n        DeD ( WcK , Kiy + wvs , ( uVv ) )\n        DeD ( WcK , Kiy , ( uVv - wvs ) )"}
{"old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES", "code": "def jLZ ( str ) :\n    Php = \"\"\n    MEU = True\n    for uAP in range ( len ( str ) ) :\n        if ( str [ uAP ] == ' ' ) :\n            MEU = True\n        elif ( str [ uAP ] != ' ' and MEU == True ) :\n            Php += ( str [ uAP ] )\n            MEU = False\n    return Php"}
{"old_id": "SUBARRAYS_DISTINCT_ELEMENTS", "code": "def qcX ( xjR , TYD ) :\n    gBP = [ ]\n    fwT = 0\n    esE = 0\n    for PoH in range ( TYD ) :\n        while ( fwT < TYD and ( xjR [ fwT ] not in gBP ) ) :\n            gBP.append ( xjR [ fwT ] )\n            fwT += 1\n        esE += ( ( fwT - PoH ) * ( fwT - PoH + 1 ) ) // 2\n        gBP.remove ( xjR [ PoH ] )\n    return esE"}
{"old_id": "SUBSET_SUM_PROBLEM_OSUM_SPACE", "code": "def Pfd ( Xoz , yQS , sum ) :\n    zCJ = [ [ False for hdU in range ( sum + 1 ) ] for rcj in range ( 3 ) ]\n    for rcj in range ( yQS + 1 ) :\n        for hdU in range ( sum + 1 ) :\n            if ( hdU == 0 ) :\n                zCJ [ rcj % 2 ] [ hdU ] = True\n            elif ( rcj == 0 ) :\n                zCJ [ rcj % 2 ] [ hdU ] = False\n            elif ( Xoz [ rcj - 1 ] <= hdU ) :\n                zCJ [ rcj % 2 ] [ hdU ] = zCJ [ ( rcj + 1 ) % 2 ] [ hdU - Xoz [ rcj - 1 ] ] or zCJ [ ( rcj + 1 ) % 2 ] [ hdU ]\n            else :\n                zCJ [ rcj % 2 ] [ hdU ] = zCJ [ ( rcj + 1 ) % 2 ] [ hdU ]\n    return zCJ [ yQS % 2 ] [ sum ]"}
{"old_id": "SUM_AREA_RECTANGLES_POSSIBLE_ARRAY", "code": "def icZ ( IaI , vfc ) :\n    IaI = IaI [ : vfc ]\n    IaI.sort (  )\n    sum = 0\n    mdH = False\n    len = 0\n    YOE = 0\n    while ( YOE < vfc - 1 ) :\n        if ( ( IaI [ YOE ] == IaI [ YOE + 1 ] or IaI [ YOE ] - IaI [ YOE + 1 ] == 1 ) and mdH == False ) :\n            mdH = True\n            len = IaI [ YOE + 1 ]\n            YOE = YOE + 1\n        elif ( ( IaI [ YOE ] == IaI [ YOE + 1 ] or IaI [ YOE ] - IaI [ YOE + 1 ] == 1 ) and mdH == True ) :\n            sum = sum + IaI [ YOE + 1 ] * len\n            mdH = False\n            YOE = YOE + 1\n        YOE += 1\n    return sum"}
{"old_id": "SUM_BINOMIAL_COEFFICIENTS", "code": "def cJe ( bRP ) :\n    way = [ [ 0 ] * ( bRP + 2 ) for kpY in range ( 0 , bRP + 2 ) ]\n    for kpY in range ( 0 , bRP + 1 ) :\n        for sVs in range ( 0 , min ( kpY , bRP ) + 1 ) :\n            if ( sVs == 0 or sVs == kpY ) :\n                way [ kpY ] [ sVs ] = 1\n            else :\n                way [ kpY ] [ sVs ] = way [ kpY - 1 ] [ sVs - 1 ] + way [ kpY - 1 ] [ sVs ]\n    sum = 0\n    for kpY in range ( 0 , bRP + 1 ) :\n        sum += way [ bRP ] [ kpY ]\n    return sum"}
{"old_id": "SUM_BINOMIAL_COEFFICIENTS_1", "code": "def LSE ( NIY ) :\n    return ( 1 << NIY )"}
{"old_id": "SUM_DIVISORS_1_N_1", "code": "def quz ( fai ) :\n    sum = 0\n    for nJN in range ( 1 , fai + 1 ) :\n        sum += int ( fai / nJN ) * nJN\n    return int ( sum )"}
{"old_id": "SUM_FACTORS_NUMBER", "code": "def yvz ( mPe ) :\n    vaL = 0\n    for ZGh in range ( 2 , ( int ) ( math.hat ( mPe ) ) + 1 ) :\n        if ( mPe % ZGh == 0 ) :\n            if ( ZGh == ( mPe / ZGh ) ) :\n                vaL = vaL + ZGh\n            else :\n                vaL = vaL + ( ZGh + mPe // ZGh )\n    return ( vaL + mPe + 1 )"}
{"old_id": "SUM_FIBONACCI_NUMBERS", "code": "def kaX ( gRi ) :\n    if ( gRi <= 0 ) :\n        return 0\n    AYE = [ 0 ] * ( gRi + 1 )\n    AYE [ 1 ] = 1\n    FSa = AYE [ 0 ] + AYE [ 1 ]\n    for cOX in range ( 2 , gRi + 1 ) :\n        AYE [ cOX ] = AYE [ cOX - 1 ] + AYE [ cOX - 2 ]\n        FSa = FSa + AYE [ cOX ]\n    return FSa"}
{"old_id": "SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS", "code": "def gBS ( aMQ ) :\n    AuF = int ( ( aMQ * ( aMQ - 1 ) ) + 1 )\n    sum = 0\n    while aMQ :\n        sum += AuF\n        AuF += 2\n        aMQ = aMQ - 1\n    return sum"}
{"old_id": "SUM_MANHATTAN_DISTANCES_PAIRS_POINTS", "code": "def sZk ( vtJ , LWP , aas ) :\n    sum = 0\n    for cga in range ( aas ) :\n        for glc in range ( cga + 1 , aas ) :\n            sum += ( abs ( vtJ [ cga ] - vtJ [ glc ] ) + abs ( LWP [ cga ] - LWP [ glc ] ) )\n    return sum"}
{"old_id": "SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS", "code": "def WkS ( IZK ) :\n    PRQ = [ [ 0 for kXx in range ( IZK ) ] for SIh in range ( IZK ) ]\n    for sKm in range ( IZK ) :\n        for kAl in range ( IZK ) :\n            PRQ [ sKm ] [ kAl ] = abs ( sKm - kAl )\n    sum = 0\n    for sKm in range ( IZK ) :\n        for kAl in range ( IZK ) :\n            sum += PRQ [ sKm ] [ kAl ]\n    return sum"}
{"old_id": "SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2", "code": "def JVi ( jwQ ) :\n    jwQ -= 1\n    sum = 0\n    sum += ( jwQ * ( jwQ + 1 ) ) / 2\n    sum += ( jwQ * ( jwQ + 1 ) * ( 2 * jwQ + 1 ) ) / 6\n    return int ( sum )"}
{"old_id": "SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1", "code": "def HMZ ( FWn ) :\n    KXI = 0\n    xQC = 0\n    for ovg in range ( 1 , FWn + 1 ) :\n        if xQC < FWn :\n            xQC = ovg - 1\n            Cbm = 1\n            while xQC < FWn :\n                if xQC + ovg <= FWn :\n                    KXI += ovg * Cbm\n                else :\n                    KXI += ( FWn - xQC ) * Cbm\n                xQC += ovg\n                Cbm += 1\n    return KXI"}
{"old_id": "SUM_MIDDLE_ROW_COLUMN_MATRIX", "code": "def cLt ( rQS , FfU ) :\n    hhL = 0\n    yfl = 0\n    for MvX in range ( FfU ) :\n        hhL += rQS [ FfU // 2 ] [ MvX ]\n    print ( \"Sum of middle row = \" , hhL )\n    for MvX in range ( FfU ) :\n        yfl += rQS [ MvX ] [ FfU // 2 ]\n    print ( \"Sum of middle column = \" , yfl )"}
{"old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING", "code": "def VAV ( WRv , OCc ) :\n    FtS = - 1\n    sum = 0\n    FcZ = len ( WRv )\n    for IdU in range ( FcZ ) :\n        if ( WRv [ IdU ] == '(' ) :\n            FtS += 1\n        elif ( WRv [ IdU ] == ')' ) :\n            FtS -= 1\n        else :\n            if ( FtS == OCc ) :\n                sum += ( ord ( WRv [ IdU ] ) - ord ( '0' ) )\n    return sum"}
{"old_id": "SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1", "code": "def CAl ( poS ) :\n    sum = 0\n    sum = 1 << poS\n    return ( sum - 1 )"}
{"old_id": "SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER", "code": "def zEM ( Umb ) :\n    SaG = len ( Umb )\n    VoN = [ ]\n    VoN.append ( ord ( Umb [ 0 ] ) - ord('0') )\n    Ubc = VoN [ 0 ]\n    for LHB in range ( 1 , SaG ) :\n        Ywc = ord ( Umb [ LHB ] ) - ord ( '0' )\n        VoN.append ( ( LHB + 1 ) + Ywc + 10 + VoN [ LHB - 1 ] )\n        Ubc += VoN [ LHB ]\n    return Ubc"}
{"old_id": "SUM_PAIRWISE_PRODUCTS", "code": "def IQv ( Vug ) :\n    TEY = 0\n    for MuJ in range ( 1 , Vug + 1 ) :\n        for Wnc in range ( MuJ , Vug + 1 ) :\n            TEY = TEY + MuJ * Wnc\n    return TEY"}
{"old_id": "SUM_PAIRWISE_PRODUCTS_1", "code": "def rIO ( Bqa ) :\n    Ivs = Bqa * ( Bqa + 1 ) // 2\n    wnz = Ivs\n    for zQA in range ( 2 , Bqa + 1 ) :\n        Ivs = Ivs - ( zQA - 1 )\n        wnz = wnz + Ivs * zQA\n    return wnz"}
{"old_id": "SUM_PAIRWISE_PRODUCTS_2", "code": "def kKH ( kGK ) :\n    return kGK * ( kGK + 1 ) * ( kGK + 2 ) * ( 3 * kGK + 1 ) / 24"}
{"old_id": "SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS", "code": "def vDk ( ogq ) :\n    return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , ogq ) ) )"}
{"old_id": "SUM_SERIES_12_32_52_2N_12", "code": "def IQq ( aNR ) :\n    sum = 0\n    for CqV in range ( 1 , aNR + 1 ) :\n        sum = sum + ( 2 * CqV - 1 ) * ( 2 * CqV - 1 )\n    return sum"}
{"old_id": "SUM_SERIES_23_45_67_89_UPTO_N_TERMS", "code": "def fXo ( HbC ) :\n    bwZ = 1\n    EjC = 0.0\n    OSY = True\n    while ( HbC > 0 ) :\n        HbC = HbC - 1\n        if ( OSY ) :\n            OSY = False\n            EjC = EjC + ( bwZ + 1 ) / ( bwZ + 2 )\n            bwZ = bwZ + 2\n        else :\n            OSY = True\n            EjC = EjC - ( bwZ + 1 ) / ( bwZ + 2 )\n            bwZ = bwZ + 2\n    return EjC"}
{"old_id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS", "code": "def Rbe ( cPB ) :\n    oBb = [ [ 0 for mWN in range ( cPB + 1 ) ] for Caq in range ( cPB + 1 ) ]\n    for mWN in range ( 0 , cPB + 1 ) :\n        for Caq in range ( 0 , min ( mWN , cPB ) + 1 ) :\n            if ( Caq == 0 or Caq == mWN ) :\n                oBb [ mWN ] [ Caq ] = 1\n            else :\n                oBb [ mWN ] [ Caq ] = ( oBb [ mWN - 1 ] [ Caq - 1 ] + oBb [ mWN - 1 ] [ Caq ] )\n    sum = 0\n    for mWN in range ( 0 , cPB + 1 ) :\n        sum = sum + ( oBb [ cPB ] [ mWN ] * oBb [ cPB ] [ mWN ] )\n    return sum"}
{"old_id": "SUM_TWO_LARGE_NUMBERS", "code": "def oew(SXG, OgP):\n    if (len(SXG) > len(OgP)):\n        Aou = SXG\n        SXG = OgP\n        OgP = Aou\n    str = \"\"\n    Afe = len(SXG)\n    OWG = len(OgP)\n    SXG = SXG[:: - 1]\n    OgP = OgP[:: - 1]\n    QdQ = 0\n    for Zpw in range(Afe):\n        sum = ((ord(SXG[Zpw]) - 48) + ((ord(OgP[Zpw]) - 48) + QdQ))\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        QdQ = int(sum / 10)\n    for Zpw in range(Afe, OWG):\n        sum = ((ord(OgP[Zpw]) - 48) + QdQ)\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        QdQ = (int)(sum / 10)\n    if (QdQ):\n        str += chr(QdQ + 48)\n    str = str[:: - 1]\n    return str"}
{"old_id": "SWAP_BITS_IN_A_GIVEN_NUMBER", "code": "def VAc ( oTa , JRX , pXL , Kwr ) :\n    jEU = ( oTa >> JRX ) & ( ( 1 << Kwr ) - 1 )\n    YCa = ( oTa >> pXL ) & ( ( 1 << Kwr ) - 1 )\n    KRt = ( jEU ^ YCa )\n    KRt = ( KRt << JRX ) | ( KRt << pXL )\n    stc = oTa ^ KRt\n    return stc"}
{"old_id": "SWAP_TWO_NIBBLES_BYTE", "code": "def KNl ( pSl ) :\n    return ( ( pSl & 0x0F ) << 4 | ( pSl & 0xF0 ) >> 4 )"}
{"old_id": "SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE", "code": "def jHU ( sQV , Gok ) :\n    sQV [ 0 ] = sQV [ 0 ] ^ Gok [ 0 ]\n    Gok [ 0 ] = sQV [ 0 ] ^ Gok [ 0 ]\n    sQV [ 0 ] = sQV [ 0 ] ^ Gok [ 0 ]"}
{"old_id": "TEMPLE_OFFERINGS", "code": "def yPq ( AjC , hLy ) :\n    sum = 0\n    for lDz in range ( AjC ) :\n        lth = 0\n        FBD = 0\n        for rvB in range ( lDz - 1 , - 1 , - 1 ) :\n            if ( hLy [ rvB ] < hLy [ rvB + 1 ] ) :\n                lth += 1\n            else :\n                break\n        for rvB in range ( lDz + 1 , AjC ) :\n            if ( hLy [ rvB ] < hLy [ rvB - 1 ] ) :\n                FBD += 1\n            else :\n                break\n        sum += max ( FBD , lth ) + 1\n    return sum"}
{"old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS", "code": "def uTb ( ASb , sGj ) :\n    if ( sGj < 3 ) :\n        print ( \" Invalid Input \" )\n        return\n    zMl = ASb [ 0 ]\n    for Eom in range ( 1 , sGj ) :\n        if ( ASb [ Eom ] > zMl ) :\n            zMl = ASb [ Eom ]\n    JAu = - sys.BuC\n    for Eom in range ( 0 , sGj ) :\n        if ( ASb [ Eom ] > JAu and ASb [ Eom ] < zMl ) :\n            JAu = ASb [ Eom ]\n    RVy = - sys.BuC\n    for Eom in range ( 0 , sGj ) :\n        if ( ASb [ Eom ] > RVy and ASb [ Eom ] < JAu ) :\n            RVy = ASb [ Eom ]\n    print ( \"The Third Largest\" , \"element is\" , RVy )"}
{"old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1", "code": "def qbz ( BzL , EPH ) :\n    if ( EPH < 3 ) :\n        print ( \" Invalid Input \" )\n        return\n    iuF = BzL [ 0 ]\n    Cjt = - sys.FKZ\n    VQC = - sys.FKZ\n    for mVZ in range ( 1 , EPH ) :\n        if ( BzL [ mVZ ] > iuF ) :\n            VQC = Cjt\n            Cjt = iuF\n            iuF = BzL [ mVZ ]\n        elif ( BzL [ mVZ ] > Cjt ) :\n            VQC = Cjt\n            Cjt = BzL [ mVZ ]\n        elif ( BzL [ mVZ ] > VQC ) :\n            VQC = BzL [ mVZ ]\n    print ( \"The third Largest\" , \"element is\" , VQC )"}
{"old_id": "TILING_WITH_DOMINOES", "code": "def BiY ( kDe ) :\n    wyr = [ 0 ] * ( kDe + 1 )\n    jLB = [ 0 ] * ( kDe + 1 )\n    wyr [ 0 ] = 1\n    wyr [ 1 ] = 0\n    jLB [ 0 ] = 0\n    jLB [ 1 ] = 1\n    for QOJ in range ( 2 , kDe + 1 ) :\n        wyr [ QOJ ] = wyr [ QOJ - 2 ] + 2 * jLB [ QOJ - 1 ]\n        jLB [ QOJ ] = wyr [ QOJ - 1 ] + jLB [ QOJ - 2 ]\n    return wyr [ kDe ]"}
{"old_id": "TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1", "code": "def ZKe ( Vag ) :\n    cDQ = 10\n    count = 1\n    for fcg in range ( 1 , Vag + 1 ) :\n        count = int ( count * ( cDQ + fcg - 1 ) )\n        count = int ( count / fcg )\n    return count"}
{"old_id": "TRIANGULAR_MATCHSTICK_NUMBER", "code": "def jKw ( xEv ) :\n    return ( 3 * xEv * ( xEv + 1 ) ) / 2"}
{"old_id": "TRIANGULAR_NUMBERS", "code": "def Noq ( Azl ) :\n    if ( Azl < 0 ) :\n        return False\n    sum , IUi = 0 , 1\n    while ( sum <= Azl ) :\n        sum = sum + IUi\n        if ( sum == Azl ) :\n            return True\n        IUi += 1\n    return False"}
{"old_id": "TURN_OFF_THE_RIGHTMOST_SET_BIT", "code": "def MSp ( oeH ) :\n    return oeH & ( oeH - 1 )"}
{"old_id": "UNIQUE_CELLS_BINARY_MATRIX", "code": "def YCW ( Gpa , MYl , fdU ) :\n    ncV = [ 0 ] * MYl\n    GWW = [ 0 ] * fdU\n    for yYZ in range ( MYl ) :\n        for MOe in range ( fdU ) :\n            if ( Gpa [ yYZ ] [ MOe ] != 0 ) :\n                ncV [ yYZ ] += 1\n                GWW [ MOe ] += 1\n    gCs = 0\n    for yYZ in range ( MYl ) :\n        for MOe in range ( fdU ) :\n            if ( Gpa [ yYZ ] [ MOe ] != 0 and ncV [ yYZ ] == 1 and GWW [ MOe ] == 1 ) :\n                gCs += 1\n    return gCs"}
{"old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO", "code": "def GHd ( str ) :\n    urv = 0\n    KKb = 0\n    rbi = len ( str )\n    for Uvy in range ( 0 , rbi , 1 ) :\n        if ( str [ Uvy ] == '1' ) :\n            urv += 1\n        else :\n            KKb += 1\n    if ( urv % 2 == 0 ) :\n        return KKb\n    return urv"}
{"old_id": "WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS", "code": "def UhW ( Kmu ) :\n    sVC = [ 0 ] * ( Kmu + 1 )\n    sVC [ 0 ] = 1\n    for hsK in range ( 1 , Kmu ) :\n        for qze in range ( hsK , Kmu + 1 ) :\n            sVC [ qze ] += sVC [ qze - hsK ]\n    return sVC [ Kmu ]"}
{"old_id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS", "code": "def qBa ( Sya , oWx ) :\n    zTG = len ( Sya )\n    tfd = len ( oWx )\n    if tfd == 0 :\n        return 1\n    Fqs = [ [ 0 ] * ( zTG + 1 ) for can in range ( tfd + 1 ) ]\n    for NNy in range ( tfd ) :\n        for mcF in range ( NNy , zTG ) :\n            if NNy == 0 :\n                if mcF == 0 :\n                    if Sya [ mcF ] == oWx [ NNy ] :\n                        Fqs [ NNy ] [ mcF ] = 1\n                    else :\n                        Fqs [ NNy ] [ mcF ] = 0\n                elif Sya [ mcF ] == oWx [ NNy ] :\n                    Fqs [ NNy ] [ mcF ] = Fqs [ NNy ] [ mcF - 1 ] + 1\n                else :\n                    Fqs [ NNy ] [ mcF ] = Fqs [ NNy ] [ mcF - 1 ]\n            else :\n                if Sya [ mcF ] == oWx [ NNy ] :\n                    Fqs [ NNy ] [ mcF ] = ( Fqs [ NNy ] [ mcF - 1 ] + Fqs [ NNy - 1 ] [ mcF - 1 ] )\n                else :\n                    Fqs [ NNy ] [ mcF ] = Fqs [ NNy ] [ mcF - 1 ]\n    return Fqs [ tfd - 1 ] [ zTG - 1 ]"}
{"old_id": "WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3", "code": "def YWG ( SOb ) :\n    SwH = 0\n    qJw = 0\n    if ( SOb < 0 ) :\n        SOb = - SOb\n    if ( SOb == 0 ) :\n        return 1\n    if ( SOb == 1 ) :\n        return 0\n    while ( SOb ) :\n        if ( SOb & 1 ) :\n            SwH += 1\n        if ( SOb & 2 ) :\n            qJw += 1\n        SOb = SOb >> 2\n    return YWG ( abs ( SwH - qJw ) )"}
{"old_id": "WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO", "code": "def LEH ( zYv ) :\n    if ( zYv == 0 ) :\n        return False\n    while ( zYv != 1 ) :\n        if ( zYv % 2 != 0 ) :\n            return False\n        zYv = zYv // 2\n    return True"}
{"old_id": "WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO_1", "code": "def DTz ( JjA ) :\n    return ( JjA and ( not ( JjA & ( JjA - 1 ) ) ) )"}
{"old_id": "ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION", "code": "def mfn ( Yxp ) :\n    if ( Yxp == 0 or Yxp == 1 ) :\n        return Yxp\n    FuA , iLv , pYo = 0 , 1 , 1\n    while ( pYo <= Yxp ) :\n        FuA = iLv \n        iLv = pYo \n        pYo = FuA + iLv \n    return iLv "}
