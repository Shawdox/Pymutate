{"code": "def addOne ( x ) :\n    m = 1\n    while ( x & m ) :\n        x = x ^ m\n        m = m << 1\n    x = x ^ m\n    return x", "id": "AugAssign2Assign_sample_from_ADD_1_TO_A_GIVEN_NUMBER_to_0", "old_id": "ADD_1_TO_A_GIVEN_NUMBER"}
{"code": "def winner ( a , n , k ) :\n    if k >= n - 1 :\n        return n\n    best = 0\n    times = 0\n    for i in range ( n ) :\n        if a [ i ] > best :\n            best = a [ i ]\n            if i == True :\n                times = 1\n        else :\n            times = times + 1\n        if times >= k :\n            return best\n    return best", "id": "AugAssign2Assign_sample_from_ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES_to_1", "old_id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES"}
{"code": "def solveQuery ( start , end , arr ) :\n    frequency = dict ( )\n    for i in range ( start , end + 1 ) :\n        if arr [ i ] in frequency.keys ( ) :\n            frequency [ arr [ i ] ] = frequency [ arr [ i ] ] + 1\n        else :\n            frequency [ arr [ i ] ] = 1\n    count = 0\n    for x in frequency :\n        if x == frequency [ x ] :\n            count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE_to_2", "old_id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE"}
{"code": "def encrypt ( text , s ) :\n    result = \"\"\n    for i in range ( len ( text ) ) :\n        char = text [ i ]\n        if ( char.isupper ( ) ) :\n            result = result + chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        else :\n            result = result + chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n    return result", "id": "AugAssign2Assign_sample_from_CAESAR_CIPHER_to_3", "old_id": "CAESAR_CIPHER"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    for i in range ( 1 , len ( str ) ) :\n        if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) :\n            res = res + ord ( str [ i ] ) - 48\n        else :\n            res = res + ord ( str [ i ] ) - 48\n    return res", "id": "AugAssign2Assign_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_4", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = \"0\"\n    Sum = 0\n    for ch in str :\n        if ( ch.isdigit ( ) ) :\n            temp = temp + ch\n        else :\n            Sum = Sum + int ( temp )\n            temp = \"0\"\n    return Sum + int ( temp )", "id": "AugAssign2Assign_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_5", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def HalfDiagonalSums ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    i = 0\n    j = n - 1\n    while i < n :\n        if ( i < n // 2 ) :\n            diag1_left = diag1_left + mat [ i ] [ i ]\n            diag2_left = diag2_left + mat [ j ] [ i ]\n        elif ( i > n // 2 ) :\n            diag1_right = diag1_right + mat [ i ] [ i ]\n            diag2_right = diag2_right + mat [ j ] [ i ]\n        i = i + 1\n        j = j - 1\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )", "id": "AugAssign2Assign_sample_from_CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS_to_6", "old_id": "CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS"}
{"code": "def isOneFlip ( str ) :\n    sum = 0\n    n = len ( str )\n    for i in range ( 0 , n ) :\n        sum = sum + ord ( str [ i ] ) - ord ( '0' )\n    return ( sum == n - 1 or sum == 1 )", "id": "AugAssign2Assign_sample_from_CHANGE_BITS_CAN_MADE_ONE_FLIP_1_to_7", "old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP_1"}
{"code": "def isMajority ( a, n ) :\n    mp = { }\n    for i in range(n) :\n        if a[i] in mp : mp [ a[i] ] = mp [ a[i] ] + 1\n        else : mp [ a[i] ] = 1\n    for x in mp :\n        if mp [ x ] >= len ( a ) // 2 :\n            return True\n    return False", "id": "AugAssign2Assign_sample_from_CHECK_ARRAY_MAJORITY_ELEMENT_to_8", "old_id": "CHECK_ARRAY_MAJORITY_ELEMENT"}
{"code": "def isDivisible ( str , k ) :\n    n = len ( str )\n    c = 0\n    for i in range ( 0 , k ) :\n        if ( str [ n - i - 1 ] == '0' ) :\n            c = c + 1\n    return ( c == k )", "id": "AugAssign2Assign_sample_from_CHECK_DIVISIBILITY_BINARY_STRING_2K_to_9", "old_id": "CHECK_DIVISIBILITY_BINARY_STRING_2K"}
{"code": "def isDivisible999 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '0' ) :\n        return True\n    if ( ( n % 3 ) == 1 ) :\n        num = \"00\" + num\n    if ( ( n % 3 ) == 2 ) :\n        num = \"0\" + num\n    gSum = 0\n    for i in range ( 0 , n , 3 ) :\n        group = 0\n        group = group + ( ord ( num [ i ] ) - 48 ) * 100\n        group = group + ( ord ( num [ i + 1 ] ) - 48 ) * 10\n        group = group + ( ord ( num [ i + 2 ] ) - 48 )\n        gSum = gSum + group\n    if ( gSum > 1000 ) :\n        num = str ( gSum )\n        n = len ( num )\n        gSum = isDivisible999 ( num )\n    return ( gSum == 999 )", "id": "AugAssign2Assign_sample_from_CHECK_DIVISIBILITY_LARGE_NUMBER_999_to_10", "old_id": "CHECK_DIVISIBILITY_LARGE_NUMBER_999"}
{"code": "def isPalindrome ( string ) :\n    l = 0\n    h = len ( string ) - 1\n    while h > l :\n        l = l + 1\n        h = h - 1\n        if string [ l - 1 ] != string [ h + 1 ] :\n            return False\n    return True", "id": "AugAssign2Assign_sample_from_CHECK_GIVEN_STRING_ROTATION_PALINDROME_to_11", "old_id": "CHECK_GIVEN_STRING_ROTATION_PALINDROME"}
{"code": "def flipsPossible ( a , n ) :\n    count_odd = 0\n    count_even = 0\n    for i in range ( n ) :\n        if ( a [ i ] & 1 ) :\n            count_odd = count_odd + 1\n        else :\n            count_even = count_even + 1\n    if ( count_odd % 2 and count_even % 2 ) :\n        return False\n    else :\n        return True", "id": "AugAssign2Assign_sample_from_CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS_to_12", "old_id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS"}
{"code": "def isChangeable ( notes , n ) :\n    fiveCount = 0\n    tenCount = 0\n    for i in range ( n ) :\n        if ( notes [ i ] == 5 ) :\n            fiveCount = fiveCount + 1\n        elif ( notes [ i ] == 10 ) :\n            if ( fiveCount > 0 ) :\n                fiveCount = fiveCount - 1\n                tenCount = tenCount + 1\n            else :\n                return 0\n        else :\n            if ( fiveCount > 0 and tenCount > 0 ) :\n                fiveCount = fiveCount - 1\n                tenCount = tenCount - 1\n            elif ( fiveCount >= 3 ) :\n                fiveCount = fiveCount - 3\n            else :\n                return 0\n    return 1", "id": "AugAssign2Assign_sample_from_CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE_to_13", "old_id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num = str ( num ) + \"00\"\n        length = length + 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        length = length + 1\n    sum = 0\n    p = 1\n    for i in range ( length - 1 , - 1 , - 3 ) :\n        group = 0\n        group = group + ord ( num [ i ] ) - ord ( '0' )\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p = p * ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "AugAssign2Assign_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_14", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def isPerfectSquare ( n ) :\n    i = 1\n    the_sum = 0\n    while the_sum < n :\n        the_sum = the_sum + i\n        if the_sum == n :\n            return True\n        i = i + 2\n    return False", "id": "AugAssign2Assign_sample_from_CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION_to_15", "old_id": "CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION"}
{"code": "def checkReverse ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    for i in range ( 1 , n ) :\n        if arr [ i - 1 ] >= arr [ i ] :\n            break\n        else:\n            if ( i == n ) :\n                return True\n    j = i\n    i = i + 1\n    while ( arr [ j ] < arr [ j - 1 ] ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j = j + 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k = k + 1\n    return True", "id": "AugAssign2Assign_sample_from_CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1_to_16", "old_id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1"}
{"code": "def areSumSame ( a , n , m ) :\n    sum1 = 0\n    sum2 = 0\n    for i in range ( 0 , n ) :\n        sum1 = 0\n        sum2 = 0\n        for j in range ( 0 , m ) :\n            sum1 = sum1 + a [ i ] [ j ]\n            sum2 = sum2 + a [ j ] [ i ]\n        if ( sum1 == sum2 ) :\n            return 1\n    return 0", "id": "AugAssign2Assign_sample_from_CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX_to_17", "old_id": "CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX"}
{"code": "def check ( degree , n ) :\n    deg_sum = 0\n    for i in range(n):\n        deg_sum = deg_sum + degree[i]\n    if ( 2 * ( n - 1 ) == deg_sum ) :\n        return True\n    else :\n        return False", "id": "AugAssign2Assign_sample_from_CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE_to_18", "old_id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if ( n % 3 == 1 ) :\n        num = str ( num ) + \"00\"\n        n = n + 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        n = n + 1\n    GSum = 0\n    p = 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        group = 0\n        group = group + ord ( num [ i ] ) - ord ( '0' )\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p = p * ( - 1 )\n    return ( GSum % 7 == 0 )", "id": "AugAssign2Assign_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_19", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def spiralFill ( m , n , a ) :\n    val = 1\n    k , l = 0 , 0\n    while ( k < m and l < n ) :\n        for i in range ( l , n ) :\n            a [ k ] [ i ] = val\n            val = val + 1\n        k = k + 1\n        for i in range ( k , m ) :\n            a [ i ] [ n - 1 ] = val\n            val = val + 1\n        n = n - 1\n        if ( k < m ) :\n            for i in range ( n - 1 , l - 1 , - 1 ) :\n                a [ m - 1 ] [ i ] = val\n                val = val + 1\n            m = m - 1\n        if ( l < n ) :\n            for i in range ( m - 1 , k - 1 , - 1 ) :\n                a [ i ] [ l ] = val\n                val = val + 1\n            l = l + 1", "id": "AugAssign2Assign_sample_from_CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY_to_20", "old_id": "CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY"}
{"code": "def constructPalin ( str , len ) :\n    str = list ( str )\n    i = - 1\n    j = len\n    while i < j :\n        i = i + 1\n        j = j - 1\n        if ( str [ i ] == str [ j ] and str [ i ] != '*' ) :\n            continue\n        elif ( str [ i ] == str [ j ] and str [ i ] == '*' ) :\n            str [ i ] = 'a'\n            str [ j ] = 'a'\n            continue\n        elif str [ i ] == '*' :\n            str [ i ] = str [ j ]\n            continue\n        elif str [ j ] == '*' :\n            str [ j ] = str [ i ]\n            continue\n        print ( \"Not Possible\" )\n        return \"\"\n    return ''.join ( str )", "id": "AugAssign2Assign_sample_from_CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME_to_21", "old_id": "CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME"}
{"code": "def decimalToBinary ( num , k_prec ) :\n    binary = \"\"\n    Integral = int ( num )\n    fractional = num - Integral\n    while ( Integral > 0 ) :\n        rem = Integral % 2\n        binary = binary + str ( rem )\n        Integral = Integral // 2\n    binary = binary [ : : - 1 ]\n    binary = binary + '.'\n    while ( k_prec > 0 ) :\n        fractional = fractional * 2\n        fract_bit = int ( fractional )\n        if ( fract_bit == 1 ) :\n            fractional = fractional - fract_bit\n            binary = binary + '1'\n        else :\n            binary = binary + '0'\n        k_prec = k_prec - 1\n    return binary", "id": "AugAssign2Assign_sample_from_CONVERT_DECIMAL_FRACTION_BINARY_NUMBER_to_22", "old_id": "CONVERT_DECIMAL_FRACTION_BINARY_NUMBER"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( k + 1 ) :\n            if j >= i:\n                break\n            else:\n                dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j ] [ 1 ] + dp [ i - 1 ] [ j - 1 ] [ 1 ]\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]", "id": "AugAssign2Assign_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_23", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def countPairs ( str ) :\n    result = 0 ;\n    n = len ( str )\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if ( abs ( ord ( str [ i ] ) - ord ( str [ j ] ) ) == abs ( i - j ) ) :\n                result = result + 1\n    return result ;", "id": "AugAssign2Assign_sample_from_COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_to_24", "old_id": "COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS"}
{"code": "def findDigits ( n ) :\n    if ( n < 0 ) :\n        return 0\n    if ( n <= 1 ) :\n        return 1\n    digits = 0\n    for i in range ( 2 , n + 1 ) :\n        digits = digits + math.log10 ( i )\n    return math.floor ( digits ) + 1", "id": "AugAssign2Assign_sample_from_COUNT_DIGITS_FACTORIAL_SET_1_to_25", "old_id": "COUNT_DIGITS_FACTORIAL_SET_1"}
{"code": "def count ( n , x ) :\n    cnt = 0\n    for i in range ( 1 , n + 1 ) :\n        if i <= x :\n            if x // i <= n and x % i == 0 :\n                cnt = cnt + 1\n    return cnt", "id": "AugAssign2Assign_sample_from_COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX_to_26", "old_id": "COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX"}
{"code": "def countSeq ( n ) :\n    nCr = 1\n    res = 1\n    for r in range ( 1 , n + 1 ) :\n        nCr = int ( ( nCr * ( n + 1 - r ) ) / r )\n        res = res + nCr * nCr \n    return res ", "id": "AugAssign2Assign_sample_from_COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1_to_27", "old_id": "COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1"}
{"code": "def countPairs ( arr , n ) :\n    ans = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] == arr [ j ] ) :\n                ans = ans + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_to_28", "old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY"}
{"code": "def countPairs ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        if arr [ i ] in mp.keys ( ) :\n            mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n        else :\n            mp [ arr [ i ] ] = 1\n    ans = 0\n    for it in mp :\n        count = mp [ it ]\n        ans = ans + ( count * ( count - 1 ) ) // 2\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1_to_29", "old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1"}
{"code": "def getInvCount ( arr , n ) :\n    invcount = 0\n    for i in range ( 1 , n - 1 ) :\n        small = 0\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] > arr [ j ] ) :\n                small = small + 1\n        great = 0\n        for j in range ( i - 1 , - 1 , - 1 ) :\n            if ( arr [ i ] < arr [ j ] ) :\n                great = great + 1\n        invcount = invcount + great * small\n    return invcount", "id": "AugAssign2Assign_sample_from_COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1_to_30", "old_id": "COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1"}
{"code": "def countNumber ( n ) :\n    result = 0\n    for i in range ( 1 , 10 ) :\n        s = [ ]\n        if ( i <= n ) :\n            s.append ( i )\n            result = result + 1\n        while len ( s ) != 0 :\n            tp = s [ - 1 ]\n            s.pop ( )\n            for j in range ( tp % 10 , 10 ) :\n                x = tp * 10 + j\n                if ( x <= n ) :\n                    s.append ( x )\n                    result = result + 1\n    return result", "id": "AugAssign2Assign_sample_from_COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER_to_31", "old_id": "COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER"}
{"code": "def countNegative ( M , n , m ) :\n    count = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if M [ i ] [ j ] < 0 :\n                count = count + 1\n            else :\n                break\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_to_32", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX"}
{"code": "def countNegative ( M , n , m ) :\n    count = 0\n    i = 0\n    j = m - 1\n    while j >= 0 and i < n :\n        if M [ i ] [ j ] < 0 :\n            count = count + ( j + 1 )\n            i = i + 1\n        else :\n            j = j - 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1_to_33", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1"}
{"code": "def numOfIncSubseqOfSizeK ( arr , n , k ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ]\n    for i in range ( n ) :\n        dp [ 0 ] [ i ] = 1\n    for l in range ( 1 , k ) :\n        for i in range ( l , n ) :\n            dp [ l ] [ i ] = 0\n            for j in range ( l - 1 , i ) :\n                if ( arr [ j ] < arr [ i ] ) :\n                    dp [ l ] [ i ] = dp [ l ] [ i ] + dp [ l - 1 ] [ j ]\n    Sum = 0\n    for i in range ( k - 1 , n ) :\n        Sum = Sum + dp [ k - 1 ] [ i ]\n    return Sum", "id": "AugAssign2Assign_sample_from_COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K_to_34", "old_id": "COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K"}
{"code": "def countOccurrences ( arr , n , x ) :\n    res = 0\n    for i in range ( n ) :\n        if x == arr [ i ] :\n            res = res + 1\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY_to_35", "old_id": "COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY"}
{"code": "def CountPairs ( n ) :\n    k = n\n    imin = 1\n    ans = 0\n    while ( imin <= n ) :\n        imax = int ( n / k )\n        ans = ans + k * ( imax - imin + 1 )\n        imin = imax + 1\n        k = int ( n / imin )\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B_to_36", "old_id": "COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B"}
{"code": "def count ( n ) :\n    table = [ 0 for i in range ( n + 1 ) ]\n    table [ 0 ] = 1\n    for i in range ( 3 , n + 1 ) :\n        table [ i ] = table [ i ] + table [ i - 3 ]\n    for i in range ( 5 , n + 1 ) :\n        table [ i ] = table [ i ] + table [ i - 5 ]\n    for i in range ( 10 , n + 1 ) :\n        table [ i ] = table [ i ] + table [ i - 10 ]\n    return table [ n ]", "id": "AugAssign2Assign_sample_from_COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME_to_37", "old_id": "COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    for i in range ( n ) :\n        if ( str [ i ] == 'a' ) :\n            a_index = i + 1\n            ans = ans - min ( b_index , c_index )\n        elif ( str [ i ] == 'b' ) :\n            b_index = i + 1\n            ans = ans - min ( a_index , c_index )\n        else :\n            c_index = i + 1\n            ans = ans - min ( a_index , b_index )\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_38", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    for i in range ( len ( s ) ) :\n        if s [ ~ i ] == 'a' :\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n        else :\n            b_count = b_count + 1\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_39", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def countPairsWithDiffK ( arr , n , k ) :\n    count = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k :\n                count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_PAIRS_DIFFERENCE_EQUAL_K_to_40", "old_id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K"}
{"code": "def countPairsWithDiffK ( arr , n , k ) :\n    count = 0\n    arr.sort ( )\n    l = 0\n    r = 0\n    while r < n :\n        if arr [ r ] - arr [ l ] == k :\n            count = count + 1\n            l = l + 1\n            r = r + 1\n        elif arr [ r ] - arr [ l ] > k :\n            l = l + 1\n        else :\n            r = r + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_PAIRS_DIFFERENCE_EQUAL_K_1_to_41", "old_id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K_1"}
{"code": "def countPairs ( arr1 , arr2 , m , n , x ) :\n    count = 0\n    us = set ( )\n    for i in range ( m ) :\n        us.add ( arr1 [ i ] )\n    for j in range ( n ) :\n        if x - arr2 [ j ] in us :\n            count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1_to_42", "old_id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1"}
{"code": "def countPairs ( arr , n ) :\n    result = 0\n    Hash = set ( )\n    for i in range ( n ) :\n        Hash.add ( arr [ i ] )\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            product = arr [ i ] * arr [ j ]\n            if product in ( Hash ) :\n                result = result + 1\n    return result", "id": "AugAssign2Assign_sample_from_COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1_to_43", "old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1"}
{"code": "def countDecodingDP ( digits , n ) :\n    count = [ 0 ] * ( n + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == '0' :\n        return 0\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > '0' ) :\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :\n            count [ i ] = count [ i ] + count [ i - 2 ]\n    return count [ n ]", "id": "AugAssign2Assign_sample_from_COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1_to_44", "old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1"}
{"code": "def findgroups ( arr , n ) :\n    c = [ 0 , 0 , 0 ]\n    res = 0\n    for i in range ( 0 , n ) :\n        c [ arr [ i ] % 3 ] = c [ arr [ i ] % 3 ] + 1\n    res = res + ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )\n    res = res + c [ 1 ] * c [ 2 ]\n    res = res + ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6\n    res = res + ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6\n    res = res + ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 )\n    res = res + c [ 0 ] * c [ 1 ] * c [ 2 ]\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3_to_45", "old_id": "COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3"}
{"code": "def numberOfPaths ( m , n ) :\n    dp = [ 0 for i in range ( n ) ]\n    dp[0]=1\n    for i in range ( m  ) :\n        for j in range ( 1 , n ) :\n            dp [ j ] = dp [ j ] + dp [ j - 1 ]\n    return dp [ n - 1 ]", "id": "AugAssign2Assign_sample_from_COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2_to_46", "old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2"}
{"code": "def numberOfPaths ( m , n ) :\n    for i in range ( n , ( m + n - 1 ) ) :\n        path = path * i\n        path = path // ( i - n + 1 )\n    return path", "id": "AugAssign2Assign_sample_from_COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3_to_47", "old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3"}
{"code": "def countRotationsDivBy8 ( n ) :\n    l = len ( n )\n    count = 0\n    if ( l == 1 ) :\n        oneDigit = int ( n [ 0 ] )\n        if ( oneDigit % 8 == 0 ) :\n            return 1\n        return 0\n    if ( l == 2 ) :\n        first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] )\n        second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] )\n        if ( first % 8 == 0 ) :\n            count = count + 1\n        if ( second % 8 == 0 ) :\n            count = count + 1\n        return count\n    threeDigit = 0\n    for i in range ( 0 , ( l - 2 ) ) :\n        threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) )\n        if ( threeDigit % 8 == 0 ) :\n            count = count + 1\n    threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) )\n    if ( threeDigit % 8 == 0 ) :\n        count = count + 1\n    threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) )\n    if ( threeDigit % 8 == 0 ) :\n        count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_ROTATIONS_DIVISIBLE_8_to_48", "old_id": "COUNT_ROTATIONS_DIVISIBLE_8"}
{"code": "def countSetBits ( n ) :\n    count = 0\n    while ( n ) :\n        n = n & ( n - 1 )\n        count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_SET_BITS_IN_AN_INTEGER_2_to_49", "old_id": "COUNT_SET_BITS_IN_AN_INTEGER_2"}
{"code": "def sortedCount ( mat , r , c ) :\n    result = 0\n    for i in range ( r ) :\n        j = 0\n        for j in range ( c - 1 ) :\n            if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :\n                break\n        if j == c - 2 :\n            result = result + 1\n    for i in range ( 0 , r ) :\n        j = 0\n        for j in range ( c - 1 , 0 , - 1 ) :\n            if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :\n                break\n        if c > 1 and j == 1 :\n            result = result + 1\n    return result", "id": "AugAssign2Assign_sample_from_COUNT_SORTED_ROWS_MATRIX_to_50", "old_id": "COUNT_SORTED_ROWS_MATRIX"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ] * ( n + 1 )\n    hash_negative = [ 0 ] * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    for i in range ( n ) :\n        if ( arr [ i ] & 1 == 1 ) :\n            difference = difference + 1\n        else :\n            difference = difference - 1\n        if ( difference < 0 ) :\n            ans = ans + hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n        else :\n            ans = ans + hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ] + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_51", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1 << i\n        for j in range ( 0 , n + 1 ) :\n            ans = ans + k\n            if change == 1 :\n                k = not k\n                change = 1 << i\n            else :\n                change = change - 1\n        i = i + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_52", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def findTrailingZeros ( n ) :\n    count = 0\n    i = 5\n    while ( n / i >= 1 ) :\n        count = count + int ( n / i )\n        i = i * 5\n    return int ( count )", "id": "AugAssign2Assign_sample_from_COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER_to_53", "old_id": "COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER"}
{"code": "def chordCnt ( A ) :\n    n = 2 * A\n    dpArray = [ 0 ] * ( n + 1 )\n    dpArray [ 0 ] = 1\n    dpArray [ 2 ] = 1\n    for i in range ( 4 , n + 1 , 2 ) :\n        for j in range ( 0 , i - 1 , 2 ) :\n            dpArray [ i ] = dpArray [ i ] + ( dpArray [ j ] * dpArray [ i - 2 - j ] )\n    return int ( dpArray [ n ] )", "id": "AugAssign2Assign_sample_from_COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS_to_54", "old_id": "COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS"}
{"code": "def countWords ( str , n ) :\n    m = dict ( )\n    for i in range ( n ) :\n        m [ str [ i ] ] = m.get ( str [ i ] , 0 ) + 1\n    res = 0\n    for i in m.values ( ) :\n        if i == 2 :\n            res = res + 1\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS_to_55", "old_id": "COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS"}
{"code": "def countWords ( str , len ) :\n    count = 1 ;\n    if ( len == 1 ) :\n        return count\n    if ( str [ 0 ] == str [ 1 ] ) :\n        count = count * 1\n    else :\n        count = count * 2\n    for j in range ( 1 , len - 1 ) :\n        if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) :\n            count = count * 1\n        elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :\n            count = count * 2\n        else :\n            count = count * 3\n    if ( str [ len - 1 ] == str [ len - 2 ] ) :\n        count = count * 1\n    else :\n        count = count * 2\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD_to_56", "old_id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD"}
{"code": "def repeat ( s , n ) :\n    s1 = s\n    for i in range ( 1 , n ) :\n        s = s + s1\n    return s", "id": "AugAssign2Assign_sample_from_C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES_to_57", "old_id": "C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ] * NO_OF_CHARS\n    for i in range ( len ( str ) ) :\n        count [ ord ( str [ i ] ) ] = count [ ord ( str [ i ] ) ] + 1\n    first , second = 0 , 0\n    for i in range ( NO_OF_CHARS ) :\n        if count [ i ] > count [ first ] :\n            second = first\n            first = i\n        elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n            second = i\n    return chr ( second )", "id": "AugAssign2Assign_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_58", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    for i in range ( len ( Str ) ) :\n        count = 0\n        if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( '0' )\n                i = i + 1\n            i = i - 1\n            integerstack.append ( count )\n        elif ( Str [ i ] == ']' ) :\n            temp = \"\"\n            count = 0\n            if ( len ( integerstack ) != 0 ) :\n                count = integerstack [ - 1 ]\n                integerstack.pop ( )\n            while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                temp = stringstack [ - 1 ] + temp\n                stringstack.pop ( )\n            if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                stringstack.pop ( )\n            for j in range ( count ) :\n                result = result + temp\n            for j in range ( len ( result ) ) :\n                stringstack.append ( result [ j ] )\n            result = \"\"\n        elif ( Str [ i ] == '[' ) :\n            if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                stringstack.append ( Str [ i ] )\n            else :\n                stringstack.append ( Str [ i ] )\n                integerstack.append ( 1 )\n        else :\n            stringstack.append ( Str [ i ] )\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "AugAssign2Assign_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_59", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def findWays ( m , n , x ) :\n    table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ]\n    for j in range ( 1 , min ( m + 1 , x + 1 ) ) :\n        table [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 1 , x + 1 ) :\n            for k in range ( 1 , min ( m + 1 , j ) ) :\n                table [ i ] [ j ] = table [ i ] [ j ] + table [ i - 1 ] [ j - k ]\n    return table [ - 1 ] [ - 1 ]", "id": "AugAssign2Assign_sample_from_DICE_THROW_PROBLEM_to_60", "old_id": "DICE_THROW_PROBLEM"}
{"code": "def findDiff ( arr , n ) :\n    arr.sort ( )\n    count = 0\n    max_count = 0\n    min_count = n\n    for i in range ( 0 , ( n - 1 ) ) :\n        if arr [ i ] == arr [ i + 1 ] :\n            count = count + 1\n            continue\n        else :\n            max_count = max ( max_count , count )\n            min_count = min ( min_count , count )\n            count = 0\n    return max_count - min_count", "id": "AugAssign2Assign_sample_from_DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_to_61", "old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY"}
{"code": "def findDiff ( arr , n ) :\n    mp = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n    max_count = 0\n    min_count = n\n    for key , values in mp.items ( ) :\n        max_count = max ( max_count , values )\n        min_count = min ( min_count , values )\n    return max_count - min_count", "id": "AugAssign2Assign_sample_from_DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_1_to_62", "old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_1"}
{"code": "def checkCount ( arr , n , k ) :\n    mp = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n    for key , values in mp.items ( ) :\n        if values > 2 * k :\n            return False\n    return True", "id": "AugAssign2Assign_sample_from_DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1_to_63", "old_id": "DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1"}
{"code": "def longDivision ( number , divisor ) :\n    ans = \"\"\n    idx = 0\n    temp = ord ( number [ idx ] ) - ord ( '0' )\n    while ( temp < divisor ) :\n        temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) )\n        idx = idx + 1\n    while ( ( len ( number ) ) > idx ) :\n        ans = ans + chr ( math.floor ( temp // divisor ) + ord ( '0' ) )\n        temp = ( ( temp % divisor ) * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) )\n        idx = idx + 1\n    ans = ans + chr ( math.floor ( temp // divisor ) + ord ( '0' ) )\n    if ( len ( ans ) == 0 ) :\n        return \"0\"\n    return ans", "id": "AugAssign2Assign_sample_from_DIVIDE_LARGE_NUMBER_REPRESENTED_STRING_to_64", "old_id": "DIVIDE_LARGE_NUMBER_REPRESENTED_STRING"}
{"code": "def isDvisibleBy12 ( num ) :\n    if ( len ( num ) >= 3 ) :\n        d1 = int ( num [ len ( num ) - 1 ] )\n        if ( d1 % 2 != 0 ) :\n            return False\n        d2 = int ( num [ len ( num ) - 2 ] )\n        sum = 0\n        for i in range ( 0 , len ( num ) ) :\n            sum = sum + int ( num [ i ] )\n        return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )\n    else :\n        number = int ( num )\n        return ( number % 12 == 0 )", "id": "AugAssign2Assign_sample_from_DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER_to_65", "old_id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER"}
{"code": "def doublefactorial ( n ) :\n    res = 1\n    for i in range ( n , - 1 , - 2 ) :\n        if ( i == 0 or i == 1 ) :\n            return res\n        else :\n            res = res * i\n    return res;", "id": "AugAssign2Assign_sample_from_DOUBLE_FACTORIAL_1_to_66", "old_id": "DOUBLE_FACTORIAL_1"}
{"code": "def maxProd ( n ) :\n    if ( n == 2 or n == 3 ) :\n        return ( n - 1 )\n    res = 1\n    while ( n > 4 ) :\n        n = n - 3\n        res = res * 3\n    return ( n * res )", "id": "AugAssign2Assign_sample_from_DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1_to_67", "old_id": "DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if symb [ i ] == 'F' :\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == 'T' :\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n    for gap in range ( 1 , n ) :\n        i = 0\n        for j in range ( gap , n ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] = T [ i ] [ j ] + T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] = F [ i ] [ j ] + ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] = F [ i ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] = T [ i ] [ j ] + ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] = T [ i ] [ j ] + ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] = F [ i ] [ j ] + ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n            i = i + 1\n    return T [ 0 ] [ n - 1 ]", "id": "AugAssign2Assign_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_68", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def search ( arr , n , x ) :\n    i = 0\n    while ( i <= n - 1 ) :\n        if ( arr [ i ] == x ) :\n            return i\n        i = i + abs ( arr [ i ] - x )\n    return - 1", "id": "AugAssign2Assign_sample_from_EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1_to_69", "old_id": "EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1"}
{"code": "def countNum ( arr , n ) :\n    count = 0\n    arr = arr[:n]\n    arr.sort ( )\n    for i in range ( 0 , n - 1 ) :\n        if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) :\n            count = count + arr [ i + 1 ] - arr [ i ] - 1\n    return count", "id": "AugAssign2Assign_sample_from_ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_to_70", "old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY"}
{"code": "def countNum ( arr , n ) :\n    s = dict ( )\n    count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9\n    for i in range ( n ) :\n        s [ arr [ i ] ] = 1\n        if ( arr [ i ] < minm ) :\n            minm = arr [ i ]\n        if ( arr [ i ] > maxm ) :\n            maxm = arr [ i ]\n    for i in range ( minm , maxm + 1 ) :\n        if i not in s.keys ( ) :\n            count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1_to_71", "old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1"}
{"code": "def equilibrium ( arr , n) :\n    leftsum = 0\n    rightsum = 0\n    for i in range ( n ) :\n        leftsum = 0\n        rightsum = 0\n        for j in range ( i ) :\n            leftsum = leftsum + arr [ j ]\n        for j in range ( i + 1 , n ) :\n            rightsum = rightsum + arr [ j ]\n        if leftsum == rightsum :\n            return i\n    return - 1", "id": "AugAssign2Assign_sample_from_EQUILIBRIUM_INDEX_OF_AN_ARRAY_to_72", "old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY"}
{"code": "def equilibrium ( arr ,n) :\n    total_sum = sum ( arr )\n    leftsum = 0\n    for i , num in enumerate ( arr ) :\n        total_sum = total_sum - num\n        if leftsum == total_sum :\n            return i\n        leftsum = leftsum + num\n    return - 1", "id": "AugAssign2Assign_sample_from_EQUILIBRIUM_INDEX_OF_AN_ARRAY_1_to_73", "old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY_1"}
{"code": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans = ans + int(n / temp)\n        temp = temp * p\n    return ans", "id": "AugAssign2Assign_sample_from_FINDING_POWER_PRIME_NUMBER_P_N_to_74", "old_id": "FINDING_POWER_PRIME_NUMBER_P_N"}
{"code": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans = ans + n / temp\n        temp = temp * p\n    return int ( ans )", "id": "AugAssign2Assign_sample_from_FINDING_POWER_PRIME_NUMBER_P_N_1_to_75", "old_id": "FINDING_POWER_PRIME_NUMBER_P_N_1"}
{"code": "def maxHamming ( arr , n ) :\n    brr = [ 0 ] * ( 2 * n + 1 )\n    for i in range ( n ) :\n        brr [ i ] = arr [ i ]\n    for i in range ( n ) :\n        brr [ n + i ] = arr [ i ]\n    maxHam = 0\n    for i in range ( 1 , n ) :\n        currHam = 0\n        k = 0\n        for j in range ( i , i + n ) :\n            if brr [ j ] != arr [ k ] :\n                currHam = currHam + 1\n                k = k + 1\n        if currHam == n :\n            return n\n        maxHam = max ( maxHam , currHam )\n    return maxHam", "id": "AugAssign2Assign_sample_from_FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE_to_76", "old_id": "FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    for ch in string :\n        if ch == ')' :\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != '(' :\n                elementsInside = elementsInside + 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n        else :\n            Stack.append ( ch )\n    return False", "id": "AugAssign2Assign_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_77", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def maxPrimeFactors ( n ) :\n    maxPrime = - 1\n    while n % 2 == 0 :\n        maxPrime = 2\n        n = n >> 1\n    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :\n        while n % i == 0 :\n            maxPrime = i\n            n = n / i\n    if n > 2 :\n        maxPrime = n\n    return int ( maxPrime )", "id": "AugAssign2Assign_sample_from_FIND_LARGEST_PRIME_FACTOR_NUMBER_to_78", "old_id": "FIND_LARGEST_PRIME_FACTOR_NUMBER"}
{"code": "def findMaxAverage ( arr , n , k ) :\n    if ( k > n ) :\n        return - 1\n    sum = arr [ 0 ]\n    for i in range ( 1 , k ) :\n        sum = sum + arr [ i ]\n    max_sum = sum\n    max_end = k - 1\n    for i in range ( k , n ) :\n        sum = sum + arr [ i ] - arr [ i - k ]\n        if ( sum > max_sum ) :\n            max_sum = sum\n            max_end = i\n    return max_end - k + 1", "id": "AugAssign2Assign_sample_from_FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1_to_79", "old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1"}
{"code": "def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :\n    sum1 , sum2 , sum3 = 0 , 0 , 0\n    for i in range ( n1 ) :\n        sum1 = sum1 + stack1 [ i ]\n    for i in range ( n2 ) :\n        sum2 = sum2 + stack2 [ i ]\n    for i in range ( n3 ) :\n        sum3 = sum3 + stack3 [ i ]\n    top1 , top2 , top3 = 0 , 0 , 0\n    ans = 0\n    while ( 1 ) :\n        if ( top1 == n1 or top2 == n2 or top3 == n3 ) :\n            return 0\n        if ( sum1 == sum2 and sum2 == sum3 ) :\n            return sum1\n        if ( sum1 >= sum2 and sum1 >= sum3 ) :\n            sum1 = sum1 - stack1 [ top1 ]\n            top1 = top1 + 1\n        elif ( sum2 >= sum3 and sum2 >= sum3 ) :\n            sum2 = sum2 - stack2 [ top2 ]\n            top2 = top2 + 1\n        elif ( sum3 >= sum2 and sum3 >= sum1 ) :\n            sum3 = sum3 - stack3 [ top3 ]\n            top3 = top3 + 1", "id": "AugAssign2Assign_sample_from_FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS_to_80", "old_id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS"}
{"code": "def findMinNumber ( n ) :\n    count = 0\n    ans = 1\n    while n % 2 == 0 :\n        count = count + 1\n        n = n // 2\n    if count % 2 is not 0 :\n        ans = ans * 2\n    for i in range ( 3 , ( int ) ( math.sqrt ( n ) ) + 1 , 2 ) :\n        count = 0\n        while n % i == 0 :\n            count = count + 1\n            n = n // i\n        if count % 2 is not 0 :\n            ans = ans * i\n    if n > 2 :\n        ans = ans * n\n    return ans", "id": "AugAssign2Assign_sample_from_FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE_to_81", "old_id": "FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE"}
{"code": "def countEndless ( input , n ) :\n    row = np.zeros ( ( n , n ) )\n    col = np.zeros ( ( n , n ) )\n    for j in range ( n ) :\n        isEndless = 1\n        for i in range ( n - 1 , - 1 , - 1 ) :\n            if ( input [ i ] [ j ] == 0 ) :\n                isEndless = 0\n            col [ i ] [ j ] = isEndless\n    for i in range ( n ) :\n        isEndless = 1\n        for j in range ( n - 1 , - 1 , - 1 ) :\n            if ( input [ i ] [ j ] == 0 ) :\n                isEndless = 0\n            row [ i ] [ j ] = isEndless\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( 1 , n ) :\n            if ( row [ i ] [ j ] and col [ i ] [ j ] ) :\n                ans = ans + 1\n    return ans", "id": "AugAssign2Assign_sample_from_FIND_NUMBER_ENDLESS_POINTS_to_82", "old_id": "FIND_NUMBER_ENDLESS_POINTS"}
{"code": "def countOps ( A , B , m , n ) :\n    for i in range ( n ) :\n        for j in range ( m ) :\n            A [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]\n    for i in range ( 1 , n ) :\n        for j in range ( 1 , n ) :\n            if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) :\n                return - 1\n    result = 0\n    for i in range ( n ) :\n        result = result + abs ( A [ i ] [ 0 ] )\n    for j in range ( m ) :\n        result = result + abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] )\n    return ( result )", "id": "AugAssign2Assign_sample_from_FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL_to_83", "old_id": "FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL"}
{"code": "def pairSum ( mat , n , sum ) :\n    for i in range ( n ) :\n        mat [ i ].sort ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) :\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left = left + 1\n                    right = right - 1\n                else :\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left = left + 1\n                    else :\n                        right = right - 1", "id": "AugAssign2Assign_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_84", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    for i in range ( 0 , n ) :\n        high = max ( high , arr [ i ] )\n    count = [ 0 ] * ( high + 1 )\n    for i in range ( 0 , n ) :\n        count [ arr [ i ] ] = count [ arr [ i ] ] + 1\n    counter = 0\n    for i in range ( high , 0 , - 1 ) :\n        j = i\n        while ( j <= high ) :\n            if ( count [ j ] > 0 ) :\n                counter = counter + count [ j ]\n            j = j + i\n            if ( counter == 2 ) :\n                return i\n        counter = 0\n    return 1\n", "id": "AugAssign2Assign_sample_from_FIND_PAIR_MAXIMUM_GCD_ARRAY_1_to_85", "old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY_1"}
{"code": "def patternCount ( str ) :\n    last = str [ 0 ]\n    i = 1\n    counter = 0\n    while ( i < len ( str ) ) :\n        if ( str [ i ] == '0' and last == '1' ) :\n            while ( str [ i ] == '0' ) :\n                i = i + 1\n                if ( str [ i ] == '1' ) :\n                    counter = counter + 1\n        last = str [ i ]\n        i = i + 1\n    return counter", "id": "AugAssign2Assign_sample_from_FIND_PATTERNS_101_GIVEN_STRING_to_86", "old_id": "FIND_PATTERNS_101_GIVEN_STRING"}
{"code": "def subArraySum ( arr , n , sum ) :\n    for i in range ( n ) :\n        curr_sum = arr [ i ]\n        j = i + 1\n        while j <= n :\n            if curr_sum == sum :\n                print ( \"Sum found between\" )\n                print ( \"indexes %d and %d\" % ( i , j - 1 ) )\n                return 1\n            if curr_sum > sum or j == n :\n                break\n            curr_sum = curr_sum + arr [ j ]\n            j = j + 1\n    print ( \"No subarray found\" )\n    return 0", "id": "AugAssign2Assign_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_to_87", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM"}
{"code": "def subArraySum ( arr , n , sum ) :\n    curr_sum = arr [ 0 ]\n    start = 0\n    i = 1\n    while i <= n :\n        while curr_sum > sum and start < i - 1 :\n            curr_sum = curr_sum - arr [ start ]\n            start = start + 1\n        if curr_sum == sum :\n            print ( \"Sum found between indexes\" )\n            print ( \"%d and %d\" % ( start , i - 1 ) )\n            return 1\n        if i < n :\n            curr_sum = curr_sum + arr [ i ]\n        i = i + 1\n    print ( \"No subarray found\" )\n    return 0", "id": "AugAssign2Assign_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_1_to_88", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM_1"}
{"code": "def findSum ( N , K ) :\n    ans = 0\n    for i in range ( 1 , N + 1 ) :\n        ans = ans + ( i % K )\n    return ans", "id": "AugAssign2Assign_sample_from_FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER_to_89", "old_id": "FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER"}
{"code": "def sumofoddFactors ( n ) :\n    res = 1\n    while n % 2 == 0 :\n        n = n // 2\n    for i in range ( 3 , int ( math.sqrt ( n ) + 1 ) ) :\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0 :\n            count = count + 1\n            n = n // i\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if n >= 2 :\n        res = res * ( 1 + n )\n    return res", "id": "AugAssign2Assign_sample_from_FIND_SUM_ODD_FACTORS_NUMBER_to_90", "old_id": "FIND_SUM_ODD_FACTORS_NUMBER"}
{"code": "def findSubarraySum ( arr , n ) :\n    res = 0\n    m = dict ( )\n    for i in range ( n ) :\n        Sum = 0\n        for j in range ( i , n ) :\n            Sum = Sum + arr [ j ]\n            m [ Sum ] = m.get ( Sum , 0 ) + 1\n    for x in m :\n        if m [ x ] == 1 :\n            res = res + x\n    return res", "id": "AugAssign2Assign_sample_from_FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY_to_91", "old_id": "FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY"}
{"code": "def getSingle ( arr , n ) :\n    ones = 0\n    twos = 0\n    for i in range ( n ) :\n        twos = twos | ( ones & arr [ i ] )\n        ones = ones ^ arr [ i ]\n        common_bit_mask = ~ ( ones & twos )\n        ones = ones & common_bit_mask\n        twos = twos & common_bit_mask\n    return ones", "id": "AugAssign2Assign_sample_from_FIND_THE_ELEMENT_THAT_APPEARS_ONCE_to_92", "old_id": "FIND_THE_ELEMENT_THAT_APPEARS_ONCE"}
{"code": "def maxLen ( arr , n ) :\n    max_len = 0\n    for i in range ( n ) :\n        curr_sum = 0\n        for j in range ( i , n ) :\n            curr_sum = curr_sum + arr [ j ]\n            if curr_sum == 0 :\n                max_len = max ( max_len , j - i + 1 )\n    return max_len\n", "id": "AugAssign2Assign_sample_from_FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_to_93", "old_id": "FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM"}
{"code": "def getMissingNo ( a , n ) :\n    i , total = 0 , 1\n    for i in range ( 2 , n + 2 ) :\n        total = total + i\n        total = total - a [ i - 2 ]\n    return total", "id": "AugAssign2Assign_sample_from_FIND_THE_MISSING_NUMBER_1_to_94", "old_id": "FIND_THE_MISSING_NUMBER_1"}
{"code": "def getOddOccurrence ( arr , arr_size ) :\n    for i in range ( 0 , arr_size ) :\n        count = 0\n        for j in range ( 0 , arr_size ) :\n            if arr [ i ] == arr [ j ] :\n                count = count + 1\n        if ( count % 2 != 0 ) :\n            return arr [ i ]\n    return - 1", "id": "AugAssign2Assign_sample_from_FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_to_95", "old_id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    for i in range ( 0 , n - 1 ) :\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if ( x + arr [ l ] + arr [ r ] == 0 ) :\n                print ( x , arr [ l ] , arr [ r ] )\n                l = l + 1\n                r = r - 1\n                found = True\n            elif ( x + arr [ l ] + arr [ r ] < 0 ) :\n                l = l + 1\n            else :\n                r = r - 1\n    if ( found == False ) :\n        print ( \" No Triplet Found\" )", "id": "AugAssign2Assign_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_96", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def isPowerOfFour ( n ) :\n    count = 0\n    if ( n and ( not ( n & ( n - 1 ) ) ) ) :\n        while ( n > 1 ) :\n            n = n >> 1\n            count = count + 1\n        if ( count % 2 == 0 ) :\n            return True\n        else :\n            return False\n    return False", "id": "AugAssign2Assign_sample_from_FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1_to_97", "old_id": "FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1"}
{"code": "def firstElement ( arr , n , k ) :\n    count_map = { }\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] in count_map.keys ( ) ) :\n            count_map [ arr [ i ] ] = count_map [ arr [ i ] ] + 1\n        else :\n            count_map [ arr [ i ] ] = 1\n        i = i + 1\n    for i in range ( 0 , n ) :\n        if ( count_map [ arr [ i ] ] == k ) :\n            return arr [ i ]\n        i = i + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY_to_98", "old_id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count = count + 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return result", "id": "AugAssign2Assign_sample_from_FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1_to_99", "old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1"}
{"code": "def mostFrequent ( arr , n ) :\n    Hash = dict ( )\n    for i in range ( n ) :\n        if arr [ i ] in Hash.keys ( ) :\n            Hash [ arr [ i ] ] = Hash [ arr [ i ] ] + 1\n        else :\n            Hash [ arr [ i ] ] = 1\n    max_count = 0\n    res = - 1\n    for i in Hash :\n        if ( max_count < Hash [ i ] ) :\n            res = i\n            max_count = Hash [ i ]\n    return res", "id": "AugAssign2Assign_sample_from_FREQUENT_ELEMENT_ARRAY_1_to_100", "old_id": "FREQUENT_ELEMENT_ARRAY_1"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count = count + 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return \"\".join(str(i) for i in result)", "id": "AugAssign2Assign_sample_from_GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1_to_101", "old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1"}
{"code": "def largestPower ( n , p ) :\n    x = 0\n    while n :\n        n = n / p\n        x = x + n\n    return x", "id": "AugAssign2Assign_sample_from_GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2_to_102", "old_id": "GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0\n    for i in range ( 1 , m + 1 ) :\n        if ( nxtbb < n ) :\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb = nxtbb + 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n    return maxRev [ m ]", "id": "AugAssign2Assign_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_103", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def mulmod ( a , b , mod ) :\n    res = 0\n    a = a % mod\n    while ( b > 0 ) :\n        if ( b % 2 == 1 ) :\n            res = ( res + a ) % mod\n        a = ( a * 2 ) % mod\n        b = b // 2\n    return res % mod", "id": "AugAssign2Assign_sample_from_HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION_to_104", "old_id": "HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    for i in arr :\n        if ( i < 0 ) :\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] = hash [ abs ( i ) ] - 1\n        else :\n            hash [ i ] = hash.get ( i , 0 ) + 1\n    for i in arr :\n        if i in hash.keys ( ) and hash [ i ] > 0 :\n            return i\n    return - 1", "id": "AugAssign2Assign_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_105", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def kth ( arr1 , arr2 , m , n , k ) :\n    sorted1 = [ 0 ] * ( m + n )\n    i = 0\n    j = 0\n    d = 0\n    while ( i < m and j < n ) :\n        if ( arr1 [ i ] < arr2 [ j ] ) :\n            sorted1 [ d ] = arr1 [ i ]\n            i = i + 1\n        else :\n            sorted1 [ d ] = arr2 [ j ]\n            j = j + 1\n        d = d + 1\n    while ( i < m ) :\n        sorted1 [ d ] = arr1 [ i ]\n        d = d + 1\n        i = i + 1\n    while ( j < n ) :\n        sorted1 [ d ] = arr2 [ j ]\n        d = d + 1\n        j = j + 1\n    return sorted1 [ k - 1 ]", "id": "AugAssign2Assign_sample_from_K_TH_ELEMENT_TWO_SORTED_ARRAYS_to_106", "old_id": "K_TH_ELEMENT_TWO_SORTED_ARRAYS"}
{"code": "def find ( a , b , k , n1 , n2 ) :\n    s = set ( )\n    for i in range ( n2 ) :\n        s.add ( b [ i ] )\n    missing = 0\n    for i in range ( n1 ) :\n        if a [ i ] not in s :\n            missing = missing + 1\n        if missing == k :\n            return a [ i ]\n    return - 1", "id": "AugAssign2Assign_sample_from_K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE_to_107", "old_id": "K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE"}
{"code": "def largestGCDSubsequence ( arr , n ) :\n    ans = 0\n    maxele = max ( arr )\n    for i in range ( 2 , maxele + 1 ) :\n        count = 0\n        for j in range ( n ) :\n            if ( arr [ j ] % i == 0 ) :\n                count = count + 1\n        ans = max ( ans , count )\n    return ans", "id": "AugAssign2Assign_sample_from_LARGEST_SUBSEQUENCE_GCD_GREATER_1_to_108", "old_id": "LARGEST_SUBSEQUENCE_GCD_GREATER_1"}
{"code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    for i in range ( n - 1 ) :\n        if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :\n            dp [ i ] [ i + 1 ] = 2\n    for l in range ( 2 , n ) :\n        i = - 1\n        for j in range ( l , n ) :\n            i = i + 1\n            if ( s [ i ] == '(' and s [ j ] == ')' ) :\n                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]\n            for k in range ( i , j ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n    return dp [ 0 ] [ n - 1 ]", "id": "AugAssign2Assign_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_to_109", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    for i in range ( n ) :\n        if ( s [ i ] == '(' ) :\n            invalidOpenBraces = invalidOpenBraces + 1\n        else :\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces = invalidCloseBraces + 1\n            else :\n                invalidOpenBraces = invalidOpenBraces - 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "AugAssign2Assign_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_110", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :\n                k = k + 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i = i - 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i = i - 1\n                k = k + 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i = i - 1\n    return llap", "id": "AugAssign2Assign_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_111", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def subsequence ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n    for ch in string :\n        cnt = 0\n        for i in range ( last , n ) :\n            if s [ i ] == ch :\n                cnt = cnt + 1\n        if cnt >= k :\n            for i in range ( last , n ) :\n                if s [ i ] == ch :\n                    t [ size ] = ch\n                    new_last = i\n                    size = size + 1\n            last = new_last\n    t[size] = '\\0';", "id": "AugAssign2Assign_sample_from_LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES_to_112", "old_id": "LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES"}
{"code": "def nextWord ( s ) :\n    if ( s == \" \" ) :\n        return \"a\"\n    i = len ( s ) - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i = i - 1\n    if ( i == - 1 ) :\n        s = s + 'a'\n    else :\n        s = s [ 0 : i ] + chr ( ord ( s [ i ] ) + 1 ) + s [ i + 1 : ]\n    return s", "id": "AugAssign2Assign_sample_from_LEXICOGRAPHICALLY_NEXT_STRING_to_113", "old_id": "LEXICOGRAPHICALLY_NEXT_STRING"}
{"code": "def prevPermutation ( str ) :\n    n = len ( str ) - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i = i - 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j = j + 1\n    str = list ( str )\n    temp = str [ i - 1 ]\n    str [ i - 1 ] = str [ j ]\n    str [ j ] = temp\n    str = ''.join ( str )\n    str [ : : - 1 ]\n    return True", "id": "AugAssign2Assign_sample_from_LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C_to_114", "old_id": "LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C"}
{"code": "def minimizeWithKSwaps ( arr , n , k ) :\n    for i in range ( n - 1 ) :\n        pos = i\n        for j in range ( i + 1 , n ) :\n            if ( j - i > k ) :\n                break\n            if ( arr [ j ] < arr [ pos ] ) :\n                pos = j\n        for j in range ( pos , i , - 1 ) :\n            arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ]\n        k = k - pos - i", "id": "AugAssign2Assign_sample_from_LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS_to_115", "old_id": "LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS"}
{"code": "def lexicographicSubConcat ( s ) :\n    n = len ( s )\n    sub_count = ( n * ( n + 1 ) ) // 2\n    arr = [ 0 ] * sub_count\n    index = 0\n    for i in range ( n ) :\n        for j in range ( 1 , n - i + 1 ) :\n            arr [ index ] = s [ i : i + j ]\n            index = index + 1\n    arr.sort ( )\n    res = \"\"\n    for i in range ( sub_count ) :\n        res = res + arr [ i ]\n    return res", "id": "AugAssign2Assign_sample_from_LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING_to_116", "old_id": "LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING"}
{"code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n , 2 ) :\n            length = j - i + 1\n            leftsum = 0\n            rightsum = 0\n            for k in range ( 0 , int ( length / 2 ) ) :\n                leftsum = leftsum + ( int ( str [ i + k ] ) - int ( '0' ) )\n                rightsum = rightsum + ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) )\n            if ( leftsum == rightsum and maxlen < length ) :\n                maxlen = length\n    return maxlen", "id": "AugAssign2Assign_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_to_117", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) :\n            res = res + str [ i - 1 ]\n            i = i - 1\n            j = j - 1\n        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n            i = i - 1\n        else :\n            j = j - 1\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "AugAssign2Assign_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_118", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if arr [ i ] == 0 :\n            sum = sum + - 1\n        else :\n            sum = sum + 1\n        if ( sum == 1 ) :\n            maxLen = i + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n    return maxLen", "id": "AugAssign2Assign_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_119", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    for i in range ( n ) :\n        curr_sum = curr_sum + arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k\n    for i in range ( n ) :\n        if ( mod_arr [ i ] == 0 ) :\n            max = i + 1\n        elif ( mod_arr [ i ] in um ) :\n            um [ mod_arr [ i ] ] = i\n        else :\n            if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                max = i - um [ mod_arr [ i ] ]\n    return max", "id": "AugAssign2Assign_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_120", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def maximumPalinUsingKChanges ( str , k ) :\n    palin = list(str)\n    l = 0\n    r = len ( str ) - 1\n    while ( l <= r ) :\n        if ( str [ l ] != str [ r ] ) :\n            palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] )\n            k = k - 1\n        l = l + 1\n        r = r - 1\n    if ( k < 0 ) :\n        return \"Not possible\"\n    l = 0\n    r = len ( str ) - 1\n    while ( l <= r ) :\n        if ( l == r ) :\n            if ( k > 0 ) :\n                palin [ l ] = '9'\n        if ( palin [ l ] < '9' ) :\n            if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) :\n                k = k - 1\n                palin [ l ] = palin [ r ] = '9'\n            elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) ) :\n                k = k - 1\n                palin [ l ] = palin [ r ] = '9'\n        l = l + 1\n        r = r - 1\n    return \"\".join(palin)", "id": "AugAssign2Assign_sample_from_MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS_to_121", "old_id": "MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS"}
{"code": "def maxvolume ( s ) :\n    length = s // 3 \n    s = s - length\n    breadth = s // 2\n    height = s - breadth\n    return int ( length * breadth * height )", "id": "AugAssign2Assign_sample_from_MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1_to_122", "old_id": "MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1"}
{"code": "def findArea ( arr , n ) :\n    arr.sort ( reverse = True )\n    dimension = [ 0 , 0 ]\n    i = 0\n    j = 0\n    while ( i < n - 1 and j < 2 ) :\n        if ( arr [ i ] == arr [ i + 1 ] ) :\n            dimension [ j ] = arr [ i ]\n            j = j + 1\n            i = i + 1\n        i = i + 1\n    return ( dimension [ 0 ] * dimension [ 1 ] )", "id": "AugAssign2Assign_sample_from_MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY_to_123", "old_id": "MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY"}
{"code": "def findLongestConseqSubseq ( arr , n ) :\n    S = set ( )\n    for i in range ( n ) :\n        S.add ( arr [ i ] )\n    ans = 0\n    for i in range ( n ) :\n        if S.__contains__ ( arr [ i ] ) :\n            j = arr [ i ]\n            while ( S.__contains__ ( j ) ) :\n                j = j + 1\n            ans = max ( ans , j - arr [ i ] )\n    return ans", "id": "AugAssign2Assign_sample_from_MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY_to_124", "old_id": "MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY"}
{"code": "def maxRepeating ( str ) :\n    n = len ( str )\n    count = 0\n    res = str [ 0 ]\n    cur_count = 1\n    for i in range ( n ) :\n        if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) :\n            cur_count = cur_count + 1\n        else :\n            if cur_count > count :\n                count = cur_count\n                res = str [ i ]\n            cur_count = 1\n    return res", "id": "AugAssign2Assign_sample_from_MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1_to_125", "old_id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1"}
{"code": "def maxdiff ( arr , n ) :\n    freq = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] :\n                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )\n            elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :\n                ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )\n    return ans", "id": "AugAssign2Assign_sample_from_MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER_to_126", "old_id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER"}
{"code": "def maxRowDiff ( mat , m , n ) :\n    rowSum = [ 0 ] * m\n    for i in range ( 0 , m ) :\n        sum = 0\n        for j in range ( 0 , n ) :\n            sum = sum + mat [ i ] [ j ]\n        rowSum [ i ] = sum\n    max_diff = rowSum [ 1 ] - rowSum [ 0 ]\n    min_element = rowSum [ 0 ]\n    for i in range ( 1 , m ) :\n        if ( rowSum [ i ] - min_element > max_diff ) :\n            max_diff = rowSum [ i ] - min_element\n        if ( rowSum [ i ] < min_element ) :\n            min_element = rowSum [ i ]\n    return max_diff", "id": "AugAssign2Assign_sample_from_MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX_to_127", "old_id": "MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX"}
{"code": "def maxDiff ( arr , n ) :\n    SubsetSum_1 = 0\n    SubsetSum_2 = 0\n    for i in range ( 0 , n ) :\n        isSingleOccurance = True\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] == arr [ j ] ) :\n                isSingleOccurance = False\n                arr [ i ] = arr [ j ] = 0\n                break\n        if ( isSingleOccurance == True ) :\n            if ( arr [ i ] > 0 ) :\n                SubsetSum_1 = SubsetSum_1 + arr [ i ]\n            else :\n                SubsetSum_2 = SubsetSum_2 + arr [ i ]\n    return abs ( SubsetSum_1 - SubsetSum_2 )", "id": "AugAssign2Assign_sample_from_MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_to_128", "old_id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY"}
{"code": "def maxDiff ( arr , n ) :\n    result = 0\n    arr.sort ( )\n    i = 0\n    while i < n-1:\n        if ( arr [ i ] !=  arr [ i + 1 ] ) :\n            result = result + abs ( arr [ i ] )\n        else:\n            i = i + 1\n        i = i + 1\n    if ( arr [ n - 2 ] != arr [ n - 1 ] ) :\n        result = result + abs ( arr [ n - 1 ] )\n    return result", "id": "AugAssign2Assign_sample_from_MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1_to_129", "old_id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1"}
{"code": "def returnMaxSum ( A , B , n ) :\n    mp = set ( )\n    result = 0\n    curr_sum = curr_begin = 0\n    for i in range ( 0 , n ) :\n        while A [ i ] in mp :\n            mp.remove ( A [ curr_begin ] )\n            curr_sum = curr_sum - B [ curr_begin ]\n            curr_begin = curr_begin + 1\n        mp.add ( A [ i ] )\n        curr_sum = curr_sum + B [ i ]\n        result = max ( result , curr_sum )\n    return result", "id": "AugAssign2Assign_sample_from_MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE_to_130", "old_id": "MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE"}
{"code": "def maxProductSubset ( a , n ) :\n    if n == 1 :\n        return a [ 0 ]\n    max_neg = - 999999999999\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( n ) :\n        if a [ i ] == 0 :\n            count_zero = count_zero + 1\n            continue\n        if a [ i ] < 0 :\n            count_neg = count_neg + 1\n            max_neg = max ( max_neg , a [ i ] )\n        prod = prod + a [ i ]\n    if count_zero == n :\n        return 0\n    if count_neg & 1 :\n        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :\n            return 0\n        prod = int(prod / max_neg)\n    return prod", "id": "AugAssign2Assign_sample_from_MAXIMUM_PRODUCT_SUBSET_ARRAY_to_131", "old_id": "MAXIMUM_PRODUCT_SUBSET_ARRAY"}
{"code": "def maxSum ( arr , n ) :\n    res = - sys.maxsize\n    for i in range ( 0 , n ) :\n        curr_sum = 0\n        for j in range ( 0 , n ) :\n            index = int ( ( i + j ) % n )\n            curr_sum = curr_sum + j * arr [ index ]\n        res = max ( res , curr_sum )\n    return res", "id": "AugAssign2Assign_sample_from_MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_to_132", "old_id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY"}
{"code": "def maxSum ( arr , n ) :\n    cum_sum = 0\n    for i in range ( 0 , n ) :\n        cum_sum = cum_sum + arr [ i ]\n    curr_val = 0\n    for i in range ( 0 , n ) :\n        curr_val = curr_val + i * arr [ i ]\n    res = curr_val\n    for i in range ( 1 , n ) :\n        next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) )\n        curr_val = next_val\n        res = max ( res , next_val )\n    return res", "id": "AugAssign2Assign_sample_from_MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1_to_133", "old_id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1"}
{"code": "def maxSumPairWithDifferenceLessThanK ( arr , N , k ) :\n    maxSum = 0\n    arr.sort ( )\n    i = N - 1\n    while ( i > 0 ) :\n        if ( arr [ i ] - arr [ i - 1 ] < k ) :\n            maxSum = maxSum + arr [ i ]\n            maxSum = maxSum + arr [ i - 1 ]\n            i = i - 1\n        i = i - 1\n    return maxSum", "id": "AugAssign2Assign_sample_from_MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1_to_134", "old_id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1"}
{"code": "def maxSumSubarrayRemovingOneEle ( arr , n ) :\n    fw = [ 0 for k in range ( n ) ]\n    bw = [ 0 for k in range ( n ) ]\n    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]\n    for i in range (1, n ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        fw [ i ] = cur_max\n    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]\n    i = n - 2\n    while i >= 0 :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        bw [ i ] = cur_max\n        i = i - 1\n    fans = max_so_far\n    for i in range ( 1 , n - 1 ) :\n        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )\n    return fans", "id": "AugAssign2Assign_sample_from_MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT_to_135", "old_id": "MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT"}
{"code": "def getMedian ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count = count + 1\n        if i == n :\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        elif j == n :\n            m1 = m2\n            m2 = ar1 [ 0 ]\n            break\n        if ar1 [ i ] < ar2 [ j ] :\n            m1 = m2\n            m2 = ar1 [ i ]\n            i = i + 1\n        else :\n            m1 = m2\n            m2 = ar2 [ j ]\n            j = j + 1\n    return int(( m1 + m2 ) / 2)", "id": "AugAssign2Assign_sample_from_MEDIAN_OF_TWO_SORTED_ARRAYS_to_136", "old_id": "MEDIAN_OF_TWO_SORTED_ARRAYS"}
{"code": "def minValue ( A , B , n ) :\n    sorted ( A )\n    sorted ( B )\n    result = 0\n    for i in range ( n ) :\n        result = result + ( A [ i ] * B [ n - i - 1 ] )\n    return result", "id": "AugAssign2Assign_sample_from_MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED_to_137", "old_id": "MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED"}
{"code": "def minSum ( n ) :\n    sum = 0\n    while ( n > 0 ) :\n        sum = sum + ( n % 10 )\n        n = n // 10\n    if ( sum == 1 ) :\n        return 10\n    return sum", "id": "AugAssign2Assign_sample_from_MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N_to_138", "old_id": "MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N"}
{"code": "def minimum_cost ( a , n ) :\n    mn = sys.maxsize\n    sum = 0\n    for i in range ( n ) :\n        mn = min ( a [ i ] , mn )\n        sum = sum + a [ i ]\n    return mn * ( sum - mn )", "id": "AugAssign2Assign_sample_from_MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY_to_139", "old_id": "MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY"}
{"code": "def calculateEnergy ( mat , n ) :\n    tot_energy = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            q = mat [ i ] [ j ] // n\n            i_des = q\n            j_des = mat [ i ] [ j ] - ( n * q )\n            tot_energy = tot_energy + ( abs ( i_des - i ) + abs ( j_des - j ) )\n    return tot_energy", "id": "AugAssign2Assign_sample_from_MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1_to_140", "old_id": "MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1"}
{"code": "def MinimumCost ( cost , n , W ) :\n    val = list ( )\n    wt = list ( )\n    size = 0\n    for i in range ( n ) :\n        if ( cost [ i ] != - 1 ) :\n            val.append ( cost [ i ] )\n            wt.append ( i + 1 )\n            size = size + 1\n    n = size\n    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( W + 1 ) :\n        min_cost [ 0 ] [ i ] = INF\n    for i in range ( 1 , n + 1 ) :\n        min_cost [ i ] [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , W + 1 ) :\n            if ( wt [ i - 1 ] > j ) :\n                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]\n            else :\n                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )\n    if ( min_cost [ n ] [ W ] == INF ) :\n        return - 1\n    else :\n        return min_cost [ n ] [ W ]", "id": "AugAssign2Assign_sample_from_MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG_to_141", "old_id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG"}
{"code": "def minimumflip ( mat , n ) :\n    flip = 0\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if mat [ i ] [ j ] != mat [ j ] [ i ] :\n                flip = flip + 1\n    return flip", "id": "AugAssign2Assign_sample_from_MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1_to_142", "old_id": "MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1"}
{"code": "def minOps ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    for i in range ( 0 , n ) :\n        if ( ( max1 - arr [ i ] ) % k != 0 ) :\n            return - 1\n        else :\n            res = res + ( max1 - arr [ i ] ) / k\n    return int ( res )", "id": "AugAssign2Assign_sample_from_MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL_to_143", "old_id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL"}
{"code": "def smallestSubWithSum ( arr , n , x ) :\n    curr_sum = 0\n    min_len = n + 1\n    start = 0\n    end = 0\n    while ( end < n ) :\n        while ( curr_sum <= x and end < n ) :\n            if ( curr_sum <= 0 and x > 0 ) :\n                start = end\n                curr_sum = 0\n            curr_sum = curr_sum + arr [ end ]\n            end = end + 1\n        while ( curr_sum > x and start < n ) :\n            if ( end - start < min_len ) :\n                min_len = end - start\n            curr_sum = curr_sum - arr [ start ]\n            start = start + 1\n    return min_len", "id": "AugAssign2Assign_sample_from_MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1_to_144", "old_id": "MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1"}
{"code": "def subset ( ar , n ) :\n    res = 0\n    ar.sort ( )\n    i = 0\n    while i < n:\n        count = 1\n        j = i\n        while j < n - 1:\n            if ar [ j ] == ar [ j + 1 ] :\n                count = count + 1\n            else :\n                break\n            j = j + 1\n        i = j\n        i = i + 1\n        res = max ( res , count )\n    return res", "id": "AugAssign2Assign_sample_from_MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_to_145", "old_id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS"}
{"code": "def subset ( arr , n ) :\n    maxv = max(arr)\n    minv = min(arr)\n    mp = { i : 0 for i in range ( minv, maxv+1 ) }\n    for i in range ( n ) :\n        mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n    res = 0\n    for key , value in mp.items ( ) :\n        res = max ( res , value )\n    return res", "id": "AugAssign2Assign_sample_from_MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1_to_146", "old_id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1"}
{"code": "def minOperation ( arr , n ) :\n    Hash = defaultdict ( lambda : 0 )\n    for i in range ( 0 , n ) :\n        Hash [ arr [ i ] ] = Hash [ arr [ i ] ] + 1\n    max_count = 0\n    for i in Hash :\n        if max_count < Hash [ i ] :\n            max_count = Hash [ i ]\n    return n - max_count", "id": "AugAssign2Assign_sample_from_MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY_to_147", "old_id": "MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY"}
{"code": "def minPerimeter ( n ) :\n    l = int ( math.sqrt ( n ) )\n    sq = l * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = int ( n / l )\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter = perimeter + 2\n        return perimeter", "id": "AugAssign2Assign_sample_from_MINIMUM_PERIMETER_N_BLOCKS_to_148", "old_id": "MINIMUM_PERIMETER_N_BLOCKS"}
{"code": "def minProduct(arr, n, k):\n    pq = []\n    for i in range(n):\n        heapq.heappush(pq, arr[i])\n    count = 0\n    ans = 1\n    while pq and count < k:\n        ans = ans + heapq.heappop(pq)\n        count = count + 1\n    return ans", "id": "AugAssign2Assign_sample_from_MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS_to_149", "old_id": "MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS"}
{"code": "def findMinRooms ( slots , n , m ) :\n    counts = [ 0 ] * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if i < len(slots) and j < len(slots[i]):\n                if ( slots [ i ] [ j ] == '1' ) :\n                    counts [ j ] = counts [ j ] + 1\n    return max ( counts )", "id": "AugAssign2Assign_sample_from_MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE_to_150", "old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE"}
{"code": "def minRotation ( input , unlock_code ) :\n    rotation = 0\n    while ( input > 0 or unlock_code > 0 ) :\n        input_digit = input % 10\n        code_digit = unlock_code % 10\n        rotation = rotation + min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) )\n        input = int ( input / 10 )\n        unlock_code = int ( unlock_code / 10 )\n    return rotation", "id": "AugAssign2Assign_sample_from_MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK_to_151", "old_id": "MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK"}
{"code": "def segregateElements ( arr , n ) :\n    temp = [ 0 for k in range ( n ) ]\n    j = 0\n    for i in range ( n ) :\n        if ( arr [ i ] >= 0 ) :\n            temp [ j ] = arr [ i ]\n            j = j + 1\n    if ( j == n or j == 0 ) :\n        return\n    for i in range ( n ) :\n        if ( arr [ i ] < 0 ) :\n            temp [ j ] = arr [ i ]\n            j = j + 1\n    for k in range ( n ) :\n        arr [ k ] = temp [ k ]", "id": "AugAssign2Assign_sample_from_MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED_to_152", "old_id": "MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED"}
{"code": "def moduloMultiplication ( a , b , mod ) :\n    res = 0 ;\n    a = a % mod ;\n    while ( b ) :\n        if ( b & 1 ) :\n            res = ( res + a ) % mod ;\n        a = ( 2 * a ) % mod ;\n        b = b >> 1\n    return res ;", "id": "AugAssign2Assign_sample_from_MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO_to_153", "old_id": "MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO"}
{"code": "def nextPowerOf2 ( n ) :\n    count = 0\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( n != 0 ) :\n        n = n >> 1\n        count = count + 1\n    return 1 << count", "id": "AugAssign2Assign_sample_from_NEXT_POWER_OF_2_to_154", "old_id": "NEXT_POWER_OF_2"}
{"code": "def nextPowerOf2 ( n ) :\n    p = 1\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( p < n ) :\n        p = p << 1\n    return p", "id": "AugAssign2Assign_sample_from_NEXT_POWER_OF_2_1_to_155", "old_id": "NEXT_POWER_OF_2_1"}
{"code": "def nextPowerOf2 ( n ) :\n    n = n - 1\n    n = n | n >> 1\n    n = n | n >> 2\n    n = n | n >> 4\n    n = n | n >> 8\n    n = n | n >> 16\n    n = n + 1\n    return n", "id": "AugAssign2Assign_sample_from_NEXT_POWER_OF_2_2_to_156", "old_id": "NEXT_POWER_OF_2_2"}
{"code": "def firstNonRepeating ( arr , n ) :\n    for i in range ( n ) :\n        j = 0\n        while ( j < n ) :\n            if ( i != j and arr [ i ] == arr [ j ] ) :\n                break\n            j = j + 1\n        if ( j == n ) :\n            return arr [ i ]\n    return - 1", "id": "AugAssign2Assign_sample_from_NON_REPEATING_ELEMENT_to_157", "old_id": "NON_REPEATING_ELEMENT"}
{"code": "def firstNonRepeating ( arr , n ) :\n    mp = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n    for i in range ( n ) :\n        if mp [ arr [ i ] ] == 1 :\n            return arr [ i ]\n    return - 1", "id": "AugAssign2Assign_sample_from_NON_REPEATING_ELEMENT_1_to_158", "old_id": "NON_REPEATING_ELEMENT_1"}
{"code": "def evenlength ( n ) :\n    res = n\n    for j in range ( len ( n ) - 1 , - 1 , - 1 ) :\n        res = res + n [ j ]\n    return res", "id": "AugAssign2Assign_sample_from_NTH_EVEN_LENGTH_PALINDROME_to_159", "old_id": "NTH_EVEN_LENGTH_PALINDROME"}
{"code": "def findPosition ( k , n ) :\n    f1 = 0\n    f2 = 1\n    i = 2\n    while i != 0 :\n        f3 = f1 + f2\n        f1 = f2\n        f2 = f3\n        if f2 % k == 0 :\n            return n * i\n        i = i + 1\n    return", "id": "AugAssign2Assign_sample_from_NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES_to_160", "old_id": "NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES"}
{"code": "def divisible ( num ) :\n    n = len ( num )\n    sum = 0\n    for i in range ( n ) :\n        sum = sum + ord ( num [ i ] )\n    if ( sum % 3 == 0 ) :\n        return 0\n    if ( n == 1 ) :\n        return - 1\n    for i in range ( n ) :\n        if ( sum % 3 == ord ( num [ i ] ) % 3 ) :\n            return 1\n    if ( n == 2 ) :\n        return - 1\n    return 2", "id": "AugAssign2Assign_sample_from_NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3_to_161", "old_id": "NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3"}
{"code": "def answer_query ( a , n , l , r ) :\n    count = 0\n    for i in range ( l , r ) :\n        if ( a [ i ] == a [ i + 1 ] ) :\n            count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE_to_162", "old_id": "NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE"}
{"code": "def isDivisible ( n ) :\n    while ( int ( n / 100 ) ) :\n        last_digit = int ( n % 10 )\n        n = int ( n / 10 )\n        n = n + last_digit * 3\n    return ( n % 29 == 0 )", "id": "AugAssign2Assign_sample_from_NUMBER_IS_DIVISIBLE_BY_29_OR_NOT_to_163", "old_id": "NUMBER_IS_DIVISIBLE_BY_29_OR_NOT"}
{"code": "def countIntegralSolutions ( n ) :\n    result = 0\n    for i in range ( n + 1 ) :\n        for j in range ( n + 1 ) :\n            for k in range ( n + 1 ) :\n                if i + j + k == n :\n                    result = result + 1\n    return result", "id": "AugAssign2Assign_sample_from_NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_to_164", "old_id": "NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N"}
{"code": "def sumEqualProduct ( a , n ) :\n    zero = 0\n    two = 0\n    for i in range ( n ) :\n        if a [ i ] == 0 :\n            zero = zero + 1\n        if a [ i ] == 2 :\n            two = two + 1\n    cnt = ( zero * ( zero - 1 ) ) // 2 + \\\n        ( two * ( two - 1 ) ) // 2\n    return cnt", "id": "AugAssign2Assign_sample_from_NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT_to_165", "old_id": "NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT"}
{"code": "def countOccurrences ( s , K ) :\n    n = len ( s )\n    c1 = 0\n    c2 = 0\n    C = 0\n    for i in range ( n ) :\n        if s [ i ] == 'a' :\n            c1 = c1 + 1\n        if s [ i ] == 'b' :\n            c2 = c2 + 1\n            C = C + c1\n    return C * K + int ( K * ( K - 1 ) / 2 ) * c1 * c2", "id": "AugAssign2Assign_sample_from_NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES_to_166", "old_id": "NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES"}
{"code": "def countDivisibleSubseq ( str , n ) :\n    l = len ( str )\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( l ) ]\n    dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] = dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] + 1\n    for i in range ( 1 , l ) :\n        dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] = dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] + 1\n        for j in range ( n ) :\n            dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j ]\n            dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] = dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] + dp [ i - 1 ] [ j ]\n    return dp [ l - 1 ] [ 0 ]", "id": "AugAssign2Assign_sample_from_NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N_to_167", "old_id": "NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N"}
{"code": "def countRect ( n ) :\n    ans = 0\n    for length in range ( 1 , int ( math.sqrt ( n ) ) + 1 ) :\n        height = length\n        while ( height * length <= n ) :\n            ans = ans + 1\n            height = height + 1\n    return ans", "id": "AugAssign2Assign_sample_from_NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES_to_168", "old_id": "NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES"}
{"code": "def maximumNumberDistinctPrimeRange ( m , n ) :\n    factorCount = [ 0 ] * ( n + 1 )\n    prime = [ False ] * ( n + 1 )\n    for i in range ( n + 1 ) :\n        factorCount [ i ] = 0\n        prime [ i ] = True\n    for i in range ( 2 , n + 1 ) :\n        if ( prime [ i ] == True ) :\n            factorCount [ i ] = 1\n            for j in range ( i * 2 , n + 1 , i ) :\n                factorCount [ j ] = factorCount [ j ] + 1\n                prime [ j ] = False\n    max = factorCount [ m ]\n    num = m\n    for i in range ( m , n + 1 ) :\n        if ( factorCount [ i ] > max ) :\n            max = factorCount [ i ]\n            num = i\n    return num", "id": "AugAssign2Assign_sample_from_NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N_to_169", "old_id": "NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N"}
{"code": "def findNth ( n ) :\n    nthElement = 19 + ( n - 1 ) * 9\n    outliersCount = int ( math.log10 ( nthElement ) ) - 1\n    nthElement = nthElement + 9 * outliersCount\n    return nthElement", "id": "AugAssign2Assign_sample_from_N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2_to_170", "old_id": "N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2"}
{"code": "def findSum ( A , B , n ) :\n    Hash = defaultdict ( lambda : 0 )\n    for i in range ( 0 , n ) :\n        Hash [ A [ i ] ] = Hash [ A [ i ] ] + 1\n        Hash [ B [ i ] ] = Hash [ B [ i ] ] + 1\n    Sum = 0\n    for x in Hash :\n        if Hash [ x ] == 1 :\n            Sum = Sum + x\n    return Sum", "id": "AugAssign2Assign_sample_from_OVERLAPPING_SUM_TWO_ARRAY_to_171", "old_id": "OVERLAPPING_SUM_TWO_ARRAY"}
{"code": "def minimumSquare ( a , b ) :\n    result = 0\n    rem = 0\n    if ( a < b ) :\n        a , b = b , a\n    while ( b > 0 ) :\n        result = result + int ( a / b )\n        rem = int ( a % b )\n        a = b\n        b = rem\n    return result", "id": "AugAssign2Assign_sample_from_PAPER_CUT_MINIMUM_NUMBER_SQUARES_to_172", "old_id": "PAPER_CUT_MINIMUM_NUMBER_SQUARES"}
{"code": "def maxDifference ( arr , N , k ) :\n    S = 0\n    S1 = 0\n    max_difference = 0\n    for i in range ( N ) :\n        S = S + arr [ i ]\n    arr.sort ( reverse = True )\n    M = max ( k , N - k )\n    for i in range ( M ) :\n        S1 = S1 + arr [ i ]\n    max_difference = S1 - ( S - S1 )\n    return max_difference", "id": "AugAssign2Assign_sample_from_PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM_to_173", "old_id": "PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM"}
{"code": "def noAdjacentDup ( s ) :\n    n = len ( s )\n    for i in range ( 1 , n ) :\n        if ( s [ i ] == s [ i - 1 ] ) :\n            s [ i ] = \"a\"\n            while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) :\n                s [ i ] = s [ i ] + 1\n            i = i + 1\n    return s", "id": "AugAssign2Assign_sample_from_PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES_to_174", "old_id": "PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES"}
{"code": "def antiSpiralTraversal ( m , n , a ) :\n    k = 0\n    l = 0\n    stk = [ ]\n    while ( k <= m and l <= n ) :\n        for i in range ( l , n + 1 ) :\n            stk.append ( a [ k ] [ i ] )\n        k = k + 1\n        for i in range ( k , m + 1 ) :\n            stk.append ( a [ i ] [ n ] )\n        n = n - 1\n        if ( k <= m ) :\n            for i in range ( n , l - 1 , - 1 ) :\n                stk.append ( a [ m ] [ i ] )\n            m = m - 1\n        if ( l <= n ) :\n            for i in range ( m , k - 1 , - 1 ) :\n                stk.append ( a [ i ] [ l ] )\n            l = l + 1\n    while len ( stk ) != 0 :\n        print ( str ( stk [ - 1 ] ) , end = \" \" )\n        stk.pop ( )", "id": "AugAssign2Assign_sample_from_PRINT_MATRIX_ANTISPIRAL_FORM_to_175", "old_id": "PRINT_MATRIX_ANTISPIRAL_FORM"}
{"code": "def printSpiral ( mat , r , c ) :\n    a = 0\n    b = 2\n    low_row = 0 if ( 0 > a ) else a\n    low_column = 0 if ( 0 > b ) else b - 1\n    high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1\n    high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1\n    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :\n        i = low_column + 1\n        while ( i <= high_column and i < c and low_row >= 0 ) :\n            print ( mat [ low_row ] [ i ] , end = \" \" )\n            i = i + 1\n        low_row = low_row - 1\n        i = low_row + 2\n        while ( i <= high_row and i < r and high_column < c ) :\n            print ( mat [ i ] [ high_column ] , end = \" \" )\n            i = i + 1\n        high_column = high_column + 1\n        i = high_column - 2\n        while ( i >= low_column and i >= 0 and high_row < r ) :\n            print ( mat [ high_row ] [ i ] , end = \" \" )\n            i = i - 1\n        high_row = high_row + 1\n        i = high_row - 2\n        while ( i > low_row and i >= 0 and low_column >= 0 ) :\n            print ( mat [ i ] [ low_column ] , end = \" \" )\n            i = i - 1\n        low_column = low_column - 1\n    print ( )", "id": "AugAssign2Assign_sample_from_PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT_to_176", "old_id": "PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        bestIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] = blockSize [ bestIdx ] - processSize [ i ]\n    print ( \"Process No.Process Size     Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )", "id": "AugAssign2Assign_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_177", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def binaryToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base1 = 1\n    len1 = len ( num )\n    for i in range ( len1 - 1 , - 1 , - 1 ) :\n        if ( num [ i ] == '1' ) :\n            dec_value = dec_value + base1\n        base1 = base1 * 2\n    return dec_value", "id": "AugAssign2Assign_sample_from_PROGRAM_BINARY_DECIMAL_CONVERSION_1_to_178", "old_id": "PROGRAM_BINARY_DECIMAL_CONVERSION_1"}
{"code": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = ''\n    stars = '*' * len ( word )\n    count = 0\n    index = 0\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index = index + 1\n    result = ' '.join ( word_list )\n    return result", "id": "AugAssign2Assign_sample_from_PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE_to_179", "old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 :\n        return False\n    _sum = 0\n    for i in range ( 9 ) :\n        if 0 <= int ( isbn [ i ] ) <= 9 :\n            _sum = _sum + int ( isbn [ i ] ) * ( 10 - i )\n        else :\n            return False\n    if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) :\n        return False\n    _sum = _sum + 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )", "id": "AugAssign2Assign_sample_from_PROGRAM_CHECK_ISBN_to_180", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def decimalToBinary ( N ) :\n    B_Number = 0\n    cnt = 0\n    while ( N != 0 ) :\n        rem = N % 2\n        c = pow ( 10 , cnt )\n        B_Number = B_Number + rem * c\n        N = N // 2\n        cnt = cnt + 1\n    return B_Number", "id": "AugAssign2Assign_sample_from_PROGRAM_DECIMAL_BINARY_CONVERSION_2_to_181", "old_id": "PROGRAM_DECIMAL_BINARY_CONVERSION_2"}
{"code": "def findMinimumAngle ( arr , n ) :\n    l = 0\n    _sum = 0\n    ans = 360\n    for i in range ( n ) :\n        _sum = _sum + arr [ i ]\n        while _sum >= 180 :\n            ans = min ( ans , 2 * abs ( 180 - _sum ) )\n            _sum = _sum - arr [ l ]\n            l = l + 1\n        ans = min ( ans , 2 * abs ( 180 - _sum ) )\n    return ans", "id": "AugAssign2Assign_sample_from_PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE_to_182", "old_id": "PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE"}
{"code": "def octalToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base = 1\n    temp = num\n    while ( temp ) :\n        last_digit = temp % 10\n        temp = int ( temp / 10 )\n        dec_value = dec_value + last_digit * base\n        base = base * 8\n    return dec_value", "id": "AugAssign2Assign_sample_from_PROGRAM_OCTAL_DECIMAL_CONVERSION_to_183", "old_id": "PROGRAM_OCTAL_DECIMAL_CONVERSION"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        wstIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] = blockSize [ wstIdx ] - processSize [ i ]\n    print ( \"Process No.Process Size Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )", "id": "AugAssign2Assign_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_184", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def countInRange ( arr , n , x , y ) :\n    count = 0 ;\n    for i in range ( n ) :\n        if ( arr [ i ] >= x and arr [ i ] <= y ) :\n            count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE_to_185", "old_id": "QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE"}
{"code": "def rearrange ( arr , n ) :\n    temp = n * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    for i in range ( n ) :\n        if flag is True :\n            temp [ i ] = arr [ large ]\n            large = large - 1\n        else :\n            temp [ i ] = arr [ small ]\n            small = small + 1\n        flag = bool ( 1 - flag )\n    for i in range ( n ) :\n        arr [ i ] = temp [ i ]\n    return arr", "id": "AugAssign2Assign_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_186", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    for i in range ( 0 , n ) :\n        if i % 2 == 0 :\n            arr [ i ] = arr [ i ] + ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx = max_idx - 1\n        else :\n            arr [ i ] = arr [ i ] + ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx = min_idx + 1\n    for i in range ( 0 , n ) :\n        arr [ i ] = int ( arr [ i ] / max_elem )", "id": "AugAssign2Assign_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_187", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def rearrange ( arr , n ) :\n    i = - 1\n    for j in range ( n ) :\n        if ( arr [ j ] < 0 ) :\n            i = i + 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    pos , neg = i + 1 , 0\n    while ( pos < n and neg < pos and arr [ neg ] < 0 ) :\n        arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ]\n        pos = pos + 1\n        neg = neg + 2", "id": "AugAssign2Assign_sample_from_REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH_to_188", "old_id": "REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH"}
{"code": "def remainderWith7 ( num ) :\n    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]\n    series_index = 0\n    result = 0\n    for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) :\n        digit = ord ( num [ i ] ) - 48\n        result = result + digit * series [ series_index ]\n        series_index = ( series_index + 1 ) % 6\n        result = result % 7\n    if ( result < 0 ) :\n        result = ( result + 7 ) % 7\n    return result", "id": "AugAssign2Assign_sample_from_REMAINDER_7_LARGE_NUMBERS_to_189", "old_id": "REMAINDER_7_LARGE_NUMBERS"}
{"code": "def simplify ( Str ) :\n    Len = len ( Str )\n    res = [ None ] * Len\n    index = 0\n    i = 0\n    s = [ ]\n    s.append ( 0 )\n    while ( i < Len ) :\n        if ( Str [ i ] == '+' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index = index + 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index = index + 1\n        elif ( Str [ i ] == '-' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '+'\n                index = index + 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = '-'\n                index = index + 1\n        elif ( Str [ i ] == '(' and i > 0 ) :\n            if ( Str [ i - 1 ] == '-' ) :\n                x = 0 if ( s [ - 1 ] == 1 ) else 1\n                s.append ( x )\n            elif ( Str [ i - 1 ] == '+' ) :\n                s.append ( s [ - 1 ] )\n        elif ( Str [ i ] == ')' ) :\n            s.pop ( )\n        else :\n            res [ index ] = Str [ i ]\n            index = index + 1\n        i = i + 1\n    return \"\".join(res)", "id": "AugAssign2Assign_sample_from_REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS_to_190", "old_id": "REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS"}
{"code": "def removeDuplicates ( S ) :\n    n = len ( S )\n    if ( n < 2 ) :\n        return\n    j = 0\n    for i in range ( 1 , n ) :\n        if ( S [ j ] != S [ i ] ) :\n            j = j + 1\n            S [ j ] = S [ i ]\n    j = j + 1\n    S = S [ : j ]", "id": "AugAssign2Assign_sample_from_REMOVE_CONSECUTIVE_DUPLICATES_STRING_to_191", "old_id": "REMOVE_CONSECUTIVE_DUPLICATES_STRING"}
{"code": "def insertSorted ( arr , n , key , capacity ) :\n    if ( n >= capacity ) :\n        return n\n    i = n - 1\n    while i >= 0 and arr [ i ] > key :\n        arr [ i + 1 ] = arr [ i ]\n        i = i - 1\n    arr [ i + 1 ] = key\n    return ( n + 1 )", "id": "AugAssign2Assign_sample_from_SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1_to_192", "old_id": "SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1"}
{"code": "def selectRandom ( x ) :\n    res = 0\n    count = 0\n    count = count + 1\n    if ( count == 1 ) :\n        res = x\n    else :\n        i = random.randrange ( count )\n        if ( i == count - 1 ) :\n            res = x\n    return res", "id": "AugAssign2Assign_sample_from_SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE_to_193", "old_id": "SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE"}
{"code": "def maxSubArraySum ( a , size ) :\n    max_so_far = - maxsize - 1\n    max_ending_here = 0\n    start = 0\n    end = 0\n    s = 0\n    for i in range ( 0 , size ) :\n        max_ending_here = max_ending_here + a [ i ]\n        if max_so_far < max_ending_here :\n            max_so_far = max_ending_here\n            start = s\n            end = i\n        if max_ending_here < 0 :\n            max_ending_here = 0\n            s = i + 1\n    return ( end - start + 1 )", "id": "AugAssign2Assign_sample_from_SIZE_SUBARRAY_MAXIMUM_SUM_to_194", "old_id": "SIZE_SUBARRAY_MAXIMUM_SUM"}
{"code": "def findSmallestDifference ( A , B , m , n ) :\n    A = A [ : m ]\n    B = B [ : n ]\n    A.sort ( )\n    B.sort ( )\n    a = 0\n    b = 0\n    result = sys.maxsize\n    while ( a < m and b < n ) :\n        if ( abs ( A [ a ] - B [ b ] ) < result ) :\n            result = abs ( A [ a ] - B [ b ] )\n        if ( A [ a ] < B [ b ] ) :\n            a = a + 1\n        else :\n            b = b + 1\n    return result", "id": "AugAssign2Assign_sample_from_SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS_to_195", "old_id": "SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS"}
{"code": "def nextPowerOf2 ( n ) :\n    p = 1\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( p < n ) :\n        p = p << 1\n    return p", "id": "AugAssign2Assign_sample_from_SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1_to_196", "old_id": "SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1"}
{"code": "def nextPowerOf2 ( n ) :\n    n = n - 1\n    n = n | n >> 1\n    n = n | n >> 2\n    n = n | n >> 4\n    n = n | n >> 8\n    n = n | n >> 16\n    n = n + 1\n    return n", "id": "AugAssign2Assign_sample_from_SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2_to_197", "old_id": "SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    for i in range ( n ) :\n        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    for i in range ( n ) :\n        if maximum < arr [ i ] :\n            index = i\n            maximum = arr [ i ]\n    i = 0\n    j = n - 1\n    new_arr = [ 0 ] * n\n    k = 0\n    while i < index and j > index :\n        if arr [ i ] < arr [ j ] :\n            new_arr [ k ] = arr [ i ]\n            k = k + 1\n            i = i + 1\n        else :\n            new_arr [ k ] = arr [ j ]\n            k = k + 1\n            j = j - 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k = k + 1\n        i = i + 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k = k + 1\n        j = j - 1\n        new_arr [ n - 1 ] = maximum\n    for i in range ( n ) :\n        arr [ i ] = new_arr [ i ]", "id": "AugAssign2Assign_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_198", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def twoWaySort ( arr , n ) :\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] & 1 ) :\n            arr [ i ] = arr [ i ] * - 1\n    arr.sort ( )\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] & 1 ) :\n            arr [ i ] = arr [ i ] * - 1", "id": "AugAssign2Assign_sample_from_SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1_to_199", "old_id": "SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1"}
{"code": "def bitonicGenerator ( arr , n ) :\n    evenArr = [ ]\n    oddArr = [ ]\n    for i in range ( n ) :\n        if ( ( i % 2 ) == 0 ) :\n            evenArr.append ( arr [ i ] )\n        else :\n            oddArr.append ( arr [ i ] )\n    evenArr = sorted ( evenArr )\n    oddArr = sorted ( oddArr )\n    oddArr = oddArr [ : : - 1 ]\n    i = 0\n    for j in range ( len ( evenArr ) ) :\n        arr [ i ] = evenArr [ j ]\n        i = i + 1\n    for j in range ( len ( oddArr ) ) :\n        arr [ i ] = oddArr [ j ]\n        i = i + 1", "id": "AugAssign2Assign_sample_from_SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_to_200", "old_id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER"}
{"code": "def KnapSack ( val , wt , n , W ) :\n    mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ]\n    i = 0\n    while i < n :\n        j = 0\n        if i % 2 == 0 :\n            while j < W :\n                j = j + 1\n                if wt [ i ] <= j and j - wt [ i ] < W:\n                    mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] )\n                else :\n                    mat [ 1 ] [ j ] = mat [ 0 ] [ j ]\n        else :\n            while j < W :\n                j = j + 1\n                if wt [ i ] <= j and j - wt [ i ] < W:\n                    mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] )\n                else :\n                    mat [ 0 ] [ j ] = mat [ 1 ] [ j ]\n        i = i + 1\n    if n % 2 == 0 :\n        return mat [ 0 ] [ W ]\n    else :\n        return mat [ 1 ] [ W ]", "id": "AugAssign2Assign_sample_from_SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_to_201", "old_id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM"}
{"code": "def findS ( s ) :\n    _sum = 0\n    n = 1\n    while ( _sum < s ) :\n        _sum = _sum + n * n * n\n        n = n + 1\n    n = n - 1\n    if _sum == s :\n        return n\n    return - 1", "id": "AugAssign2Assign_sample_from_SQUARED_TRIANGULAR_NUMBER_SUM_CUBES_to_202", "old_id": "SQUARED_TRIANGULAR_NUMBER_SUM_CUBES"}
{"code": "def findS ( s ) :\n    _sum = 0\n    n = 1\n    while ( _sum < s ) :\n        _sum = _sum + n * n\n        n = n + 1\n    n = n - 1\n    if _sum == s :\n        return n\n    return - 1", "id": "AugAssign2Assign_sample_from_SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES_to_203", "old_id": "SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES"}
{"code": "def floorSqrt ( x ) :\n    if ( x == 0 or x == 1 ) :\n        return x\n    i = 1\n    result = 1\n    while ( result <= x ) :\n        i = i + 1\n        result = i * i\n    return i - 1", "id": "AugAssign2Assign_sample_from_SQUARE_ROOT_OF_AN_INTEGER_to_204", "old_id": "SQUARE_ROOT_OF_AN_INTEGER"}
{"code": "def firstLetterWord ( str ) :\n    result = \"\"\n    v = True\n    for i in range ( len ( str ) ) :\n        if ( str [ i ] == ' ' ) :\n            v = True\n        elif ( str [ i ] != ' ' and v == True ) :\n            result = result + ( str [ i ] )\n            v = False\n    return result", "id": "AugAssign2Assign_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_205", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def sumoflength ( arr , n ) :\n    s = [ ]\n    j = 0\n    ans = 0\n    for i in range ( n ) :\n        while ( j < n and ( arr [ j ] not in s ) ) :\n            s.append ( arr [ j ] )\n            j = j + 1\n        ans = ans + ( ( j - i ) * ( j - i + 1 ) ) // 2\n        s.remove ( arr [ i ] )\n    return ans", "id": "AugAssign2Assign_sample_from_SUBARRAYS_DISTINCT_ELEMENTS_to_206", "old_id": "SUBARRAYS_DISTINCT_ELEMENTS"}
{"code": "def MaxTotalRectangleArea ( a , n ) :\n    a = a [ : n ]\n    a.sort (  )\n    sum = 0\n    flag = False\n    len = 0\n    i = 0\n    while ( i < n - 1 ) :\n        if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) :\n            flag = True\n            len = a [ i + 1 ]\n            i = i + 1\n        elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) :\n            sum = sum + a [ i + 1 ] * len\n            flag = False\n            i = i + 1\n        i = i + 1\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_AREA_RECTANGLES_POSSIBLE_ARRAY_to_207", "old_id": "SUM_AREA_RECTANGLES_POSSIBLE_ARRAY"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        sum = sum + C [ n ] [ i ]\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_208", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def divisorSum ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        sum = sum + int ( n / i ) * i\n    return int ( sum )", "id": "AugAssign2Assign_sample_from_SUM_DIVISORS_1_N_1_to_209", "old_id": "SUM_DIVISORS_1_N_1"}
{"code": "def kthgroupsum ( k ) :\n    cur = int ( ( k * ( k - 1 ) ) + 1 )\n    sum = 0\n    while k :\n        sum = sum + cur\n        cur = cur + 2\n        k = k - 1\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS_to_210", "old_id": "SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS"}
{"code": "def distancesum ( x , y , n ) :\n    sum = 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            sum = sum + ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) )\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_MANHATTAN_DISTANCES_PAIRS_POINTS_to_211", "old_id": "SUM_MANHATTAN_DISTANCES_PAIRS_POINTS"}
{"code": "def findSum ( n ) :\n    arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        for j in range ( n ) :\n            arr [ i ] [ j ] = abs ( i - j )\n    sum = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            sum = sum + arr [ i ] [ j ]\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_to_212", "old_id": "SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS"}
{"code": "def findSum ( n ) :\n    n = n - 1\n    sum = 0\n    sum = sum + ( n * ( n + 1 ) ) / 2\n    sum = sum + ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6\n    return int ( sum )", "id": "AugAssign2Assign_sample_from_SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2_to_213", "old_id": "SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2"}
{"code": "def findSum ( n ) :\n    ans = 0\n    temp = 0\n    for i in range ( 1 , n + 1 ) :\n        if temp < n :\n            temp = i - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans = ans + i * num\n                else :\n                    ans = ans + ( n - temp ) * num\n                temp = temp + i\n                num = num + 1\n    return ans", "id": "AugAssign2Assign_sample_from_SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1_to_214", "old_id": "SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1"}
{"code": "def middlesum ( mat , n ) :\n    row_sum = 0\n    col_sum = 0\n    for i in range ( n ) :\n        row_sum = row_sum + mat [ n // 2 ] [ i ]\n    print ( \"Sum of middle row = \" , row_sum )\n    for i in range ( n ) :\n        col_sum = col_sum + mat [ i ] [ n // 2 ]\n    print ( \"Sum of middle column = \" , col_sum )", "id": "AugAssign2Assign_sample_from_SUM_MIDDLE_ROW_COLUMN_MATRIX_to_215", "old_id": "SUM_MIDDLE_ROW_COLUMN_MATRIX"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    for i in range ( n ) :\n        if ( tree [ i ] == '(' ) :\n            level = level + 1\n        elif ( tree [ i ] == ')' ) :\n            level = level - 1\n        else :\n            if ( level == k ) :\n                sum = sum + ( ord ( tree [ i ] ) - ord ( '0' ) )\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_216", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def sumOfSubstrings ( num ) :\n    n = len ( num )\n    sumofdigit = [ ]\n    sumofdigit.append ( ord ( num [ 0 ] ) - ord('0') )\n    res = sumofdigit [ 0 ]\n    for i in range ( 1 , n ) :\n        numi = ord ( num [ i ] ) - ord ( '0' )\n        sumofdigit.append ( ( i + 1 ) + numi + 10 + sumofdigit [ i - 1 ] )\n        res = res + sumofdigit [ i ]\n    return res", "id": "AugAssign2Assign_sample_from_SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER_to_217", "old_id": "SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    for i in range(n1):\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if sum < 0:\n            str = str + chr(sum % -10 + 48)\n        else:\n            str = str + chr(sum % 10 + 48)\n        carry = int(sum / 10)\n    for i in range(n1, n2):\n        sum = ((ord(str2[i]) - 48) + carry)\n        if sum < 0:\n            str = str + chr(sum % -10 + 48)\n        else:\n            str = str + chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n    if (carry):\n        str = str + chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "AugAssign2Assign_sample_from_SUM_TWO_LARGE_NUMBERS_to_218", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def offeringNumber ( n , templeHeight ) :\n    sum = 0\n    for i in range ( n ) :\n        left = 0\n        right = 0\n        for j in range ( i - 1 , - 1 , - 1 ) :\n            if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) :\n                left = left + 1\n            else :\n                break\n        for j in range ( i + 1 , n ) :\n            if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) :\n                right = right + 1\n            else :\n                break\n        sum = sum + max ( right , left ) + 1\n    return sum", "id": "AugAssign2Assign_sample_from_TEMPLE_OFFERINGS_to_219", "old_id": "TEMPLE_OFFERINGS"}
{"code": "def isTriangular ( num ) :\n    if ( num < 0 ) :\n        return False\n    sum , n = 0 , 1\n    while ( sum <= num ) :\n        sum = sum + n\n        if ( sum == num ) :\n            return True\n        n = n + 1\n    return False", "id": "AugAssign2Assign_sample_from_TRIANGULAR_NUMBERS_to_220", "old_id": "TRIANGULAR_NUMBERS"}
{"code": "def countUnique ( mat , n , m ) :\n    rowsum = [ 0 ] * n\n    colsum = [ 0 ] * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( mat [ i ] [ j ] != 0 ) :\n                rowsum [ i ] = rowsum [ i ] + 1\n                colsum [ j ] = colsum [ j ] + 1\n    uniquecount = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) :\n                uniquecount = uniquecount + 1\n    return uniquecount", "id": "AugAssign2Assign_sample_from_UNIQUE_CELLS_BINARY_MATRIX_to_221", "old_id": "UNIQUE_CELLS_BINARY_MATRIX"}
{"code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    for i in range ( 0 , n , 1 ) :\n        if ( str [ i ] == '1' ) :\n            one_count = one_count + 1\n        else :\n            zero_count = zero_count + 1\n    if ( one_count % 2 == 0 ) :\n        return zero_count\n    return one_count", "id": "AugAssign2Assign_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_222", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
{"code": "def CountWays ( n ) :\n    table = [ 0 ] * ( n + 1 )\n    table [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        for j in range ( i , n + 1 ) :\n            table [ j ] = table [ j ] + table [ j - i ]\n    return table [ n ]", "id": "AugAssign2Assign_sample_from_WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS_to_223", "old_id": "WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS"}
{"code": "def isMultipleOf3 ( n ) :\n    odd_count = 0\n    even_count = 0\n    if ( n < 0 ) :\n        n = - n\n    if ( n == 0 ) :\n        return 1\n    if ( n == 1 ) :\n        return 0\n    while ( n ) :\n        if ( n & 1 ) :\n            odd_count = odd_count + 1\n        if ( n & 2 ) :\n            even_count = even_count + 1\n        n = n >> 2\n    return isMultipleOf3 ( abs ( odd_count - even_count ) )", "id": "AugAssign2Assign_sample_from_WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3_to_224", "old_id": "WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3"}
