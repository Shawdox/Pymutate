{"code": "def getArea ( a ) :\n    area = ( math.pi * a * a ); area = area / 4\n    return area", "id": "AssignUnfoldding_sample_from_AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT_to_0", "old_id": "AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT"}
{"code": "def binarySearch ( arr , l , r , x ) :\n    if r >= l :\n        mid = l; mid = mid + ( r - l ) // 2\n        if arr [ mid ] == x :\n            return mid\n        elif arr [ mid ] > x :\n            return binarySearch ( arr , l , mid - 1 , x )\n        else :\n            return binarySearch ( arr , mid + 1 , r , x )\n    else :\n        return - 1", "id": "AssignUnfoldding_sample_from_BINARY_SEARCH_to_1", "old_id": "BINARY_SEARCH"}
{"code": "def count_of_ways ( n ) :\n    count = 0\n    count = ( n + 1 ) * ( n + 2 ); count = count // 2\n    return count", "id": "AssignUnfoldding_sample_from_BREAK_NUMBER_THREE_PARTS_1_to_2", "old_id": "BREAK_NUMBER_THREE_PARTS_1"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ); res = res - 48\n    for i in range ( 1 , len ( str ) ) :\n        if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) :\n            res += ord ( str [ i ] ) - 48\n        else :\n            res += ord ( str [ i ] ) - 48\n    return res", "id": "AssignUnfoldding_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_3", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def ceilSearch ( arr , low , high , x ) :\n    if x <= arr [ low ] :\n        return low\n    if x > arr [ high ] :\n        return - 1\n    mid = ( low + high ); mid = mid / 2\n    if arr [ mid ] == x :\n        return mid\n    elif arr [ mid ] < x :\n        if mid + 1 <= high and x <= arr [ mid + 1 ] :\n            return mid + 1\n        else :\n            return ceilSearch ( arr , mid + 1 , high , x )\n    else :\n        if mid - 1 >= low and x > arr [ mid - 1 ] :\n            return mid\n        else :\n            return ceilSearch ( arr , low , mid - 1 , x )", "id": "AssignUnfoldding_sample_from_CEILING_IN_A_SORTED_ARRAY_1_to_4", "old_id": "CEILING_IN_A_SORTED_ARRAY_1"}
{"code": "def HalfDiagonalSums ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    i = 0\n    j = n; j = j - 1\n    while i < n :\n        if ( i < n // 2 ) :\n            diag1_left += mat [ i ] [ i ]\n            diag2_left += mat [ j ] [ i ]\n        elif ( i > n // 2 ) :\n            diag1_right += mat [ i ] [ i ]\n            diag2_right += mat [ j ] [ i ]\n        i += 1\n        j -= 1\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )", "id": "AssignUnfoldding_sample_from_CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS_to_5", "old_id": "CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS"}
{"code": "def isPalindrome ( string ) :\n    l = 0\n    h = len ( string ); h = h - 1\n    while h > l :\n        l += 1\n        h -= 1\n        if string [ l - 1 ] != string [ h + 1 ] :\n            return False\n    return True", "id": "AssignUnfoldding_sample_from_CHECK_GIVEN_STRING_ROTATION_PALINDROME_to_6", "old_id": "CHECK_GIVEN_STRING_ROTATION_PALINDROME"}
{"code": "def isPower ( x , y ) :\n    res1 = int ( math.log ( y ) / math.log ( x ) )\n    res2 = math.log ( y ); res2 = res2 / math.log ( x )\n    return 1 if ( res1 == res2 ) else 0", "id": "AssignUnfoldding_sample_from_CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1_to_7", "old_id": "CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1"}
{"code": "def isOverflow ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return False\n    result = a; result = result * b\n    if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) :\n        result = 0\n    if ( a == ( result // b ) ) :\n        return False\n    else :\n        return True", "id": "AssignUnfoldding_sample_from_CHECK_INTEGER_OVERFLOW_MULTIPLICATION_to_8", "old_id": "CHECK_INTEGER_OVERFLOW_MULTIPLICATION"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num = str ( num ); num = num + \"00\"\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ); num = num + \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    for i in range ( length - 1 , - 1 , - 3 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "AssignUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_9", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def check ( str ) :\n    n = len ( str )\n    digitSum = 0\n    for i in range ( 0 , n ) :\n        digitSum = digitSum + ord ( str [ i ] ); digitSum = digitSum - 48\n    return ( digitSum % 9 == 0 )", "id": "AssignUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT_to_10", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT"}
{"code": "def isRotated ( str1 , str2 ) :\n    if ( len ( str1 ) != len ( str2 ) ) :\n        return False\n    clock_rot = \"\"\n    anticlock_rot = \"\"\n    l = len ( str2 )\n    anticlock_rot = anticlock_rot + str2 [ l - 2 : ]; anticlock_rot = anticlock_rot + str2 [ 0 : l - 2 ]\n    clock_rot = clock_rot + str2 [ 2 : ]; clock_rot = clock_rot + str2 [ 0 : 2 ]\n    return ( str1 == clock_rot or str1 == anticlock_rot )", "id": "AssignUnfoldding_sample_from_CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES_to_11", "old_id": "CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES"}
{"code": "def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :\n    distSq = ( x1 - x2 ) * ( x1 - x2 ); distSq = distSq + ( y1 - y2 ) * ( y1 - y2 )\n    radSumSq = ( r1 + r2 ); radSumSq = radSumSq * ( r1 + r2 )\n    if ( distSq == radSumSq ) :\n        return 1\n    elif ( distSq > radSumSq ) :\n        return - 1\n    else :\n        return 0", "id": "AssignUnfoldding_sample_from_CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT_to_12", "old_id": "CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT"}
{"code": "def isPossible ( n , index , modulo , M , arr , dp ) :\n    modulo = ( ( modulo % M ) + M ); modulo = modulo % M\n    if ( index == n ) :\n        if ( modulo == 0 ) :\n            return 1\n        return 0\n    if ( dp [ index ] [ modulo ] != - 1 ) :\n        return dp [ index ] [ modulo ]\n    placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp )\n    placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp )\n    res = bool ( placeAdd or placeMinus )\n    dp [ index ] [ modulo ] = res\n    return res", "id": "AssignUnfoldding_sample_from_CHECK_VALID_SEQUENCE_DIVISIBLE_M_1_to_13", "old_id": "CHECK_VALID_SEQUENCE_DIVISIBLE_M_1"}
{"code": "def checkIsAP ( arr , n ) :\n    if ( n == 1 ) : return True\n    arr.sort ( )\n    d = arr [ 1 ]; d = d - arr [ 0 ]\n    for i in range ( 2 , n ) :\n        if ( arr [ i ] - arr [ i - 1 ] != d ) :\n            return False\n    return True", "id": "AssignUnfoldding_sample_from_CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY_to_14", "old_id": "CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if ( n % 3 == 1 ) :\n        num = str ( num ); num = num + \"00\"\n        n += 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ); num = num + \"0\"\n        n += 1\n    GSum = 0\n    p = 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n    return ( GSum % 7 == 0 )", "id": "AssignUnfoldding_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_15", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def nCrModp ( n , r , p ) :\n    C = [ 0 for i in range ( r + 1 ) ]\n    C [ 0 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( min ( i , r ) , 0 , - 1 ) :\n            C [ j ] = ( C [ j ] + C [ j - 1 ] ); C [ j ] = C [ j ] % p\n    return C [ r ]", "id": "AssignUnfoldding_sample_from_COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION_to_16", "old_id": "COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION"}
{"code": "def decimalToBinary ( num , k_prec ) :\n    binary = \"\"\n    Integral = int ( num )\n    fractional = num; fractional = fractional - Integral\n    while ( Integral > 0 ) :\n        rem = Integral; rem = rem % 2\n        binary += str ( rem )\n        Integral //= 2\n    binary = binary [ : : - 1 ]\n    binary += '.'\n    while ( k_prec > 0 ) :\n        fractional *= 2\n        fract_bit = int ( fractional )\n        if ( fract_bit == 1 ) :\n            fractional -= fract_bit\n            binary += '1'\n        else :\n            binary += '0'\n        k_prec -= 1\n    return binary", "id": "AssignUnfoldding_sample_from_CONVERT_DECIMAL_FRACTION_BINARY_NUMBER_to_17", "old_id": "CONVERT_DECIMAL_FRACTION_BINARY_NUMBER"}
{"code": "def numberOfWays ( x ) :\n    dp = [ 0 for _ in range (x + 1)]\n    dp[0] = dp[1] = 1\n    for i in range(2, x + 1):\n        dp[i] = dp[i - 1]; dp[i] = dp[i] + (i - 1) * dp[i - 2]\n    return dp[x]", "id": "AssignUnfoldding_sample_from_COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1_to_18", "old_id": "COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1"}
{"code": "def countBT ( h ) :\n    MOD = 1000000007\n    dp = [ 0 for i in range ( h + 1 ) ]\n    dp [ 0 ] = 1\n    dp [ 1 ] = 1\n    for i in range ( 2 , h + 1 ) :\n        dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ); dp [ i ] = dp [ i ] % MOD\n    return dp [ h ]", "id": "AssignUnfoldding_sample_from_COUNT_BALANCED_BINARY_TREES_HEIGHT_H_to_19", "old_id": "COUNT_BALANCED_BINARY_TREES_HEIGHT_H"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( k + 1 ) :\n            if j >= i:\n                break\n            else:\n                dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ]; dp [ i ] [ j ] [ 0 ] = dp [ i ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ]\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_20", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def countDer ( n ) :\n    der = [ 0 for i in range ( n + 1 ) ]\n    der [ 0 ] = 1\n    der [ 1 ] = 0\n    der [ 2 ] = 1\n    for i in range ( 3 , n + 1 ) :\n        der [ i ] = ( i - 1 ); der [ i ] = der [ i ] * ( der [ i - 1 ] + der [ i - 2 ] )\n    return der [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1_to_21", "old_id": "COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1"}
{"code": "def findSubsequenceCount ( S , T ) :\n    m = len ( T )\n    n = len ( S )\n    if m > n :\n        return 0\n    mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ]\n    for i in range ( 1 , m + 1 ) :\n        mat [ i ] [ 0 ] = 0\n    for j in range ( n + 1 ) :\n        mat [ 0 ] [ j ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if T [ i - 1 ] != S [ j - 1 ] :\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]\n            else :\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]; mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ i - 1 ] [ j - 1 ]\n    return mat [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE_to_22", "old_id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE"}
{"code": "def countNumber ( n ) :\n    result = 0\n    for i in range ( 1 , 10 ) :\n        s = [ ]\n        if ( i <= n ) :\n            s.append ( i )\n            result += 1\n        while len ( s ) != 0 :\n            tp = s [ - 1 ]\n            s.pop ( )\n            for j in range ( tp % 10 , 10 ) :\n                x = tp * 10; x = x + j\n                if ( x <= n ) :\n                    s.append ( x )\n                    result += 1\n    return result", "id": "AssignUnfoldding_sample_from_COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER_to_23", "old_id": "COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER"}
{"code": "def countNegative ( M , n , m ) :\n    count = 0\n    i = 0\n    j = m; j = j - 1\n    while j >= 0 and i < n :\n        if M [ i ] [ j ] < 0 :\n            count += ( j + 1 )\n            i += 1\n        else :\n            j -= 1\n    return count", "id": "AssignUnfoldding_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1_to_24", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1"}
{"code": "def countStrings ( n ) :\n    a = [ 0 for i in range ( n ) ]\n    b = [ 0 for i in range ( n ) ]\n    a [ 0 ] = b [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        a [ i ] = a [ i - 1 ]; a [ i ] = a [ i ] + b [ i - 1 ]\n        b [ i ] = a [ i - 1 ]\n    return a [ n - 1 ] + b [ n - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S_to_25", "old_id": "COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S"}
{"code": "def possibleStrings ( n , r , b , g ) :\n    fact = [ 0 for i in range ( n + 1 ) ]\n    fact [ 0 ] = 1\n    for i in range ( 1 , n + 1 , 1 ) :\n        fact [ i ] = fact [ i - 1 ]; fact [ i ] = fact [ i ] + i\n    left = n; left = left - ( r + g + b )\n    sum = 0\n    for i in range ( 0 , left + 1 , 1 ) :\n        for j in range ( 0 , left - i + 1 , 1 ) :\n            k = left; k = k - ( i + j )\n            sum = int ( sum + fact [ n ] / ( fact [ i + r ] + fact [ j + b ] + fact [ k + g ] ) )\n    return sum", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION_to_26", "old_id": "COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION"}
{"code": "def countP ( n , k ) :\n    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        dp [ i ] [ 0 ] = 0\n    for i in range ( k + 1 ) :\n        dp [ 0 ] [ k ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , k + 1 ) :\n            if ( j == 1 or i == j ) :\n                dp [ i ] [ j ] = 1\n            else :\n                dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n    return dp [ n ] [ k ]", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1_to_27", "old_id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1"}
{"code": "def CountPairs ( n ) :\n    k = n\n    imin = 1\n    ans = 0\n    while ( imin <= n ) :\n        imax = int ( n / k )\n        ans += k * ( imax - imin + 1 )\n        imin = imax; imin = imin + 1\n        k = int ( n / imin )\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B_to_28", "old_id": "COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B"}
{"code": "def countWays ( n , m ) :\n    count = [ ]\n    for i in range ( n + 2 ) :\n        count.append ( 0 )\n    count [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        if ( i > m ) :\n            count [ i ] = count [ i - 1 ]; count [ i ] = count [ i ] + count [ i - m ]\n        elif ( i < m ) :\n            count [ i ] = 1\n        else :\n            count [ i ] = 2\n    return count [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES_to_29", "old_id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ); ans = ans // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    for i in range ( n ) :\n        if ( str [ i ] == 'a' ) :\n            a_index = i; a_index = a_index + 1\n            ans -= min ( b_index , c_index )\n        elif ( str [ i ] == 'b' ) :\n            b_index = i; b_index = b_index + 1\n            ans -= min ( a_index , c_index )\n        else :\n            c_index = i; c_index = c_index + 1\n            ans -= min ( a_index , b_index )\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_30", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def countPairs ( arr , n ) :\n    result = 0 ;\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            product = arr [ i ]; product = product * arr [ j ]\n            for k in range ( 0 , n ) :\n                if ( arr [ k ] == product ) :\n                    result = result + 1 ;\n                    break ;\n    return result ;", "id": "AssignUnfoldding_sample_from_COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_to_31", "old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY"}
{"code": "def countPairs ( arr , n ) :\n    result = 0\n    Hash = set ( )\n    for i in range ( n ) :\n        Hash.add ( arr [ i ] )\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            product = arr [ i ]; product = product * arr [ j ]\n            if product in ( Hash ) :\n                result += 1\n    return result", "id": "AssignUnfoldding_sample_from_COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1_to_32", "old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1"}
{"code": "def CountPS ( str , n ) :\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n    for i in range ( n - 1 ) :\n        if ( str [ i ] == str [ i + 1 ] ) :\n            P [ i ] [ i + 1 ] = True\n            dp [ i ] [ i + 1 ] = 1\n    for gap in range ( 2 , n ) :\n        for i in range ( n - gap ) :\n            j = gap; j = j + i\n            if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) :\n                P [ i ] [ j ] = True\n            if ( P [ i ] [ j ] == True ) :\n                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1; dp [ i ] [ j ] = dp [ i ] [ j ] - dp [ i + 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] - dp [ i + 1 ] [ j - 1 ]\n    return dp [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_PALINDROME_SUB_STRINGS_STRING_to_33", "old_id": "COUNT_PALINDROME_SUB_STRINGS_STRING"}
{"code": "def countPS ( str ) :\n    N = len ( str )\n    cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ]\n    for i in range ( N ) :\n        cps [ i ] [ i ] = 1\n    for L in range ( 2 , N + 1 ) :\n        for i in range ( N ) :\n            k = L + i; k = k - 1\n            if ( k < N ) :\n                if ( str [ i ] == str [ k ] ) :\n                    cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ]; cps [ i ] [ k ] = cps [ i ] [ k ] + 1\n                else :\n                    cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ]; cps [ i ] [ k ] = cps [ i ] [ k ] - cps [ i + 1 ] [ k - 1 ]\n    return cps [ 0 ] [ N - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_to_34", "old_id": "COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING"}
{"code": "def countDecodingDP ( digits , n ) :\n    count = [ 0 ]; count = count * ( n + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == '0' :\n        return 0\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > '0' ) :\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :\n            count [ i ] += count [ i - 2 ]\n    return count [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1_to_35", "old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1"}
{"code": "def numberOfPaths ( m , n ) :\n    count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ]\n    for i in range ( m ) :\n        count [ i ] [ 0 ] = 1 ;\n    for j in range ( n ) :\n        count [ 0 ] [ j ] = 1 ;\n    for i in range ( 1 , m ) :\n        for j in range ( n ) :\n            count [ i ] [ j ] = count [ i - 1 ] [ j ]; count [ i ] [ j ] = count [ i ] [ j ] + count [ i ] [ j - 1 ]\n    return count [ m - 1 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1_to_36", "old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1"}
{"code": "def countRotations ( n ) :\n    l = len ( n )\n    if ( l == 1 ) :\n        oneDigit = ( int ) ( n [ 0 ] )\n        if ( oneDigit % 4 == 0 ) :\n            return 1\n        return 0\n    count = 0\n    for i in range ( 0 , l - 1 ) :\n        twoDigit = ( int ) ( n [ i ] ) * 10; twoDigit = twoDigit + ( int ) ( n [ i + 1 ] )\n        if ( twoDigit % 4 == 0 ) :\n            count = count + 1\n    twoDigit = ( int ) ( n [ l - 1 ] ) * 10; twoDigit = twoDigit + ( int ) ( n [ 0 ] )\n    if ( twoDigit % 4 == 0 ) :\n        count = count + 1\n    return count", "id": "AssignUnfoldding_sample_from_COUNT_ROTATIONS_DIVISIBLE_4_to_37", "old_id": "COUNT_ROTATIONS_DIVISIBLE_4"}
{"code": "def countRotationsDivBy8 ( n ) :\n    l = len ( n )\n    count = 0\n    if ( l == 1 ) :\n        oneDigit = int ( n [ 0 ] )\n        if ( oneDigit % 8 == 0 ) :\n            return 1\n        return 0\n    if ( l == 2 ) :\n        first = int ( n [ 0 ] ) * 10; first = first + int ( n [ 1 ] )\n        second = int ( n [ 1 ] ) * 10; second = second + int ( n [ 0 ] )\n        if ( first % 8 == 0 ) :\n            count += 1\n        if ( second % 8 == 0 ) :\n            count += 1\n        return count\n    threeDigit = 0\n    for i in range ( 0 , ( l - 2 ) ) :\n        threeDigit = int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10; threeDigit = threeDigit + int ( n [ i + 2 ] )\n        if ( threeDigit % 8 == 0 ) :\n            count += 1\n    threeDigit = int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10; threeDigit = threeDigit + int ( n [ 1 ] )\n    if ( threeDigit % 8 == 0 ) :\n        count += 1\n    threeDigit = int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10; threeDigit = threeDigit + int ( n [ 0 ] )\n    if ( threeDigit % 8 == 0 ) :\n        count += 1\n    return count", "id": "AssignUnfoldding_sample_from_COUNT_ROTATIONS_DIVISIBLE_8_to_38", "old_id": "COUNT_ROTATIONS_DIVISIBLE_8"}
{"code": "def countStrings ( n ) :\n    a = [ 0 ]; a = a * n\n    b = [ 0 ]; b = b * n\n    a [ 0 ] = b [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        a [ i ] = a [ i - 1 ]; a [ i ] = a [ i ] + b [ i - 1 ]\n        b [ i ] = a [ i - 1 ]\n    return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_STRINGS_WITH_CONSECUTIVE_1S_to_39", "old_id": "COUNT_STRINGS_WITH_CONSECUTIVE_1S"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ]; hash_positive = hash_positive * ( n + 1 )\n    hash_negative = [ 0 ]; hash_negative = hash_negative * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    for i in range ( n ) :\n        if ( arr [ i ] & 1 == 1 ) :\n            difference = difference + 1\n        else :\n            difference = difference - 1\n        if ( difference < 0 ) :\n            ans += hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ]; hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n        else :\n            ans += hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ]; hash_positive [ difference ] = hash_positive [ difference ] + 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_40", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1; change = change << i\n        for j in range ( 0 , n + 1 ) :\n            ans += k\n            if change == 1 :\n                k = not k\n                change = 1; change = change << i\n            else :\n                change -= 1\n        i += 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_41", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def countWays ( n ) :\n    dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ]\n    dp [ 0 ] [ 1 ] = 1\n    dp [ 1 ] [ 1 ] = 2\n    for i in range ( 2 , n + 1 ) :\n        dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]; dp [ 0 ] [ i ] = dp [ 0 ] [ i ] + dp [ 1 ] [ i - 1 ]\n        dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2; dp [ 1 ] [ i ] = dp [ 1 ] [ i ] + dp [ 1 ] [ i - 1 ]\n    return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS_to_42", "old_id": "COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS"}
{"code": "def chordCnt ( A ) :\n    n = 2; n = n * A\n    dpArray = [ 0 ]; dpArray = dpArray * ( n + 1 )\n    dpArray [ 0 ] = 1\n    dpArray [ 2 ] = 1\n    for i in range ( 4 , n + 1 , 2 ) :\n        for j in range ( 0 , i - 1 , 2 ) :\n            dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] )\n    return int ( dpArray [ n ] )", "id": "AssignUnfoldding_sample_from_COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS_to_43", "old_id": "COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS"}
{"code": "def countWords ( str , n ) :\n    m = dict ( )\n    for i in range ( n ) :\n        m [ str [ i ] ] = m.get ( str [ i ] , 0 ); m [ str [ i ] ] = m [ str [ i ] ] + 1\n    res = 0\n    for i in m.values ( ) :\n        if i == 2 :\n            res += 1\n    return res", "id": "AssignUnfoldding_sample_from_COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS_to_44", "old_id": "COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ]; count = count * NO_OF_CHARS\n    for i in range ( len ( str ) ) :\n        count [ ord ( str [ i ] ) ] += 1\n    first , second = 0 , 0\n    for i in range ( NO_OF_CHARS ) :\n        if count [ i ] > count [ first ] :\n            second = first\n            first = i\n        elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n            second = i\n    return chr ( second )", "id": "AssignUnfoldding_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_45", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    for i in range ( len ( Str ) ) :\n        count = 0\n        if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ); count = count - ord ( '0' )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n        elif ( Str [ i ] == ']' ) :\n            temp = \"\"\n            count = 0\n            if ( len ( integerstack ) != 0 ) :\n                count = integerstack [ - 1 ]\n                integerstack.pop ( )\n            while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                temp = stringstack [ - 1 ] + temp\n                stringstack.pop ( )\n            if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                stringstack.pop ( )\n            for j in range ( count ) :\n                result = result + temp\n            for j in range ( len ( result ) ) :\n                stringstack.append ( result [ j ] )\n            result = \"\"\n        elif ( Str [ i ] == '[' ) :\n            if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                stringstack.append ( Str [ i ] )\n            else :\n                stringstack.append ( Str [ i ] )\n                integerstack.append ( 1 )\n        else :\n            stringstack.append ( Str [ i ] )\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "AssignUnfoldding_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_46", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def dealnnoy ( n , m ) :\n    dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ]\n    for i in range ( m + 1 ) :\n        dp [ 0 ] [ i ] = 1\n    for i in range ( m + 1 ) :\n        dp [ i ] [ 0 ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i ] [ j - 1 ]\n    return dp [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_DELANNOY_NUMBER_1_to_47", "old_id": "DELANNOY_NUMBER_1"}
{"code": "def numberofways ( n , m ) :\n    dp = np.zeros ( ( n + 2 , n + 2 ) )\n    dp [ 0 ] [ n + 1 ] = 1\n    for k in range ( n , m - 1 , - 1 ) :\n        for i in range ( n + 1 ) :\n            dp [ i ] [ k ] = dp [ i ] [ k + 1 ]\n            if ( i - k >= 0 ) :\n                dp [ i ] [ k ] = dp [ i ] [ k ]; dp [ i ] [ k ] = dp [ i ] [ k ] + dp [ i - k ] [ k ]\n    return dp [ n ] [ m ]", "id": "AssignUnfoldding_sample_from_DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M_to_48", "old_id": "DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M"}
{"code": "def discreteLogarithm ( a , b , m ) :\n    n = int ( math.sqrt ( m ) + 1 )\n    an = 1\n    for i in range ( n ) :\n        an = ( an * a ); an = an % m\n    value = [ 0 ]; value = value * m\n    cur = an\n    for i in range ( 1 , n + 1 ) :\n        if ( value [ cur ] == 0 ) :\n            value [ cur ] = i\n        cur = ( cur * an ); cur = cur % m\n    cur = b\n    for i in range ( n + 1 ) :\n        if ( value [ cur ] > 0 ) :\n            ans = value [ cur ] * n; ans = ans - i\n            if ( ans < m ) :\n                return ans\n        cur = ( cur * a ); cur = cur % m\n    return - 1", "id": "AssignUnfoldding_sample_from_DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B_to_49", "old_id": "DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B"}
{"code": "def longDivision ( number , divisor ) :\n    ans = \"\"\n    idx = 0\n    temp = ord ( number [ idx ] ); temp = temp - ord ( '0' )\n    while ( temp < divisor ) :\n        temp = temp * 10 + ord ( number [ idx + 1 ] ); temp = temp - ord ( '0' )\n        idx += 1\n    while ( ( len ( number ) ) > idx ) :\n        ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) )\n        temp = ( temp % divisor ) * 10 + ord ( number [ idx + 1 ] ); temp = temp - ord ( '0' )\n        idx += 1\n    ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) )\n    if ( len ( ans ) == 0 ) :\n        return \"0\"\n    return ans", "id": "AssignUnfoldding_sample_from_DIVIDE_LARGE_NUMBER_REPRESENTED_STRING_to_50", "old_id": "DIVIDE_LARGE_NUMBER_REPRESENTED_STRING"}
{"code": "def eggDrop ( n , k ) :\n    eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        eggFloor [ i ] [ 1 ] = 1\n        eggFloor [ i ] [ 0 ] = 0\n    for j in range ( 1 , k + 1 ) :\n        eggFloor [ 1 ] [ j ] = j\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 2 , k + 1 ) :\n            eggFloor [ i ] [ j ] = INT_MAX\n            for x in range ( 1 , j + 1 ) :\n                res = 1; res = res + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] )\n                if res < eggFloor [ i ] [ j ] :\n                    eggFloor [ i ] [ j ] = res\n    return eggFloor [ n ] [ k ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1_to_51", "old_id": "DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1"}
{"code": "def lps ( seq ) :\n    n = len ( seq )\n    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]\n    for i in range ( n ) :\n        L [ i ] [ i ] = 1\n    for cl in range ( 2 , n + 1 ) :\n        for i in range ( n - cl + 1 ) :\n            j = i + cl; j = j - 1\n            if seq [ i ] == seq [ j ] and cl == 2 :\n                L [ i ] [ j ] = 2\n            elif seq [ i ] == seq [ j ] :\n                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ]; L [ i ] [ j ] = L [ i ] [ j ] + 2\n            else :\n                L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;\n    return L [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE_to_52", "old_id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE"}
{"code": "def maxSumIS ( arr , n ) :\n    max = 0\n    msis = [ 0 for x in range ( n ) ]\n    for i in range ( n ) :\n        msis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :\n                msis [ i ] = msis [ j ]; msis [ i ] = msis [ i ] + arr [ i ]\n    for i in range ( n ) :\n        if max < msis [ i ] :\n            max = msis [ i ]\n    return max", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE_to_53", "old_id": "DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE"}
{"code": "def lbs ( arr , n ) :\n    lis = [ 1 for i in range ( n + 1 ) ]\n    for i in range ( 1 , n ) :\n        for j in range ( 0 , i ) :\n            if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) :\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n    lds = [ 1 for i in range ( n + 1 ) ]\n    for i in reversed ( range ( n - 1 ) ) :\n        for j in reversed ( range ( i - 1 , n ) ) :\n            if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) :\n                lds [ i ] = lds [ j ]; lds [ i ] = lds [ i ] + 1\n    maximum = lis [ 0 ] + lds [ 0 ]; maximum = maximum - 1\n    for i in range ( 1 , n ) :\n        maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum )\n    return maximum", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE_to_54", "old_id": "DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE"}
{"code": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = 0\n    k = 0\n    L = 0\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = 0\n    for L in range ( 2 , n + 1 ) :\n        for i in range ( n - L + 1 ) :\n            j = i + L; j = j - 1\n            if L == 2 :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            else :\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )\n            if P [ i ] [ j ] == True :\n                C [ i ] [ j ] = 0\n            else :\n                C [ i ] [ j ] = 100000000\n                for k in range ( i , j ) :\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n    return C [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_to_55", "old_id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if symb [ i ] == 'F' :\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == 'T' :\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n    for gap in range ( 1 , n ) :\n        i = 0\n        for j in range ( gap , n ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i; k = k + g\n                tik = T [ i ] [ k ]; tik = tik + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ]; tkj = tkj + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n            i += 1\n    return T [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_56", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def lis ( arr , n) :\n    lis = [ 1 ]; lis = lis * n\n    for i in range ( 1 , n ) :\n        for j in range ( 0 , i ) :\n            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n    maximum = 0\n    for i in range ( n ) :\n        maximum = max ( maximum , lis [ i ] )\n    return maximum", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1_to_57", "old_id": "DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1"}
{"code": "def MatrixChainOrder ( p , i , j ) :\n    if i == j :\n        return 0\n    _min = sys.maxsize\n    for k in range ( i , j ) :\n        count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ); count = count + p [ i - 1 ] * p [ k ] * p [ j ]\n        if count < _min :\n            _min = count\n    return _min", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_to_58", "old_id": "DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION"}
{"code": "def evenFibSum ( limit ) :\n    if ( limit < 2 ) :\n        return 0\n    ef1 = 0\n    ef2 = 2\n    sm = ef1; sm = sm + ef2\n    while ( ef2 <= limit ) :\n        ef3 = 4 * ef2; ef3 = ef3 + ef1\n        if ( ef3 > limit ) :\n            break\n        ef1 = ef2\n        ef2 = ef3\n        sm = sm + ef2\n    return sm", "id": "AssignUnfoldding_sample_from_EVEN_FIBONACCI_NUMBERS_SUM_to_59", "old_id": "EVEN_FIBONACCI_NUMBERS_SUM"}
{"code": "def findMinZero ( p ) :\n    first = 1\n    second = 1\n    number = 2\n    next = 1\n    while ( next ) :\n        next = ( first + second ); next = next % p\n        first = second\n        second = next\n        number = number + 1\n    return number", "id": "AssignUnfoldding_sample_from_FIBONACCI_MODULO_P_to_60", "old_id": "FIBONACCI_MODULO_P"}
{"code": "def maxHamming ( arr , n ) :\n    brr = [ 0 ]; brr = brr * ( 2 * n + 1 )\n    for i in range ( n ) :\n        brr [ i ] = arr [ i ]\n    for i in range ( n ) :\n        brr [ n + i ] = arr [ i ]\n    maxHam = 0\n    for i in range ( 1 , n ) :\n        currHam = 0\n        k = 0\n        for j in range ( i , i + n ) :\n            if brr [ j ] != arr [ k ] :\n                currHam += 1\n                k = k + 1\n        if currHam == n :\n            return n\n        maxHam = max ( maxHam , currHam )\n    return maxHam", "id": "AssignUnfoldding_sample_from_FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE_to_61", "old_id": "FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE"}
{"code": "def compute ( a , b ) :\n    AM = ( a + b ); AM = AM / 2\n    GM = math.sqrt ( a * b )\n    HM = ( GM * GM ); HM = HM / AM\n    return HM", "id": "AssignUnfoldding_sample_from_FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN_to_62", "old_id": "FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN"}
{"code": "def findIndex ( n ) :\n    if ( n <= 1 ) :\n        return n\n    a = 0\n    b = 1\n    c = 1\n    res = 1\n    while ( c < n ) :\n        c = a; c = c + b\n        res = res + 1\n        a = b\n        b = c\n    return res", "id": "AssignUnfoldding_sample_from_FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME_to_63", "old_id": "FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME"}
{"code": "def computeLastDigit ( A , B ) :\n    variable = 1\n    if ( A == B ) :\n        return 1\n    elif ( ( B - A ) >= 5 ) :\n        return 0\n    else :\n        for i in range ( A + 1 , B + 1 ) :\n            variable = ( variable * ( i % 10 ) ); variable = variable % 10\n        return variable % 10", "id": "AssignUnfoldding_sample_from_FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B_to_64", "old_id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B"}
{"code": "def findMaxAverage ( arr , n , k ) :\n    if k > n :\n        return - 1\n    csum = [ 0 ]; csum = csum * n\n    csum [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        csum [ i ] = csum [ i - 1 ]; csum [ i ] = csum [ i ] + arr [ i ]\n    max_sum = csum [ k - 1 ]\n    max_end = k; max_end = max_end - 1\n    for i in range ( k , n ) :\n        curr_sum = csum [ i ]; curr_sum = curr_sum - csum [ i - k ]\n        if curr_sum > max_sum :\n            max_sum = curr_sum\n            max_end = i\n    return max_end - k + 1", "id": "AssignUnfoldding_sample_from_FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_to_65", "old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH"}
{"code": "def findMaxAverage ( arr , n , k ) :\n    if ( k > n ) :\n        return - 1\n    sum = arr [ 0 ]\n    for i in range ( 1 , k ) :\n        sum += arr [ i ]\n    max_sum = sum\n    max_end = k; max_end = max_end - 1\n    for i in range ( k , n ) :\n        sum = sum + arr [ i ]; sum = sum - arr [ i - k ]\n        if ( sum > max_sum ) :\n            max_sum = sum\n            max_end = i\n    return max_end - k + 1", "id": "AssignUnfoldding_sample_from_FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1_to_66", "old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize; mx = mx - 1\n    for i in range ( r ) :\n        if m [ i ] [ 0 ] < mi :\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx :\n            mx = m [ i ] [ c - 1 ]\n    desired = ( r * c + 1 ); desired = desired // 2\n    while ( mi < mx ) :\n        mid = mi; mid = mid + ( mx - mi ) // 2\n        place = [ 0 ]\n        for i in range ( r ) :\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ]; place [ 0 ] = place [ 0 ] + j\n        if place [ 0 ] < desired :\n            mi = mid; mi = mi + 1\n        else :\n            mx = mid\n    print ( \"Median is\" , mi )\n    return mi", "id": "AssignUnfoldding_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_67", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def findMinDiff ( arr , n ) :\n    diff = 10; diff = diff ** 20\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            if abs ( arr [ i ] - arr [ j ] ) < diff :\n                diff = abs ( arr [ i ] - arr [ j ] )\n    return diff", "id": "AssignUnfoldding_sample_from_FIND_MINIMUM_DIFFERENCE_PAIR_to_68", "old_id": "FIND_MINIMUM_DIFFERENCE_PAIR"}
{"code": "def findMinDiff ( arr , n ) :\n    arr = arr[:n]\n    arr = sorted ( arr )\n    diff = 10; diff = diff ** 20\n    for i in range ( n - 1 ) :\n        if arr [ i + 1 ] - arr [ i ] < diff :\n            diff = arr [ i + 1 ]; diff = diff - arr [ i ]\n    return diff", "id": "AssignUnfoldding_sample_from_FIND_MINIMUM_DIFFERENCE_PAIR_1_to_69", "old_id": "FIND_MINIMUM_DIFFERENCE_PAIR_1"}
{"code": "def minCoins ( coins , m , V ) :\n    table = [ 0 for i in range ( V + 1 ) ]\n    table [ 0 ] = 0\n    for i in range ( 1 , V + 1 ) :\n        table [ i ] = sys.maxsize\n    for i in range ( 1 , V + 1 ) :\n        for j in range ( m ) :\n            if ( coins [ j ] <= i ) :\n                sub_res = table [ i - coins [ j ] ]\n                if ( sub_res != sys.maxsize and sub_res + 1 < table [ i ] ) :\n                    table [ i ] = sub_res; table [ i ] = table [ i ] + 1\n    return table [ V ]", "id": "AssignUnfoldding_sample_from_FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1_to_70", "old_id": "FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1"}
{"code": "def minRadius ( k , x , y , n ) :\n    dis = [ 0 ]; dis = dis * n\n    for i in range ( 0 , n ) :\n        dis [ i ] = x [ i ] * x [ i ]; dis [ i ] = dis [ i ] + y [ i ] * y [ i ]\n    dis.sort ( )\n    return dis [ k - 1 ]", "id": "AssignUnfoldding_sample_from_FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE_to_71", "old_id": "FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE"}
{"code": "def mirrorImage ( a , b , c , x1 , y1 ) :\n    temp = - 2 * ( a * x1 + b * y1 + c ); temp = temp / ( a * a + b * b )\n    x = temp * a; x = x + x1\n    y = temp * b; y = y + y1\n    return ( x , y )", "id": "AssignUnfoldding_sample_from_FIND_MIRROR_IMAGE_POINT_2_D_PLANE_to_72", "old_id": "FIND_MIRROR_IMAGE_POINT_2_D_PLANE"}
{"code": "def count ( a , b ) :\n    m = len ( a )\n    n = len ( b )\n    lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]\n    for i in range ( n + 1 ) :\n        lookup [ 0 ] [ i ] = 0\n    for i in range ( m + 1 ) :\n        lookup [ i ] [ 0 ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if a [ i - 1 ] == b [ j - 1 ] :\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ]; lookup [ i ] [ j ] = lookup [ i ] [ j ] + lookup [ i - 1 ] [ j ]\n            else :\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]\n    return lookup [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1_to_73", "old_id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1"}
{"code": "def findSDSFunc ( n ) :\n    DP = [ 0 ]; DP = DP * ( n + 1 )\n    DP [ 0 ] = 0\n    DP [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        if ( int ( i % 2 ) == 0 ) :\n            DP [ i ] = DP [ int ( i / 2 ) ]\n        else :\n            DP [ i ] = DP [ int ( ( i - 1 ) / 2 ) ]; DP [ i ] = DP [ i ] + DP [ int ( ( i + 1 ) / 2 ) ]\n    return DP [ n ]", "id": "AssignUnfoldding_sample_from_FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES_to_74", "old_id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES"}
{"code": "def pairSum ( mat , n , sum ) :\n    for i in range ( n ) :\n        mat [ i ].sort ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            left = 0\n            right = n; right = right - 1\n            while ( left < n and right >= 0 ) :\n                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) :\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left += 1\n                    right -= 1\n                else :\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1", "id": "AssignUnfoldding_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_75", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    i = 0\n    while i < n :\n        high = max ( high , arr [ i ] )\n        i = i + 1\n    divisors = [ 0 ]; divisors = divisors * ( high + 1 )\n    i = 0\n    while i < n :\n        j = 1\n        while j <= math.sqrt ( arr [ i ] ) :\n            if ( arr [ i ] % j == 0 ) :\n                divisors [ j ] = divisors [ j ]; divisors [ j ] = divisors [ j ] + 1\n                if ( j != arr [ i ] / j ) :\n                    divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ]; divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] + 1\n            j = j + 1\n        i = i + 1\n    i = high\n    while i >= 1 :\n        if ( divisors [ i ] > 1 ) :\n            return i\n        i = i - 1\n    return 1", "id": "AssignUnfoldding_sample_from_FIND_PAIR_MAXIMUM_GCD_ARRAY_to_76", "old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY"}
{"code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    for i in range ( 0 , n ) :\n        high = max ( high , arr [ i ] )\n    count = [ 0 ]; count = count * ( high + 1 )\n    for i in range ( 0 , n ) :\n        count [ arr [ i ] ] += 1\n    counter = 0\n    for i in range ( high , 0 , - 1 ) :\n        j = i\n        while ( j <= high ) :\n            if ( count [ j ] > 0 ) :\n                counter += count [ j ]\n            j += i\n            if ( counter == 2 ) :\n                return i\n        counter = 0\n    return 1\n", "id": "AssignUnfoldding_sample_from_FIND_PAIR_MAXIMUM_GCD_ARRAY_1_to_77", "old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY_1"}
{"code": "def findpos ( n ) :\n    i = 0\n    j = len ( n )\n    pos = 0\n    while ( i < j ) :\n        if ( n [ i ] == '4' ) :\n            pos = pos * 2; pos = pos + 1\n        if ( n [ i ] == '7' ) :\n            pos = pos * 2; pos = pos + 2\n        i = i + 1\n    return pos", "id": "AssignUnfoldding_sample_from_FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7_to_78", "old_id": "FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7"}
{"code": "def countRotations ( arr , low , high ) :\n    if ( high < low ) :\n        return 0\n    if ( high == low ) :\n        return low\n    mid = low; mid = mid + ( high - low ) / 2\n    mid = int ( mid )\n    if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) :\n        return ( mid + 1 )\n    if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) :\n        return mid\n    if ( arr [ high ] > arr [ mid ] ) :\n        return countRotations ( arr , low , mid - 1 )\n    return countRotations ( arr , mid + 1 , high )", "id": "AssignUnfoldding_sample_from_FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1_to_79", "old_id": "FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1"}
{"code": "def subArraySum ( arr , n , sum ) :\n    for i in range ( n ) :\n        curr_sum = arr [ i ]\n        j = i; j = j + 1\n        while j <= n :\n            if curr_sum == sum :\n                print ( \"Sum found between\" )\n                print ( \"indexes %d and %d\" % ( i , j - 1 ) )\n                return 1\n            if curr_sum > sum or j == n :\n                break\n            curr_sum = curr_sum + arr [ j ]\n            j += 1\n    print ( \"No subarray found\" )\n    return 0", "id": "AssignUnfoldding_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_to_80", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM"}
{"code": "def evenSum ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if j == 0 or j == i :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n    sum = 0 ;\n    for i in range ( 0 , n + 1 ) :\n        if i % 2 == 0 :\n            sum = sum + C [ n ] [ i ]\n    return sum", "id": "AssignUnfoldding_sample_from_FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_to_81", "old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS"}
{"code": "def sumNodes ( l ) :\n    leafNodeCount = math.pow ( 2 , l - 1 )\n    sumLastLevel = 0\n    sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ); sumLastLevel = sumLastLevel / 2\n    sum = sumLastLevel; sum = sum * l\n    return sum", "id": "AssignUnfoldding_sample_from_FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1_to_82", "old_id": "FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1"}
{"code": "def findSubarraySum ( arr , n ) :\n    res = 0\n    m = dict ( )\n    for i in range ( n ) :\n        Sum = 0\n        for j in range ( i , n ) :\n            Sum += arr [ j ]\n            m [ Sum ] = m.get ( Sum , 0 ); m [ Sum ] = m [ Sum ] + 1\n    for x in m :\n        if m [ x ] == 1 :\n            res += x\n    return res", "id": "AssignUnfoldding_sample_from_FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY_to_83", "old_id": "FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY"}
{"code": "def findElement ( arr , n ) :\n    leftMax = [ None ]; leftMax = leftMax * n\n    leftMax [ 0 ] = float ( '-inf' )\n    for i in range ( 1 , n ) :\n        leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] )\n    rightMin = float ( 'inf' )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] :\n            return i\n        rightMin = min ( rightMin , arr [ i ] )\n    return - 1", "id": "AssignUnfoldding_sample_from_FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT_to_84", "old_id": "FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    for i in range ( 0 , n - 1 ) :\n        l = i; l = l + 1\n        r = n; r = r - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if ( x + arr [ l ] + arr [ r ] == 0 ) :\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n            elif ( x + arr [ l ] + arr [ r ] < 0 ) :\n                l += 1\n            else :\n                r -= 1\n    if ( found == False ) :\n        print ( \" No Triplet Found\" )", "id": "AssignUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_85", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ]; result = result * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return result", "id": "AssignUnfoldding_sample_from_FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1_to_86", "old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1"}
{"code": "def countFriendsPairings ( n ) :\n    dp = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        if ( i <= 2 ) :\n            dp [ i ] = i\n        else :\n            dp [ i ] = dp [ i - 1 ]; dp [ i ] = dp [ i ] + ( i - 1 ) * dp [ i - 2 ]\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_FRIENDS_PAIRING_PROBLEM_to_87", "old_id": "FRIENDS_PAIRING_PROBLEM"}
{"code": "def countFriendsPairings ( n ) :\n    a , b , c = 1 , 2 , 0\n    if ( n <= 2 ) :\n        return n\n    for i in range ( 3 , n + 1 ) :\n        c = b; c = c + ( i - 1 ) * a\n        a = b\n        b = c\n    return c", "id": "AssignUnfoldding_sample_from_FRIENDS_PAIRING_PROBLEM_2_to_88", "old_id": "FRIENDS_PAIRING_PROBLEM_2"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ]; result = result * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return \"\".join(str(i) for i in result)", "id": "AssignUnfoldding_sample_from_GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1_to_89", "old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1"}
{"code": "def isSubSeqDivisible ( str ) :\n    l = len ( str )\n    arr = [ 0 ]; arr = arr * l\n    for i in range ( 0 , l ) :\n        for j in range ( i , l ) :\n            for k in range ( j , l ) :\n                if ( arr [ i ] % 8 == 0 ) :\n                    return True\n                elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :\n                    return True\n                elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :\n                    return True\n    return False", "id": "AssignUnfoldding_sample_from_GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_to_90", "old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ]; maxRev = maxRev * ( m + 1 )\n    nxtbb = 0\n    for i in range ( 1 , m + 1 ) :\n        if ( nxtbb < n ) :\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb += 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n    return maxRev [ m ]", "id": "AssignUnfoldding_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_91", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def horner ( poly , n , x ) :\n    result = poly [ 0 ]\n    for i in range ( 1 , n ) :\n        result = result * x; result = result + poly [ i ]\n    return result", "id": "AssignUnfoldding_sample_from_HORNERS_METHOD_POLYNOMIAL_EVALUATION_to_92", "old_id": "HORNERS_METHOD_POLYNOMIAL_EVALUATION"}
{"code": "def mulmod ( a , b , mod ) :\n    res = 0\n    a = a % mod\n    while ( b > 0 ) :\n        if ( b % 2 == 1 ) :\n            res = ( res + a ); res = res % mod\n        a = ( a * 2 ); a = a % mod\n        b //= 2\n    return res % mod", "id": "AssignUnfoldding_sample_from_HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION_to_93", "old_id": "HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    for i in arr :\n        if ( i < 0 ) :\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] -= 1\n        else :\n            hash [ i ] = hash.get ( i , 0 ); hash [ i ] = hash [ i ] + 1\n    for i in arr :\n        if i in hash.keys ( ) and hash [ i ] > 0 :\n            return i\n    return - 1", "id": "AssignUnfoldding_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_94", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def kthdigit ( a , b , k ) :\n    p = a; p = p ** b\n    count = 0\n    while ( p > 0 and count < k ) :\n        rem = p; rem = rem % 10\n        count = count + 1\n        if ( count == k ) :\n            return rem\n        p = p // 10\n    return 0\n", "id": "AssignUnfoldding_sample_from_K_TH_DIGIT_RAISED_POWER_B_to_95", "old_id": "K_TH_DIGIT_RAISED_POWER_B"}
{"code": "def kth ( arr1 , arr2 , m , n , k ) :\n    sorted1 = [ 0 ]; sorted1 = sorted1 * ( m + n )\n    i = 0\n    j = 0\n    d = 0\n    while ( i < m and j < n ) :\n        if ( arr1 [ i ] < arr2 [ j ] ) :\n            sorted1 [ d ] = arr1 [ i ]\n            i += 1\n        else :\n            sorted1 [ d ] = arr2 [ j ]\n            j += 1\n        d += 1\n    while ( i < m ) :\n        sorted1 [ d ] = arr1 [ i ]\n        d += 1\n        i += 1\n    while ( j < n ) :\n        sorted1 [ d ] = arr2 [ j ]\n        d += 1\n        j += 1\n    return sorted1 [ k - 1 ]", "id": "AssignUnfoldding_sample_from_K_TH_ELEMENT_TWO_SORTED_ARRAYS_to_96", "old_id": "K_TH_ELEMENT_TWO_SORTED_ARRAYS"}
{"code": "def kthLargestSum ( arr , n , k ) :\n    sum = [ ]\n    sum.append ( 0 )\n    sum.append ( arr [ 0 ] )\n    for i in range ( 2 , n + 1 ) :\n        sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )\n    Q = [ ]\n    heapq.heapify ( Q )\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( i , n + 1 ) :\n            x = sum [ j ]; x = x - sum [ i - 1 ]\n            if len ( Q ) < k :\n                heapq.heappush ( Q , x )\n            else :\n                if Q [ 0 ] < x :\n                    heapq.heappop ( Q )\n                    heapq.heappush ( Q , x )\n    return Q [ 0 ]", "id": "AssignUnfoldding_sample_from_K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY_to_97", "old_id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY"}
{"code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    for i in range ( 0 , n - 1 ) :\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        for j in range ( i + 1 , n ) :\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) :\n                maxsize = j - i; maxsize = maxsize + 1\n                startindex = i\n    if ( maxsize == - 1 ) :\n        print ( \"No such subarray\" )\n    else :\n        print ( startindex , \"to\" , startindex + maxsize - 1 )\n    return maxsize", "id": "AssignUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_98", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 0 ) :\n            arr [ i ] = - 1\n        else :\n            arr [ i ] = 1\n    for i in range ( 0 , n ) :\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) :\n            max_len = i; max_len = max_len + 1\n            ending_index = i\n        if ( curr_sum + n ) in hash_map :\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i; max_len = max_len - hash_map [ curr_sum + n ]\n                ending_index = i\n        else :\n            hash_map[curr_sum + n] = i\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == - 1 ) :\n            arr [ i ] = 0\n        else :\n            arr [ i ] = 1\n    print ( ending_index - max_len + 1 , end = \" \" )\n    print ( \"to\" , end = \" \" )\n    print ( ending_index )\n    return max_len", "id": "AssignUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_99", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def longestSubsequenceCommonSegment ( k , s1 , s2 ) :\n    n = len ( s1 )\n    m = len ( s2 )\n    lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , m + 1 ) :\n            lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] )\n            if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) :\n                cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ]; cnt [ i ] [ j ] = cnt [ i ] [ j ] + 1\n            if ( cnt [ i ] [ j ] >= k ) :\n                for a in range ( k , cnt [ i ] [ j ] + 1 ) :\n                    lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a )\n    return lcs [ n ] [ m ]", "id": "AssignUnfoldding_sample_from_LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K_to_100", "old_id": "LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K"}
{"code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    for i in range ( n - 1 ) :\n        if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :\n            dp [ i ] [ i + 1 ] = 2\n    for l in range ( 2 , n ) :\n        i = - 1\n        for j in range ( l , n ) :\n            i += 1\n            if ( s [ i ] == '(' and s [ j ] == ')' ) :\n                dp [ i ] [ j ] = 2; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i + 1 ] [ j - 1 ]\n            for k in range ( i , j ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n    return dp [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_to_101", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j; i = i - 1\n        k = j; k = k + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :\n                k += 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ]; L [ i ] [ j ] = L [ i ] [ j ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i -= 1\n    return llap", "id": "AssignUnfoldding_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_102", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def minLexRotation ( str_ ) :\n    n = len ( str_ )\n    arr = [ 0 ]; arr = arr * n\n    concat = str_; concat = concat + str_\n    for i in range ( n ) :\n        arr [ i ] = concat [ i : n + i ]\n    arr.sort ( )\n    return arr [ 0 ]", "id": "AssignUnfoldding_sample_from_LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION_to_103", "old_id": "LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION"}
{"code": "def nextWord ( s ) :\n    if ( s == \" \" ) :\n        return \"a\"\n    i = len ( s ); i = i - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        s = s + 'a'\n    else :\n        s = s [ 0 : i ] + chr ( ord ( s [ i ] ) + 1 ); s = s + s [ i + 1 : ]\n    return s", "id": "AssignUnfoldding_sample_from_LEXICOGRAPHICALLY_NEXT_STRING_to_104", "old_id": "LEXICOGRAPHICALLY_NEXT_STRING"}
{"code": "def prevPermutation ( str ) :\n    n = len ( str ); n = n - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i; j = j - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j += 1\n    str = list ( str )\n    temp = str [ i - 1 ]\n    str [ i - 1 ] = str [ j ]\n    str [ j ] = temp\n    str = ''.join ( str )\n    str [ : : - 1 ]\n    return True", "id": "AssignUnfoldding_sample_from_LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C_to_105", "old_id": "LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C"}
{"code": "def lexicographicSubConcat ( s ) :\n    n = len ( s )\n    sub_count = ( n * ( n + 1 ) ); sub_count = sub_count // 2\n    arr = [ 0 ]; arr = arr * sub_count\n    index = 0\n    for i in range ( n ) :\n        for j in range ( 1 , n - i + 1 ) :\n            arr [ index ] = s [ i : i + j ]\n            index += 1\n    arr.sort ( )\n    res = \"\"\n    for i in range ( sub_count ) :\n        res += arr [ i ]\n    return res", "id": "AssignUnfoldding_sample_from_LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING_to_106", "old_id": "LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING"}
{"code": "def LCSubStr ( X , Y , m , n ) :\n    LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ]\n    result = 0\n    for i in range ( m + 1 ) :\n        for j in range ( n + 1 ) :\n            if ( i == 0 or j == 0 ) :\n                LCSuff [ i ] [ j ] = 0\n            elif ( X [ i - 1 ] == Y [ j - 1 ] ) :\n                LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ]; LCSuff [ i ] [ j ] = LCSuff [ i ] [ j ] + 1\n                result = max ( result , LCSuff [ i ] [ j ] )\n            else :\n                LCSuff [ i ] [ j ] = 0\n    return result", "id": "AssignUnfoldding_sample_from_LONGEST_COMMON_SUBSTRING_to_107", "old_id": "LONGEST_COMMON_SUBSTRING"}
{"code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n , 2 ) :\n            length = j - i; length = length + 1\n            leftsum = 0\n            rightsum = 0\n            for k in range ( 0 , int ( length / 2 ) ) :\n                leftsum += ( int ( str [ i + k ] ) - int ( '0' ) )\n                rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) )\n            if ( leftsum == rightsum and maxlen < length ) :\n                maxlen = length\n    return maxlen", "id": "AssignUnfoldding_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_to_108", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF"}
{"code": "def findLength ( string ) :\n    n = len ( string )\n    maxlen = 0\n    Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( 0 , n ) :\n        Sum [ i ] [ i ] = int ( string [ i ] )\n    for length in range ( 2 , n + 1 ) :\n        for i in range ( 0 , n - length + 1 ) :\n            j = i + length; j = j - 1\n            k = length; k = k // 2\n            Sum [ i ] [ j ] = Sum [ i ] [ j - k ]; Sum [ i ] [ j ] = Sum [ i ] [ j ] + Sum [ j - k + 1 ] [ j ]\n            if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) :\n                maxlen = length\n    return maxlen", "id": "AssignUnfoldding_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1_to_109", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1"}
{"code": "def longOddEvenIncSeq ( arr , n ) :\n    lioes = list ( )\n    maxLen = 0\n    for i in range ( n ) :\n        lioes.append ( 1 )\n    i = 1\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) :\n                lioes [ i ] = lioes [ j ]; lioes [ i ] = lioes [ i ] + 1\n    for i in range ( n ) :\n        if maxLen < lioes [ i ] :\n            maxLen = lioes [ i ]\n    return maxLen", "id": "AssignUnfoldding_sample_from_LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE_to_110", "old_id": "LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE"}
{"code": "def lis ( arr , n ) :\n    lis = [ 1 ]; lis = lis * n\n    for i in range ( 1 , n ) :\n        for j in range ( 0 , i ) :\n            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n    maximum = 0\n    for i in range ( n ) :\n        maximum = max ( maximum , lis [ i ] )\n    return maximum", "id": "AssignUnfoldding_sample_from_LONGEST_INCREASING_SUBSEQUENCE_1_to_111", "old_id": "LONGEST_INCREASING_SUBSEQUENCE_1"}
{"code": "def longestPrefixSuffix ( s ) :\n    n = len ( s )\n    lps = [ 0 ]; lps = lps * n\n    l = 0\n    i = 1\n    while ( i < n ) :\n        if ( s [ i ] == s [ l ] ) :\n            l = l + 1\n            lps [ i ] = l\n            i = i + 1\n        else :\n            if ( l != 0 ) :\n                l = lps [ l - 1 ]\n            else :\n                lps [ i ] = 0\n                i = i + 1\n    res = lps [ n - 1 ]\n    if ( res > n / 2 ) :\n        return n // 2\n    else :\n        return res", "id": "AssignUnfoldding_sample_from_LONGEST_PREFIX_ALSO_SUFFIX_1_to_112", "old_id": "LONGEST_PREFIX_ALSO_SUFFIX_1"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :\n                dp [ i ] [ j ] = 1; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) :\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n            i -= 1\n        else :\n            j -= 1\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "AssignUnfoldding_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_113", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def findLongestRepeatingSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 ] * ( n + 1 ) ]; dp = dp * ( n + 1 )\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :\n                dp [ i ] [ j ] = 1; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    return dp [ n ] [ n ]", "id": "AssignUnfoldding_sample_from_LONGEST_REPEATING_SUBSEQUENCE_to_114", "old_id": "LONGEST_REPEATING_SUBSEQUENCE"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if arr [ i ] == 0 :\n            sum += - 1\n        else :\n            sum += 1\n        if ( sum == 1 ) :\n            maxLen = i; maxLen = maxLen + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i; maxLen = maxLen - um [ sum - 1 ]\n    return maxLen", "id": "AssignUnfoldding_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_115", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    for i in range ( n ) :\n        curr_sum += arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ); mod_arr [ i ] = mod_arr [ i ] % k\n    for i in range ( n ) :\n        if ( mod_arr [ i ] == 0 ) :\n            max = i; max = max + 1\n        elif ( mod_arr [ i ] in um ) :\n            um [ mod_arr [ i ] ] = i\n        else :\n            if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                max = i; max = max - um [ mod_arr [ i ] ]\n    return max", "id": "AssignUnfoldding_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_116", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def longLenSub ( arr , n ) :\n    um = defaultdict ( lambda : 0 )\n    longLen = 0\n    for i in range ( n ) :\n        len1 = 0\n        if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) :\n            len1 = um [ arr [ i ] - 1 ]\n        if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) :\n            len1 = um [ arr [ i ] + 1 ]\n        um [ arr [ i ] ] = len1; um [ arr [ i ] ] = um [ arr [ i ] ] + 1\n        if longLen < um [ arr [ i ] ] :\n            longLen = um [ arr [ i ] ]\n    return longLen", "id": "AssignUnfoldding_sample_from_LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2_to_117", "old_id": "LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2"}
{"code": "def maximumPalinUsingKChanges ( str , k ) :\n    palin = list(str)\n    l = 0\n    r = len ( str ); r = r - 1\n    while ( l <= r ) :\n        if ( str [ l ] != str [ r ] ) :\n            palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] )\n            k -= 1\n        l += 1\n        r -= 1\n    if ( k < 0 ) :\n        return \"Not possible\"\n    l = 0\n    r = len ( str ); r = r - 1\n    while ( l <= r ) :\n        if ( l == r ) :\n            if ( k > 0 ) :\n                palin [ l ] = '9'\n        if ( palin [ l ] < '9' ) :\n            if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) :\n                k -= 1\n                palin [ l ] = palin [ r ] = '9'\n            elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) ) :\n                k -= 1\n                palin [ l ] = palin [ r ] = '9'\n        l += 1\n        r -= 1\n    return \"\".join(palin)", "id": "AssignUnfoldding_sample_from_MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS_to_118", "old_id": "MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS"}
{"code": "def maxvolume ( s ) :\n    length = s; length = length // 3 \n    s -= length\n    breadth = s; breadth = breadth // 2\n    height = s; height = height - breadth\n    return int ( length * breadth * height )", "id": "AssignUnfoldding_sample_from_MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1_to_119", "old_id": "MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1"}
{"code": "def largestSumOfAverages ( A , K ) :\n    n = len ( A )\n    pre_sum = [ 0 ]; pre_sum = pre_sum * ( n + 1 )\n    pre_sum [ 0 ] = 0\n    for i in range ( n ) :\n        pre_sum [ i + 1 ] = pre_sum [ i ]; pre_sum [ i + 1 ] = pre_sum [ i + 1 ] + A [ i ]\n    dp = [ 0 ]; dp = dp * n\n    sum = 0\n    for i in range ( n ) :\n        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ); dp [ i ] = dp [ i ] / ( n - i )\n    for k in range ( K - 1 ) :\n        for i in range ( n ) :\n            for j in range ( i + 1 , n ) :\n                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] )\n    return  dp [ 0 ]", "id": "AssignUnfoldding_sample_from_MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY_to_120", "old_id": "MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY"}
{"code": "def maxcoefficientvalue ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n    maxvalue = 0\n    for i in range ( n + 1 ) :\n        maxvalue = max ( maxvalue , C [ n ] [ i ] )\n    return maxvalue", "id": "AssignUnfoldding_sample_from_MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE_to_121", "old_id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE"}
{"code": "def maxRowDiff ( mat , m , n ) :\n    rowSum = [ 0 ]; rowSum = rowSum * m\n    for i in range ( 0 , m ) :\n        sum = 0\n        for j in range ( 0 , n ) :\n            sum += mat [ i ] [ j ]\n        rowSum [ i ] = sum\n    max_diff = rowSum [ 1 ]; max_diff = max_diff - rowSum [ 0 ]\n    min_element = rowSum [ 0 ]\n    for i in range ( 1 , m ) :\n        if ( rowSum [ i ] - min_element > max_diff ) :\n            max_diff = rowSum [ i ]; max_diff = max_diff - min_element\n        if ( rowSum [ i ] < min_element ) :\n            min_element = rowSum [ i ]\n    return max_diff", "id": "AssignUnfoldding_sample_from_MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX_to_122", "old_id": "MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX"}
{"code": "def maxGameByWinner ( N ) :\n    dp = [ 0 for i in range ( N ) ]\n    dp [ 0 ] = 1\n    dp [ 1 ] = 2\n    i = 1\n    while dp [ i ] <= N :\n        i = i + 1\n        dp [ i ] = dp [ i - 1 ]; dp [ i ] = dp [ i ] + dp [ i - 2 ]\n    return ( i - 1 )", "id": "AssignUnfoldding_sample_from_MAXIMUM_GAMES_PLAYED_WINNER_to_123", "old_id": "MAXIMUM_GAMES_PLAYED_WINNER"}
{"code": "def maxLenSub ( arr , n ) :\n    mls = [ ]\n    max = 0\n    for i in range ( n ) :\n        mls.append ( 1 )\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) :\n                mls [ i ] = mls [ j ]; mls [ i ] = mls [ i ] + 1\n    for i in range ( n ) :\n        if ( max < mls [ i ] ) :\n            max = mls [ i ]\n    return max", "id": "AssignUnfoldding_sample_from_MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1_to_124", "old_id": "MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1"}
{"code": "def maxNumOfChocolates ( arr , n , k ) :\n    um , curr_rem , maxSum = { } , 0 , 0\n    sm = [ 0 ]; sm = sm * n\n    sm [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        sm [ i ] = sm [ i - 1 ]; sm [ i ] = sm [ i ] + arr [ i ]\n    for i in range ( n ) :\n        curr_rem = sm [ i ]; curr_rem = curr_rem % k\n        if ( not curr_rem and maxSum < sm [ i ] ) :\n            maxSum = sm [ i ]\n        elif ( not curr_rem in um ) :\n            um [ curr_rem ] = i\n        elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :\n            maxSum = sm [ i ]; maxSum = maxSum - sm [ um [ curr_rem ] ]\n    return maxSum // k", "id": "AssignUnfoldding_sample_from_MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS_to_125", "old_id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS"}
{"code": "def maximumSegments ( n , a , b , c ) :\n    dp = [ - 1 ]; dp = dp * ( n + 10 )\n    dp [ 0 ] = 0\n    for i in range ( 0 , n ) :\n        if ( dp [ i ] != - 1 ) :\n            if ( i + a <= n ) :\n                dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] )\n            if ( i + b <= n ) :\n                dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] )\n            if ( i + c <= n ) :\n                dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] )\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C_to_126", "old_id": "MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C"}
{"code": "def lis ( arr , n ) :\n    mpis = [ 0 ]; mpis = mpis * ( n )\n    for i in range ( n ) :\n        mpis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) :\n                mpis [ i ] = mpis [ j ]; mpis [ i ] = mpis [ i ] * arr [ i ]\n    return max ( mpis )", "id": "AssignUnfoldding_sample_from_MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE_to_127", "old_id": "MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE"}
{"code": "def maxProfit ( price , n ) :\n    profit = [ 0 ]; profit = profit * n\n    max_price = price [ n - 1 ]\n    for i in range ( n - 2 , 0 , - 1 ) :\n        if price [ i ] > max_price :\n            max_price = price [ i ]\n        profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] )\n    min_price = price [ 0 ]\n    for i in range ( 1 , n ) :\n        if price [ i ] < min_price :\n            min_price = price [ i ]\n        profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) )\n    result = profit [ n - 1 ]\n    return result", "id": "AssignUnfoldding_sample_from_MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE_to_128", "old_id": "MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE"}
{"code": "def maxSumWO3Consec ( arr , n ) :\n    sum = [ 0 for k in range ( n ) ]\n    if n >= 1 :\n        sum [ 0 ] = arr [ 0 ]\n    if n >= 2 :\n        sum [ 1 ] = arr [ 0 ]; sum [ 1 ] = sum [ 1 ] + arr [ 1 ]\n    if n > 2 :\n        sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) )\n    for i in range ( 3 , n ) :\n        sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] )\n    return sum [ n - 1 ]", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_to_129", "old_id": "MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE"}
{"code": "def maxSum ( grid , n ) :\n    incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] )\n    excl = 0\n    for i in range ( 1 , n ) :\n        excl_new = max ( excl , incl )\n        incl = excl; incl = incl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] )\n        excl = excl_new\n    return max ( excl , incl )", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT_to_130", "old_id": "MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT"}
{"code": "def maxSumBitonicSubArr ( arr , n ) :\n    msis = [ None ]; msis = msis * n\n    msds = [ None ]; msds = msds * n\n    max_sum = 0\n    msis [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] > arr [ i - 1 ] ) :\n            msis [ i ] = msis [ i - 1 ]; msis [ i ] = msis [ i ] + arr [ i ]\n        else :\n            msis [ i ] = arr [ i ]\n    msds [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] > arr [ i + 1 ] ) :\n            msds [ i ] = msds [ i + 1 ]; msds [ i ] = msds [ i ] + arr [ i ]\n        else :\n            msds [ i ] = arr [ i ]\n    for i in range ( n ) :\n        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :\n            max_sum = msis [ i ] + msds [ i ]; max_sum = max_sum - arr [ i ]\n    return max_sum", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_BITONIC_SUBARRAY_to_131", "old_id": "MAXIMUM_SUM_BITONIC_SUBARRAY"}
{"code": "def maxSum ( arr , n ) :\n    cum_sum = 0\n    for i in range ( 0 , n ) :\n        cum_sum += arr [ i ]\n    curr_val = 0\n    for i in range ( 0 , n ) :\n        curr_val += i * arr [ i ]\n    res = curr_val\n    for i in range ( 1 , n ) :\n        next_val = curr_val - ( cum_sum - arr [ i - 1 ] ); next_val = next_val + arr [ i - 1 ] * ( n - 1 )\n        curr_val = next_val\n        res = max ( res , next_val )\n    return res", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1_to_132", "old_id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1"}
{"code": "def maxSumPairWithDifferenceLessThanK ( arr , N , K ) :\n    arr.sort ( )\n    dp = [ 0 ]; dp = dp * N\n    dp [ 0 ] = 0\n    for i in range ( 1 , N ) :\n        dp [ i ] = dp [ i - 1 ]\n        if ( arr [ i ] - arr [ i - 1 ] < K ) :\n            if ( i >= 2 ) :\n                dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] )\n            else :\n                dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] )\n    return dp [ N - 1 ]", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_to_133", "old_id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE"}
{"code": "def maxSumPairWithDifferenceLessThanK ( arr , N , k ) :\n    maxSum = 0\n    arr.sort ( )\n    i = N; i = i - 1\n    while ( i > 0 ) :\n        if ( arr [ i ] - arr [ i - 1 ] < k ) :\n            maxSum += arr [ i ]\n            maxSum += arr [ i - 1 ]\n            i -= 1\n        i -= 1\n    return maxSum", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1_to_134", "old_id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1"}
{"code": "def maxSumSubarrayRemovingOneEle ( arr , n ) :\n    fw = [ 0 for k in range ( n ) ]\n    bw = [ 0 for k in range ( n ) ]\n    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]\n    for i in range (1, n ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        fw [ i ] = cur_max\n    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]\n    i = n; i = i - 2\n    while i >= 0 :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        bw [ i ] = cur_max\n        i -= 1\n    fans = max_so_far\n    for i in range ( 1 , n - 1 ) :\n        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )\n    return fans", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT_to_135", "old_id": "MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT"}
{"code": "def maxTripletSum ( arr , n ) :\n    sm = - 1000000\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            for k in range ( j + 1 , n ) :\n                if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) :\n                    sm = arr [ i ] + arr [ j ]; sm = sm + arr [ k ]\n    return sm", "id": "AssignUnfoldding_sample_from_MAXIMUM_TRIPLET_SUM_ARRAY_to_136", "old_id": "MAXIMUM_TRIPLET_SUM_ARRAY"}
{"code": "def maxCost ( mat , N ) :\n    dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ]\n    dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]\n    for i in range ( 1 , N ) :\n        dp [ i ] [ 0 ] = mat [ i ] [ 0 ]; dp [ i ] [ 0 ] = dp [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ]\n    for i in range ( 1 , N ) :\n        for j in range ( 1 , min ( i + 1 , N ) ) :\n            dp [ i ] [ j ] = mat [ i ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] + \\\n                max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    result = 0\n    for i in range ( N ) :\n        if ( result < dp [ N - 1 ] [ i ] ) :\n            result = dp [ N - 1 ] [ i ]\n    return result", "id": "AssignUnfoldding_sample_from_MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX_to_137", "old_id": "MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX"}
{"code": "def middleOfThree ( a , b , c ) :\n    x = a; x = x - b\n    y = b; y = y - c\n    z = a; z = z - c\n    if x * y > 0 :\n        return b\n    elif ( x * z > 0 ) :\n        return c\n    else :\n        return a", "id": "AssignUnfoldding_sample_from_MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2_to_138", "old_id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2"}
{"code": "def getMinDiff ( arr , n , k ) :\n    if ( n == 1 ) :\n        return 0\n    arr.sort ( )\n    ans = arr [ n - 1 ]; ans = ans - arr [ 0 ]\n    small = arr [ 0 ]; small = small + k\n    big = arr [ n - 1 ]; big = big - k\n    if ( small > big ) :\n        small , big = big , small\n    for i in range ( 1 , n - 1 ) :\n        subtract = arr [ i ]; subtract = subtract - k\n        add = arr [ i ]; add = add + k\n        if ( subtract >= small or add <= big ) :\n            continue\n        if ( big - subtract <= add - small ) :\n            small = subtract\n        else :\n            big = add\n    return min ( ans , big - small )", "id": "AssignUnfoldding_sample_from_MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS_to_139", "old_id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS"}
{"code": "def solve ( X , Y , l , r , k , dp ) :\n    if k == 0 :\n        return 0\n    if l < 0 or r < 0 :\n        return 1000000000\n    if dp [ l ] [ r ] [ k ] != - 1 :\n        return dp [ l ] [ r ] [ k ]\n    cost = ( ord ( X [ l ] ) - ord ( 'a' ) ); cost = cost ^ ( ord ( Y [ r ] ) - ord ( 'a' ) )\n    dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] )\n    return dp [ l ] [ r ] [ k ]", "id": "AssignUnfoldding_sample_from_MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K_to_140", "old_id": "MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K"}
{"code": "def calculateEnergy ( mat , n ) :\n    tot_energy = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            q = mat [ i ] [ j ]; q = q // n\n            i_des = q\n            j_des = mat [ i ] [ j ]; j_des = j_des - ( n * q )\n            tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) )\n    return tot_energy", "id": "AssignUnfoldding_sample_from_MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1_to_141", "old_id": "MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1"}
{"code": "def minInsertionStepToSortArray ( arr , N ) :\n    lis = [ 0 ]; lis = lis * N\n    for i in range ( N ) :\n        lis [ i ] = 1\n    for i in range ( 1 , N ) :\n        for j in range ( i ) :\n            if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) :\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n    max = 0\n    for i in range ( N ) :\n        if ( max < lis [ i ] ) :\n            max = lis [ i ]\n    return ( N - max )", "id": "AssignUnfoldding_sample_from_MINIMUM_INSERTIONS_SORT_ARRAY_to_142", "old_id": "MINIMUM_INSERTIONS_SORT_ARRAY"}
{"code": "def smallestSubWithSum ( arr , n , x ) :\n    curr_sum = 0\n    min_len = n; min_len = min_len + 1\n    start = 0\n    end = 0\n    while ( end < n ) :\n        while ( curr_sum <= x and end < n ) :\n            if ( curr_sum <= 0 and x > 0 ) :\n                start = end\n                curr_sum = 0\n            curr_sum += arr [ end ]\n            end += 1\n        while ( curr_sum > x and start < n ) :\n            if ( end - start < min_len ) :\n                min_len = end; min_len = min_len - start\n            curr_sum -= arr [ start ]\n            start += 1\n    return min_len", "id": "AssignUnfoldding_sample_from_MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1_to_143", "old_id": "MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = float ( 'inf' )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( 'inf' )\n            for j in range ( i + 1 , n ) :\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n            if ( min != float ( 'inf' ) ) :\n                jumps [ i ] = min; jumps [ i ] = jumps [ i ] + 1\n            else :\n                jumps [ i ] = min\n    return jumps [ 0 ]", "id": "AssignUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_144", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def getMinSquares ( n ) :\n    dp = [ 0 , 1 , 2 , 3 ]\n    for i in range ( 4 , n + 1 ) :\n        dp.append ( i )\n        for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) :\n            temp = x; temp = temp * x\n            if temp > i :\n                break\n            else :\n                dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1_to_145", "old_id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1"}
{"code": "def minPerimeter ( n ) :\n    l = int ( math.sqrt ( n ) )\n    sq = l; sq = sq * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = int ( n / l )\n        perimeter = 2; perimeter = perimeter * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter", "id": "AssignUnfoldding_sample_from_MINIMUM_PERIMETER_N_BLOCKS_to_146", "old_id": "MINIMUM_PERIMETER_N_BLOCKS"}
{"code": "def findMinRooms ( slots , n , m ) :\n    counts = [ 0 ]; counts = counts * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if i < len(slots) and j < len(slots[i]):\n                if ( slots [ i ] [ j ] == '1' ) :\n                    counts [ j ] += 1\n    return max ( counts )", "id": "AssignUnfoldding_sample_from_MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE_to_147", "old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE"}
{"code": "def findRotations ( str ) :\n    tmp = str; tmp = tmp + str\n    n = len ( str )\n    for i in range ( 1 , n + 1 ) :\n        substring = tmp [ i : n ]\n        if ( str == substring ) :\n            return i\n    return n", "id": "AssignUnfoldding_sample_from_MINIMUM_ROTATIONS_REQUIRED_GET_STRING_to_148", "old_id": "MINIMUM_ROTATIONS_REQUIRED_GET_STRING"}
{"code": "def minRotation ( input , unlock_code ) :\n    rotation = 0\n    while ( input > 0 or unlock_code > 0 ) :\n        input_digit = input; input_digit = input_digit % 10\n        code_digit = unlock_code; code_digit = code_digit % 10\n        rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) )\n        input = int ( input / 10 )\n        unlock_code = int ( unlock_code / 10 )\n    return rotation", "id": "AssignUnfoldding_sample_from_MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK_to_149", "old_id": "MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK"}
{"code": "def getMinSteps ( n ) :\n    table = [ 0 ]; table = table * ( n + 1 )\n    for i in range ( n + 1 ) :\n        table [ i ] = n; table [ i ] = table [ i ] - i\n    for i in range ( n , 0 , - 1 ) :\n        if ( not ( i % 2 ) ) :\n            table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] )\n        if ( not ( i % 3 ) ) :\n            table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] )\n    return table [ 1 ]", "id": "AssignUnfoldding_sample_from_MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION_to_150", "old_id": "MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION"}
{"code": "def minproduct ( a , b , n , k ) :\n    diff = 0\n    res = 0\n    temp = 0\n    for i in range ( n ) :\n        pro = a [ i ]; pro = pro * b [ i ]\n        res = res + pro\n        if ( pro < 0 and b [ i ] < 0 ) :\n            temp = ( a [ i ] + 2 * k ); temp = temp * b [ i ]\n        elif ( pro < 0 and a [ i ] < 0 ) :\n            temp = ( a [ i ] - 2 * k ); temp = temp * b [ i ]\n        elif ( pro > 0 and a [ i ] < 0 ) :\n            temp = ( a [ i ] + 2 * k ); temp = temp * b [ i ]\n        elif ( pro > 0 and a [ i ] > 0 ) :\n            temp = ( a [ i ] - 2 * k ); temp = temp * b [ i ]\n        d = abs ( pro - temp )\n        if ( d > diff ) :\n            diff = d\n    return res - diff", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_PRODUCT_TWO_ARRAYS_to_151", "old_id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS"}
{"code": "def minSum ( arr , n ) :\n    dp = [ 0 ]; dp = dp * n\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    if ( n == 2 ) :\n        return min ( arr [ 0 ] , arr [ 1 ] )\n    if ( n == 3 ) :\n        return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) )\n    if ( n == 4 ) :\n        return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) )\n    dp [ 0 ] = arr [ 0 ]\n    dp [ 1 ] = arr [ 1 ]\n    dp [ 2 ] = arr [ 2 ]\n    dp [ 3 ] = arr [ 3 ]\n    for i in range ( 4 , n ) :\n        dp [ i ] = arr [ i ]; dp [ i ] = dp [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) )\n    return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) )", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED_to_152", "old_id": "MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED"}
{"code": "def solve ( arr , n ) :\n    arr.sort ( )\n    a = 0\n    b = 0\n    for i in range ( n ) :\n        if ( i % 2 != 0 ) :\n            a = a * 10; a = a + arr [ i ]\n        else :\n            b = b * 10; b = b + arr [ i ]\n    return a + b", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_to_153", "old_id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY"}
{"code": "def minTimeForWritingChars ( N , insert , remove , copy ) :\n    if N == 0 :\n        return 0\n    if N == 1 :\n        return insert\n    dp = [ 0 ]; dp = dp * ( N + 1 )\n    for i in range ( 1 , N + 1 ) :\n        if i % 2 == 0 :\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy )\n        else :\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove )\n    return dp [ N ]", "id": "AssignUnfoldding_sample_from_MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION_to_154", "old_id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION"}
{"code": "def minXOR ( arr , n ) :\n    min_xor = 999999\n    val = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            val = arr [ i ]; val = val ^ arr [ j ]\n            min_xor = min ( min_xor , val )\n    return min_xor", "id": "AssignUnfoldding_sample_from_MINIMUM_XOR_VALUE_PAIR_to_155", "old_id": "MINIMUM_XOR_VALUE_PAIR"}
{"code": "def minXOR ( arr , n ) :\n    arr = arr [ : n ]\n    arr.sort ( )\n    minXor = int ( sys.float_info.max )\n    val = 0\n    for i in range ( 0 , n - 1 ) :\n        val = arr [ i ]; val = val ^ arr [ i + 1 ]\n        minXor = min ( minXor , val )\n    return minXor", "id": "AssignUnfoldding_sample_from_MINIMUM_XOR_VALUE_PAIR_1_to_156", "old_id": "MINIMUM_XOR_VALUE_PAIR_1"}
{"code": "def power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( ( y & 1 ) == 1 ) :\n            res = ( res * x ); res = res % p\n        y = y >> 1\n        x = ( x * x ); x = x % p\n    return res", "id": "AssignUnfoldding_sample_from_MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC_to_157", "old_id": "MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC"}
{"code": "def moduloMultiplication ( a , b , mod ) :\n    res = 0 ;\n    a = a % mod ;\n    while ( b ) :\n        if ( b & 1 ) :\n            res = ( res + a ); res = res % mod\n        a = ( 2 * a ); a = a % mod\n        b >>= 1 ;\n    return res ;", "id": "AssignUnfoldding_sample_from_MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO_to_158", "old_id": "MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO"}
{"code": "def sequence ( n ) :\n    f = array.array ( 'i' , [ 0 , 1 , 1 ] )\n    for i in range ( 3 , n + 1 ) :\n        r = f [ f [ i - 1 ] ]; r = r + f [ i - f [ i - 1 ] ]\n        f.append ( r )\n    return f[n]", "id": "AssignUnfoldding_sample_from_NEWMAN_CONWAY_SEQUENCE_1_to_159", "old_id": "NEWMAN_CONWAY_SEQUENCE_1"}
{"code": "def snoob ( x ) :\n    next = 0\n    if ( x ) :\n        rightOne = x; rightOne = rightOne & - ( x )\n        nextHigherOneBit = x; nextHigherOneBit = nextHigherOneBit + int ( rightOne )\n        rightOnesPattern = x; rightOnesPattern = rightOnesPattern ^ int ( nextHigherOneBit )\n        rightOnesPattern = int ( rightOnesPattern ); rightOnesPattern = rightOnesPattern / int ( rightOne )\n        rightOnesPattern = int ( rightOnesPattern ); rightOnesPattern = rightOnesPattern >> 2\n        next = nextHigherOneBit; next = next | rightOnesPattern\n    return next", "id": "AssignUnfoldding_sample_from_NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS_to_160", "old_id": "NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS"}
{"code": "def findPosition ( k , n ) :\n    f1 = 0\n    f2 = 1\n    i = 2\n    while i != 0 :\n        f3 = f1; f3 = f3 + f2\n        f1 = f2\n        f2 = f3\n        if f2 % k == 0 :\n            return n * i\n        i += 1\n    return", "id": "AssignUnfoldding_sample_from_NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES_to_161", "old_id": "NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES"}
{"code": "def nonFibonacci ( n ) :\n    prevPrev = 1\n    prev = 2\n    curr = 3\n    while n > 0 :\n        prevPrev = prev\n        prev = curr\n        curr = prevPrev; curr = curr + prev\n        n = n - ( curr - prev - 1 )\n    n = n + ( curr - prev - 1 )\n    return prev + n", "id": "AssignUnfoldding_sample_from_NTH_NON_FIBONACCI_NUMBER_to_162", "old_id": "NTH_NON_FIBONACCI_NUMBER"}
{"code": "def nonDecNums ( n ) :\n    a = np.zeros ( ( n + 1 , 10 ) )\n    for i in range ( 10 ) :\n        a [ 0 ] [ i ] = 1\n    for i in range ( 1 , n + 1 ) :\n        a [ i ] [ 9 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 8 , - 1 , - 1 ) :\n            a [ i ] [ j ] = a [ i - 1 ] [ j ]; a [ i ] [ j ] = a [ i ] [ j ] + a [ i ] [ j + 1 ]\n    return int ( a [ n ] [ 0 ] )", "id": "AssignUnfoldding_sample_from_NUMBER_N_DIGITS_NON_DECREASING_INTEGERS_to_163", "old_id": "NUMBER_N_DIGITS_NON_DECREASING_INTEGERS"}
{"code": "def answer ( n ) :\n    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ]\n    if ( n == 1 ) :\n        return 10\n    for j in range ( 10 ) :\n        dp [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 10 ) :\n            if ( j == 0 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]\n            elif ( j == 9 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j + 1 ]\n    sum = 0\n    for j in range ( 1 , 10 ) :\n        sum = sum + dp [ n ] [ j ]\n    return sum", "id": "AssignUnfoldding_sample_from_NUMBER_N_DIGIT_STEPPING_NUMBERS_to_164", "old_id": "NUMBER_N_DIGIT_STEPPING_NUMBERS"}
{"code": "def sumEqualProduct ( a , n ) :\n    zero = 0\n    two = 0\n    for i in range ( n ) :\n        if a [ i ] == 0 :\n            zero += 1\n        if a [ i ] == 2 :\n            two += 1\n    cnt = ( zero * ( zero - 1 ) ) // 2; cnt = cnt + \\\n        ( two * ( two - 1 ) ) // 2\n    return cnt", "id": "AssignUnfoldding_sample_from_NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT_to_165", "old_id": "NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT"}
{"code": "def maximumNumberDistinctPrimeRange ( m , n ) :\n    factorCount = [ 0 ]; factorCount = factorCount * ( n + 1 )\n    prime = [ False ]; prime = prime * ( n + 1 )\n    for i in range ( n + 1 ) :\n        factorCount [ i ] = 0\n        prime [ i ] = True\n    for i in range ( 2 , n + 1 ) :\n        if ( prime [ i ] == True ) :\n            factorCount [ i ] = 1\n            for j in range ( i * 2 , n + 1 , i ) :\n                factorCount [ j ] += 1\n                prime [ j ] = False\n    max = factorCount [ m ]\n    num = m\n    for i in range ( m , n + 1 ) :\n        if ( factorCount [ i ] > max ) :\n            max = factorCount [ i ]\n            num = i\n    return num", "id": "AssignUnfoldding_sample_from_NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N_to_166", "old_id": "NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N"}
{"code": "def findNth ( n ) :\n    nthElement = 19; nthElement = nthElement + ( n - 1 ) * 9\n    outliersCount = int ( math.log10 ( nthElement ) ); outliersCount = outliersCount - 1\n    nthElement += 9 * outliersCount\n    return nthElement", "id": "AssignUnfoldding_sample_from_N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2_to_167", "old_id": "N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2"}
{"code": "def nthRoot ( A , N ) :\n    random.seed ( 1 )\n    xPre = random.uniform ( 1 , 101 ); xPre = xPre % 10\n    eps = 0.001\n    delX = 2147483647\n    xK = 0.0\n    while ( delX > eps ) :\n        xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ); xK = xK / N\n        delX = abs ( xK - xPre )\n        xPre = xK\n    return xK", "id": "AssignUnfoldding_sample_from_N_TH_ROOT_NUMBER_to_168", "old_id": "N_TH_ROOT_NUMBER"}
{"code": "def maxDifference ( arr , N , k ) :\n    S = 0\n    S1 = 0\n    max_difference = 0\n    for i in range ( N ) :\n        S += arr [ i ]\n    arr.sort ( reverse = True )\n    M = max ( k , N - k )\n    for i in range ( M ) :\n        S1 += arr [ i ]\n    max_difference = S1; max_difference = max_difference - ( S - S1 )\n    return max_difference", "id": "AssignUnfoldding_sample_from_PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM_to_169", "old_id": "PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM"}
{"code": "def maxAverageOfPath ( cost , N ) :\n    dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ]\n    dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]\n    for i in range ( 1 , N ) :\n        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]; dp [ i ] [ 0 ] = dp [ i ] [ 0 ] + cost [ i ] [ 0 ]\n    for j in range ( 1 , N ) :\n        dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ]; dp [ 0 ] [ j ] = dp [ 0 ] [ j ] + cost [ 0 ] [ j ]\n    for i in range ( 1 , N ) :\n        for j in range ( 1 , N ) :\n            dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ); dp [ i ] [ j ] = dp [ i ] [ j ] + cost [ i ] [ j ]\n    return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )", "id": "AssignUnfoldding_sample_from_PATH_MAXIMUM_AVERAGE_VALUE_to_170", "old_id": "PATH_MAXIMUM_AVERAGE_VALUE"}
{"code": "def isPrime ( p ) :\n    checkNumber = 2 ** p; checkNumber = checkNumber - 1\n    nextval = 4; nextval = nextval % checkNumber\n    for i in range ( 1 , p - 1 ) :\n        nextval = ( nextval * nextval - 2 ); nextval = nextval % checkNumber\n    if ( nextval == 0 ) : return True\n    else : return False", "id": "AssignUnfoldding_sample_from_PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES_to_171", "old_id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES"}
{"code": "def printSpiral ( mat , r , c ) :\n    a = 0\n    b = 2\n    low_row = 0 if ( 0 > a ) else a\n    low_column = 0 if ( 0 > b ) else b - 1\n    high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1\n    high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1\n    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :\n        i = low_column; i = i + 1\n        while ( i <= high_column and i < c and low_row >= 0 ) :\n            print ( mat [ low_row ] [ i ] , end = \" \" )\n            i += 1\n        low_row -= 1\n        i = low_row; i = i + 2\n        while ( i <= high_row and i < r and high_column < c ) :\n            print ( mat [ i ] [ high_column ] , end = \" \" )\n            i += 1\n        high_column += 1\n        i = high_column; i = i - 2\n        while ( i >= low_column and i >= 0 and high_row < r ) :\n            print ( mat [ high_row ] [ i ] , end = \" \" )\n            i -= 1\n        high_row += 1\n        i = high_row; i = i - 2\n        while ( i > low_row and i >= 0 and low_column >= 0 ) :\n            print ( mat [ i ] [ low_column ] , end = \" \" )\n            i -= 1\n        low_column -= 1\n    print ( )", "id": "AssignUnfoldding_sample_from_PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT_to_172", "old_id": "PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT"}
{"code": "def areaSquare ( side ) :\n    area = side; area = area * side\n    return area", "id": "AssignUnfoldding_sample_from_PROGRAM_AREA_SQUARE_to_173", "old_id": "PROGRAM_AREA_SQUARE"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ]; allocation = allocation * n\n    for i in range ( n ) :\n        bestIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n    print ( \"Process No.Process Size     Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )", "id": "AssignUnfoldding_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_174", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = ''\n    stars = '*'; stars = stars * len ( word )\n    count = 0\n    index = 0\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index += 1\n    result = ' '.join ( word_list )\n    return result", "id": "AssignUnfoldding_sample_from_PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE_to_175", "old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE"}
{"code": "def decimalToBinary ( N ) :\n    B_Number = 0\n    cnt = 0\n    while ( N != 0 ) :\n        rem = N; rem = rem % 2\n        c = pow ( 10 , cnt )\n        B_Number += rem * c\n        N //= 2\n        cnt += 1\n    return B_Number", "id": "AssignUnfoldding_sample_from_PROGRAM_DECIMAL_BINARY_CONVERSION_2_to_176", "old_id": "PROGRAM_DECIMAL_BINARY_CONVERSION_2"}
{"code": "def distance ( lat1 , lat2 , lon1 , lon2 ) :\n    lon1 = radians ( lon1 )\n    lon2 = radians ( lon2 )\n    lat1 = radians ( lat1 )\n    lat2 = radians ( lat2 )\n    dlon = lon2; dlon = dlon - lon1\n    dlat = lat2; dlat = dlat - lat1\n    a = sin ( dlat / 2 ) ** 2; a = a + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2\n    c = 2; c = c * asin ( sqrt ( a ) )\n    r = 6371\n    return ( c * r )", "id": "AssignUnfoldding_sample_from_PROGRAM_DISTANCE_TWO_POINTS_EARTH_to_177", "old_id": "PROGRAM_DISTANCE_TWO_POINTS_EARTH"}
{"code": "def remainder ( str ) :\n    ln = len ( str )\n    rem = 0\n    for i in range ( 0 , ln ) :\n        num = rem * 10; num = num + ( int ) ( str [ i ] )\n        rem = num; rem = rem % 11\n    return rem", "id": "AssignUnfoldding_sample_from_PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11_to_178", "old_id": "PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11"}
{"code": "def Resources ( process , need ) :\n    minResources = 0\n    minResources = process * ( need - 1 ); minResources = minResources + 1\n    return minResources", "id": "AssignUnfoldding_sample_from_PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM_to_179", "old_id": "PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM"}
{"code": "def octalToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base = 1\n    temp = num\n    while ( temp ) :\n        last_digit = temp; last_digit = last_digit % 10\n        temp = int ( temp / 10 )\n        dec_value += last_digit * base\n        base = base * 8\n    return dec_value", "id": "AssignUnfoldding_sample_from_PROGRAM_OCTAL_DECIMAL_CONVERSION_to_180", "old_id": "PROGRAM_OCTAL_DECIMAL_CONVERSION"}
{"code": "def isLucky ( n ) :\n    ar = [ 0 ]; ar = ar * 10\n    while ( n > 0 ) :\n        digit = math.floor ( n % 10 )\n        if ( ar [ digit ] ) :\n            return False\n        ar [ digit ] = 1\n        n = int ( n / 10 )\n    return True", "id": "AssignUnfoldding_sample_from_PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT_to_181", "old_id": "PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT"}
{"code": "def findArea ( a ) :\n    area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ); area = area / 4\n    return area", "id": "AssignUnfoldding_sample_from_PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON_to_182", "old_id": "PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ]; allocation = allocation * n\n    for i in range ( n ) :\n        wstIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n    print ( \"Process No.Process Size Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )", "id": "AssignUnfoldding_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_183", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def rearrange ( arr , n ) :\n    temp = n; temp = temp * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    for i in range ( n ) :\n        if flag is True :\n            temp [ i ] = arr [ large ]\n            large -= 1\n        else :\n            temp [ i ] = arr [ small ]\n            small += 1\n        flag = bool ( 1 - flag )\n    for i in range ( n ) :\n        arr [ i ] = temp [ i ]\n    return arr", "id": "AssignUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_184", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n; max_idx = max_idx - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ]; max_elem = max_elem + 1\n    for i in range ( 0 , n ) :\n        if i % 2 == 0 :\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        else :\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n    for i in range ( 0 , n ) :\n        arr [ i ] = int ( arr [ i ] / max_elem )", "id": "AssignUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_185", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def breakSum ( n ) :\n    dp = [ 0 ]; dp = dp * ( n + 1 )\n    dp [ 0 ] = 0\n    dp [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i )\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1_to_186", "old_id": "RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1"}
{"code": "def insertionSortRecursive ( arr , n ) :\n    if n <= 1 :\n        return\n    insertionSortRecursive ( arr , n - 1 )\n    last = arr [ n - 1 ]\n    j = n; j = j - 2\n    while ( j >= 0 and arr [ j ] > last ) :\n        arr [ j + 1 ] = arr [ j ]\n        j = j - 1\n    arr [ j + 1 ] = last", "id": "AssignUnfoldding_sample_from_RECURSIVE_INSERTION_SORT_to_187", "old_id": "RECURSIVE_INSERTION_SORT"}
{"code": "def remainderWith7 ( num ) :\n    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]\n    series_index = 0\n    result = 0\n    for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) :\n        digit = ord ( num [ i ] ); digit = digit - 48\n        result += digit * series [ series_index ]\n        series_index = ( series_index + 1 ); series_index = series_index % 6\n        result %= 7\n    if ( result < 0 ) :\n        result = ( result + 7 ); result = result % 7\n    return result", "id": "AssignUnfoldding_sample_from_REMAINDER_7_LARGE_NUMBERS_to_188", "old_id": "REMAINDER_7_LARGE_NUMBERS"}
{"code": "def simplify ( Str ) :\n    Len = len ( Str )\n    res = [ None ]; res = res * Len\n    index = 0\n    i = 0\n    s = [ ]\n    s.append ( 0 )\n    while ( i < Len ) :\n        if ( Str [ i ] == '+' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index += 1\n        elif ( Str [ i ] == '-' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '+'\n                index += 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = '-'\n                index += 1\n        elif ( Str [ i ] == '(' and i > 0 ) :\n            if ( Str [ i - 1 ] == '-' ) :\n                x = 0 if ( s [ - 1 ] == 1 ) else 1\n                s.append ( x )\n            elif ( Str [ i - 1 ] == '+' ) :\n                s.append ( s [ - 1 ] )\n        elif ( Str [ i ] == ')' ) :\n            s.pop ( )\n        else :\n            res [ index ] = Str [ i ]\n            index += 1\n        i += 1\n    return \"\".join(res)", "id": "AssignUnfoldding_sample_from_REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS_to_189", "old_id": "REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS"}
{"code": "def replace ( s , c1 , c2 ) :\n    l = len ( s )\n    for i in range ( l ) :\n        if ( s [ i ] == c1 ) :\n            s = s [ 0 : i ] + c2; s = s + s [ i + 1 : ]\n        elif ( s [ i ] == c2 ) :\n            s = s [ 0 : i ] + c1; s = s + s [ i + 1 : ]\n    return s", "id": "AssignUnfoldding_sample_from_REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S_to_190", "old_id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S"}
{"code": "def search ( arr , l , h , key ) :\n    if l > h :\n        return - 1\n    mid = ( l + h ); mid = mid // 2\n    if arr [ mid ] == key :\n        return mid\n    if arr [ l ] <= arr [ mid ] :\n        if key >= arr [ l ] and key <= arr [ mid ] :\n            return search ( arr , l , mid - 1 , key )\n        return search ( arr , mid + 1 , h , key )\n    if key >= arr [ mid ] and key <= arr [ h ] :\n        return search ( arr , mid + 1 , h , key )\n    return search ( arr , l , mid - 1 , key )", "id": "AssignUnfoldding_sample_from_SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY_to_191", "old_id": "SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY"}
{"code": "def binarySearch ( arr , low , high , key ) :\n    if ( high < low ) :\n        return - 1\n    mid = ( low + high ); mid = mid / 2\n    if ( key == arr [ int ( mid ) ] ) :\n        return mid\n    if ( key > arr [ int ( mid ) ] ) :\n        return binarySearch ( arr , ( mid + 1 ) , high , key )\n    return ( binarySearch ( arr , low , ( mid - 1 ) , key ) )", "id": "AssignUnfoldding_sample_from_SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_to_192", "old_id": "SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY"}
{"code": "def insertSorted ( arr , n , key , capacity ) :\n    if ( n >= capacity ) :\n        return n\n    i = n; i = i - 1\n    while i >= 0 and arr [ i ] > key :\n        arr [ i + 1 ] = arr [ i ]\n        i -= 1\n    arr [ i + 1 ] = key\n    return ( n + 1 )", "id": "AssignUnfoldding_sample_from_SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1_to_193", "old_id": "SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1"}
{"code": "def getTotalNumberOfSequences ( m , n ) :\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ]\n    for i in range ( m + 1 ) :\n        for j in range ( n + 1 ) :\n            if i == 0 or j == 0 :\n                T [ i ] [ j ] = 0\n            elif i < j :\n                T [ i ] [ j ] = 0\n            elif j == 1 :\n                T [ i ] [ j ] = i\n            else :\n                T [ i ] [ j ] = T [ i - 1 ] [ j ]; T [ i ] [ j ] = T [ i ] [ j ] + T [ i // 2 ] [ j - 1 ]\n    return T [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1_to_194", "old_id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1"}
{"code": "def maxSubArraySum ( a , size ) :\n    max_so_far = - maxsize; max_so_far = max_so_far - 1\n    max_ending_here = 0\n    start = 0\n    end = 0\n    s = 0\n    for i in range ( 0 , size ) :\n        max_ending_here += a [ i ]\n        if max_so_far < max_ending_here :\n            max_so_far = max_ending_here\n            start = s\n            end = i\n        if max_ending_here < 0 :\n            max_ending_here = 0\n            s = i; s = s + 1\n    return ( end - start + 1 )", "id": "AssignUnfoldding_sample_from_SIZE_SUBARRAY_MAXIMUM_SUM_to_195", "old_id": "SIZE_SUBARRAY_MAXIMUM_SUM"}
{"code": "def sort012 ( a , arr_size ) :\n    lo = 0\n    hi = arr_size; hi = hi - 1\n    mid = 0\n    while mid <= hi :\n        if a [ mid ] == 0 :\n            a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]\n            lo = lo + 1\n            mid = mid + 1\n        elif a [ mid ] == 1 :\n            mid = mid + 1\n        else :\n            a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]\n            hi = hi - 1", "id": "AssignUnfoldding_sample_from_SORT_AN_ARRAY_OF_0S_1S_AND_2S_to_196", "old_id": "SORT_AN_ARRAY_OF_0S_1S_AND_2S"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    for i in range ( n ) :\n        arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ]; arr [ i ] = arr [ i ] + C\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    for i in range ( n ) :\n        if maximum < arr [ i ] :\n            index = i\n            maximum = arr [ i ]\n    i = 0\n    j = n; j = j - 1\n    new_arr = [ 0 ]; new_arr = new_arr * n\n    k = 0\n    while i < index and j > index :\n        if arr [ i ] < arr [ j ] :\n            new_arr [ k ] = arr [ i ]\n            k += 1\n            i += 1\n        else :\n            new_arr [ k ] = arr [ j ]\n            k += 1\n            j -= 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k += 1\n        i += 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k += 1\n        j -= 1\n        new_arr [ n - 1 ] = maximum\n    for i in range ( n ) :\n        arr [ i ] = new_arr [ i ]", "id": "AssignUnfoldding_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_197", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def sortit ( arr , n ) :\n    for i in range ( n ) :\n        arr [ i ] = i; arr [ i ] = arr [ i ] + 1", "id": "AssignUnfoldding_sample_from_SORT_ARRAY_CONTAIN_1_N_VALUES_to_198", "old_id": "SORT_ARRAY_CONTAIN_1_N_VALUES"}
{"code": "def KnapSack ( val , wt , n , W ) :\n    dp = [ 0 ]; dp = dp * ( W + 1 )\n    for i in range ( n ) :\n        for j in range ( W , -1 , - 1 ) :\n            if j - wt [ i ] < W + 1 and j - wt [ i ] >= 0:\n                dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] )\n    return dp [ W ]", "id": "AssignUnfoldding_sample_from_SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1_to_199", "old_id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1"}
{"code": "def floorSqrt ( x ) :\n    if ( x == 0 or x == 1 ) :\n        return x\n    i = 1\n    result = 1\n    while ( result <= x ) :\n        i += 1\n        result = i; result = result * i\n    return i - 1", "id": "AssignUnfoldding_sample_from_SQUARE_ROOT_OF_AN_INTEGER_to_200", "old_id": "SQUARE_ROOT_OF_AN_INTEGER"}
{"code": "def squareRoot ( n ) :\n    x = n\n    y = 1\n    e = 0.000001\n    while ( x - y > e ) :\n        x = ( x + y ); x = x / 2\n        y = n; y = y / x\n    return x", "id": "AssignUnfoldding_sample_from_SQUARE_ROOT_OF_A_PERFECT_SQUARE_to_201", "old_id": "SQUARE_ROOT_OF_A_PERFECT_SQUARE"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        sum += C [ n ] [ i ]\n    return sum", "id": "AssignUnfoldding_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_202", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def calculateSum ( n ) :\n    if ( n <= 0 ) :\n        return 0\n    fibo = [ 0 ]; fibo = fibo * ( n + 1 )\n    fibo [ 1 ] = 1\n    sm = fibo [ 0 ]; sm = sm + fibo [ 1 ]\n    for i in range ( 2 , n + 1 ) :\n        fibo [ i ] = fibo [ i - 1 ]; fibo [ i ] = fibo [ i ] + fibo [ i - 2 ]\n        sm = sm + fibo [ i ]\n    return sm", "id": "AssignUnfoldding_sample_from_SUM_FIBONACCI_NUMBERS_to_203", "old_id": "SUM_FIBONACCI_NUMBERS"}
{"code": "def findSum ( n ) :\n    ans = 0\n    temp = 0\n    for i in range ( 1 , n + 1 ) :\n        if temp < n :\n            temp = i; temp = temp - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans += i * num\n                else :\n                    ans += ( n - temp ) * num\n                temp += i\n                num += 1\n    return ans", "id": "AssignUnfoldding_sample_from_SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1_to_204", "old_id": "SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1"}
{"code": "def calculateSum ( n ) :\n    sum = 0\n    sum = 1; sum = sum << n\n    return ( sum - 1 )", "id": "AssignUnfoldding_sample_from_SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1_to_205", "old_id": "SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1"}
{"code": "def sumOfSubstrings ( num ) :\n    n = len ( num )\n    sumofdigit = [ ]\n    sumofdigit.append ( ord ( num [ 0 ] ) - ord('0') )\n    res = sumofdigit [ 0 ]\n    for i in range ( 1 , n ) :\n        numi = ord ( num [ i ] ); numi = numi - ord ( '0' )\n        sumofdigit.append ( ( i + 1 ) + numi + 10 + sumofdigit [ i - 1 ] )\n        res += sumofdigit [ i ]\n    return res", "id": "AssignUnfoldding_sample_from_SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER_to_206", "old_id": "SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER"}
{"code": "def findSum ( n ) :\n    multiTerms = n * ( n + 1 ); multiTerms = multiTerms // 2\n    sm = multiTerms\n    for i in range ( 2 , n + 1 ) :\n        multiTerms = multiTerms - ( i - 1 )\n        sm = sm + multiTerms * i\n    return sm", "id": "AssignUnfoldding_sample_from_SUM_PAIRWISE_PRODUCTS_1_to_207", "old_id": "SUM_PAIRWISE_PRODUCTS_1"}
{"code": "def sumofsquare ( n ) :\n    C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )\n    return sum", "id": "AssignUnfoldding_sample_from_SUM_SQUARES_BINOMIAL_COEFFICIENTS_to_208", "old_id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    for i in range(n1):\n        sum = (ord(str1[i]) - 48); sum = sum + ((ord(str2[i]) - 48) + carry)\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = int(sum / 10)\n    for i in range(n1, n2):\n        sum = (ord(str2[i]) - 48); sum = sum + carry\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n    if (carry):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "AssignUnfoldding_sample_from_SUM_TWO_LARGE_NUMBERS_to_209", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def swapBits ( x , p1 , p2 , n ) :\n    set1 = ( x >> p1 ); set1 = set1 & ( ( 1 << n ) - 1 )\n    set2 = ( x >> p2 ); set2 = set2 & ( ( 1 << n ) - 1 )\n    xor = set1; xor = xor ^ set2\n    xor = ( xor << p1 ); xor = xor | ( xor << p2 )\n    result = x; result = result ^ xor\n    return result", "id": "AssignUnfoldding_sample_from_SWAP_BITS_IN_A_GIVEN_NUMBER_to_210", "old_id": "SWAP_BITS_IN_A_GIVEN_NUMBER"}
{"code": "def swap ( xp , yp ) :\n    xp [ 0 ] = xp [ 0 ]; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\n    yp [ 0 ] = xp [ 0 ]; yp [ 0 ] = yp [ 0 ] ^ yp [ 0 ]\n    xp [ 0 ] = xp [ 0 ]; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]", "id": "AssignUnfoldding_sample_from_SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE_to_211", "old_id": "SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE"}
{"code": "def countWays ( n ) :\n    A = [ 0 ]; A = A * ( n + 1 )\n    B = [ 0 ]; B = B * ( n + 1 )\n    A [ 0 ] = 1\n    A [ 1 ] = 0\n    B [ 0 ] = 0\n    B [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        A [ i ] = A [ i - 2 ]; A [ i ] = A [ i ] + 2 * B [ i - 1 ]\n        B [ i ] = A [ i - 1 ]; B [ i ] = B [ i ] + B [ i - 2 ]\n    return A [ n ]", "id": "AssignUnfoldding_sample_from_TILING_WITH_DOMINOES_to_212", "old_id": "TILING_WITH_DOMINOES"}
{"code": "def countUnique ( mat , n , m ) :\n    rowsum = [ 0 ]; rowsum = rowsum * n\n    colsum = [ 0 ]; colsum = colsum * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( mat [ i ] [ j ] != 0 ) :\n                rowsum [ i ] += 1\n                colsum [ j ] += 1\n    uniquecount = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) :\n                uniquecount += 1\n    return uniquecount", "id": "AssignUnfoldding_sample_from_UNIQUE_CELLS_BINARY_MATRIX_to_213", "old_id": "UNIQUE_CELLS_BINARY_MATRIX"}
{"code": "def CountWays ( n ) :\n    table = [ 0 ]; table = table * ( n + 1 )\n    table [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        for j in range ( i , n + 1 ) :\n            table [ j ] += table [ j - i ]\n    return table [ n ]", "id": "AssignUnfoldding_sample_from_WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS_to_214", "old_id": "WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS"}
{"code": "def countTransformation ( a , b ) :\n    n = len ( a )\n    m = len ( b )\n    if m == 0 :\n        return 1\n    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]\n    for i in range ( m ) :\n        for j in range ( i , n ) :\n            if i == 0 :\n                if j == 0 :\n                    if a [ j ] == b [ i ] :\n                        dp [ i ] [ j ] = 1\n                    else :\n                        dp [ i ] [ j ] = 0\n                elif a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + 1\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n            else :\n                if a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n    return dp [ m - 1 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS_to_215", "old_id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS"}
{"code": "def nearestSmallerEqFib ( n ) :\n    if ( n == 0 or n == 1 ) :\n        return n\n    f1 , f2 , f3 = 0 , 1 , 1\n    while ( f3 <= n ) :\n        f1 = f2 \n        f2 = f3 \n        f3 = f1; f3 = f3 + f2 \n    return f2 ", "id": "AssignUnfoldding_sample_from_ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION_to_216", "old_id": "ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION"}
