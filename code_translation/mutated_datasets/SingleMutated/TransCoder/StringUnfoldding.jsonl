{"code": "def encrypt ( text , s ) :\n    result = (\"\" + \"\")\n    for i in range ( len ( text ) ) :\n        char = text [ i ]\n        if ( char.isupper ( ) ) :\n            result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        else :\n            result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n    return result", "id": "StringUnfoldding_sample_from_CAESAR_CIPHER_to_0", "old_id": "CAESAR_CIPHER"}
{"code": "def calcAngle ( h , m ) :\n    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :\n        print ( ('W' + 'rong input') )\n    if ( h == 12 ) :\n        h = 0\n    if ( m == 60 ) :\n        m = 0\n    hour_angle = int ( 0.5 * ( h * 60 + m ) )\n    minute_angle = int ( 6 * m )\n    angle = abs ( hour_angle - minute_angle )\n    angle = min ( 360 - angle , angle )\n    return angle", "id": "StringUnfoldding_sample_from_CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND_to_1", "old_id": "CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    for i in range ( 1 , len ( str ) ) :\n        if ( str [ i ] == ('' + '0') or str [ i ] == ('' + '1') or res < 2 ) :\n            res += ord ( str [ i ] ) - 48\n        else :\n            res += ord ( str [ i ] ) - 48\n    return res", "id": "StringUnfoldding_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_2", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = (\"0\" + \"\")\n    Sum = 0\n    for ch in str :\n        if ( ch.isdigit ( ) ) :\n            temp += ch\n        else :\n            Sum += int ( temp )\n            temp = (\"\" + \"0\")\n    return Sum + int ( temp )", "id": "StringUnfoldding_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_3", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def canMakeAllSame ( str ) :\n    zeros = 0\n    ones = 0\n    for i in range ( 0 , len ( str ) ) :\n        ch = str [ i ]\n        if ( ch == ('' + '0') ) :\n            zeros = zeros + 1\n        else :\n            ones = ones + 1\n    return ( zeros == 1 or ones == 1 )", "id": "StringUnfoldding_sample_from_CHANGE_BITS_CAN_MADE_ONE_FLIP_to_4", "old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP"}
{"code": "def isOneFlip ( str ) :\n    sum = 0\n    n = len ( str )\n    for i in range ( 0 , n ) :\n        sum += ord ( str [ i ] ) - ord ( ('' + '0') )\n    return ( sum == n - 1 or sum == 1 )", "id": "StringUnfoldding_sample_from_CHANGE_BITS_CAN_MADE_ONE_FLIP_1_to_5", "old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP_1"}
{"code": "def isDivisible ( str , k ) :\n    n = len ( str )\n    c = 0\n    for i in range ( 0 , k ) :\n        if ( str [ n - i - 1 ] == ('' + '0') ) :\n            c += 1\n    return ( c == k )", "id": "StringUnfoldding_sample_from_CHECK_DIVISIBILITY_BINARY_STRING_2K_to_6", "old_id": "CHECK_DIVISIBILITY_BINARY_STRING_2K"}
{"code": "def isDivisible999 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == ('0' + '') ) :\n        return True\n    if ( ( n % 3 ) == 1 ) :\n        num = (\"00\" + \"\") + num\n    if ( ( n % 3 ) == 2 ) :\n        num = (\"\" + \"0\") + num\n    gSum = 0\n    for i in range ( 0 , n , 3 ) :\n        group = 0\n        group += ( ord ( num [ i ] ) - 48 ) * 100\n        group += ( ord ( num [ i + 1 ] ) - 48 ) * 10\n        group += ( ord ( num [ i + 2 ] ) - 48 )\n        gSum += group\n    if ( gSum > 1000 ) :\n        num = str ( gSum )\n        n = len ( num )\n        gSum = isDivisible999 ( num )\n    return ( gSum == 999 )", "id": "StringUnfoldding_sample_from_CHECK_DIVISIBILITY_LARGE_NUMBER_999_to_7", "old_id": "CHECK_DIVISIBILITY_LARGE_NUMBER_999"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == ('' + '0') ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num = str ( num ) + (\"0\" + \"0\")\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ) + (\"\" + \"0\")\n        length += 1\n    sum = 0\n    p = 1\n    for i in range ( length - 1 , - 1 , - 3 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( ('0' + '') )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('' + '0') ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('0' + '') ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "StringUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_8", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def check ( str ) :\n    n = len ( str )\n    if ( n == 0 ) :\n        return False\n    if ( n == 1 ) :\n        return ( ( str [ 0 ] - ('0' + '') ) % 4 == 0 )\n    last = ( int ) ( str [ n - 1 ] )\n    second_last = ( int ) ( str [ n - 2 ] )\n    return ( ( second_last * 10 + last ) % 4 == 0 )", "id": "StringUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT_to_9", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT"}
{"code": "def isRotated ( str1 , str2 ) :\n    if ( len ( str1 ) != len ( str2 ) ) :\n        return False\n    clock_rot = (\"\" + \"\")\n    anticlock_rot = (\"\" + \"\")\n    l = len ( str2 )\n    anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] )\n    clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ]\n    return ( str1 == clock_rot or str1 == anticlock_rot )", "id": "StringUnfoldding_sample_from_CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES_to_10", "old_id": "CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES"}
{"code": "def isAnBn ( s ) :\n    n = len ( s )\n    for i in range ( n ) :\n        if ( s [ i ] != ('a' + '') ) :\n            break\n    if ( i * 2 != n ) :\n        return False\n    for j in range ( i , n ) :\n        if ( s [ j ] != ('' + 'b') ) :\n            return False\n    return True", "id": "StringUnfoldding_sample_from_CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT_to_11", "old_id": "CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if ( n % 3 == 1 ) :\n        num = str ( num ) + (\"\" + \"00\")\n        n += 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ) + (\"\" + \"0\")\n        n += 1\n    GSum = 0\n    p = 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( ('0' + '') )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('' + '0') ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('' + '0') ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n    return ( GSum % 7 == 0 )", "id": "StringUnfoldding_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_12", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def constructPalin ( str , len ) :\n    str = list ( str )\n    i = - 1\n    j = len\n    while i < j :\n        i += 1\n        j -= 1\n        if ( str [ i ] == str [ j ] and str [ i ] != ('' + '*') ) :\n            continue\n        elif ( str [ i ] == str [ j ] and str [ i ] == ('*' + '') ) :\n            str [ i ] = ('' + 'a')\n            str [ j ] = ('' + 'a')\n            continue\n        elif str [ i ] == ('' + '*') :\n            str [ i ] = str [ j ]\n            continue\n        elif str [ j ] == ('' + '*') :\n            str [ j ] = str [ i ]\n            continue\n        print ( (\"Not Possibl\" + \"e\") )\n        return (\"\" + \"\")\n    return ('' + '').join ( str )", "id": "StringUnfoldding_sample_from_CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME_to_13", "old_id": "CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME"}
{"code": "def decimalToBinary ( num , k_prec ) :\n    binary = (\"\" + \"\")\n    Integral = int ( num )\n    fractional = num - Integral\n    while ( Integral > 0 ) :\n        rem = Integral % 2\n        binary += str ( rem )\n        Integral //= 2\n    binary = binary [ : : - 1 ]\n    binary += ('.' + '')\n    while ( k_prec > 0 ) :\n        fractional *= 2\n        fract_bit = int ( fractional )\n        if ( fract_bit == 1 ) :\n            fractional -= fract_bit\n            binary += ('' + '1')\n        else :\n            binary += ('0' + '')\n        k_prec -= 1\n    return binary", "id": "StringUnfoldding_sample_from_CONVERT_DECIMAL_FRACTION_BINARY_NUMBER_to_14", "old_id": "CONVERT_DECIMAL_FRACTION_BINARY_NUMBER"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    for i in range ( n ) :\n        if ( str [ i ] == ('a' + '') ) :\n            a_index = i + 1\n            ans -= min ( b_index , c_index )\n        elif ( str [ i ] == ('' + 'b') ) :\n            b_index = i + 1\n            ans -= min ( a_index , c_index )\n        else :\n            c_index = i + 1\n            ans -= min ( a_index , b_index )\n    return ans", "id": "StringUnfoldding_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_15", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    for i in range ( len ( s ) ) :\n        if s [ ~ i ] == ('a' + '') :\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n        else :\n            b_count += 1\n    return res", "id": "StringUnfoldding_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_16", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def countDecodingDP ( digits , n ) :\n    count = [ 0 ] * ( n + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == ('' + '0') :\n        return 0\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > ('0' + '') ) :\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == ('' + '1') or ( digits [ i - 2 ] == ('2' + '') and digits [ i - 1 ] < ('' + '7') ) ) :\n            count [ i ] += count [ i - 2 ]\n    return count [ n ]", "id": "StringUnfoldding_sample_from_COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1_to_17", "old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1"}
{"code": "def decToBin ( n ) :\n    if ( n == 0 ) :\n        return (\"\" + \"0\")\n    bin = (\"\" + \"\")\n    while ( n > 0 ) :\n        if ( n & 1 == 0 ) :\n            bin = ('0' + '') + bin\n        else :\n            bin = ('1' + '') + bin\n        n = n >> 1\n    return bin", "id": "StringUnfoldding_sample_from_DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS_to_18", "old_id": "DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = (\"\" + \"\")\n    result = (\"\" + \"\")\n    for i in range ( len ( Str ) ) :\n        count = 0\n        if ( Str [ i ] >= ('' + '0') and Str [ i ] <= ('' + '9') ) :\n            while ( Str [ i ] >= ('' + '0') and Str [ i ] <= ('' + '9') ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( ('' + '0') )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n        elif ( Str [ i ] == (']' + '') ) :\n            temp = (\"\" + \"\")\n            count = 0\n            if ( len ( integerstack ) != 0 ) :\n                count = integerstack [ - 1 ]\n                integerstack.pop ( )\n            while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ('' + '[') ) :\n                temp = stringstack [ - 1 ] + temp\n                stringstack.pop ( )\n            if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == ('' + '[') ) :\n                stringstack.pop ( )\n            for j in range ( count ) :\n                result = result + temp\n            for j in range ( len ( result ) ) :\n                stringstack.append ( result [ j ] )\n            result = (\"\" + \"\")\n        elif ( Str [ i ] == ('[' + '') ) :\n            if ( Str [ i - 1 ] >= ('' + '0') and Str [ i - 1 ] <= ('' + '9') ) :\n                stringstack.append ( Str [ i ] )\n            else :\n                stringstack.append ( Str [ i ] )\n                integerstack.append ( 1 )\n        else :\n            stringstack.append ( Str [ i ] )\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "StringUnfoldding_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_19", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def longDivision ( number , divisor ) :\n    ans = (\"\" + \"\")\n    idx = 0\n    temp = ord ( number [ idx ] ) - ord ( ('' + '0') )\n    while ( temp < divisor ) :\n        temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( ('' + '0') ) )\n        idx += 1\n    while ( ( len ( number ) ) > idx ) :\n        ans += chr ( math.floor ( temp // divisor ) + ord ( ('' + '0') ) )\n        temp = ( ( temp % divisor ) * 10 + ord ( number [ idx + 1 ] ) - ord ( ('0' + '') ) )\n        idx += 1\n    ans += chr ( math.floor ( temp // divisor ) + ord ( ('0' + '') ) )\n    if ( len ( ans ) == 0 ) :\n        return (\"\" + \"0\")\n    return ans", "id": "StringUnfoldding_sample_from_DIVIDE_LARGE_NUMBER_REPRESENTED_STRING_to_20", "old_id": "DIVIDE_LARGE_NUMBER_REPRESENTED_STRING"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if symb [ i ] == ('' + 'F') :\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == ('T' + '') :\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n    for gap in range ( 1 , n ) :\n        i = 0\n        for j in range ( gap , n ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == ('' + '&') :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == ('|' + '') :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == ('' + '^') :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n            i += 1\n    return T [ 0 ] [ n - 1 ]", "id": "StringUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_21", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def find3Numbers ( A , arr_size , sum ) :\n    for i in range ( 0 , arr_size - 2 ) :\n        for j in range ( i + 1 , arr_size - 1 ) :\n            for k in range ( j + 1 , arr_size ) :\n                if A [ i ] + A [ j ] + A [ k ] == sum :\n                    print ( (\"Triple\" + \"t is\") , A [ i ] , (\",\" + \" \") , A [ j ] , (\",\" + \" \") , A [ k ] )\n                    return True\n    return False", "id": "StringUnfoldding_sample_from_FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_to_22", "old_id": "FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    for ch in string :\n        if ch == ('' + ')') :\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != ('(' + '') :\n                elementsInside += 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n        else :\n            Stack.append ( ch )\n    return False", "id": "StringUnfoldding_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_23", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize - 1\n    for i in range ( r ) :\n        if m [ i ] [ 0 ] < mi :\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx :\n            mx = m [ i ] [ c - 1 ]\n    desired = ( r * c + 1 ) // 2\n    while ( mi < mx ) :\n        mid = mi + ( mx - mi ) // 2\n        place = [ 0 ]\n        for i in range ( r ) :\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ] + j\n        if place [ 0 ] < desired :\n            mi = mid + 1\n        else :\n            mx = mid\n    print ( (\"Med\" + \"ian is\") , mi )\n    return mi", "id": "StringUnfoldding_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_24", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def pairSum ( mat , n , sum ) :\n    for i in range ( n ) :\n        mat [ i ].sort ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) :\n                    print ( (\"(\" + \"\") , mat [ i ] [ left ] , (\"\" + \", \") , mat [ j ] [ right ] , (\"),\" + \" \") , end = (\"\" + \" \") )\n                    left += 1\n                    right -= 1\n                else :\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1", "id": "StringUnfoldding_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_25", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def patternCount ( str ) :\n    last = str [ 0 ]\n    i = 1\n    counter = 0\n    while ( i < len ( str ) ) :\n        if ( str [ i ] == ('0' + '') and last == ('' + '1') ) :\n            while ( str [ i ] == ('0' + '') ) :\n                i += 1\n                if ( str [ i ] == ('' + '1') ) :\n                    counter += 1\n        last = str [ i ]\n        i += 1\n    return counter", "id": "StringUnfoldding_sample_from_FIND_PATTERNS_101_GIVEN_STRING_to_26", "old_id": "FIND_PATTERNS_101_GIVEN_STRING"}
{"code": "def findpos ( n ) :\n    i = 0\n    j = len ( n )\n    pos = 0\n    while ( i < j ) :\n        if ( n [ i ] == ('' + '4') ) :\n            pos = pos * 2 + 1\n        if ( n [ i ] == ('' + '7') ) :\n            pos = pos * 2 + 2\n        i = i + 1\n    return pos", "id": "StringUnfoldding_sample_from_FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7_to_27", "old_id": "FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7"}
{"code": "def subArraySum ( arr , n , sum ) :\n    for i in range ( n ) :\n        curr_sum = arr [ i ]\n        j = i + 1\n        while j <= n :\n            if curr_sum == sum :\n                print ( (\"Sum found between\" + \"\") )\n                print ( (\"indexes %\" + \"d and %d\") % ( i , j - 1 ) )\n                return 1\n            if curr_sum > sum or j == n :\n                break\n            curr_sum = curr_sum + arr [ j ]\n            j += 1\n    print ( (\"No subarra\" + \"y found\") )\n    return 0", "id": "StringUnfoldding_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_to_28", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM"}
{"code": "def subArraySum ( arr , n , sum ) :\n    curr_sum = arr [ 0 ]\n    start = 0\n    i = 1\n    while i <= n :\n        while curr_sum > sum and start < i - 1 :\n            curr_sum = curr_sum - arr [ start ]\n            start += 1\n        if curr_sum == sum :\n            print ( (\"Sum found between\" + \" indexes\") )\n            print ( (\"\" + \"%d and %d\") % ( start , i - 1 ) )\n            return 1\n        if i < n :\n            curr_sum = curr_sum + arr [ i ]\n        i += 1\n    print ( (\"No subarray \" + \"found\") )\n    return 0", "id": "StringUnfoldding_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_1_to_29", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM_1"}
{"code": "def findElement ( arr , n ) :\n    leftMax = [ None ] * n\n    leftMax [ 0 ] = float ( ('-i' + 'nf') )\n    for i in range ( 1 , n ) :\n        leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] )\n    rightMin = float ( ('inf' + '') )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] :\n            return i\n        rightMin = min ( rightMin , arr [ i ] )\n    return - 1", "id": "StringUnfoldding_sample_from_FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT_to_30", "old_id": "FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    for i in range ( n - 1 ) :\n        s = set ( )\n        for j in range ( i + 1 , n ) :\n            x = - ( arr [ i ] + arr [ j ] )\n            if x in s :\n                print ( x , arr [ i ] , arr [ j ] )\n                found = True\n            else :\n                s.add ( arr [ j ] )\n    if found == False :\n        print ( (\"No Triplet Foun\" + \"d\") )", "id": "StringUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1_to_31", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    for i in range ( 0 , n - 1 ) :\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if ( x + arr [ l ] + arr [ r ] == 0 ) :\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n            elif ( x + arr [ l ] + arr [ r ] < 0 ) :\n                l += 1\n            else :\n                r -= 1\n    if ( found == False ) :\n        print ( (\" No Triplet\" + \" Found\") )", "id": "StringUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_32", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def first ( str , i ) :\n    if ( str [ i ] == ('\\0' + '') ) :\n        return 0\n    if ( str [ i ].isupper ( ) ) :\n        return str [ i ]\n    return first ( str , i + 1 )", "id": "StringUnfoldding_sample_from_FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1_to_33", "old_id": "FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return (\"-1\" + \"\")\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == ('' + 'I') ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( ('0' + '') + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == ('' + 'I') ) :\n                    break\n    return result", "id": "StringUnfoldding_sample_from_FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1_to_34", "old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return (\"-\" + \"1\")\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == ('' + 'I') ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( ('0' + '') + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == ('I' + '') ) :\n                    break\n    return (\"\" + \"\").join(str(i) for i in result)", "id": "StringUnfoldding_sample_from_GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1_to_35", "old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1"}
{"code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    for i in range ( 0 , n - 1 ) :\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        for j in range ( i + 1 , n ) :\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) :\n                maxsize = j - i + 1\n                startindex = i\n    if ( maxsize == - 1 ) :\n        print ( (\"No s\" + \"uch subarray\") )\n    else :\n        print ( startindex , (\"to\" + \"\") , startindex + maxsize - 1 )\n    return maxsize", "id": "StringUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_36", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 0 ) :\n            arr [ i ] = - 1\n        else :\n            arr [ i ] = 1\n    for i in range ( 0 , n ) :\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) :\n            max_len = i + 1\n            ending_index = i\n        if ( curr_sum + n ) in hash_map :\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i - hash_map [ curr_sum + n ]\n                ending_index = i\n        else :\n            hash_map[curr_sum + n] = i\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == - 1 ) :\n            arr [ i ] = 0\n        else :\n            arr [ i ] = 1\n    print ( ending_index - max_len + 1 , end = (\" \" + \"\") )\n    print ( (\"to\" + \"\") , end = (\" \" + \"\") )\n    print ( ending_index )\n    return max_len", "id": "StringUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_37", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    for i in range ( n - 1 ) :\n        if ( s [ i ] == ('' + '(') and s [ i + 1 ] == (')' + '') ) :\n            dp [ i ] [ i + 1 ] = 2\n    for l in range ( 2 , n ) :\n        i = - 1\n        for j in range ( l , n ) :\n            i += 1\n            if ( s [ i ] == ('' + '(') and s [ j ] == ('' + ')') ) :\n                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]\n            for k in range ( i , j ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n    return dp [ 0 ] [ n - 1 ]", "id": "StringUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_to_38", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    for i in range ( n ) :\n        if ( s [ i ] == ('' + '(') ) :\n            invalidOpenBraces += 1\n        else :\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces += 1\n            else :\n                invalidOpenBraces -= 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "StringUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_39", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def longestNull ( S ) :\n    arr = [ ]\n    arr.append ( [ ('' + '@') , - 1 ] )\n    maxlen = 0\n    for i in range ( len ( S ) ) :\n        arr.append ( [ S [ i ] , i ] )\n        while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] [ 0 ] == ('1' + '') and arr [ len ( arr ) - 2 ] [ 0 ] == ('' + '0') and arr [ len ( arr ) - 1 ] [ 0 ] == ('' + '0') ) :\n            arr.pop ( )\n            arr.pop ( )\n            arr.pop ( )\n        tmp = arr [ - 1 ]\n        maxlen = max ( maxlen , i - tmp [ 1 ] )\n    return maxlen", "id": "StringUnfoldding_sample_from_LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED_to_40", "old_id": "LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED"}
{"code": "def subsequence ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = ('zyxwv' + 'utsrqponmlkjihgfedcba')\n    for ch in string :\n        cnt = 0\n        for i in range ( last , n ) :\n            if s [ i ] == ch :\n                cnt += 1\n        if cnt >= k :\n            for i in range ( last , n ) :\n                if s [ i ] == ch :\n                    t [ size ] = ch\n                    new_last = i\n                    size += 1\n            last = new_last\n    t[size] = ('\\0' + '');", "id": "StringUnfoldding_sample_from_LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES_to_41", "old_id": "LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES"}
{"code": "def nextWord ( s ) :\n    if ( s == (\"\" + \" \") ) :\n        return (\"a\" + \"\")\n    i = len ( s ) - 1\n    while ( s [ i ] == ('z' + '') and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        s = s + ('' + 'a')\n    else :\n        s = s [ 0 : i ] + chr ( ord ( s [ i ] ) + 1 ) + s [ i + 1 : ]\n    return s", "id": "StringUnfoldding_sample_from_LEXICOGRAPHICALLY_NEXT_STRING_to_42", "old_id": "LEXICOGRAPHICALLY_NEXT_STRING"}
{"code": "def prevPermutation ( str ) :\n    n = len ( str ) - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j += 1\n    str = list ( str )\n    temp = str [ i - 1 ]\n    str [ i - 1 ] = str [ j ]\n    str [ j ] = temp\n    str = ('' + '').join ( str )\n    str [ : : - 1 ]\n    return True", "id": "StringUnfoldding_sample_from_LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C_to_43", "old_id": "LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C"}
{"code": "def lexicographicSubConcat ( s ) :\n    n = len ( s )\n    sub_count = ( n * ( n + 1 ) ) // 2\n    arr = [ 0 ] * sub_count\n    index = 0\n    for i in range ( n ) :\n        for j in range ( 1 , n - i + 1 ) :\n            arr [ index ] = s [ i : i + j ]\n            index += 1\n    arr.sort ( )\n    res = (\"\" + \"\")\n    for i in range ( sub_count ) :\n        res += arr [ i ]\n    return res", "id": "StringUnfoldding_sample_from_LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING_to_44", "old_id": "LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING"}
{"code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n , 2 ) :\n            length = j - i + 1\n            leftsum = 0\n            rightsum = 0\n            for k in range ( 0 , int ( length / 2 ) ) :\n                leftsum += ( int ( str [ i + k ] ) - int ( ('' + '0') ) )\n                rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( ('' + '0') ) )\n            if ( leftsum == rightsum and maxlen < length ) :\n                maxlen = length\n    return maxlen", "id": "StringUnfoldding_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_to_45", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    res = ('' + '')\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) :\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n            i -= 1\n        else :\n            j -= 1\n    res = ('' + '').join ( reversed ( res ) )\n    return res", "id": "StringUnfoldding_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_46", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def to_upper(in_list):\n    for i in range(len(in_list)):\n        if ('' + 'a') <= in_list[i] <= ('z' + ''):\n            in_list[i] = chr(ord(in_list[i]) - ord(('' + 'a')) + ord(('' + 'A')))\n    return ('' + '').join(in_list)", "id": "StringUnfoldding_sample_from_LOWER_CASE_UPPER_CASE_INTERESTING_FACT_to_47", "old_id": "LOWER_CASE_UPPER_CASE_INTERESTING_FACT"}
{"code": "def maximumPalinUsingKChanges ( str , k ) :\n    palin = list(str)\n    l = 0\n    r = len ( str ) - 1\n    while ( l <= r ) :\n        if ( str [ l ] != str [ r ] ) :\n            palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] )\n            k -= 1\n        l += 1\n        r -= 1\n    if ( k < 0 ) :\n        return (\"Not \" + \"possible\")\n    l = 0\n    r = len ( str ) - 1\n    while ( l <= r ) :\n        if ( l == r ) :\n            if ( k > 0 ) :\n                palin [ l ] = ('9' + '')\n        if ( palin [ l ] < ('' + '9') ) :\n            if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) :\n                k -= 1\n                palin [ l ] = palin [ r ] = ('' + '9')\n            elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) ) :\n                k -= 1\n                palin [ l ] = palin [ r ] = ('' + '9')\n        l += 1\n        r -= 1\n    return (\"\" + \"\").join(palin)", "id": "StringUnfoldding_sample_from_MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS_to_48", "old_id": "MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS"}
{"code": "def findMaxValue ( arr , n ) :\n    if n < 4 :\n        print ( (\"The arra\" + \"y should have atlest 4 elements\") )\n        return MIN\n    table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n\n    table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] )\n    for i in range ( n - 3 , - 1 , - 1 ) :\n        table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] )\n    for i in range ( n - 4 , - 1 , - 1 ) :\n        table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] )\n    return table4 [ 0 ]", "id": "StringUnfoldding_sample_from_MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L_to_49", "old_id": "MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L"}
{"code": "def solve ( X , Y , l , r , k , dp ) :\n    if k == 0 :\n        return 0\n    if l < 0 or r < 0 :\n        return 1000000000\n    if dp [ l ] [ r ] [ k ] != - 1 :\n        return dp [ l ] [ r ] [ k ]\n    cost = ( ( ord ( X [ l ] ) - ord ( ('' + 'a') ) ) ^ ( ord ( Y [ r ] ) - ord ( ('' + 'a') ) ) )\n    dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] )\n    return dp [ l ] [ r ] [ k ]", "id": "StringUnfoldding_sample_from_MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K_to_50", "old_id": "MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 ) or ( arr [ 0 ] == 0 ) :\n        return float ( ('' + 'inf') )\n    jumps [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        jumps [ i ] = float ( ('i' + 'nf') )\n        for j in range ( i ) :\n            if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( ('inf' + '') ) ) :\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n    return jumps [ n - 1 ]", "id": "StringUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1_to_51", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = float ( ('inf' + '') )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( ('i' + 'nf') )\n            for j in range ( i + 1 , n ) :\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n            if ( min != float ( ('inf' + '') ) ) :\n                jumps [ i ] = min + 1\n            else :\n                jumps [ i ] = min\n    return jumps [ 0 ]", "id": "StringUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_52", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def minProductSubset ( a , n ) :\n    if ( n == 1 ) :\n        return a [ 0 ]\n    max_neg = float ( ('' + '-inf') )\n    min_pos = float ( ('i' + 'nf') )\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( 0 , n ) :\n        if ( a [ i ] == 0 ) :\n            count_zero = count_zero + 1\n            continue\n        if ( a [ i ] < 0 ) :\n            count_neg = count_neg + 1\n            max_neg = max ( max_neg , a [ i ] )\n        if ( a [ i ] > 0 ) :\n            min_pos = min ( min_pos , a [ i ] )\n        prod = prod * a [ i ]\n    if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) :\n        return 0\n    if ( count_neg == 0 ) :\n        return min_pos\n    if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) :\n        prod = int ( prod / max_neg )\n    return prod", "id": "StringUnfoldding_sample_from_MINIMUM_PRODUCT_SUBSET_ARRAY_to_53", "old_id": "MINIMUM_PRODUCT_SUBSET_ARRAY"}
{"code": "def findMinRooms ( slots , n , m ) :\n    counts = [ 0 ] * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if i < len(slots) and j < len(slots[i]):\n                if ( slots [ i ] [ j ] == ('' + '1') ) :\n                    counts [ j ] += 1\n    return max ( counts )", "id": "StringUnfoldding_sample_from_MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE_to_54", "old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE"}
{"code": "def compute ( str , n ) :\n    reverseAlphabet = (\"zyx\" + \"wvutsrqponmlkjihgfedcba\")\n    l = len ( str )\n    answer = (\"\" + \"\")\n    for i in range ( 0 , n ) :\n        if i < l:\n            answer = answer + str [ i ]\n    for i in range ( n , l ) :\n        answer = ( answer + reverseAlphabet [ ord ( str [ i ] ) - ord ( (\"\" + \"a\") ) ] )\n    return answer", "id": "StringUnfoldding_sample_from_MIRROR_CHARACTERS_STRING_to_55", "old_id": "MIRROR_CHARACTERS_STRING"}
{"code": "def sequence ( n ) :\n    f = array.array ( ('' + 'i') , [ 0 , 1 , 1 ] )\n    for i in range ( 3 , n + 1 ) :\n        r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]\n        f.append ( r )\n    return f[n]", "id": "StringUnfoldding_sample_from_NEWMAN_CONWAY_SEQUENCE_1_to_56", "old_id": "NEWMAN_CONWAY_SEQUENCE_1"}
{"code": "def countOccurrences ( s , K ) :\n    n = len ( s )\n    c1 = 0\n    c2 = 0\n    C = 0\n    for i in range ( n ) :\n        if s [ i ] == ('' + 'a') :\n            c1 += 1\n        if s [ i ] == ('' + 'b') :\n            c2 += 1\n            C += c1\n    return C * K + int ( K * ( K - 1 ) / 2 ) * c1 * c2", "id": "StringUnfoldding_sample_from_NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES_to_57", "old_id": "NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES"}
{"code": "def countDivisibleSubseq ( str , n ) :\n    l = len ( str )\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( l ) ]\n    dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( ('' + '0') ) ) % n ] += 1\n    for i in range ( 1 , l ) :\n        dp [ i ] [ ( ord ( str [ i ] ) - ord ( ('0' + '') ) ) % n ] += 1\n        for j in range ( n ) :\n            dp [ i ] [ j ] += dp [ i - 1 ] [ j ]\n            dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( ('' + '0') ) ) ) % n ] += dp [ i - 1 ] [ j ]\n    return dp [ l - 1 ] [ 0 ]", "id": "StringUnfoldding_sample_from_NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N_to_58", "old_id": "NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N"}
{"code": "def checkPangram ( s ) :\n    List = [ ]\n    for i in range ( 26 ) :\n        List.append ( False )\n    for c in s :\n        if ('' + 'A') <= c and c <= ('' + 'Z'):\n            List [ ord ( c ) - ord ( ('A' + '') ) ] = True\n        elif ('a' + '') <= c and c <= ('' + 'z'):\n            List [ ord ( c ) - ord ( ('' + 'a') ) ] = True\n    for ch in List :\n        if ch == False :\n            return False\n    return True", "id": "StringUnfoldding_sample_from_PANGRAM_CHECKING_to_59", "old_id": "PANGRAM_CHECKING"}
{"code": "def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) :\n    print ( (\"Point inside the view\" + \"ing pane:\") )\n    for i in range ( n ) :\n        if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) :\n            if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) :\n                print ( (\"[\" + \"\") , XY [ i ] [ 0 ] , (\",\" + \" \") , XY [ i ] [ 1 ] , (\"\" + \"]\") , sep = (\"\" + \"\") , end = (\"\" + \"\") )\n    print ( (\"\\n\\nPoint outsid\" + \"e the viewing pane:\") )\n    for i in range ( n ) :\n        if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) :\n            print ( (\"\" + \"[\") , XY [ i ] [ 0 ] , (\"\" + \", \") , XY [ i ] [ 1 ] , (\"\" + \"]\") , sep = (\"\" + \"\") , end = (\"\" + \"\") )\n        if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) ) :\n            print ( (\"\" + \"[\") , XY [ i ] [ 0 ] , (\", \" + \"\") , XY [ i ] [ 1 ] , (\"]\" + \"\") , sep = (\"\" + \"\") , end = (\"\" + \"\") )", "id": "StringUnfoldding_sample_from_POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS_to_60", "old_id": "POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS"}
{"code": "def noAdjacentDup ( s ) :\n    n = len ( s )\n    for i in range ( 1 , n ) :\n        if ( s [ i ] == s [ i - 1 ] ) :\n            s [ i ] = (\"\" + \"a\")\n            while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) :\n                s [ i ] += 1\n            i += 1\n    return s", "id": "StringUnfoldding_sample_from_PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES_to_61", "old_id": "PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES"}
{"code": "def antiSpiralTraversal ( m , n , a ) :\n    k = 0\n    l = 0\n    stk = [ ]\n    while ( k <= m and l <= n ) :\n        for i in range ( l , n + 1 ) :\n            stk.append ( a [ k ] [ i ] )\n        k += 1\n        for i in range ( k , m + 1 ) :\n            stk.append ( a [ i ] [ n ] )\n        n -= 1\n        if ( k <= m ) :\n            for i in range ( n , l - 1 , - 1 ) :\n                stk.append ( a [ m ] [ i ] )\n            m -= 1\n        if ( l <= n ) :\n            for i in range ( m , k - 1 , - 1 ) :\n                stk.append ( a [ i ] [ l ] )\n            l += 1\n    while len ( stk ) != 0 :\n        print ( str ( stk [ - 1 ] ) , end = (\" \" + \"\") )\n        stk.pop ( )", "id": "StringUnfoldding_sample_from_PRINT_MATRIX_ANTISPIRAL_FORM_to_62", "old_id": "PRINT_MATRIX_ANTISPIRAL_FORM"}
{"code": "def printSpiral ( mat , r , c ) :\n    a = 0\n    b = 2\n    low_row = 0 if ( 0 > a ) else a\n    low_column = 0 if ( 0 > b ) else b - 1\n    high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1\n    high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1\n    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :\n        i = low_column + 1\n        while ( i <= high_column and i < c and low_row >= 0 ) :\n            print ( mat [ low_row ] [ i ] , end = (\"\" + \" \") )\n            i += 1\n        low_row -= 1\n        i = low_row + 2\n        while ( i <= high_row and i < r and high_column < c ) :\n            print ( mat [ i ] [ high_column ] , end = (\"\" + \" \") )\n            i += 1\n        high_column += 1\n        i = high_column - 2\n        while ( i >= low_column and i >= 0 and high_row < r ) :\n            print ( mat [ high_row ] [ i ] , end = (\"\" + \" \") )\n            i -= 1\n        high_row += 1\n        i = high_row - 2\n        while ( i > low_row and i >= 0 and low_column >= 0 ) :\n            print ( mat [ i ] [ low_column ] , end = (\" \" + \"\") )\n            i -= 1\n        low_column -= 1\n    print ( )", "id": "StringUnfoldding_sample_from_PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT_to_63", "old_id": "PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        bestIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n    print ( (\"Process No.Process Size     B\" + \"lock no.\") )\n    for i in range ( n ) :\n        print ( i + 1 , (\"       \" + \"  \") , processSize [ i ] , end = (\"  \" + \"       \") )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( (\"\" + \"Not Allocated\") )", "id": "StringUnfoldding_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_64", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def binaryToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base1 = 1\n    len1 = len ( num )\n    for i in range ( len1 - 1 , - 1 , - 1 ) :\n        if ( num [ i ] == ('1' + '') ) :\n            dec_value += base1\n        base1 = base1 * 2\n    return dec_value", "id": "StringUnfoldding_sample_from_PROGRAM_BINARY_DECIMAL_CONVERSION_1_to_65", "old_id": "PROGRAM_BINARY_DECIMAL_CONVERSION_1"}
{"code": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = ('' + '')\n    stars = ('*' + '') * len ( word )\n    count = 0\n    index = 0\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index += 1\n    result = ('' + ' ').join ( word_list )\n    return result", "id": "StringUnfoldding_sample_from_PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE_to_66", "old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 :\n        return False\n    _sum = 0\n    for i in range ( 9 ) :\n        if 0 <= int ( isbn [ i ] ) <= 9 :\n            _sum += int ( isbn [ i ] ) * ( 10 - i )\n        else :\n            return False\n    if ( isbn [ 9 ] != ('' + 'X') and 0 <= int ( isbn [ 9 ] ) <= 9 ) :\n        return False\n    _sum += 10 if isbn [ 9 ] == ('' + 'X') else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )", "id": "StringUnfoldding_sample_from_PROGRAM_CHECK_ISBN_to_67", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        wstIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n    print ( (\"Process No.P\" + \"rocess Size Block no.\") )\n    for i in range ( n ) :\n        print ( i + 1 , (\"        \" + \" \") , processSize [ i ] , end = (\"\" + \"     \") )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( (\"N\" + \"ot Allocated\") )", "id": "StringUnfoldding_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_68", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def simplify ( Str ) :\n    Len = len ( Str )\n    res = [ None ] * Len\n    index = 0\n    i = 0\n    s = [ ]\n    s.append ( 0 )\n    while ( i < Len ) :\n        if ( Str [ i ] == ('+' + '') ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = ('' + '-')\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = ('+' + '')\n                index += 1\n        elif ( Str [ i ] == ('' + '-') ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = ('' + '+')\n                index += 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = ('-' + '')\n                index += 1\n        elif ( Str [ i ] == ('' + '(') and i > 0 ) :\n            if ( Str [ i - 1 ] == ('' + '-') ) :\n                x = 0 if ( s [ - 1 ] == 1 ) else 1\n                s.append ( x )\n            elif ( Str [ i - 1 ] == ('' + '+') ) :\n                s.append ( s [ - 1 ] )\n        elif ( Str [ i ] == ('' + ')') ) :\n            s.pop ( )\n        else :\n            res [ index ] = Str [ i ]\n            index += 1\n        i += 1\n    return (\"\" + \"\").join(res)", "id": "StringUnfoldding_sample_from_REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS_to_69", "old_id": "REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS"}
{"code": "def search ( arr , n , x , k ) :\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] == x ) :\n            return i\n        i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) )\n    print ( (\"number is no\" + \"t present!\") )\n    return - 1", "id": "StringUnfoldding_sample_from_SEARCHING_ARRAY_ADJACENT_DIFFER_K_to_70", "old_id": "SEARCHING_ARRAY_ADJACENT_DIFFER_K"}
{"code": "def search ( arr , n , x ) :\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] == x ) :\n            return i\n        i = i + abs ( arr [ i ] - x )\n    print ( (\"number is n\" + \"ot present!\") )\n    return - 1", "id": "StringUnfoldding_sample_from_SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1_to_71", "old_id": "SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1"}
{"code": "def arrayEvenAndOdd ( arr , n ) :\n    i = - 1\n    j = 0\n    while ( j != n ) :\n        if ( arr [ j ] % 2 == 0 ) :\n            i = i + 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n        j = j + 1\n    for i in arr :\n        print ( str ( i ) + (\"\" + \" \") , end = ('' + '') )", "id": "StringUnfoldding_sample_from_SEGREGATE_EVEN_ODD_NUMBERS_SET_3_to_72", "old_id": "SEGREGATE_EVEN_ODD_NUMBERS_SET_3"}
{"code": "def diagonalsquare ( mat , row , column ) :\n    print ( (\"Diagonal one \" + \": \") , end = (\"\" + \"\") )\n    for i in range ( 0 , row ) :\n        for j in range ( 0 , column ) :\n            if ( i == j ) :\n                print ( (\"{} \" + \"\").format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = (\"\" + \"\") )\n    print ( (\" \\n\\nD\" + \"iagonal two : \") , end = (\"\" + \"\") )\n    for i in range ( 0 , row ) :\n        for j in range ( 0 , column ) :\n            if ( i + j == column - 1 ) :\n                print ( (\"{} \" + \"\").format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = (\"\" + \"\") )", "id": "StringUnfoldding_sample_from_SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_to_73", "old_id": "SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS"}
{"code": "def firstLetterWord ( str ) :\n    result = (\"\" + \"\")\n    v = True\n    for i in range ( len ( str ) ) :\n        if ( str [ i ] == ('' + ' ') ) :\n            v = True\n        elif ( str [ i ] != ('' + ' ') and v == True ) :\n            result += ( str [ i ] )\n            v = False\n    return result", "id": "StringUnfoldding_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_74", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def middlesum ( mat , n ) :\n    row_sum = 0\n    col_sum = 0\n    for i in range ( n ) :\n        row_sum += mat [ n // 2 ] [ i ]\n    print ( (\"Sum of middle \" + \"row = \") , row_sum )\n    for i in range ( n ) :\n        col_sum += mat [ i ] [ n // 2 ]\n    print ( (\"Sum\" + \" of middle column = \") , col_sum )", "id": "StringUnfoldding_sample_from_SUM_MIDDLE_ROW_COLUMN_MATRIX_to_75", "old_id": "SUM_MIDDLE_ROW_COLUMN_MATRIX"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    for i in range ( n ) :\n        if ( tree [ i ] == ('' + '(') ) :\n            level += 1\n        elif ( tree [ i ] == (')' + '') ) :\n            level -= 1\n        else :\n            if ( level == k ) :\n                sum += ( ord ( tree [ i ] ) - ord ( ('' + '0') ) )\n    return sum", "id": "StringUnfoldding_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_76", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def sumOfSubstrings ( num ) :\n    n = len ( num )\n    sumofdigit = [ ]\n    sumofdigit.append ( ord ( num [ 0 ] ) - ord(('0' + '')) )\n    res = sumofdigit [ 0 ]\n    for i in range ( 1 , n ) :\n        numi = ord ( num [ i ] ) - ord ( ('' + '0') )\n        sumofdigit.append ( ( i + 1 ) + numi + 10 + sumofdigit [ i - 1 ] )\n        res += sumofdigit [ i ]\n    return res", "id": "StringUnfoldding_sample_from_SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER_to_77", "old_id": "SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = (\"\" + \"\")\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    for i in range(n1):\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = int(sum / 10)\n    for i in range(n1, n2):\n        sum = ((ord(str2[i]) - 48) + carry)\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n    if (carry):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "StringUnfoldding_sample_from_SUM_TWO_LARGE_NUMBERS_to_78", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( (\" Invalid Inpu\" + \"t \") )\n        return\n    first = arr [ 0 ]\n    for i in range ( 1 , arr_size ) :\n        if ( arr [ i ] > first ) :\n            first = arr [ i ]\n    second = - sys.maxsize\n    for i in range ( 0 , arr_size ) :\n        if ( arr [ i ] > second and arr [ i ] < first ) :\n            second = arr [ i ]\n    third = - sys.maxsize\n    for i in range ( 0 , arr_size ) :\n        if ( arr [ i ] > third and arr [ i ] < second ) :\n            third = arr [ i ]\n    print ( (\"\" + \"The Third Largest\") , (\"ele\" + \"ment is\") , third )", "id": "StringUnfoldding_sample_from_THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_to_79", "old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS"}
{"code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( (\"\" + \" Invalid Input \") )\n        return\n    first = arr [ 0 ]\n    second = - sys.maxsize\n    third = - sys.maxsize\n    for i in range ( 1 , arr_size ) :\n        if ( arr [ i ] > first ) :\n            third = second\n            second = first\n            first = arr [ i ]\n        elif ( arr [ i ] > second ) :\n            third = second\n            second = arr [ i ]\n        elif ( arr [ i ] > third ) :\n            third = arr [ i ]\n    print ( (\"The\" + \" third Largest\") , (\"\" + \"element is\") , third )", "id": "StringUnfoldding_sample_from_THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1_to_80", "old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1"}
{"code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    for i in range ( 0 , n , 1 ) :\n        if ( str [ i ] == ('' + '1') ) :\n            one_count += 1\n        else :\n            zero_count += 1\n    if ( one_count % 2 == 0 ) :\n        return zero_count\n    return one_count", "id": "StringUnfoldding_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_81", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
