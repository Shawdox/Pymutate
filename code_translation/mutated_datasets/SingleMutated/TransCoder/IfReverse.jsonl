{"code": "def winner ( a , n , k ) :\n    if k >= n - 1 :\n        return n\n    best = 0\n    times = 0\n    for i in range ( n ) :\n        if not a [ i ] > best:\n            times += 1\n        else:\n            best = a [ i ]\n            if i == True :\n                times = 1\n        if times >= k :\n            return best\n    return best", "id": "IfReverse_sample_from_ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES_to_0", "old_id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES"}
{"code": "def solveQuery ( start , end , arr ) :\n    frequency = dict ( )\n    for i in range ( start , end + 1 ) :\n        if not arr [ i ] in frequency.keys ( ):\n            frequency [ arr [ i ] ] = 1\n        else:\n            frequency [ arr [ i ] ] += 1\n    count = 0\n    for x in frequency :\n        if x == frequency [ x ] :\n            count += 1\n    return count", "id": "IfReverse_sample_from_ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE_to_1", "old_id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE"}
{"code": "def binarySearch ( arr , l , r , x ) :\n    if not r >= l:\n        return - 1\n    else:\n        mid = l + ( r - l ) // 2\n        if arr [ mid ] == x :\n            return mid\n        elif arr [ mid ] > x :\n            return binarySearch ( arr , l , mid - 1 , x )\n        else :\n            return binarySearch ( arr , mid + 1 , r , x )", "id": "IfReverse_sample_from_BINARY_SEARCH_to_2", "old_id": "BINARY_SEARCH"}
{"code": "def encrypt ( text , s ) :\n    result = \"\"\n    for i in range ( len ( text ) ) :\n        char = text [ i ]\n        if not ( char.isupper ( ) ):\n            result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n        else:\n            result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n    return result", "id": "IfReverse_sample_from_CAESAR_CIPHER_to_3", "old_id": "CAESAR_CIPHER"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    for i in range ( 1 , len ( str ) ) :\n        if not ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ):\n            res += ord ( str [ i ] ) - 48\n        else:\n            res += ord ( str [ i ] ) - 48\n    return res", "id": "IfReverse_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_4", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = \"0\"\n    Sum = 0\n    for ch in str :\n        if not ( ch.isdigit ( ) ):\n            Sum += int ( temp )\n            temp = \"0\"\n        else:\n            temp += ch\n    return Sum + int ( temp )", "id": "IfReverse_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_5", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def ceilSearch ( arr , low , high , x ) :\n    if x <= arr [ low ] :\n        return low\n    if x > arr [ high ] :\n        return - 1\n    mid = ( low + high ) / 2\n    if not arr [ mid ] == x:\n        if arr [ mid ] < x :\n            if mid + 1 <= high and x <= arr [ mid + 1 ] :\n                return mid + 1\n            else :\n                return ceilSearch ( arr , mid + 1 , high , x )\n        else :\n            if mid - 1 >= low and x > arr [ mid - 1 ] :\n                return mid\n            else :\n                return ceilSearch ( arr , low , mid - 1 , x )\n    else:\n        return mid", "id": "IfReverse_sample_from_CEILING_IN_A_SORTED_ARRAY_1_to_6", "old_id": "CEILING_IN_A_SORTED_ARRAY_1"}
{"code": "def HalfDiagonalSums ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    i = 0\n    j = n - 1\n    while i < n :\n        if not ( i < n // 2 ):\n            if ( i > n // 2 ) :\n                diag1_right += mat [ i ] [ i ]\n                diag2_right += mat [ j ] [ i ]\n        else:\n            diag1_left += mat [ i ] [ i ]\n            diag2_left += mat [ j ] [ i ]\n        i += 1\n        j -= 1\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )", "id": "IfReverse_sample_from_CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS_to_7", "old_id": "CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS"}
{"code": "def canMakeAllSame ( str ) :\n    zeros = 0\n    ones = 0\n    for i in range ( 0 , len ( str ) ) :\n        ch = str [ i ]\n        if not ( ch == '0' ):\n            ones = ones + 1\n        else:\n            zeros = zeros + 1\n    return ( zeros == 1 or ones == 1 )", "id": "IfReverse_sample_from_CHANGE_BITS_CAN_MADE_ONE_FLIP_to_8", "old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP"}
{"code": "def isMajority ( a, n ) :\n    mp = { }\n    for i in range(n) :\n        if not a[i] in mp: mp [ a[i] ] = 1\n        else: mp [ a[i] ] += 1\n    for x in mp :\n        if mp [ x ] >= len ( a ) // 2 :\n            return True\n    return False", "id": "IfReverse_sample_from_CHECK_ARRAY_MAJORITY_ELEMENT_to_9", "old_id": "CHECK_ARRAY_MAJORITY_ELEMENT"}
{"code": "def flipsPossible ( a , n ) :\n    count_odd = 0\n    count_even = 0\n    for i in range ( n ) :\n        if not ( a [ i ] & 1 ):\n            count_even += 1\n        else:\n            count_odd += 1\n    if not ( count_odd % 2 and count_even % 2 ):\n        return True\n    else:\n        return False", "id": "IfReverse_sample_from_CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS_to_10", "old_id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS"}
{"code": "def isChangeable ( notes , n ) :\n    fiveCount = 0\n    tenCount = 0\n    for i in range ( n ) :\n        if not ( notes [ i ] == 5 ):\n            if ( notes [ i ] == 10 ) :\n                if ( fiveCount > 0 ) :\n                    fiveCount -= 1\n                    tenCount += 1\n                else :\n                    return 0\n            else :\n                if ( fiveCount > 0 and tenCount > 0 ) :\n                    fiveCount -= 1\n                    tenCount -= 1\n                elif ( fiveCount >= 3 ) :\n                    fiveCount -= 3\n                else :\n                    return 0\n        else:\n            fiveCount += 1\n    return 1", "id": "IfReverse_sample_from_CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE_to_11", "old_id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE"}
{"code": "def isOverflow ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return False\n    result = a * b\n    if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) :\n        result = 0\n    if not ( a == ( result // b ) ):\n        return True\n    else:\n        return False", "id": "IfReverse_sample_from_CHECK_INTEGER_OVERFLOW_MULTIPLICATION_to_12", "old_id": "CHECK_INTEGER_OVERFLOW_MULTIPLICATION"}
{"code": "def check ( str ) :\n    n = len ( str )\n    oddDigSum = 0\n    evenDigSum = 0\n    for i in range ( 0 , n ) :\n        if not ( i % 2 == 0 ):\n            evenDigSum = evenDigSum + ( ord ( str [ i ] ) - 48 )\n        else:\n            oddDigSum = oddDigSum + ( ord ( str [ i ] ) - 48 )\n    return ( ( oddDigSum - evenDigSum ) % 11 == 0 )", "id": "IfReverse_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT_to_13", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if not ( length % 3 == 1 ):\n        if ( length % 3 == 2 ) :\n            num = str ( num ) + \"0\"\n            length += 1\n    else:\n        num = str ( num ) + \"00\"\n        length += 2\n    sum = 0\n    p = 1\n    for i in range ( length - 1 , - 1 , - 3 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "IfReverse_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_14", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def checkReverse ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    for i in range ( 1 , n ) :\n        if not arr [ i - 1 ] >= arr [ i ]:\n            if ( i == n ) :\n                return True\n        else:\n            break\n    j = i\n    i += 1\n    while ( arr [ j ] < arr [ j - 1 ] ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j += 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k += 1\n    return True", "id": "IfReverse_sample_from_CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1_to_15", "old_id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1"}
{"code": "def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :\n    distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 )\n    radSumSq = ( r1 + r2 ) * ( r1 + r2 )\n    if not ( distSq == radSumSq ):\n        if ( distSq > radSumSq ) :\n            return - 1\n        else :\n            return 0\n    else:\n        return 1", "id": "IfReverse_sample_from_CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT_to_16", "old_id": "CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT"}
{"code": "def check ( degree , n ) :\n    deg_sum = 0\n    for i in range(n):\n        deg_sum += degree[i]\n    if not ( 2 * ( n - 1 ) == deg_sum ):\n        return False\n    else:\n        return True", "id": "IfReverse_sample_from_CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE_to_17", "old_id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if not ( n % 3 == 1 ):\n        if ( n % 3 == 2 ) :\n            num = str ( num ) + \"0\"\n            n += 1\n    else:\n        num = str ( num ) + \"00\"\n        n += 2\n    GSum = 0\n    p = 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n    return ( GSum % 7 == 0 )", "id": "IfReverse_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_18", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def checkValidity ( a , b , c ) :\n    if not ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ):\n        return True\n    else:\n        return False", "id": "IfReverse_sample_from_CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN_to_19", "old_id": "CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN"}
{"code": "def constructPalin ( str , len ) :\n    str = list ( str )\n    i = - 1\n    j = len\n    while i < j :\n        i += 1\n        j -= 1\n        if not ( str [ i ] == str [ j ] and str [ i ] != '*' ):\n            if ( str [ i ] == str [ j ] and str [ i ] == '*' ) :\n                str [ i ] = 'a'\n                str [ j ] = 'a'\n                continue\n            elif str [ i ] == '*' :\n                str [ i ] = str [ j ]\n                continue\n            elif str [ j ] == '*' :\n                str [ j ] = str [ i ]\n                continue\n        else:\n            continue\n        print ( \"Not Possible\" )\n        return \"\"\n    return ''.join ( str )", "id": "IfReverse_sample_from_CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME_to_20", "old_id": "CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME"}
{"code": "def decimalToBinary ( num , k_prec ) :\n    binary = \"\"\n    Integral = int ( num )\n    fractional = num - Integral\n    while ( Integral > 0 ) :\n        rem = Integral % 2\n        binary += str ( rem )\n        Integral //= 2\n    binary = binary [ : : - 1 ]\n    binary += '.'\n    while ( k_prec > 0 ) :\n        fractional *= 2\n        fract_bit = int ( fractional )\n        if not ( fract_bit == 1 ):\n            binary += '0'\n        else:\n            fractional -= fract_bit\n            binary += '1'\n        k_prec -= 1\n    return binary", "id": "IfReverse_sample_from_CONVERT_DECIMAL_FRACTION_BINARY_NUMBER_to_21", "old_id": "CONVERT_DECIMAL_FRACTION_BINARY_NUMBER"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( k + 1 ) :\n            if not j >= i:\n                dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n            else:\n                break\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]", "id": "IfReverse_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_22", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def findSubsequenceCount ( S , T ) :\n    m = len ( T )\n    n = len ( S )\n    if m > n :\n        return 0\n    mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ]\n    for i in range ( 1 , m + 1 ) :\n        mat [ i ] [ 0 ] = 0\n    for j in range ( n + 1 ) :\n        mat [ 0 ] [ j ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if not T [ i - 1 ] != S [ j - 1 ]:\n                mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] )\n            else:\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]\n    return mat [ m ] [ n ]", "id": "IfReverse_sample_from_COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE_to_23", "old_id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE"}
{"code": "def find ( n , k ) :\n    if not ( n + 1 >= k ):\n        return ( 2 * n + 1 - k )\n    else:\n        return ( k - 1 )", "id": "IfReverse_sample_from_COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ_to_24", "old_id": "COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ"}
{"code": "def countPairs ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        if not arr [ i ] in mp.keys ( ):\n            mp [ arr [ i ] ] = 1\n        else:\n            mp [ arr [ i ] ] += 1\n    ans = 0\n    for it in mp :\n        count = mp [ it ]\n        ans += ( count * ( count - 1 ) ) // 2\n    return ans", "id": "IfReverse_sample_from_COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1_to_25", "old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1"}
{"code": "def countNegative ( M , n , m ) :\n    count = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if not M [ i ] [ j ] < 0:\n                break\n            else:\n                count += 1\n    return count", "id": "IfReverse_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_to_26", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX"}
{"code": "def countNegative ( M , n , m ) :\n    count = 0\n    i = 0\n    j = m - 1\n    while j >= 0 and i < n :\n        if not M [ i ] [ j ] < 0:\n            j -= 1\n        else:\n            count += ( j + 1 )\n            i += 1\n    return count", "id": "IfReverse_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1_to_27", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1"}
{"code": "def countP ( n , k ) :\n    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        dp [ i ] [ 0 ] = 0\n    for i in range ( k + 1 ) :\n        dp [ 0 ] [ k ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , k + 1 ) :\n            if not ( j == 1 or i == j ):\n                dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] )\n            else:\n                dp [ i ] [ j ] = 1\n    return dp [ n ] [ k ]", "id": "IfReverse_sample_from_COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1_to_28", "old_id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1"}
{"code": "def countWays ( n , m ) :\n    count = [ ]\n    for i in range ( n + 2 ) :\n        count.append ( 0 )\n    count [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        if not ( i > m ):\n            if ( i < m ) :\n                count [ i ] = 1\n            else :\n                count [ i ] = 2\n        else:\n            count [ i ] = count [ i - 1 ] + count [ i - m ]\n    return count [ n ]", "id": "IfReverse_sample_from_COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES_to_29", "old_id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    for i in range ( n ) :\n        if not ( str [ i ] == 'a' ):\n            if ( str [ i ] == 'b' ) :\n                b_index = i + 1\n                ans -= min ( a_index , c_index )\n            else :\n                c_index = i + 1\n                ans -= min ( a_index , b_index )\n        else:\n            a_index = i + 1\n            ans -= min ( b_index , c_index )\n    return ans", "id": "IfReverse_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_30", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    for i in range ( len ( s ) ) :\n        if not s [ ~ i ] == 'a':\n            b_count += 1\n        else:\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n    return res", "id": "IfReverse_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_31", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def countPairsWithDiffK ( arr , n , k ) :\n    count = 0\n    arr.sort ( )\n    l = 0\n    r = 0\n    while r < n :\n        if not arr [ r ] - arr [ l ] == k:\n            if arr [ r ] - arr [ l ] > k :\n                l += 1\n            else :\n                r += 1\n        else:\n            count += 1\n            l += 1\n            r += 1\n    return count", "id": "IfReverse_sample_from_COUNT_PAIRS_DIFFERENCE_EQUAL_K_1_to_32", "old_id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K_1"}
{"code": "def CountPS ( str , n ) :\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n    for i in range ( n - 1 ) :\n        if ( str [ i ] == str [ i + 1 ] ) :\n            P [ i ] [ i + 1 ] = True\n            dp [ i ] [ i + 1 ] = 1\n    for gap in range ( 2 , n ) :\n        for i in range ( n - gap ) :\n            j = gap + i ;\n            if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) :\n                P [ i ] [ j ] = True\n            if not ( P [ i ] [ j ] == True ):\n                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] )\n            else:\n                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] )\n    return dp [ 0 ] [ n - 1 ]", "id": "IfReverse_sample_from_COUNT_PALINDROME_SUB_STRINGS_STRING_to_33", "old_id": "COUNT_PALINDROME_SUB_STRINGS_STRING"}
{"code": "def countSetBits ( n ) :\n    if not ( n == 0 ):\n        return ( n & 1 ) + countSetBits ( n >> 1 )\n    else:\n        return 0", "id": "IfReverse_sample_from_COUNT_SET_BITS_IN_AN_INTEGER_1_to_34", "old_id": "COUNT_SET_BITS_IN_AN_INTEGER_1"}
{"code": "def countSetBits ( n ) :\n    if not ( n == 0 ):\n        return 1 + countSetBits ( n & ( n - 1 ) )\n    else:\n        return 0", "id": "IfReverse_sample_from_COUNT_SET_BITS_IN_AN_INTEGER_3_to_35", "old_id": "COUNT_SET_BITS_IN_AN_INTEGER_3"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ] * ( n + 1 )\n    hash_negative = [ 0 ] * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    for i in range ( n ) :\n        if not ( arr [ i ] & 1 == 1 ):\n            difference = difference - 1\n        else:\n            difference = difference + 1\n        if not ( difference < 0 ):\n            ans += hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ] + 1\n        else:\n            ans += hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n    return ans", "id": "IfReverse_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_36", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1 << i\n        for j in range ( 0 , n + 1 ) :\n            ans += k\n            if not change == 1:\n                change -= 1\n            else:\n                k = not k\n                change = 1 << i\n        i += 1\n    return ans", "id": "IfReverse_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_37", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def countWords ( str , len ) :\n    count = 1 ;\n    if ( len == 1 ) :\n        return count\n    if not ( str [ 0 ] == str [ 1 ] ):\n        count *= 2\n    else:\n        count *= 1\n    for j in range ( 1 , len - 1 ) :\n        if not ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ):\n            if ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :\n                count *= 2\n            else :\n                count *= 3\n        else:\n            count *= 1\n    if not ( str [ len - 1 ] == str [ len - 2 ] ):\n        count *= 2\n    else:\n        count *= 1\n    return count", "id": "IfReverse_sample_from_COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD_to_38", "old_id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ] * NO_OF_CHARS\n    for i in range ( len ( str ) ) :\n        count [ ord ( str [ i ] ) ] += 1\n    first , second = 0 , 0\n    for i in range ( NO_OF_CHARS ) :\n        if not count [ i ] > count [ first ]:\n            if ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n                second = i\n        else:\n            second = first\n            first = i\n    return chr ( second )", "id": "IfReverse_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_39", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decToBin ( n ) :\n    if ( n == 0 ) :\n        return \"0\"\n    bin = \"\"\n    while ( n > 0 ) :\n        if not ( n & 1 == 0 ):\n            bin = '1' + bin\n        else:\n            bin = '0' + bin\n        n = n >> 1\n    return bin", "id": "IfReverse_sample_from_DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS_to_40", "old_id": "DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    for i in range ( len ( Str ) ) :\n        count = 0\n        if not ( Str [ i ] >= '0' and Str [ i ] <= '9' ):\n            if ( Str [ i ] == ']' ) :\n                temp = \"\"\n                count = 0\n                if ( len ( integerstack ) != 0 ) :\n                    count = integerstack [ - 1 ]\n                    integerstack.pop ( )\n                while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                    temp = stringstack [ - 1 ] + temp\n                    stringstack.pop ( )\n                if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                    stringstack.pop ( )\n                for j in range ( count ) :\n                    result = result + temp\n                for j in range ( len ( result ) ) :\n                    stringstack.append ( result [ j ] )\n                result = \"\"\n            elif ( Str [ i ] == '[' ) :\n                if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                    stringstack.append ( Str [ i ] )\n                else :\n                    stringstack.append ( Str [ i ] )\n                    integerstack.append ( 1 )\n            else :\n                stringstack.append ( Str [ i ] )\n        else:\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( '0' )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "IfReverse_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_41", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def findDiff ( arr , n ) :\n    arr.sort ( )\n    count = 0\n    max_count = 0\n    min_count = n\n    for i in range ( 0 , ( n - 1 ) ) :\n        if not arr [ i ] == arr [ i + 1 ]:\n            max_count = max ( max_count , count )\n            min_count = min ( min_count , count )\n            count = 0\n        else:\n            count += 1\n            continue\n    return max_count - min_count", "id": "IfReverse_sample_from_DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_to_42", "old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY"}
{"code": "def lastPosition ( n , m , k ) :\n    if ( m <= n - k + 1 ) :\n        return m + k - 1\n    m = m - ( n - k + 1 )\n    if not ( m % n == 0 ):\n        return m % n\n    else:\n        return n", "id": "IfReverse_sample_from_DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION_to_43", "old_id": "DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION"}
{"code": "def isDvisibleBy12 ( num ) :\n    if not ( len ( num ) >= 3 ):\n        number = int ( num )\n        return ( number % 12 == 0 )\n    else:\n        d1 = int ( num [ len ( num ) - 1 ] )\n        if ( d1 % 2 != 0 ) :\n            return False\n        d2 = int ( num [ len ( num ) - 2 ] )\n        sum = 0\n        for i in range ( 0 , len ( num ) ) :\n            sum += int ( num [ i ] )\n        return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )", "id": "IfReverse_sample_from_DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER_to_44", "old_id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER"}
{"code": "def doublefactorial ( n ) :\n    res = 1\n    for i in range ( n , - 1 , - 2 ) :\n        if not ( i == 0 or i == 1 ):\n            res *= i\n        else:\n            return res\n    return res;", "id": "IfReverse_sample_from_DOUBLE_FACTORIAL_1_to_45", "old_id": "DOUBLE_FACTORIAL_1"}
{"code": "def knapSack ( W , wt , val , n ) :\n    if n == 0 or W == 0 :\n        return 0\n    if not ( wt [ n - 1 ] > W ):\n        return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )\n    else:\n        return knapSack ( W , wt , val , n - 1 )", "id": "IfReverse_sample_from_DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_to_46", "old_id": "DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM"}
{"code": "def lps ( seq ) :\n    n = len ( seq )\n    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]\n    for i in range ( n ) :\n        L [ i ] [ i ] = 1\n    for cl in range ( 2 , n + 1 ) :\n        for i in range ( n - cl + 1 ) :\n            j = i + cl - 1\n            if not seq [ i ] == seq [ j ] and cl == 2:\n                if seq [ i ] == seq [ j ] :\n                    L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2\n                else :\n                    L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;\n            else:\n                L [ i ] [ j ] = 2\n    return L [ 0 ] [ n - 1 ]", "id": "IfReverse_sample_from_DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE_to_47", "old_id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE"}
{"code": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = 0\n    k = 0\n    L = 0\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = 0\n    for L in range ( 2 , n + 1 ) :\n        for i in range ( n - L + 1 ) :\n            j = i + L - 1\n            if not L == 2:\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )\n            else:\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            if not P [ i ] [ j ] == True:\n                C [ i ] [ j ] = 100000000\n                for k in range ( i , j ) :\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n            else:\n                C [ i ] [ j ] = 0\n    return C [ 0 ] [ n - 1 ]", "id": "IfReverse_sample_from_DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_to_48", "old_id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING"}
{"code": "def findMinInsertions ( str , l , h ) :\n    if ( l > h ) :\n        return sys.maxsize\n    if ( l == h ) :\n        return 0\n    if ( l == h - 1 ) :\n        return 0 if ( str [ l ] == str [ h ] ) else 1\n    if not ( str [ l ] == str [ h ] ):\n        return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )\n    else:\n        return findMinInsertions ( str , l + 1 , h - 1 )", "id": "IfReverse_sample_from_DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME_to_49", "old_id": "DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if not symb [ i ] == 'F':\n            F [ i ] [ i ] = 0\n        else:\n            F [ i ] [ i ] = 1\n        if not symb [ i ] == 'T':\n            T [ i ] [ i ] = 0\n        else:\n            T [ i ] [ i ] = 1\n    for gap in range ( 1 , n ) :\n        i = 0\n        for j in range ( gap , n ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n            i += 1\n    return T [ 0 ] [ n - 1 ]", "id": "IfReverse_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_50", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    for ch in string :\n        if not ch == ')':\n            Stack.append ( ch )\n        else:\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != '(' :\n                elementsInside += 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n    return False", "id": "IfReverse_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_51", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def computeLastDigit ( A , B ) :\n    variable = 1\n    if not ( A == B ):\n        if ( ( B - A ) >= 5 ) :\n            return 0\n        else :\n            for i in range ( A + 1 , B + 1 ) :\n                variable = ( variable * ( i % 10 ) ) % 10\n            return variable % 10\n    else:\n        return 1", "id": "IfReverse_sample_from_FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B_to_52", "old_id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B"}
{"code": "def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :\n    sum1 , sum2 , sum3 = 0 , 0 , 0\n    for i in range ( n1 ) :\n        sum1 += stack1 [ i ]\n    for i in range ( n2 ) :\n        sum2 += stack2 [ i ]\n    for i in range ( n3 ) :\n        sum3 += stack3 [ i ]\n    top1 , top2 , top3 = 0 , 0 , 0\n    ans = 0\n    while ( 1 ) :\n        if ( top1 == n1 or top2 == n2 or top3 == n3 ) :\n            return 0\n        if ( sum1 == sum2 and sum2 == sum3 ) :\n            return sum1\n        if not ( sum1 >= sum2 and sum1 >= sum3 ):\n            if ( sum2 >= sum3 and sum2 >= sum3 ) :\n                sum2 -= stack2 [ top2 ]\n                top2 = top2 + 1\n            elif ( sum3 >= sum2 and sum3 >= sum1 ) :\n                sum3 -= stack3 [ top3 ]\n                top3 = top3 + 1\n        else:\n            sum1 -= stack1 [ top1 ]\n            top1 = top1 + 1", "id": "IfReverse_sample_from_FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS_to_53", "old_id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize - 1\n    for i in range ( r ) :\n        if m [ i ] [ 0 ] < mi :\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx :\n            mx = m [ i ] [ c - 1 ]\n    desired = ( r * c + 1 ) // 2\n    while ( mi < mx ) :\n        mid = mi + ( mx - mi ) // 2\n        place = [ 0 ]\n        for i in range ( r ) :\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ] + j\n        if not place [ 0 ] < desired:\n            mx = mid\n        else:\n            mi = mid + 1\n    print ( \"Median is\" , mi )\n    return mi", "id": "IfReverse_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_54", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def count ( a , b ) :\n    m = len ( a )\n    n = len ( b )\n    lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]\n    for i in range ( n + 1 ) :\n        lookup [ 0 ] [ i ] = 0\n    for i in range ( m + 1 ) :\n        lookup [ i ] [ 0 ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if not a [ i - 1 ] == b [ j - 1 ]:\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]\n            else:\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ]\n    return lookup [ m ] [ n ]", "id": "IfReverse_sample_from_FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1_to_55", "old_id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1"}
{"code": "def findSDSFunc ( n ) :\n    DP = [ 0 ] * ( n + 1 )\n    DP [ 0 ] = 0\n    DP [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        if not ( int ( i % 2 ) == 0 ):\n            DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] )\n        else:\n            DP [ i ] = DP [ int ( i / 2 ) ]\n    return DP [ n ]", "id": "IfReverse_sample_from_FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES_to_56", "old_id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES"}
{"code": "def pairSum ( mat , n , sum ) :\n    for i in range ( n ) :\n        mat [ i ].sort ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if not ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ):\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1\n                else:\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left += 1\n                    right -= 1", "id": "IfReverse_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_57", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def evenSum ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if not j == 0 or j == i:\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n            else:\n                C [ i ] [ j ] = 1\n    sum = 0 ;\n    for i in range ( 0 , n + 1 ) :\n        if i % 2 == 0 :\n            sum = sum + C [ n ] [ i ]\n    return sum", "id": "IfReverse_sample_from_FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_to_58", "old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    for i in range ( n - 1 ) :\n        s = set ( )\n        for j in range ( i + 1 , n ) :\n            x = - ( arr [ i ] + arr [ j ] )\n            if not x in s:\n                s.add ( arr [ j ] )\n            else:\n                print ( x , arr [ i ] , arr [ j ] )\n                found = True\n    if found == False :\n        print ( \"No Triplet Found\" )", "id": "IfReverse_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1_to_59", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    for i in range ( 0 , n - 1 ) :\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if not ( x + arr [ l ] + arr [ r ] == 0 ):\n                if ( x + arr [ l ] + arr [ r ] < 0 ) :\n                    l += 1\n                else :\n                    r -= 1\n            else:\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n    if ( found == False ) :\n        print ( \" No Triplet Found\" )", "id": "IfReverse_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_60", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def firstElement ( arr , n , k ) :\n    count_map = { }\n    for i in range ( 0 , n ) :\n        if not ( arr [ i ] in count_map.keys ( ) ):\n            count_map [ arr [ i ] ] = 1\n        else:\n            count_map [ arr [ i ] ] += 1\n        i += 1\n    for i in range ( 0 , n ) :\n        if ( count_map [ arr [ i ] ] == k ) :\n            return arr [ i ]\n        i += 1\n    return - 1", "id": "IfReverse_sample_from_FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY_to_61", "old_id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY"}
{"code": "def mostFrequent ( arr , n ) :\n    Hash = dict ( )\n    for i in range ( n ) :\n        if not arr [ i ] in Hash.keys ( ):\n            Hash [ arr [ i ] ] = 1\n        else:\n            Hash [ arr [ i ] ] += 1\n    max_count = 0\n    res = - 1\n    for i in Hash :\n        if ( max_count < Hash [ i ] ) :\n            res = i\n            max_count = Hash [ i ]\n    return res", "id": "IfReverse_sample_from_FREQUENT_ELEMENT_ARRAY_1_to_62", "old_id": "FREQUENT_ELEMENT_ARRAY_1"}
{"code": "def countFriendsPairings ( n ) :\n    dp = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        if not ( i <= 2 ):\n            dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]\n        else:\n            dp [ i ] = i\n    return dp [ n ]", "id": "IfReverse_sample_from_FRIENDS_PAIRING_PROBLEM_to_63", "old_id": "FRIENDS_PAIRING_PROBLEM"}
{"code": "def isSubSeqDivisible ( str ) :\n    l = len ( str )\n    arr = [ 0 ] * l\n    for i in range ( 0 , l ) :\n        for j in range ( i , l ) :\n            for k in range ( j , l ) :\n                if not ( arr [ i ] % 8 == 0 ):\n                    if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :\n                        return True\n                    elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :\n                        return True\n                else:\n                    return True\n    return False", "id": "IfReverse_sample_from_GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_to_64", "old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8"}
{"code": "def gnomeSort ( arr , n ) :\n    index = 0\n    while index < n :\n        if index == 0 :\n            index = index + 1\n        if not arr [ index ] >= arr [ index - 1 ]:\n            arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ]\n            index = index - 1\n        else:\n            index = index + 1\n    return arr", "id": "IfReverse_sample_from_GNOME_SORT_A_STUPID_ONE_to_65", "old_id": "GNOME_SORT_A_STUPID_ONE"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0\n    for i in range ( 1 , m + 1 ) :\n        if not ( nxtbb < n ):\n            maxRev [ i ] = maxRev [ i - 1 ]\n        else:\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb += 1\n    return maxRev [ m ]", "id": "IfReverse_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_66", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    for i in arr :\n        if not ( i < 0 ):\n            hash [ i ] = hash.get ( i , 0 ) + 1\n        else:\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] -= 1\n    for i in arr :\n        if i in hash.keys ( ) and hash [ i ] > 0 :\n            return i\n    return - 1", "id": "IfReverse_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_67", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def kth ( arr1 , arr2 , m , n , k ) :\n    sorted1 = [ 0 ] * ( m + n )\n    i = 0\n    j = 0\n    d = 0\n    while ( i < m and j < n ) :\n        if not ( arr1 [ i ] < arr2 [ j ] ):\n            sorted1 [ d ] = arr2 [ j ]\n            j += 1\n        else:\n            sorted1 [ d ] = arr1 [ i ]\n            i += 1\n        d += 1\n    while ( i < m ) :\n        sorted1 [ d ] = arr1 [ i ]\n        d += 1\n        i += 1\n    while ( j < n ) :\n        sorted1 [ d ] = arr2 [ j ]\n        d += 1\n        j += 1\n    return sorted1 [ k - 1 ]", "id": "IfReverse_sample_from_K_TH_ELEMENT_TWO_SORTED_ARRAYS_to_68", "old_id": "K_TH_ELEMENT_TWO_SORTED_ARRAYS"}
{"code": "def kthLargestSum ( arr , n , k ) :\n    sum = [ ]\n    sum.append ( 0 )\n    sum.append ( arr [ 0 ] )\n    for i in range ( 2 , n + 1 ) :\n        sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )\n    Q = [ ]\n    heapq.heapify ( Q )\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( i , n + 1 ) :\n            x = sum [ j ] - sum [ i - 1 ]\n            if not len ( Q ) < k:\n                if Q [ 0 ] < x :\n                    heapq.heappop ( Q )\n                    heapq.heappush ( Q , x )\n            else:\n                heapq.heappush ( Q , x )\n    return Q [ 0 ]", "id": "IfReverse_sample_from_K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY_to_69", "old_id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY"}
{"code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    for i in range ( 0 , n - 1 ) :\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        for j in range ( i + 1 , n ) :\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) :\n                maxsize = j - i + 1\n                startindex = i\n    if not ( maxsize == - 1 ):\n        print ( startindex , \"to\" , startindex + maxsize - 1 )\n    else:\n        print ( \"No such subarray\" )\n    return maxsize", "id": "IfReverse_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_70", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    for i in range ( 0 , n ) :\n        if not ( arr [ i ] == 0 ):\n            arr [ i ] = 1\n        else:\n            arr [ i ] = - 1\n    for i in range ( 0 , n ) :\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) :\n            max_len = i + 1\n            ending_index = i\n        if not ( curr_sum + n ) in hash_map:\n            hash_map[curr_sum + n] = i\n        else:\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i - hash_map [ curr_sum + n ]\n                ending_index = i\n    for i in range ( 0 , n ) :\n        if not ( arr [ i ] == - 1 ):\n            arr [ i ] = 1\n        else:\n            arr [ i ] = 0\n    print ( ending_index - max_len + 1 , end = \" \" )\n    print ( \"to\" , end = \" \" )\n    print ( ending_index )\n    return max_len", "id": "IfReverse_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_71", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    for i in range ( n ) :\n        if not ( s [ i ] == '(' ):\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces += 1\n            else :\n                invalidOpenBraces -= 1\n        else:\n            invalidOpenBraces += 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "IfReverse_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_72", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if not ( set [ i ] + set [ k ] < 2 * set [ j ] ):\n                if ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                    L [ i ] [ j ] = 2\n                    i -= 1\n                else :\n                    L [ i ] [ j ] = L [ j ] [ k ] + 1\n                    llap = max ( llap , L [ i ] [ j ] )\n                    i -= 1\n                    k += 1\n            else:\n                k += 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i -= 1\n    return llap", "id": "IfReverse_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_73", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def nextWord ( s ) :\n    if ( s == \" \" ) :\n        return \"a\"\n    i = len ( s ) - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if not ( i == - 1 ):\n        s = s [ 0 : i ] + chr ( ord ( s [ i ] ) + 1 ) + s [ i + 1 : ]\n    else:\n        s = s + 'a'\n    return s", "id": "IfReverse_sample_from_LEXICOGRAPHICALLY_NEXT_STRING_to_74", "old_id": "LEXICOGRAPHICALLY_NEXT_STRING"}
{"code": "def LCSubStr ( X , Y , m , n ) :\n    LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ]\n    result = 0\n    for i in range ( m + 1 ) :\n        for j in range ( n + 1 ) :\n            if not ( i == 0 or j == 0 ):\n                if ( X [ i - 1 ] == Y [ j - 1 ] ) :\n                    LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1\n                    result = max ( result , LCSuff [ i ] [ j ] )\n                else :\n                    LCSuff [ i ] [ j ] = 0\n            else:\n                LCSuff [ i ] [ j ] = 0\n    return result", "id": "IfReverse_sample_from_LONGEST_COMMON_SUBSTRING_to_75", "old_id": "LONGEST_COMMON_SUBSTRING"}
{"code": "def longestPrefixSuffix ( s ) :\n    n = len ( s )\n    lps = [ 0 ] * n\n    l = 0\n    i = 1\n    while ( i < n ) :\n        if not ( s [ i ] == s [ l ] ):\n            if ( l != 0 ) :\n                l = lps [ l - 1 ]\n            else :\n                lps [ i ] = 0\n                i = i + 1\n        else:\n            l = l + 1\n            lps [ i ] = l\n            i = i + 1\n    res = lps [ n - 1 ]\n    if not ( res > n / 2 ):\n        return res\n    else:\n        return n // 2", "id": "IfReverse_sample_from_LONGEST_PREFIX_ALSO_SUFFIX_1_to_76", "old_id": "LONGEST_PREFIX_ALSO_SUFFIX_1"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if not ( str [ i - 1 ] == str [ j - 1 ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            else:\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if not ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ):\n            if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n                i -= 1\n            else :\n                j -= 1\n        else:\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "IfReverse_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_77", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def findLongestRepeatingSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 )\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if not ( str [ i - 1 ] == str [ j - 1 ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            else:\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n    return dp [ n ] [ n ]", "id": "IfReverse_sample_from_LONGEST_REPEATING_SUBSEQUENCE_to_78", "old_id": "LONGEST_REPEATING_SUBSEQUENCE"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if not arr [ i ] == 0:\n            sum += 1\n        else:\n            sum += - 1\n        if not ( sum == 1 ):\n            if ( sum not in um ) :\n                um [ sum ] = i\n        else:\n            maxLen = i + 1\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n    return maxLen", "id": "IfReverse_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_79", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    for i in range ( n ) :\n        curr_sum += arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k\n    for i in range ( n ) :\n        if not ( mod_arr [ i ] == 0 ):\n            if ( mod_arr [ i ] in um ) :\n                um [ mod_arr [ i ] ] = i\n            else :\n                if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                    max = i - um [ mod_arr [ i ] ]\n        else:\n            max = i + 1\n    return max", "id": "IfReverse_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_80", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def findMaxVal ( arr , n , num , maxLimit ) :\n    ind = - 1\n    val = - 1\n    dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ]\n    for ind in range ( n ) :\n        for val in range ( maxLimit + 1 ) :\n            if not ( ind == 0 ):\n                if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) :\n                    if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) :\n                        dp [ ind ] [ val ] = 1\n                elif ( val - arr [ ind ] >= 0 ) :\n                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ]\n                elif ( val + arr [ ind ] <= maxLimit ) :\n                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ]\n                else :\n                    dp [ ind ] [ val ] = 0\n            else:\n                if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) :\n                    dp [ ind ] [ val ] = 1\n                else :\n                    dp [ ind ] [ val ] = 0\n    for val in range ( maxLimit , - 1 , - 1 ) :\n        if ( dp [ n - 1 ] [ val ] == 1 ) :\n            return val\n    return - 1", "id": "IfReverse_sample_from_MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER_to_81", "old_id": "MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER"}
{"code": "def maxcoefficientvalue ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , n ) + 1 ) :\n            if not ( j == 0 or j == i ):\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )\n            else:\n                C [ i ] [ j ] = 1\n    maxvalue = 0\n    for i in range ( n + 1 ) :\n        maxvalue = max ( maxvalue , C [ n ] [ i ] )\n    return maxvalue", "id": "IfReverse_sample_from_MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE_to_82", "old_id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE"}
{"code": "def maxRepeating ( str ) :\n    n = len ( str )\n    count = 0\n    res = str [ 0 ]\n    cur_count = 1\n    for i in range ( n ) :\n        if not ( i < n - 1 and str [ i ] == str [ i + 1 ] ):\n            if cur_count > count :\n                count = cur_count\n                res = str [ i ]\n            cur_count = 1\n        else:\n            cur_count += 1\n    return res", "id": "IfReverse_sample_from_MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1_to_83", "old_id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1"}
{"code": "def maxdiff ( arr , n ) :\n    freq = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        freq [ arr [ i ] ] += 1\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            if not freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ]:\n                if freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :\n                    ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )\n            else:\n                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )\n    return ans", "id": "IfReverse_sample_from_MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER_to_84", "old_id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER"}
{"code": "def maxDistance ( arr , n ) :\n    mp = { }\n    maxDict = 0\n    for i in range ( n ) :\n        if not arr [ i ] not in mp.keys ( ):\n            maxDict = max ( maxDict , i - mp [ arr [ i ] ] )\n        else:\n            mp [ arr [ i ] ] = i\n    return maxDict", "id": "IfReverse_sample_from_MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY_to_85", "old_id": "MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY"}
{"code": "def maxNumOfChocolates ( arr , n , k ) :\n    um , curr_rem , maxSum = { } , 0 , 0\n    sm = [ 0 ] * n\n    sm [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        sm [ i ] = sm [ i - 1 ] + arr [ i ]\n    for i in range ( n ) :\n        curr_rem = sm [ i ] % k\n        if not ( not curr_rem and maxSum < sm [ i ] ):\n            if ( not curr_rem in um ) :\n                um [ curr_rem ] = i\n            elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :\n                maxSum = sm [ i ] - sm [ um [ curr_rem ] ]\n        else:\n            maxSum = sm [ i ]\n    return maxSum // k", "id": "IfReverse_sample_from_MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS_to_86", "old_id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS"}
{"code": "def maxDiff ( arr , n ) :\n    result = 0\n    arr.sort ( )\n    i = 0\n    while i < n-1:\n        if not ( arr [ i ] !=  arr [ i + 1 ] ):\n            i += 1\n        else:\n            result += abs ( arr [ i ] )\n        i += 1\n    if ( arr [ n - 2 ] != arr [ n - 1 ] ) :\n        result += abs ( arr [ n - 1 ] )\n    return result", "id": "IfReverse_sample_from_MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1_to_87", "old_id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1"}
{"code": "def maxAlternateSum ( arr , n ) :\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    dec = [ 0 for i in range ( n + 1 ) ]\n    inc = [ 0 for i in range ( n + 1 ) ]\n    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]\n    flag = 0\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if not ( arr [ j ] > arr [ i ] ):\n                if ( arr [ j ] < arr [ i ] and flag == 1 ) :\n                    inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n            else:\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = 1\n    result = - 2147483648\n    for i in range ( n ) :\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n    return result", "id": "IfReverse_sample_from_MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM_to_88", "old_id": "MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM"}
{"code": "def maxSumBitonicSubArr ( arr , n ) :\n    msis = [ None ] * n\n    msds = [ None ] * n\n    max_sum = 0\n    msis [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if not ( arr [ i ] > arr [ i - 1 ] ):\n            msis [ i ] = arr [ i ]\n        else:\n            msis [ i ] = msis [ i - 1 ] + arr [ i ]\n    msds [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if not ( arr [ i ] > arr [ i + 1 ] ):\n            msds [ i ] = arr [ i ]\n        else:\n            msds [ i ] = msds [ i + 1 ] + arr [ i ]\n    for i in range ( n ) :\n        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :\n            max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] )\n    return max_sum", "id": "IfReverse_sample_from_MAXIMUM_SUM_BITONIC_SUBARRAY_to_89", "old_id": "MAXIMUM_SUM_BITONIC_SUBARRAY"}
{"code": "def maxSum ( arr , N , k ) :\n    MS = [ 0 for i in range ( N ) ]\n    MS [ N - 1 ] = arr [ N - 1 ]\n    for i in range ( N - 2 , - 1 , - 1 ) :\n        if not ( i + k + 1 >= N ):\n            MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] )\n        else:\n            MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] )\n    return MS [ 0 ]", "id": "IfReverse_sample_from_MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS_to_90", "old_id": "MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS"}
{"code": "def getMedian ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count += 1\n        if not i == n:\n            if j == n :\n                m1 = m2\n                m2 = ar1 [ 0 ]\n                break\n        else:\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        if not ar1 [ i ] < ar2 [ j ]:\n            m1 = m2\n            m2 = ar2 [ j ]\n            j += 1\n        else:\n            m1 = m2\n            m2 = ar1 [ i ]\n            i += 1\n    return int(( m1 + m2 ) / 2)", "id": "IfReverse_sample_from_MEDIAN_OF_TWO_SORTED_ARRAYS_to_91", "old_id": "MEDIAN_OF_TWO_SORTED_ARRAYS"}
{"code": "def middleOfThree ( a , b , c ) :\n    if ( ( a < b and b < c ) or ( c < b and b < a ) ) :\n        return b\n    if not ( ( b < a and a < c ) or ( c < a and a < b ) ):\n        return c\n    else:\n        return a", "id": "IfReverse_sample_from_MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_to_92", "old_id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS"}
{"code": "def middleOfThree ( a , b , c ) :\n    if not a > b:\n        if ( a > c ) :\n            return a\n        elif ( b > c ) :\n            return c\n        else :\n            return b\n    else:\n        if ( b > c ) :\n            return b\n        elif ( a > c ) :\n            return c\n        else :\n            return a", "id": "IfReverse_sample_from_MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1_to_93", "old_id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1"}
{"code": "def middleOfThree ( a , b , c ) :\n    x = a - b\n    y = b - c\n    z = a - c\n    if not x * y > 0:\n        if ( x * z > 0 ) :\n            return c\n        else :\n            return a\n    else:\n        return b", "id": "IfReverse_sample_from_MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2_to_94", "old_id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2"}
{"code": "def getMinDiff ( arr , n , k ) :\n    if ( n == 1 ) :\n        return 0\n    arr.sort ( )\n    ans = arr [ n - 1 ] - arr [ 0 ]\n    small = arr [ 0 ] + k\n    big = arr [ n - 1 ] - k\n    if ( small > big ) :\n        small , big = big , small\n    for i in range ( 1 , n - 1 ) :\n        subtract = arr [ i ] - k\n        add = arr [ i ] + k\n        if ( subtract >= small or add <= big ) :\n            continue\n        if not ( big - subtract <= add - small ):\n            big = add\n        else:\n            small = subtract\n    return min ( ans , big - small )", "id": "IfReverse_sample_from_MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS_to_95", "old_id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS"}
{"code": "def MinimumCost ( cost , n , W ) :\n    val = list ( )\n    wt = list ( )\n    size = 0\n    for i in range ( n ) :\n        if ( cost [ i ] != - 1 ) :\n            val.append ( cost [ i ] )\n            wt.append ( i + 1 )\n            size += 1\n    n = size\n    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( W + 1 ) :\n        min_cost [ 0 ] [ i ] = INF\n    for i in range ( 1 , n + 1 ) :\n        min_cost [ i ] [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , W + 1 ) :\n            if not ( wt [ i - 1 ] > j ):\n                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )\n            else:\n                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]\n    if not ( min_cost [ n ] [ W ] == INF ):\n        return min_cost [ n ] [ W ]\n    else:\n        return - 1", "id": "IfReverse_sample_from_MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG_to_96", "old_id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG"}
{"code": "def minOps ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    for i in range ( 0 , n ) :\n        if not ( ( max1 - arr [ i ] ) % k != 0 ):\n            res += ( max1 - arr [ i ] ) / k\n        else:\n            return - 1\n    return int ( res )", "id": "IfReverse_sample_from_MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL_to_97", "old_id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if not ( arr [ i ] == 0 ):\n            if ( arr [ i ] >= n - i - 1 ) :\n                jumps [ i ] = 1\n            else :\n                min = float ( 'inf' )\n                for j in range ( i + 1 , n ) :\n                    if ( j <= arr [ i ] + i ) :\n                        if ( min > jumps [ j ] ) :\n                            min = jumps [ j ]\n                if ( min != float ( 'inf' ) ) :\n                    jumps [ i ] = min + 1\n                else :\n                    jumps [ i ] = min\n        else:\n            jumps [ i ] = float ( 'inf' )\n    return jumps [ 0 ]", "id": "IfReverse_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_98", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def getMinSquares ( n ) :\n    dp = [ 0 , 1 , 2 , 3 ]\n    for i in range ( 4 , n + 1 ) :\n        dp.append ( i )\n        for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) :\n            temp = x * x ;\n            if not temp > i:\n                dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )\n            else:\n                break\n    return dp [ n ]", "id": "IfReverse_sample_from_MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1_to_99", "old_id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1"}
{"code": "def subset ( ar , n ) :\n    res = 0\n    ar.sort ( )\n    i = 0\n    while i < n:\n        count = 1\n        j = i\n        while j < n - 1:\n            if not ar [ j ] == ar [ j + 1 ]:\n                break\n            else:\n                count += 1\n            j += 1\n        i = j\n        i += 1\n        res = max ( res , count )\n    return res", "id": "IfReverse_sample_from_MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_to_100", "old_id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS"}
{"code": "def minPerimeter ( n ) :\n    l = int ( math.sqrt ( n ) )\n    sq = l * l\n    if not ( sq == n ):\n        row = int ( n / l )\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter\n    else:\n        return l * 4", "id": "IfReverse_sample_from_MINIMUM_PERIMETER_N_BLOCKS_to_101", "old_id": "MINIMUM_PERIMETER_N_BLOCKS"}
{"code": "def minproduct ( a , b , n , k ) :\n    diff = 0\n    res = 0\n    temp = 0\n    for i in range ( n ) :\n        pro = a [ i ] * b [ i ]\n        res = res + pro\n        if not ( pro < 0 and b [ i ] < 0 ):\n            if ( pro < 0 and a [ i ] < 0 ) :\n                temp = ( a [ i ] - 2 * k ) * b [ i ]\n            elif ( pro > 0 and a [ i ] < 0 ) :\n                temp = ( a [ i ] + 2 * k ) * b [ i ]\n            elif ( pro > 0 and a [ i ] > 0 ) :\n                temp = ( a [ i ] - 2 * k ) * b [ i ]\n        else:\n            temp = ( a [ i ] + 2 * k ) * b [ i ]\n        d = abs ( pro - temp )\n        if ( d > diff ) :\n            diff = d\n    return res - diff", "id": "IfReverse_sample_from_MINIMUM_SUM_PRODUCT_TWO_ARRAYS_to_102", "old_id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS"}
{"code": "def solve ( arr , n ) :\n    arr.sort ( )\n    a = 0\n    b = 0\n    for i in range ( n ) :\n        if not ( i % 2 != 0 ):\n            b = b * 10 + arr [ i ]\n        else:\n            a = a * 10 + arr [ i ]\n    return a + b", "id": "IfReverse_sample_from_MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_to_103", "old_id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY"}
{"code": "def minTimeForWritingChars ( N , insert , remove , copy ) :\n    if N == 0 :\n        return 0\n    if N == 1 :\n        return insert\n    dp = [ 0 ] * ( N + 1 )\n    for i in range ( 1 , N + 1 ) :\n        if not i % 2 == 0:\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove )\n        else:\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy )\n    return dp [ N ]", "id": "IfReverse_sample_from_MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION_to_104", "old_id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION"}
{"code": "def answer ( n ) :\n    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ]\n    if ( n == 1 ) :\n        return 10\n    for j in range ( 10 ) :\n        dp [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 10 ) :\n            if not ( j == 0 ):\n                if ( j == 9 ) :\n                    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]\n                else :\n                    dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )\n            else:\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]\n    sum = 0\n    for j in range ( 1 , 10 ) :\n        sum = sum + dp [ n ] [ j ]\n    return sum", "id": "IfReverse_sample_from_NUMBER_N_DIGIT_STEPPING_NUMBERS_to_105", "old_id": "NUMBER_N_DIGIT_STEPPING_NUMBERS"}
{"code": "def checkPangram ( s ) :\n    List = [ ]\n    for i in range ( 26 ) :\n        List.append ( False )\n    for c in s :\n        if not 'A' <= c and c <= 'Z':\n            if 'a' <= c and c <= 'z':\n                List [ ord ( c ) - ord ( 'a' ) ] = True\n        else:\n            List [ ord ( c ) - ord ( 'A' ) ] = True\n    for ch in List :\n        if ch == False :\n            return False\n    return True", "id": "IfReverse_sample_from_PANGRAM_CHECKING_to_106", "old_id": "PANGRAM_CHECKING"}
{"code": "def rearrange ( a , size ) :\n    positive = 0\n    negative = 1\n    while ( True ) :\n        while ( positive < size and a [ positive ] >= 0 ) :\n            positive = positive + 2\n        while ( negative < size and a [ negative ] <= 0 ) :\n            negative = negative + 2\n        if not ( positive < size and negative < size ):\n            break\n        else:\n            temp = a [ positive ]\n            a [ positive ] = a [ negative ]\n            a [ negative ] = temp", "id": "IfReverse_sample_from_POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_to_107", "old_id": "POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS"}
{"code": "def isPrime ( p ) :\n    checkNumber = 2 ** p - 1\n    nextval = 4 % checkNumber\n    for i in range ( 1 , p - 1 ) :\n        nextval = ( nextval * nextval - 2 ) % checkNumber\n    if not ( nextval == 0 ): return False\n    else: return True", "id": "IfReverse_sample_from_PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES_to_108", "old_id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES"}
{"code": "def find_maximum ( a , n , k ) :\n    b = dict ( )\n    for i in range ( n ) :\n        x = a [ i ]\n        d = min ( 1 + i , n - i )\n        if not x not in b.keys ( ):\n            b [ x ] = min ( d , b [ x ] )\n        else:\n            b [ x ] = d\n    ans = sys.maxsize\n    for i in range ( n ) :\n        x = a [ i ]\n        if ( x != ( k - x ) and ( k - x ) in b.keys ( ) ) :\n            ans = min ( max ( b [ x ] , b [ k - x ] ) , ans )\n    return ans", "id": "IfReverse_sample_from_PRINT_MAXIMUM_SHORTEST_DISTANCE_to_109", "old_id": "PRINT_MAXIMUM_SHORTEST_DISTANCE"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        bestIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n    print ( \"Process No.Process Size     Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if not allocation [ i ] != - 1:\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + 1 )", "id": "IfReverse_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_110", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 :\n        return False\n    _sum = 0\n    for i in range ( 9 ) :\n        if not 0 <= int ( isbn [ i ] ) <= 9:\n            return False\n        else:\n            _sum += int ( isbn [ i ] ) * ( 10 - i )\n    if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) :\n        return False\n    _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )", "id": "IfReverse_sample_from_PROGRAM_CHECK_ISBN_to_111", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def isIdentity ( mat , N ) :\n    for row in range ( N ) :\n        for col in range ( N ) :\n            if not ( row == col and mat [ row ] [ col ] != 1 ):\n                if ( row != col and mat [ row ] [ col ] != 0 ) :\n                    return False\n            else:\n                return False\n    return True", "id": "IfReverse_sample_from_PROGRAM_PRINT_IDENTITY_MATRIX_1_to_112", "old_id": "PROGRAM_PRINT_IDENTITY_MATRIX_1"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        wstIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n    print ( \"Process No.Process Size Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if not allocation [ i ] != - 1:\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + 1 )", "id": "IfReverse_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_113", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def rearrange ( arr , n ) :\n    temp = n * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    for i in range ( n ) :\n        if not flag is True:\n            temp [ i ] = arr [ small ]\n            small += 1\n        else:\n            temp [ i ] = arr [ large ]\n            large -= 1\n        flag = bool ( 1 - flag )\n    for i in range ( n ) :\n        arr [ i ] = temp [ i ]\n    return arr", "id": "IfReverse_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_114", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    for i in range ( 0 , n ) :\n        if not i % 2 == 0:\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n        else:\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n    for i in range ( 0 , n ) :\n        arr [ i ] = int ( arr [ i ] / max_elem )", "id": "IfReverse_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_115", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def simplify ( Str ) :\n    Len = len ( Str )\n    res = [ None ] * Len\n    index = 0\n    i = 0\n    s = [ ]\n    s.append ( 0 )\n    while ( i < Len ) :\n        if not ( Str [ i ] == '+' ):\n            if ( Str [ i ] == '-' ) :\n                if ( s [ - 1 ] == 1 ) :\n                    res [ index ] = '+'\n                    index += 1\n                elif ( s [ - 1 ] == 0 ) :\n                    res [ index ] = '-'\n                    index += 1\n            elif ( Str [ i ] == '(' and i > 0 ) :\n                if ( Str [ i - 1 ] == '-' ) :\n                    x = 0 if ( s [ - 1 ] == 1 ) else 1\n                    s.append ( x )\n                elif ( Str [ i - 1 ] == '+' ) :\n                    s.append ( s [ - 1 ] )\n            elif ( Str [ i ] == ')' ) :\n                s.pop ( )\n            else :\n                res [ index ] = Str [ i ]\n                index += 1\n        else:\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index += 1\n        i += 1\n    return \"\".join(res)", "id": "IfReverse_sample_from_REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS_to_116", "old_id": "REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS"}
{"code": "def replace ( s , c1 , c2 ) :\n    l = len ( s )\n    for i in range ( l ) :\n        if not ( s [ i ] == c1 ):\n            if ( s [ i ] == c2 ) :\n                s = s [ 0 : i ] + c1 + s [ i + 1 : ]\n        else:\n            s = s [ 0 : i ] + c2 + s [ i + 1 : ]\n    return s", "id": "IfReverse_sample_from_REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S_to_117", "old_id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S"}
{"code": "def selectRandom ( x ) :\n    res = 0\n    count = 0\n    count += 1\n    if not ( count == 1 ):\n        i = random.randrange ( count )\n        if ( i == count - 1 ) :\n            res = x\n    else:\n        res = x\n    return res", "id": "IfReverse_sample_from_SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE_to_118", "old_id": "SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE"}
{"code": "def getTotalNumberOfSequences ( m , n ) :\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ]\n    for i in range ( m + 1 ) :\n        for j in range ( n + 1 ) :\n            if not i == 0 or j == 0:\n                if i < j :\n                    T [ i ] [ j ] = 0\n                elif j == 1 :\n                    T [ i ] [ j ] = i\n                else :\n                    T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ]\n            else:\n                T [ i ] [ j ] = 0\n    return T [ m ] [ n ]", "id": "IfReverse_sample_from_SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1_to_119", "old_id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1"}
{"code": "def findSmallestDifference ( A , B , m , n ) :\n    A = A [ : m ]\n    B = B [ : n ]\n    A.sort ( )\n    B.sort ( )\n    a = 0\n    b = 0\n    result = sys.maxsize\n    while ( a < m and b < n ) :\n        if ( abs ( A [ a ] - B [ b ] ) < result ) :\n            result = abs ( A [ a ] - B [ b ] )\n        if not ( A [ a ] < B [ b ] ):\n            b += 1\n        else:\n            a += 1\n    return result", "id": "IfReverse_sample_from_SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS_to_120", "old_id": "SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS"}
{"code": "def sort012 ( a , arr_size ) :\n    lo = 0\n    hi = arr_size - 1\n    mid = 0\n    while mid <= hi :\n        if not a [ mid ] == 0:\n            if a [ mid ] == 1 :\n                mid = mid + 1\n            else :\n                a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]\n                hi = hi - 1\n        else:\n            a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]\n            lo = lo + 1\n            mid = mid + 1", "id": "IfReverse_sample_from_SORT_AN_ARRAY_OF_0S_1S_AND_2S_to_121", "old_id": "SORT_AN_ARRAY_OF_0S_1S_AND_2S"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    for i in range ( n ) :\n        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    for i in range ( n ) :\n        if maximum < arr [ i ] :\n            index = i\n            maximum = arr [ i ]\n    i = 0\n    j = n - 1\n    new_arr = [ 0 ] * n\n    k = 0\n    while i < index and j > index :\n        if not arr [ i ] < arr [ j ]:\n            new_arr [ k ] = arr [ j ]\n            k += 1\n            j -= 1\n        else:\n            new_arr [ k ] = arr [ i ]\n            k += 1\n            i += 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k += 1\n        i += 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k += 1\n        j -= 1\n        new_arr [ n - 1 ] = maximum\n    for i in range ( n ) :\n        arr [ i ] = new_arr [ i ]", "id": "IfReverse_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_122", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def bitonicGenerator ( arr , n ) :\n    evenArr = [ ]\n    oddArr = [ ]\n    for i in range ( n ) :\n        if not ( ( i % 2 ) == 0 ):\n            oddArr.append ( arr [ i ] )\n        else:\n            evenArr.append ( arr [ i ] )\n    evenArr = sorted ( evenArr )\n    oddArr = sorted ( oddArr )\n    oddArr = oddArr [ : : - 1 ]\n    i = 0\n    for j in range ( len ( evenArr ) ) :\n        arr [ i ] = evenArr [ j ]\n        i += 1\n    for j in range ( len ( oddArr ) ) :\n        arr [ i ] = oddArr [ j ]\n        i += 1", "id": "IfReverse_sample_from_SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_to_123", "old_id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER"}
{"code": "def KnapSack ( val , wt , n , W ) :\n    mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ]\n    i = 0\n    while i < n :\n        j = 0\n        if not i % 2 == 0:\n            while j < W :\n                j += 1\n                if wt [ i ] <= j and j - wt [ i ] < W:\n                    mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] )\n                else :\n                    mat [ 0 ] [ j ] = mat [ 1 ] [ j ]\n        else:\n            while j < W :\n                j += 1\n                if wt [ i ] <= j and j - wt [ i ] < W:\n                    mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] )\n                else :\n                    mat [ 1 ] [ j ] = mat [ 0 ] [ j ]\n        i += 1\n    if not n % 2 == 0:\n        return mat [ 1 ] [ W ]\n    else:\n        return mat [ 0 ] [ W ]", "id": "IfReverse_sample_from_SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_to_124", "old_id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM"}
{"code": "def firstLetterWord ( str ) :\n    result = \"\"\n    v = True\n    for i in range ( len ( str ) ) :\n        if not ( str [ i ] == ' ' ):\n            if ( str [ i ] != ' ' and v == True ) :\n                result += ( str [ i ] )\n                v = False\n        else:\n            v = True\n    return result", "id": "IfReverse_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_125", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def isSubsetSum ( arr , n , sum ) :\n    subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( sum + 1 ) :\n            if not ( j == 0 ):\n                if ( i == 0 ) :\n                    subset [ i % 2 ] [ j ] = False\n                elif ( arr [ i - 1 ] <= j ) :\n                    subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ]\n                else :\n                    subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ]\n            else:\n                subset [ i % 2 ] [ j ] = True\n    return subset [ n % 2 ] [ sum ]", "id": "IfReverse_sample_from_SUBSET_SUM_PROBLEM_OSUM_SPACE_to_126", "old_id": "SUBSET_SUM_PROBLEM_OSUM_SPACE"}
{"code": "def MaxTotalRectangleArea ( a , n ) :\n    a = a [ : n ]\n    a.sort (  )\n    sum = 0\n    flag = False\n    len = 0\n    i = 0\n    while ( i < n - 1 ) :\n        if not ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ):\n            if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) :\n                sum = sum + a [ i + 1 ] * len\n                flag = False\n                i = i + 1\n        else:\n            flag = True\n            len = a [ i + 1 ]\n            i = i + 1\n        i += 1\n    return sum", "id": "IfReverse_sample_from_SUM_AREA_RECTANGLES_POSSIBLE_ARRAY_to_127", "old_id": "SUM_AREA_RECTANGLES_POSSIBLE_ARRAY"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if not ( j == 0 or j == i ):\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n            else:\n                C [ i ] [ j ] = 1\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        sum += C [ n ] [ i ]\n    return sum", "id": "IfReverse_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_128", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    for i in range ( n ) :\n        if not ( tree [ i ] == '(' ):\n            if ( tree [ i ] == ')' ) :\n                level -= 1\n            else :\n                if ( level == k ) :\n                    sum += ( ord ( tree [ i ] ) - ord ( '0' ) )\n        else:\n            level += 1\n    return sum", "id": "IfReverse_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_129", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def seriesSum ( n ) :\n    i = 1\n    res = 0.0\n    sign = True\n    while ( n > 0 ) :\n        n = n - 1\n        if not ( sign ):\n            sign = True\n            res = res - ( i + 1 ) / ( i + 2 )\n            i = i + 2\n        else:\n            sign = False\n            res = res + ( i + 1 ) / ( i + 2 )\n            i = i + 2\n    return res", "id": "IfReverse_sample_from_SUM_SERIES_23_45_67_89_UPTO_N_TERMS_to_130", "old_id": "SUM_SERIES_23_45_67_89_UPTO_N_TERMS"}
{"code": "def sumofsquare ( n ) :\n    C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if not ( j == 0 or j == i ):\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )\n            else:\n                C [ i ] [ j ] = 1\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )\n    return sum", "id": "IfReverse_sample_from_SUM_SQUARES_BINOMIAL_COEFFICIENTS_to_131", "old_id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    for i in range(n1):\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if not sum < 0:\n            str += chr(sum % 10 + 48)\n        else:\n            str += chr(sum % -10 + 48)\n        carry = int(sum / 10)\n    for i in range(n1, n2):\n        sum = ((ord(str2[i]) - 48) + carry)\n        if not sum < 0:\n            str += chr(sum % 10 + 48)\n        else:\n            str += chr(sum % -10 + 48)\n        carry = (int)(sum / 10)\n    if (carry):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "IfReverse_sample_from_SUM_TWO_LARGE_NUMBERS_to_132", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def offeringNumber ( n , templeHeight ) :\n    sum = 0\n    for i in range ( n ) :\n        left = 0\n        right = 0\n        for j in range ( i - 1 , - 1 , - 1 ) :\n            if not ( templeHeight [ j ] < templeHeight [ j + 1 ] ):\n                break\n            else:\n                left += 1\n        for j in range ( i + 1 , n ) :\n            if not ( templeHeight [ j ] < templeHeight [ j - 1 ] ):\n                break\n            else:\n                right += 1\n        sum += max ( right , left ) + 1\n    return sum", "id": "IfReverse_sample_from_TEMPLE_OFFERINGS_to_133", "old_id": "TEMPLE_OFFERINGS"}
{"code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( \" Invalid Input \" )\n        return\n    first = arr [ 0 ]\n    second = - sys.maxsize\n    third = - sys.maxsize\n    for i in range ( 1 , arr_size ) :\n        if not ( arr [ i ] > first ):\n            if ( arr [ i ] > second ) :\n                third = second\n                second = arr [ i ]\n            elif ( arr [ i ] > third ) :\n                third = arr [ i ]\n        else:\n            third = second\n            second = first\n            first = arr [ i ]\n    print ( \"The third Largest\" , \"element is\" , third )", "id": "IfReverse_sample_from_THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1_to_134", "old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1"}
{"code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    for i in range ( 0 , n , 1 ) :\n        if not ( str [ i ] == '1' ):\n            zero_count += 1\n        else:\n            one_count += 1\n    if ( one_count % 2 == 0 ) :\n        return zero_count\n    return one_count", "id": "IfReverse_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_135", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
{"code": "def countTransformation ( a , b ) :\n    n = len ( a )\n    m = len ( b )\n    if m == 0 :\n        return 1\n    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]\n    for i in range ( m ) :\n        for j in range ( i , n ) :\n            if not i == 0:\n                if a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] )\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n            else:\n                if j == 0 :\n                    if a [ j ] == b [ i ] :\n                        dp [ i ] [ j ] = 1\n                    else :\n                        dp [ i ] [ j ] = 0\n                elif a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n    return dp [ m - 1 ] [ n - 1 ]", "id": "IfReverse_sample_from_WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS_to_136", "old_id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS"}
