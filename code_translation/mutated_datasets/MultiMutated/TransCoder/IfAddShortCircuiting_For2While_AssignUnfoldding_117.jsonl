{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ); res = res - 48\n    idx_4m0v = 0\n    list_b9ct = range ( 1 , len ( str ) )\n    while idx_4m0v < len(list_b9ct):\n        i = list_b9ct[idx_4m0v]\n        if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            res += ord ( str [ i ] ) - 48\n        else :\n            res += ord ( str [ i ] ) - 48\n        idx_4m0v = idx_4m0v + 1\n    return res", "id": "AssignUnfoldding_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_0", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n        return True\n    if ( length % 3 == 1 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        num = str ( num ); num = num + \"00\"\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ); num = num + \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    idx_k0g8 = 0\n    list_kz6h = range ( length - 1 , - 1 , - 3 )\n    while idx_k0g8 < len(list_kz6h):\n        i = list_kz6h[idx_k0g8]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n        idx_k0g8 = idx_k0g8 + 1\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "AssignUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_1", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def checkIsAP ( arr , n ) :\n    if ( n == 1 ) and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))): return True\n    arr.sort ( )\n    d = arr [ 1 ]; d = d - arr [ 0 ]\n    idx_8z0y = 0\n    list_6p43 = range ( 2 , n )\n    while idx_8z0y < len(list_6p43):\n        i = list_6p43[idx_8z0y]\n        if ( arr [ i ] - arr [ i - 1 ] != d ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            return False\n        idx_8z0y = idx_8z0y + 1\n    return True", "id": "AssignUnfoldding_sample_from_CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY_to_2", "old_id": "CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n        return 1\n    if ( n % 3 == 1 ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n        num = str ( num ); num = num + \"00\"\n        n += 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ); num = num + \"0\"\n        n += 1\n    GSum = 0\n    p = 1\n    idx_e8z6 = 0\n    list_4yl9 = range ( n - 1 , - 1 , - 1 )\n    while idx_e8z6 < len(list_4yl9):\n        i = list_4yl9[idx_e8z6]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n        idx_e8z6 = idx_e8z6 + 1\n    return ( GSum % 7 == 0 )", "id": "AssignUnfoldding_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_3", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    idx_4bm2 = 0\n    list_tfij = range ( 2 , n + 1 )\n    while idx_4bm2 < len(list_tfij):\n        i = list_tfij[idx_4bm2]\n        idx_mf4o = 0\n        list_qwb1 = range ( k + 1 )\n        while idx_mf4o < len(list_qwb1):\n            j = list_qwb1[idx_mf4o]\n            if j >= i and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n                break\n            else:\n                dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ]; dp [ i ] [ j ] [ 0 ] = dp [ i ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ]\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n            idx_mf4o = idx_mf4o + 1\n        idx_4bm2 = idx_4bm2 + 1\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_4", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def findSubsequenceCount ( S , T ) :\n    m = len ( T )\n    n = len ( S )\n    if m > n and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        return 0\n    mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ]\n    idx_o1su = 0\n    list_kdt9 = range ( 1 , m + 1 )\n    while idx_o1su < len(list_kdt9):\n        i = list_kdt9[idx_o1su]\n        mat [ i ] [ 0 ] = 0\n        idx_o1su = idx_o1su + 1\n    idx_dng2 = 0\n    list_d70i = range ( n + 1 )\n    while idx_dng2 < len(list_d70i):\n        j = list_d70i[idx_dng2]\n        mat [ 0 ] [ j ] = 1\n        idx_dng2 = idx_dng2 + 1\n    idx_coym = 0\n    list_o5kt = range ( 1 , m + 1 )\n    while idx_coym < len(list_o5kt):\n        i = list_o5kt[idx_coym]\n        idx_95hr = 0\n        list_5ht3 = range ( 1 , n + 1 )\n        while idx_95hr < len(list_5ht3):\n            j = list_5ht3[idx_95hr]\n            if T [ i - 1 ] != S [ j - 1 ] and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]\n            else :\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]; mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ i - 1 ] [ j - 1 ]\n            idx_95hr = idx_95hr + 1\n        idx_coym = idx_coym + 1\n    return mat [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE_to_5", "old_id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE"}
{"code": "def countNumber ( n ) :\n    result = 0\n    idx_3bfa = 0\n    list_gmbp = range ( 1 , 10 )\n    while idx_3bfa < len(list_gmbp):\n        i = list_gmbp[idx_3bfa]\n        s = [ ]\n        if ( i <= n ) and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n            s.append ( i )\n            result += 1\n        while len ( s ) != 0 :\n            tp = s [ - 1 ]\n            s.pop ( )\n            idx_f7xc = 0\n            list_zf17 = range ( tp % 10 , 10 )\n            while idx_f7xc < len(list_zf17):\n                j = list_zf17[idx_f7xc]\n                x = tp * 10; x = x + j\n                if ( x <= n ) and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n                    s.append ( x )\n                    result += 1\n                idx_f7xc = idx_f7xc + 1\n        idx_3bfa = idx_3bfa + 1\n    return result", "id": "AssignUnfoldding_sample_from_COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER_to_6", "old_id": "COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER"}
{"code": "def countP ( n , k ) :\n    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]\n    idx_tm19 = 0\n    list_w9o4 = range ( n + 1 )\n    while idx_tm19 < len(list_w9o4):\n        i = list_w9o4[idx_tm19]\n        dp [ i ] [ 0 ] = 0\n        idx_tm19 = idx_tm19 + 1\n    idx_aufm = 0\n    list_e71w = range ( k + 1 )\n    while idx_aufm < len(list_e71w):\n        i = list_e71w[idx_aufm]\n        dp [ 0 ] [ k ] = 0\n        idx_aufm = idx_aufm + 1\n    idx_g7bx = 0\n    list_138b = range ( 1 , n + 1 )\n    while idx_g7bx < len(list_138b):\n        i = list_138b[idx_g7bx]\n        idx_l863 = 0\n        list_xiqt = range ( 1 , k + 1 )\n        while idx_l863 < len(list_xiqt):\n            j = list_xiqt[idx_l863]\n            if ( j == 1 or i == j ) and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n                dp [ i ] [ j ] = 1\n            else :\n                dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            idx_l863 = idx_l863 + 1\n        idx_g7bx = idx_g7bx + 1\n    return dp [ n ] [ k ]", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1_to_7", "old_id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1"}
{"code": "def countWays ( n , m ) :\n    count = [ ]\n    idx_tvsc = 0\n    list_kwj9 = range ( n + 2 )\n    while idx_tvsc < len(list_kwj9):\n        i = list_kwj9[idx_tvsc]\n        count.append ( 0 )\n        idx_tvsc = idx_tvsc + 1\n    count [ 0 ] = 0\n    idx_5yi1 = 0\n    list_e5oq = range ( 1 , n + 1 )\n    while idx_5yi1 < len(list_e5oq):\n        i = list_e5oq[idx_5yi1]\n        if ( i > m ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n            count [ i ] = count [ i - 1 ]; count [ i ] = count [ i ] + count [ i - m ]\n        elif ( i < m ) :\n            count [ i ] = 1\n        else :\n            count [ i ] = 2\n        idx_5yi1 = idx_5yi1 + 1\n    return count [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES_to_8", "old_id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ); ans = ans // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    idx_wj1e = 0\n    list_r6p8 = range ( n )\n    while idx_wj1e < len(list_r6p8):\n        i = list_r6p8[idx_wj1e]\n        if ( str [ i ] == 'a' ) and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n            a_index = i; a_index = a_index + 1\n            ans -= min ( b_index , c_index )\n        elif ( str [ i ] == 'b' ) :\n            b_index = i; b_index = b_index + 1\n            ans -= min ( a_index , c_index )\n        else :\n            c_index = i; c_index = c_index + 1\n            ans -= min ( a_index , b_index )\n        idx_wj1e = idx_wj1e + 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_9", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def countPairs ( arr , n ) :\n    result = 0 ;\n    idx_j4cx = 0\n    list_3lr0 = range ( 0 , n )\n    while idx_j4cx < len(list_3lr0):\n        i = list_3lr0[idx_j4cx]\n        idx_bnwv = 0\n        list_okp8 = range ( i + 1 , n )\n        while idx_bnwv < len(list_okp8):\n            j = list_okp8[idx_bnwv]\n            product = arr [ i ]; product = product * arr [ j ]\n            idx_epgd = 0\n            list_aeq2 = range ( 0 , n )\n            while idx_epgd < len(list_aeq2):\n                k = list_aeq2[idx_epgd]\n                if ( arr [ k ] == product ) and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n                    result = result + 1 ;\n                    break ;\n                idx_epgd = idx_epgd + 1\n            idx_bnwv = idx_bnwv + 1\n        idx_j4cx = idx_j4cx + 1\n    return result ;", "id": "AssignUnfoldding_sample_from_COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_to_10", "old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY"}
{"code": "def countPairs ( arr , n ) :\n    result = 0\n    Hash = set ( )\n    idx_on76 = 0\n    list_ctg1 = range ( n )\n    while idx_on76 < len(list_ctg1):\n        i = list_ctg1[idx_on76]\n        Hash.add ( arr [ i ] )\n        idx_on76 = idx_on76 + 1\n    idx_pl1w = 0\n    list_8x04 = range ( n )\n    while idx_pl1w < len(list_8x04):\n        i = list_8x04[idx_pl1w]\n        idx_n5u4 = 0\n        list_e4jb = range ( i + 1 , n )\n        while idx_n5u4 < len(list_e4jb):\n            j = list_e4jb[idx_n5u4]\n            product = arr [ i ]; product = product * arr [ j ]\n            if product in ( Hash ) and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n                result += 1\n            idx_n5u4 = idx_n5u4 + 1\n        idx_pl1w = idx_pl1w + 1\n    return result", "id": "AssignUnfoldding_sample_from_COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1_to_11", "old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1"}
{"code": "def CountPS ( str , n ) :\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    idx_9krq = 0\n    list_kax8 = range ( n )\n    while idx_9krq < len(list_kax8):\n        i = list_kax8[idx_9krq]\n        P [ i ] [ i ] = True\n        idx_9krq = idx_9krq + 1\n    idx_emk7 = 0\n    list_txbu = range ( n - 1 )\n    while idx_emk7 < len(list_txbu):\n        i = list_txbu[idx_emk7]\n        if ( str [ i ] == str [ i + 1 ] ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n            P [ i ] [ i + 1 ] = True\n            dp [ i ] [ i + 1 ] = 1\n        idx_emk7 = idx_emk7 + 1\n    idx_u8d6 = 0\n    list_ore4 = range ( 2 , n )\n    while idx_u8d6 < len(list_ore4):\n        gap = list_ore4[idx_u8d6]\n        idx_41mw = 0\n        list_pjty = range ( n - gap )\n        while idx_41mw < len(list_pjty):\n            i = list_pjty[idx_41mw]\n            j = gap; j = j + i\n            if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                P [ i ] [ j ] = True\n            if ( P [ i ] [ j ] == True ) and (((True or False) and (False or True)) and ((10 > 9) or (10 < 9))):\n                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1; dp [ i ] [ j ] = dp [ i ] [ j ] - dp [ i + 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] - dp [ i + 1 ] [ j - 1 ]\n            idx_41mw = idx_41mw + 1\n        idx_u8d6 = idx_u8d6 + 1\n    return dp [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_PALINDROME_SUB_STRINGS_STRING_to_12", "old_id": "COUNT_PALINDROME_SUB_STRINGS_STRING"}
{"code": "def countPS ( str ) :\n    N = len ( str )\n    cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ]\n    idx_pxsk = 0\n    list_2iny = range ( N )\n    while idx_pxsk < len(list_2iny):\n        i = list_2iny[idx_pxsk]\n        cps [ i ] [ i ] = 1\n        idx_pxsk = idx_pxsk + 1\n    idx_5pa4 = 0\n    list_mi9z = range ( 2 , N + 1 )\n    while idx_5pa4 < len(list_mi9z):\n        L = list_mi9z[idx_5pa4]\n        idx_95vi = 0\n        list_fjtm = range ( N )\n        while idx_95vi < len(list_fjtm):\n            i = list_fjtm[idx_95vi]\n            k = L + i; k = k - 1\n            if ( k < N ) and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n                if ( str [ i ] == str [ k ] ) :\n                    cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ]; cps [ i ] [ k ] = cps [ i ] [ k ] + 1\n                else :\n                    cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ]; cps [ i ] [ k ] = cps [ i ] [ k ] - cps [ i + 1 ] [ k - 1 ]\n            idx_95vi = idx_95vi + 1\n        idx_5pa4 = idx_5pa4 + 1\n    return cps [ 0 ] [ N - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_to_13", "old_id": "COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING"}
{"code": "def countDecodingDP ( digits , n ) :\n    count = [ 0 ]; count = count * ( n + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == '0' and (((True or False) and (False or True)) and ((10 > 9) or (10 < 9))):\n        return 0\n    idx_gxmh = 0\n    list_ypl6 = range ( 2 , n + 1 )\n    while idx_gxmh < len(list_ypl6):\n        i = list_ypl6[idx_gxmh]\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > '0' ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n            count [ i ] += count [ i - 2 ]\n        idx_gxmh = idx_gxmh + 1\n    return count [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1_to_14", "old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1"}
{"code": "def countRotations ( n ) :\n    l = len ( n )\n    if ( l == 1 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        oneDigit = ( int ) ( n [ 0 ] )\n        if ( oneDigit % 4 == 0 ) :\n            return 1\n        return 0\n    count = 0\n    idx_ibuz = 0\n    list_xgsw = range ( 0 , l - 1 )\n    while idx_ibuz < len(list_xgsw):\n        i = list_xgsw[idx_ibuz]\n        twoDigit = ( int ) ( n [ i ] ) * 10; twoDigit = twoDigit + ( int ) ( n [ i + 1 ] )\n        if ( twoDigit % 4 == 0 ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            count = count + 1\n        idx_ibuz = idx_ibuz + 1\n    twoDigit = ( int ) ( n [ l - 1 ] ) * 10; twoDigit = twoDigit + ( int ) ( n [ 0 ] )\n    if ( twoDigit % 4 == 0 ) and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n        count = count + 1\n    return count", "id": "AssignUnfoldding_sample_from_COUNT_ROTATIONS_DIVISIBLE_4_to_15", "old_id": "COUNT_ROTATIONS_DIVISIBLE_4"}
{"code": "def countRotationsDivBy8 ( n ) :\n    l = len ( n )\n    count = 0\n    if ( l == 1 ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n        oneDigit = int ( n [ 0 ] )\n        if ( oneDigit % 8 == 0 ) :\n            return 1\n        return 0\n    if ( l == 2 ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        first = int ( n [ 0 ] ) * 10; first = first + int ( n [ 1 ] )\n        second = int ( n [ 1 ] ) * 10; second = second + int ( n [ 0 ] )\n        if ( first % 8 == 0 ) :\n            count += 1\n        if ( second % 8 == 0 ) :\n            count += 1\n        return count\n    threeDigit = 0\n    idx_hb6a = 0\n    list_6te1 = range ( 0 , ( l - 2 ) )\n    while idx_hb6a < len(list_6te1):\n        i = list_6te1[idx_hb6a]\n        threeDigit = int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10; threeDigit = threeDigit + int ( n [ i + 2 ] )\n        if ( threeDigit % 8 == 0 ) and (((True or False) and (False or True)) and ((8 > 6) or (8 < 6))):\n            count += 1\n        idx_hb6a = idx_hb6a + 1\n    threeDigit = int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10; threeDigit = threeDigit + int ( n [ 1 ] )\n    if ( threeDigit % 8 == 0 ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n        count += 1\n    threeDigit = int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10; threeDigit = threeDigit + int ( n [ 0 ] )\n    if ( threeDigit % 8 == 0 ) and (((True or False) and (False or True)) and ((8 > 2) or (8 < 2))):\n        count += 1\n    return count", "id": "AssignUnfoldding_sample_from_COUNT_ROTATIONS_DIVISIBLE_8_to_16", "old_id": "COUNT_ROTATIONS_DIVISIBLE_8"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ]; hash_positive = hash_positive * ( n + 1 )\n    hash_negative = [ 0 ]; hash_negative = hash_negative * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    idx_p0ad = 0\n    list_1gqi = range ( n )\n    while idx_p0ad < len(list_1gqi):\n        i = list_1gqi[idx_p0ad]\n        if ( arr [ i ] & 1 == 1 ) and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n            difference = difference + 1\n        else :\n            difference = difference - 1\n        if ( difference < 0 ) and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n            ans += hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ]; hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n        else :\n            ans += hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ]; hash_positive [ difference ] = hash_positive [ difference ] + 1\n        idx_p0ad = idx_p0ad + 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_17", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1; change = change << i\n        idx_uae9 = 0\n        list_mb4o = range ( 0 , n + 1 )\n        while idx_uae9 < len(list_mb4o):\n            j = list_mb4o[idx_uae9]\n            ans += k\n            if change == 1 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                k = not k\n                change = 1; change = change << i\n            else :\n                change -= 1\n            idx_uae9 = idx_uae9 + 1\n        i += 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_18", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def countWords ( str , n ) :\n    m = dict ( )\n    idx_50pj = 0\n    list_jz14 = range ( n )\n    while idx_50pj < len(list_jz14):\n        i = list_jz14[idx_50pj]\n        m [ str [ i ] ] = m.get ( str [ i ] , 0 ); m [ str [ i ] ] = m [ str [ i ] ] + 1\n        idx_50pj = idx_50pj + 1\n    res = 0\n    idx_ifnd = 0\n    list_isfq = m.values ( )\n    while idx_ifnd < len(list_isfq):\n        i = list_isfq[idx_ifnd]\n        if i == 2 and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            res += 1\n        idx_ifnd = idx_ifnd + 1\n    return res", "id": "AssignUnfoldding_sample_from_COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS_to_19", "old_id": "COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ]; count = count * NO_OF_CHARS\n    idx_pd84 = 0\n    list_v14j = range ( len ( str ) )\n    while idx_pd84 < len(list_v14j):\n        i = list_v14j[idx_pd84]\n        count [ ord ( str [ i ] ) ] += 1\n        idx_pd84 = idx_pd84 + 1\n    first , second = 0 , 0\n    idx_dqgl = 0\n    list_uzen = range ( NO_OF_CHARS )\n    while idx_dqgl < len(list_uzen):\n        i = list_uzen[idx_dqgl]\n        if count [ i ] > count [ first ] and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            second = first\n            first = i\n        elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n            second = i\n        idx_dqgl = idx_dqgl + 1\n    return chr ( second )", "id": "AssignUnfoldding_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_20", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    idx_vjmt = 0\n    list_tyuk = range ( len ( Str ) )\n    while idx_vjmt < len(list_tyuk):\n        i = list_tyuk[idx_vjmt]\n        count = 0\n        if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ); count = count - ord ( '0' )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n        elif ( Str [ i ] == ']' ) :\n            temp = \"\"\n            count = 0\n            if ( len ( integerstack ) != 0 ) :\n                count = integerstack [ - 1 ]\n                integerstack.pop ( )\n            while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                temp = stringstack [ - 1 ] + temp\n                stringstack.pop ( )\n            if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                stringstack.pop ( )\n            idx_imtd = 0\n            list_sk7y = range ( count )\n            while idx_imtd < len(list_sk7y):\n                j = list_sk7y[idx_imtd]\n                result = result + temp\n                idx_imtd = idx_imtd + 1\n            idx_y7au = 0\n            list_c8r2 = range ( len ( result ) )\n            while idx_y7au < len(list_c8r2):\n                j = list_c8r2[idx_y7au]\n                stringstack.append ( result [ j ] )\n                idx_y7au = idx_y7au + 1\n            result = \"\"\n        elif ( Str [ i ] == '[' ) :\n            if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                stringstack.append ( Str [ i ] )\n            else :\n                stringstack.append ( Str [ i ] )\n                integerstack.append ( 1 )\n        else :\n            stringstack.append ( Str [ i ] )\n        idx_vjmt = idx_vjmt + 1\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "AssignUnfoldding_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_21", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def numberofways ( n , m ) :\n    dp = np.zeros ( ( n + 2 , n + 2 ) )\n    dp [ 0 ] [ n + 1 ] = 1\n    idx_bhm6 = 0\n    list_fpoh = range ( n , m - 1 , - 1 )\n    while idx_bhm6 < len(list_fpoh):\n        k = list_fpoh[idx_bhm6]\n        idx_xn5y = 0\n        list_jq3h = range ( n + 1 )\n        while idx_xn5y < len(list_jq3h):\n            i = list_jq3h[idx_xn5y]\n            dp [ i ] [ k ] = dp [ i ] [ k + 1 ]\n            if ( i - k >= 0 ) and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n                dp [ i ] [ k ] = dp [ i ] [ k ]; dp [ i ] [ k ] = dp [ i ] [ k ] + dp [ i - k ] [ k ]\n            idx_xn5y = idx_xn5y + 1\n        idx_bhm6 = idx_bhm6 + 1\n    return dp [ n ] [ m ]", "id": "AssignUnfoldding_sample_from_DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M_to_22", "old_id": "DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M"}
{"code": "def discreteLogarithm ( a , b , m ) :\n    n = int ( math.sqrt ( m ) + 1 )\n    an = 1\n    idx_xk1b = 0\n    list_yrme = range ( n )\n    while idx_xk1b < len(list_yrme):\n        i = list_yrme[idx_xk1b]\n        an = ( an * a ); an = an % m\n        idx_xk1b = idx_xk1b + 1\n    value = [ 0 ]; value = value * m\n    cur = an\n    idx_8rnx = 0\n    list_ey3c = range ( 1 , n + 1 )\n    while idx_8rnx < len(list_ey3c):\n        i = list_ey3c[idx_8rnx]\n        if ( value [ cur ] == 0 ) and (((True or False) and (False or True)) and ((9 > 0) or (9 < 0))):\n            value [ cur ] = i\n        cur = ( cur * an ); cur = cur % m\n        idx_8rnx = idx_8rnx + 1\n    cur = b\n    idx_b7u6 = 0\n    list_nc1d = range ( n + 1 )\n    while idx_b7u6 < len(list_nc1d):\n        i = list_nc1d[idx_b7u6]\n        if ( value [ cur ] > 0 ) and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n            ans = value [ cur ] * n; ans = ans - i\n            if ( ans < m ) :\n                return ans\n        cur = ( cur * a ); cur = cur % m\n        idx_b7u6 = idx_b7u6 + 1\n    return - 1", "id": "AssignUnfoldding_sample_from_DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B_to_23", "old_id": "DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B"}
{"code": "def eggDrop ( n , k ) :\n    eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ]\n    idx_0x7i = 0\n    list_xqne = range ( 1 , n + 1 )\n    while idx_0x7i < len(list_xqne):\n        i = list_xqne[idx_0x7i]\n        eggFloor [ i ] [ 1 ] = 1\n        eggFloor [ i ] [ 0 ] = 0\n        idx_0x7i = idx_0x7i + 1\n    idx_cb58 = 0\n    list_lthc = range ( 1 , k + 1 )\n    while idx_cb58 < len(list_lthc):\n        j = list_lthc[idx_cb58]\n        eggFloor [ 1 ] [ j ] = j\n        idx_cb58 = idx_cb58 + 1\n    idx_l1wy = 0\n    list_t7cd = range ( 2 , n + 1 )\n    while idx_l1wy < len(list_t7cd):\n        i = list_t7cd[idx_l1wy]\n        idx_bzwk = 0\n        list_s092 = range ( 2 , k + 1 )\n        while idx_bzwk < len(list_s092):\n            j = list_s092[idx_bzwk]\n            eggFloor [ i ] [ j ] = INT_MAX\n            idx_cd5p = 0\n            list_2z0a = range ( 1 , j + 1 )\n            while idx_cd5p < len(list_2z0a):\n                x = list_2z0a[idx_cd5p]\n                res = 1; res = res + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] )\n                if res < eggFloor [ i ] [ j ] and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n                    eggFloor [ i ] [ j ] = res\n                idx_cd5p = idx_cd5p + 1\n            idx_bzwk = idx_bzwk + 1\n        idx_l1wy = idx_l1wy + 1\n    return eggFloor [ n ] [ k ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1_to_24", "old_id": "DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1"}
{"code": "def lps ( seq ) :\n    n = len ( seq )\n    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]\n    idx_f3cn = 0\n    list_noid = range ( n )\n    while idx_f3cn < len(list_noid):\n        i = list_noid[idx_f3cn]\n        L [ i ] [ i ] = 1\n        idx_f3cn = idx_f3cn + 1\n    idx_9mow = 0\n    list_ftnk = range ( 2 , n + 1 )\n    while idx_9mow < len(list_ftnk):\n        cl = list_ftnk[idx_9mow]\n        idx_c65u = 0\n        list_t9cg = range ( n - cl + 1 )\n        while idx_c65u < len(list_t9cg):\n            i = list_t9cg[idx_c65u]\n            j = i + cl; j = j - 1\n            if seq [ i ] == seq [ j ] and cl == 2 and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n                L [ i ] [ j ] = 2\n            elif seq [ i ] == seq [ j ] :\n                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ]; L [ i ] [ j ] = L [ i ] [ j ] + 2\n            else :\n                L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;\n            idx_c65u = idx_c65u + 1\n        idx_9mow = idx_9mow + 1\n    return L [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE_to_25", "old_id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE"}
{"code": "def maxSumIS ( arr , n ) :\n    max = 0\n    msis = [ 0 for x in range ( n ) ]\n    idx_62wp = 0\n    list_r4xw = range ( n )\n    while idx_62wp < len(list_r4xw):\n        i = list_r4xw[idx_62wp]\n        msis [ i ] = arr [ i ]\n        idx_62wp = idx_62wp + 1\n    idx_62s9 = 0\n    list_wrkq = range ( 1 , n )\n    while idx_62s9 < len(list_wrkq):\n        i = list_wrkq[idx_62s9]\n        idx_02vr = 0\n        list_urcy = range ( i )\n        while idx_02vr < len(list_urcy):\n            j = list_urcy[idx_02vr]\n            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n                msis [ i ] = msis [ j ]; msis [ i ] = msis [ i ] + arr [ i ]\n            idx_02vr = idx_02vr + 1\n        idx_62s9 = idx_62s9 + 1\n    idx_3boy = 0\n    list_go9l = range ( n )\n    while idx_3boy < len(list_go9l):\n        i = list_go9l[idx_3boy]\n        if max < msis [ i ] and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            max = msis [ i ]\n        idx_3boy = idx_3boy + 1\n    return max", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE_to_26", "old_id": "DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE"}
{"code": "def lbs ( arr , n ) :\n    lis = [ 1 for i in range ( n + 1 ) ]\n    idx_50rn = 0\n    list_cur9 = range ( 1 , n )\n    while idx_50rn < len(list_cur9):\n        i = list_cur9[idx_50rn]\n        idx_nzk3 = 0\n        list_1a89 = range ( 0 , i )\n        while idx_nzk3 < len(list_1a89):\n            j = list_1a89[idx_nzk3]\n            if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n            idx_nzk3 = idx_nzk3 + 1\n        idx_50rn = idx_50rn + 1\n    lds = [ 1 for i in range ( n + 1 ) ]\n    idx_1za0 = 0\n    list_j9l2 = reversed ( range ( n - 1 ) )\n    while idx_1za0 < len(list_j9l2):\n        i = list_j9l2[idx_1za0]\n        idx_ychv = 0\n        list_1r3t = reversed ( range ( i - 1 , n ) )\n        while idx_ychv < len(list_1r3t):\n            j = list_1r3t[idx_ychv]\n            if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n                lds [ i ] = lds [ j ]; lds [ i ] = lds [ i ] + 1\n            idx_ychv = idx_ychv + 1\n        idx_1za0 = idx_1za0 + 1\n    maximum = lis [ 0 ] + lds [ 0 ]; maximum = maximum - 1\n    idx_tbn8 = 0\n    list_y3ew = range ( 1 , n )\n    while idx_tbn8 < len(list_y3ew):\n        i = list_y3ew[idx_tbn8]\n        maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum )\n        idx_tbn8 = idx_tbn8 + 1\n    return maximum", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE_to_27", "old_id": "DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE"}
{"code": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = 0\n    k = 0\n    L = 0\n    idx_0h1u = 0\n    list_qr75 = range ( n )\n    while idx_0h1u < len(list_qr75):\n        i = list_qr75[idx_0h1u]\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = 0\n        idx_0h1u = idx_0h1u + 1\n    idx_obwh = 0\n    list_d8e3 = range ( 2 , n + 1 )\n    while idx_obwh < len(list_d8e3):\n        L = list_d8e3[idx_obwh]\n        idx_k3ys = 0\n        list_3anh = range ( n - L + 1 )\n        while idx_k3ys < len(list_3anh):\n            i = list_3anh[idx_k3ys]\n            j = i + L; j = j - 1\n            if L == 2 and (((True or False) and (False or True)) and ((9 > 1) or (9 < 1))):\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            else :\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )\n            if P [ i ] [ j ] == True and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                C [ i ] [ j ] = 0\n            else :\n                C [ i ] [ j ] = 100000000\n                idx_r9d4 = 0\n                list_zfbc = range ( i , j )\n                while idx_r9d4 < len(list_zfbc):\n                    k = list_zfbc[idx_r9d4]\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n                    idx_r9d4 = idx_r9d4 + 1\n            idx_k3ys = idx_k3ys + 1\n        idx_obwh = idx_obwh + 1\n    return C [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_to_28", "old_id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    idx_5g13 = 0\n    list_e2fl = range ( n )\n    while idx_5g13 < len(list_e2fl):\n        i = list_e2fl[idx_5g13]\n        if symb [ i ] == 'F' and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == 'T' and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n        idx_5g13 = idx_5g13 + 1\n    idx_pz0m = 0\n    list_7g9j = range ( 1 , n )\n    while idx_pz0m < len(list_7g9j):\n        gap = list_7g9j[idx_pz0m]\n        i = 0\n        idx_adw2 = 0\n        list_6flz = range ( gap , n )\n        while idx_adw2 < len(list_6flz):\n            j = list_6flz[idx_adw2]\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            idx_y2vh = 0\n            list_fs0t = range ( gap )\n            while idx_y2vh < len(list_fs0t):\n                g = list_fs0t[idx_y2vh]\n                k = i; k = k + g\n                tik = T [ i ] [ k ]; tik = tik + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ]; tkj = tkj + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                idx_y2vh = idx_y2vh + 1\n            i += 1\n            idx_adw2 = idx_adw2 + 1\n        idx_pz0m = idx_pz0m + 1\n    return T [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_29", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def lis ( arr , n) :\n    lis = [ 1 ]; lis = lis * n\n    idx_ltv1 = 0\n    list_h68t = range ( 1 , n )\n    while idx_ltv1 < len(list_h68t):\n        i = list_h68t[idx_ltv1]\n        idx_6ub0 = 0\n        list_uqa6 = range ( 0 , i )\n        while idx_6ub0 < len(list_uqa6):\n            j = list_uqa6[idx_6ub0]\n            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n            idx_6ub0 = idx_6ub0 + 1\n        idx_ltv1 = idx_ltv1 + 1\n    maximum = 0\n    idx_nkl6 = 0\n    list_7hk1 = range ( n )\n    while idx_nkl6 < len(list_7hk1):\n        i = list_7hk1[idx_nkl6]\n        maximum = max ( maximum , lis [ i ] )\n        idx_nkl6 = idx_nkl6 + 1\n    return maximum", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1_to_30", "old_id": "DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1"}
{"code": "def MatrixChainOrder ( p , i , j ) :\n    if i == j and (((True or False) and (False or True)) and ((8 > 2) or (8 < 2))):\n        return 0\n    _min = sys.maxsize\n    idx_3d57 = 0\n    list_28zh = range ( i , j )\n    while idx_3d57 < len(list_28zh):\n        k = list_28zh[idx_3d57]\n        count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ); count = count + p [ i - 1 ] * p [ k ] * p [ j ]\n        if count < _min and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            _min = count\n        idx_3d57 = idx_3d57 + 1\n    return _min", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_to_31", "old_id": "DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION"}
{"code": "def maxHamming ( arr , n ) :\n    brr = [ 0 ]; brr = brr * ( 2 * n + 1 )\n    idx_iljk = 0\n    list_9ezn = range ( n )\n    while idx_iljk < len(list_9ezn):\n        i = list_9ezn[idx_iljk]\n        brr [ i ] = arr [ i ]\n        idx_iljk = idx_iljk + 1\n    idx_j5dz = 0\n    list_0ig1 = range ( n )\n    while idx_j5dz < len(list_0ig1):\n        i = list_0ig1[idx_j5dz]\n        brr [ n + i ] = arr [ i ]\n        idx_j5dz = idx_j5dz + 1\n    maxHam = 0\n    idx_n1hb = 0\n    list_f8ld = range ( 1 , n )\n    while idx_n1hb < len(list_f8ld):\n        i = list_f8ld[idx_n1hb]\n        currHam = 0\n        k = 0\n        idx_dmxs = 0\n        list_khdn = range ( i , i + n )\n        while idx_dmxs < len(list_khdn):\n            j = list_khdn[idx_dmxs]\n            if brr [ j ] != arr [ k ] and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n                currHam += 1\n                k = k + 1\n            idx_dmxs = idx_dmxs + 1\n        if currHam == n and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            return n\n        maxHam = max ( maxHam , currHam )\n        idx_n1hb = idx_n1hb + 1\n    return maxHam", "id": "AssignUnfoldding_sample_from_FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE_to_32", "old_id": "FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE"}
{"code": "def computeLastDigit ( A , B ) :\n    variable = 1\n    if ( A == B ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n        return 1\n    elif ( ( B - A ) >= 5 ) :\n        return 0\n    else :\n        idx_o3gc = 0\n        list_kp83 = range ( A + 1 , B + 1 )\n        while idx_o3gc < len(list_kp83):\n            i = list_kp83[idx_o3gc]\n            variable = ( variable * ( i % 10 ) ); variable = variable % 10\n            idx_o3gc = idx_o3gc + 1\n        return variable % 10", "id": "AssignUnfoldding_sample_from_FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B_to_33", "old_id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B"}
{"code": "def findMaxAverage ( arr , n , k ) :\n    if k > n and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n        return - 1\n    csum = [ 0 ]; csum = csum * n\n    csum [ 0 ] = arr [ 0 ]\n    idx_578j = 0\n    list_6vjc = range ( 1 , n )\n    while idx_578j < len(list_6vjc):\n        i = list_6vjc[idx_578j]\n        csum [ i ] = csum [ i - 1 ]; csum [ i ] = csum [ i ] + arr [ i ]\n        idx_578j = idx_578j + 1\n    max_sum = csum [ k - 1 ]\n    max_end = k; max_end = max_end - 1\n    idx_z2i0 = 0\n    list_m5g8 = range ( k , n )\n    while idx_z2i0 < len(list_m5g8):\n        i = list_m5g8[idx_z2i0]\n        curr_sum = csum [ i ]; curr_sum = curr_sum - csum [ i - k ]\n        if curr_sum > max_sum and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            max_sum = curr_sum\n            max_end = i\n        idx_z2i0 = idx_z2i0 + 1\n    return max_end - k + 1", "id": "AssignUnfoldding_sample_from_FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_to_34", "old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH"}
{"code": "def findMaxAverage ( arr , n , k ) :\n    if ( k > n ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n        return - 1\n    sum = arr [ 0 ]\n    idx_t9uk = 0\n    list_okam = range ( 1 , k )\n    while idx_t9uk < len(list_okam):\n        i = list_okam[idx_t9uk]\n        sum += arr [ i ]\n        idx_t9uk = idx_t9uk + 1\n    max_sum = sum\n    max_end = k; max_end = max_end - 1\n    idx_apn0 = 0\n    list_5g0j = range ( k , n )\n    while idx_apn0 < len(list_5g0j):\n        i = list_5g0j[idx_apn0]\n        sum = sum + arr [ i ]; sum = sum - arr [ i - k ]\n        if ( sum > max_sum ) and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n            max_sum = sum\n            max_end = i\n        idx_apn0 = idx_apn0 + 1\n    return max_end - k + 1", "id": "AssignUnfoldding_sample_from_FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1_to_35", "old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize; mx = mx - 1\n    idx_fwuy = 0\n    list_oz4q = range ( r )\n    while idx_fwuy < len(list_oz4q):\n        i = list_oz4q[idx_fwuy]\n        if m [ i ] [ 0 ] < mi and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n            mx = m [ i ] [ c - 1 ]\n        idx_fwuy = idx_fwuy + 1\n    desired = ( r * c + 1 ); desired = desired // 2\n    while ( mi < mx ) :\n        mid = mi; mid = mid + ( mx - mi ) // 2\n        place = [ 0 ]\n        idx_wg3a = 0\n        list_jit2 = range ( r )\n        while idx_wg3a < len(list_jit2):\n            i = list_jit2[idx_wg3a]\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ]; place [ 0 ] = place [ 0 ] + j\n            idx_wg3a = idx_wg3a + 1\n        if place [ 0 ] < desired and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            mi = mid; mi = mi + 1\n        else :\n            mx = mid\n    print ( \"Median is\" , mi )\n    return mi", "id": "AssignUnfoldding_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_36", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def findMinDiff ( arr , n ) :\n    diff = 10; diff = diff ** 20\n    idx_yomj = 0\n    list_kqem = range ( n - 1 )\n    while idx_yomj < len(list_kqem):\n        i = list_kqem[idx_yomj]\n        idx_czx4 = 0\n        list_yd7u = range ( i + 1 , n )\n        while idx_czx4 < len(list_yd7u):\n            j = list_yd7u[idx_czx4]\n            if abs ( arr [ i ] - arr [ j ] ) < diff and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                diff = abs ( arr [ i ] - arr [ j ] )\n            idx_czx4 = idx_czx4 + 1\n        idx_yomj = idx_yomj + 1\n    return diff", "id": "AssignUnfoldding_sample_from_FIND_MINIMUM_DIFFERENCE_PAIR_to_37", "old_id": "FIND_MINIMUM_DIFFERENCE_PAIR"}
{"code": "def findMinDiff ( arr , n ) :\n    arr = arr[:n]\n    arr = sorted ( arr )\n    diff = 10; diff = diff ** 20\n    idx_z16i = 0\n    list_d0jn = range ( n - 1 )\n    while idx_z16i < len(list_d0jn):\n        i = list_d0jn[idx_z16i]\n        if arr [ i + 1 ] - arr [ i ] < diff and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n            diff = arr [ i + 1 ]; diff = diff - arr [ i ]\n        idx_z16i = idx_z16i + 1\n    return diff", "id": "AssignUnfoldding_sample_from_FIND_MINIMUM_DIFFERENCE_PAIR_1_to_38", "old_id": "FIND_MINIMUM_DIFFERENCE_PAIR_1"}
{"code": "def minCoins ( coins , m , V ) :\n    table = [ 0 for i in range ( V + 1 ) ]\n    table [ 0 ] = 0\n    idx_l38s = 0\n    list_xa8o = range ( 1 , V + 1 )\n    while idx_l38s < len(list_xa8o):\n        i = list_xa8o[idx_l38s]\n        table [ i ] = sys.maxsize\n        idx_l38s = idx_l38s + 1\n    idx_cjmx = 0\n    list_5lbm = range ( 1 , V + 1 )\n    while idx_cjmx < len(list_5lbm):\n        i = list_5lbm[idx_cjmx]\n        idx_ewo9 = 0\n        list_wypn = range ( m )\n        while idx_ewo9 < len(list_wypn):\n            j = list_wypn[idx_ewo9]\n            if ( coins [ j ] <= i ) and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n                sub_res = table [ i - coins [ j ] ]\n                if ( sub_res != sys.maxsize and sub_res + 1 < table [ i ] ) :\n                    table [ i ] = sub_res; table [ i ] = table [ i ] + 1\n            idx_ewo9 = idx_ewo9 + 1\n        idx_cjmx = idx_cjmx + 1\n    return table [ V ]", "id": "AssignUnfoldding_sample_from_FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1_to_39", "old_id": "FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1"}
{"code": "def count ( a , b ) :\n    m = len ( a )\n    n = len ( b )\n    lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]\n    idx_f6p1 = 0\n    list_b3ze = range ( n + 1 )\n    while idx_f6p1 < len(list_b3ze):\n        i = list_b3ze[idx_f6p1]\n        lookup [ 0 ] [ i ] = 0\n        idx_f6p1 = idx_f6p1 + 1\n    idx_zc9w = 0\n    list_2m71 = range ( m + 1 )\n    while idx_zc9w < len(list_2m71):\n        i = list_2m71[idx_zc9w]\n        lookup [ i ] [ 0 ] = 1\n        idx_zc9w = idx_zc9w + 1\n    idx_4hgx = 0\n    list_s5ap = range ( 1 , m + 1 )\n    while idx_4hgx < len(list_s5ap):\n        i = list_s5ap[idx_4hgx]\n        idx_evg7 = 0\n        list_25c6 = range ( 1 , n + 1 )\n        while idx_evg7 < len(list_25c6):\n            j = list_25c6[idx_evg7]\n            if a [ i - 1 ] == b [ j - 1 ] and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ]; lookup [ i ] [ j ] = lookup [ i ] [ j ] + lookup [ i - 1 ] [ j ]\n            else :\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]\n            idx_evg7 = idx_evg7 + 1\n        idx_4hgx = idx_4hgx + 1\n    return lookup [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1_to_40", "old_id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1"}
{"code": "def findSDSFunc ( n ) :\n    DP = [ 0 ]; DP = DP * ( n + 1 )\n    DP [ 0 ] = 0\n    DP [ 1 ] = 1\n    idx_uryt = 0\n    list_4es8 = range ( 2 , n + 1 )\n    while idx_uryt < len(list_4es8):\n        i = list_4es8[idx_uryt]\n        if ( int ( i % 2 ) == 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            DP [ i ] = DP [ int ( i / 2 ) ]\n        else :\n            DP [ i ] = DP [ int ( ( i - 1 ) / 2 ) ]; DP [ i ] = DP [ i ] + DP [ int ( ( i + 1 ) / 2 ) ]\n        idx_uryt = idx_uryt + 1\n    return DP [ n ]", "id": "AssignUnfoldding_sample_from_FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES_to_41", "old_id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES"}
{"code": "def pairSum ( mat , n , sum ) :\n    idx_41w6 = 0\n    list_yfdt = range ( n )\n    while idx_41w6 < len(list_yfdt):\n        i = list_yfdt[idx_41w6]\n        mat [ i ].sort ( )\n        idx_41w6 = idx_41w6 + 1\n    idx_ni7o = 0\n    list_r3e9 = range ( n - 1 )\n    while idx_ni7o < len(list_r3e9):\n        i = list_r3e9[idx_ni7o]\n        idx_3zxg = 0\n        list_6guw = range ( i + 1 , n )\n        while idx_3zxg < len(list_6guw):\n            j = list_6guw[idx_3zxg]\n            left = 0\n            right = n; right = right - 1\n            while ( left < n and right >= 0 ) :\n                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left += 1\n                    right -= 1\n                else :\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1\n            idx_3zxg = idx_3zxg + 1\n        idx_ni7o = idx_ni7o + 1", "id": "AssignUnfoldding_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_42", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    idx_ykzi = 0\n    list_jt4r = range ( 0 , n )\n    while idx_ykzi < len(list_jt4r):\n        i = list_jt4r[idx_ykzi]\n        high = max ( high , arr [ i ] )\n        idx_ykzi = idx_ykzi + 1\n    count = [ 0 ]; count = count * ( high + 1 )\n    idx_xnw6 = 0\n    list_p3ou = range ( 0 , n )\n    while idx_xnw6 < len(list_p3ou):\n        i = list_p3ou[idx_xnw6]\n        count [ arr [ i ] ] += 1\n        idx_xnw6 = idx_xnw6 + 1\n    counter = 0\n    idx_dws5 = 0\n    list_vltm = range ( high , 0 , - 1 )\n    while idx_dws5 < len(list_vltm):\n        i = list_vltm[idx_dws5]\n        j = i\n        while ( j <= high ) :\n            if ( count [ j ] > 0 ) and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n                counter += count [ j ]\n            j += i\n            if ( counter == 2 ) and (((True or False) and (False or True)) and ((9 > 4) or (9 < 4))):\n                return i\n        counter = 0\n        idx_dws5 = idx_dws5 + 1\n    return 1\n", "id": "AssignUnfoldding_sample_from_FIND_PAIR_MAXIMUM_GCD_ARRAY_1_to_43", "old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY_1"}
{"code": "def subArraySum ( arr , n , sum ) :\n    idx_0kb6 = 0\n    list_5pms = range ( n )\n    while idx_0kb6 < len(list_5pms):\n        i = list_5pms[idx_0kb6]\n        curr_sum = arr [ i ]\n        j = i; j = j + 1\n        while j <= n :\n            if curr_sum == sum and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                print ( \"Sum found between\" )\n                print ( \"indexes %d and %d\" % ( i , j - 1 ) )\n                return 1\n            if curr_sum > sum or j == n and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n                break\n            curr_sum = curr_sum + arr [ j ]\n            j += 1\n        idx_0kb6 = idx_0kb6 + 1\n    print ( \"No subarray found\" )\n    return 0", "id": "AssignUnfoldding_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_to_44", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM"}
{"code": "def evenSum ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    idx_m93d = 0\n    list_u3ev = range ( 0 , n + 1 )\n    while idx_m93d < len(list_u3ev):\n        i = list_u3ev[idx_m93d]\n        idx_4289 = 0\n        list_udwe = range ( 0 , min ( i , n ) + 1 )\n        while idx_4289 < len(list_udwe):\n            j = list_udwe[idx_4289]\n            if j == 0 or j == i and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            idx_4289 = idx_4289 + 1\n        idx_m93d = idx_m93d + 1\n    sum = 0 ;\n    idx_fhx7 = 0\n    list_ibu3 = range ( 0 , n + 1 )\n    while idx_fhx7 < len(list_ibu3):\n        i = list_ibu3[idx_fhx7]\n        if i % 2 == 0 and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n            sum = sum + C [ n ] [ i ]\n        idx_fhx7 = idx_fhx7 + 1\n    return sum", "id": "AssignUnfoldding_sample_from_FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_to_45", "old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS"}
{"code": "def findSubarraySum ( arr , n ) :\n    res = 0\n    m = dict ( )\n    idx_923b = 0\n    list_nf7e = range ( n )\n    while idx_923b < len(list_nf7e):\n        i = list_nf7e[idx_923b]\n        Sum = 0\n        idx_30ro = 0\n        list_n5ji = range ( i , n )\n        while idx_30ro < len(list_n5ji):\n            j = list_n5ji[idx_30ro]\n            Sum += arr [ j ]\n            m [ Sum ] = m.get ( Sum , 0 ); m [ Sum ] = m [ Sum ] + 1\n            idx_30ro = idx_30ro + 1\n        idx_923b = idx_923b + 1\n    idx_9xse = 0\n    list_0cqr = m\n    while idx_9xse < len(list_0cqr):\n        x = list_0cqr[idx_9xse]\n        if m [ x ] == 1 and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            res += x\n        idx_9xse = idx_9xse + 1\n    return res", "id": "AssignUnfoldding_sample_from_FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY_to_46", "old_id": "FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY"}
{"code": "def findElement ( arr , n ) :\n    leftMax = [ None ]; leftMax = leftMax * n\n    leftMax [ 0 ] = float ( '-inf' )\n    idx_gszl = 0\n    list_tadm = range ( 1 , n )\n    while idx_gszl < len(list_tadm):\n        i = list_tadm[idx_gszl]\n        leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] )\n        idx_gszl = idx_gszl + 1\n    rightMin = float ( 'inf' )\n    idx_euc4 = 0\n    list_ot0f = range ( n - 1 , - 1 , - 1 )\n    while idx_euc4 < len(list_ot0f):\n        i = list_ot0f[idx_euc4]\n        if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            return i\n        rightMin = min ( rightMin , arr [ i ] )\n        idx_euc4 = idx_euc4 + 1\n    return - 1", "id": "AssignUnfoldding_sample_from_FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT_to_47", "old_id": "FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    idx_rgm5 = 0\n    list_0cex = range ( 0 , n - 1 )\n    while idx_rgm5 < len(list_0cex):\n        i = list_0cex[idx_rgm5]\n        l = i; l = l + 1\n        r = n; r = r - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if ( x + arr [ l ] + arr [ r ] == 0 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n            elif ( x + arr [ l ] + arr [ r ] < 0 ) :\n                l += 1\n            else :\n                r -= 1\n        idx_rgm5 = idx_rgm5 + 1\n    if ( found == False ) and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n        print ( \" No Triplet Found\" )", "id": "AssignUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_48", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n        return \"-1\"\n    result = [ None ]; result = result * ( n + 1 )\n    count = 1\n    idx_ukm2 = 0\n    list_89op = range ( n + 1 )\n    while idx_ukm2 < len(list_89op):\n        i = list_89op[idx_ukm2]\n        if ( i == n or seq [ i ] == 'I' ) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n            idx_24tk = 0\n            list_el8g = range ( i - 1 , - 2 , - 1 )\n            while idx_24tk < len(list_el8g):\n                j = list_el8g[idx_24tk]\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n                idx_24tk = idx_24tk + 1\n        idx_ukm2 = idx_ukm2 + 1\n    return result", "id": "AssignUnfoldding_sample_from_FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1_to_49", "old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1"}
{"code": "def countFriendsPairings ( n ) :\n    dp = [ 0 for i in range ( n + 1 ) ]\n    idx_yc2w = 0\n    list_7v6s = range ( n + 1 )\n    while idx_yc2w < len(list_7v6s):\n        i = list_7v6s[idx_yc2w]\n        if ( i <= 2 ) and (((True or False) and (False or True)) and ((8 > 2) or (8 < 2))):\n            dp [ i ] = i\n        else :\n            dp [ i ] = dp [ i - 1 ]; dp [ i ] = dp [ i ] + ( i - 1 ) * dp [ i - 2 ]\n        idx_yc2w = idx_yc2w + 1\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_FRIENDS_PAIRING_PROBLEM_to_50", "old_id": "FRIENDS_PAIRING_PROBLEM"}
{"code": "def countFriendsPairings ( n ) :\n    a , b , c = 1 , 2 , 0\n    if ( n <= 2 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return n\n    idx_1c5v = 0\n    list_wflo = range ( 3 , n + 1 )\n    while idx_1c5v < len(list_wflo):\n        i = list_wflo[idx_1c5v]\n        c = b; c = c + ( i - 1 ) * a\n        a = b\n        b = c\n        idx_1c5v = idx_1c5v + 1\n    return c", "id": "AssignUnfoldding_sample_from_FRIENDS_PAIRING_PROBLEM_2_to_51", "old_id": "FRIENDS_PAIRING_PROBLEM_2"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        return \"-1\"\n    result = [ None ]; result = result * ( n + 1 )\n    count = 1\n    idx_kmbv = 0\n    list_6rpj = range ( n + 1 )\n    while idx_kmbv < len(list_6rpj):\n        i = list_6rpj[idx_kmbv]\n        if ( i == n or seq [ i ] == 'I' ) and (((True or False) and (False or True)) and ((9 > 0) or (9 < 0))):\n            idx_9slk = 0\n            list_f8zx = range ( i - 1 , - 2 , - 1 )\n            while idx_9slk < len(list_f8zx):\n                j = list_f8zx[idx_9slk]\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n                idx_9slk = idx_9slk + 1\n        idx_kmbv = idx_kmbv + 1\n    return \"\".join(str(i) for i in result)", "id": "AssignUnfoldding_sample_from_GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1_to_52", "old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1"}
{"code": "def isSubSeqDivisible ( str ) :\n    l = len ( str )\n    arr = [ 0 ]; arr = arr * l\n    idx_stvj = 0\n    list_xpwf = range ( 0 , l )\n    while idx_stvj < len(list_xpwf):\n        i = list_xpwf[idx_stvj]\n        idx_sd7z = 0\n        list_y61i = range ( i , l )\n        while idx_sd7z < len(list_y61i):\n            j = list_y61i[idx_sd7z]\n            idx_cth5 = 0\n            list_f9rm = range ( j , l )\n            while idx_cth5 < len(list_f9rm):\n                k = list_f9rm[idx_cth5]\n                if ( arr [ i ] % 8 == 0 ) and (((True or False) and (False or True)) and ((9 > 1) or (9 < 1))):\n                    return True\n                elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :\n                    return True\n                elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :\n                    return True\n                idx_cth5 = idx_cth5 + 1\n            idx_sd7z = idx_sd7z + 1\n        idx_stvj = idx_stvj + 1\n    return False", "id": "AssignUnfoldding_sample_from_GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_to_53", "old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ]; maxRev = maxRev * ( m + 1 )\n    nxtbb = 0\n    idx_26d3 = 0\n    list_jcdg = range ( 1 , m + 1 )\n    while idx_26d3 < len(list_jcdg):\n        i = list_jcdg[idx_26d3]\n        if ( nxtbb < n ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb += 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n        idx_26d3 = idx_26d3 + 1\n    return maxRev [ m ]", "id": "AssignUnfoldding_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_54", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    idx_elxv = 0\n    list_ya6d = arr\n    while idx_elxv < len(list_ya6d):\n        i = list_ya6d[idx_elxv]\n        if ( i < 0 ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] -= 1\n        else :\n            hash [ i ] = hash.get ( i , 0 ); hash [ i ] = hash [ i ] + 1\n        idx_elxv = idx_elxv + 1\n    idx_j6vh = 0\n    list_dn3c = arr\n    while idx_j6vh < len(list_dn3c):\n        i = list_dn3c[idx_j6vh]\n        if i in hash.keys ( ) and hash [ i ] > 0 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            return i\n        idx_j6vh = idx_j6vh + 1\n    return - 1", "id": "AssignUnfoldding_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_55", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def kthLargestSum ( arr , n , k ) :\n    sum = [ ]\n    sum.append ( 0 )\n    sum.append ( arr [ 0 ] )\n    idx_63f8 = 0\n    list_d2br = range ( 2 , n + 1 )\n    while idx_63f8 < len(list_d2br):\n        i = list_d2br[idx_63f8]\n        sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )\n        idx_63f8 = idx_63f8 + 1\n    Q = [ ]\n    heapq.heapify ( Q )\n    idx_zrcp = 0\n    list_wora = range ( 1 , n + 1 )\n    while idx_zrcp < len(list_wora):\n        i = list_wora[idx_zrcp]\n        idx_9087 = 0\n        list_hag3 = range ( i , n + 1 )\n        while idx_9087 < len(list_hag3):\n            j = list_hag3[idx_9087]\n            x = sum [ j ]; x = x - sum [ i - 1 ]\n            if len ( Q ) < k and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n                heapq.heappush ( Q , x )\n            else :\n                if Q [ 0 ] < x :\n                    heapq.heappop ( Q )\n                    heapq.heappush ( Q , x )\n            idx_9087 = idx_9087 + 1\n        idx_zrcp = idx_zrcp + 1\n    return Q [ 0 ]", "id": "AssignUnfoldding_sample_from_K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY_to_56", "old_id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY"}
{"code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    idx_d7l5 = 0\n    list_ype1 = range ( 0 , n - 1 )\n    while idx_d7l5 < len(list_ype1):\n        i = list_ype1[idx_d7l5]\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        idx_lxky = 0\n        list_5l0d = range ( i + 1 , n )\n        while idx_lxky < len(list_5l0d):\n            j = list_5l0d[idx_lxky]\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n                maxsize = j - i; maxsize = maxsize + 1\n                startindex = i\n            idx_lxky = idx_lxky + 1\n        idx_d7l5 = idx_d7l5 + 1\n    if ( maxsize == - 1 ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        print ( \"No such subarray\" )\n    else :\n        print ( startindex , \"to\" , startindex + maxsize - 1 )\n    return maxsize", "id": "AssignUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_57", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    idx_dkpt = 0\n    list_vno4 = range ( 0 , n )\n    while idx_dkpt < len(list_vno4):\n        i = list_vno4[idx_dkpt]\n        if ( arr [ i ] == 0 ) and (((True or False) and (False or True)) and ((9 > 1) or (9 < 1))):\n            arr [ i ] = - 1\n        else :\n            arr [ i ] = 1\n        idx_dkpt = idx_dkpt + 1\n    idx_km9g = 0\n    list_4xzo = range ( 0 , n )\n    while idx_km9g < len(list_4xzo):\n        i = list_4xzo[idx_km9g]\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            max_len = i; max_len = max_len + 1\n            ending_index = i\n        if ( curr_sum + n ) in hash_map and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i; max_len = max_len - hash_map [ curr_sum + n ]\n                ending_index = i\n        else :\n            hash_map[curr_sum + n] = i\n        idx_km9g = idx_km9g + 1\n    idx_34eq = 0\n    list_ulw9 = range ( 0 , n )\n    while idx_34eq < len(list_ulw9):\n        i = list_ulw9[idx_34eq]\n        if ( arr [ i ] == - 1 ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            arr [ i ] = 0\n        else :\n            arr [ i ] = 1\n        idx_34eq = idx_34eq + 1\n    print ( ending_index - max_len + 1 , end = \" \" )\n    print ( \"to\" , end = \" \" )\n    print ( ending_index )\n    return max_len", "id": "AssignUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_58", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def longestSubsequenceCommonSegment ( k , s1 , s2 ) :\n    n = len ( s1 )\n    m = len ( s2 )\n    lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    idx_unjc = 0\n    list_cpn7 = range ( 1 , n + 1 )\n    while idx_unjc < len(list_cpn7):\n        i = list_cpn7[idx_unjc]\n        idx_efak = 0\n        list_vmp7 = range ( 1 , m + 1 )\n        while idx_efak < len(list_vmp7):\n            j = list_vmp7[idx_efak]\n            lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] )\n            if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ]; cnt [ i ] [ j ] = cnt [ i ] [ j ] + 1\n            if ( cnt [ i ] [ j ] >= k ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n                idx_2hj9 = 0\n                list_acev = range ( k , cnt [ i ] [ j ] + 1 )\n                while idx_2hj9 < len(list_acev):\n                    a = list_acev[idx_2hj9]\n                    lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a )\n                    idx_2hj9 = idx_2hj9 + 1\n            idx_efak = idx_efak + 1\n        idx_unjc = idx_unjc + 1\n    return lcs [ n ] [ m ]", "id": "AssignUnfoldding_sample_from_LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K_to_59", "old_id": "LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K"}
{"code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    idx_z750 = 0\n    list_frkd = range ( n - 1 )\n    while idx_z750 < len(list_frkd):\n        i = list_frkd[idx_z750]\n        if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n            dp [ i ] [ i + 1 ] = 2\n        idx_z750 = idx_z750 + 1\n    idx_x1mw = 0\n    list_f9mn = range ( 2 , n )\n    while idx_x1mw < len(list_f9mn):\n        l = list_f9mn[idx_x1mw]\n        i = - 1\n        idx_yk6d = 0\n        list_co5v = range ( l , n )\n        while idx_yk6d < len(list_co5v):\n            j = list_co5v[idx_yk6d]\n            i += 1\n            if ( s [ i ] == '(' and s [ j ] == ')' ) and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n                dp [ i ] [ j ] = 2; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i + 1 ] [ j - 1 ]\n            idx_1ivl = 0\n            list_az8x = range ( i , j )\n            while idx_1ivl < len(list_az8x):\n                k = list_az8x[idx_1ivl]\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n                idx_1ivl = idx_1ivl + 1\n            idx_yk6d = idx_yk6d + 1\n        idx_x1mw = idx_x1mw + 1\n    return dp [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_to_60", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    idx_2acu = 0\n    list_c85g = range ( n )\n    while idx_2acu < len(list_c85g):\n        i = list_c85g[idx_2acu]\n        L [ i ] [ n - 1 ] = 2\n        idx_2acu = idx_2acu + 1\n    idx_1u85 = 0\n    list_hqcb = range ( n - 2 , 0 , - 1 )\n    while idx_1u85 < len(list_hqcb):\n        j = list_hqcb[idx_1u85]\n        i = j; i = i - 1\n        k = j; k = k + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) and (((True or False) and (False or True)) and ((9 > 1) or (9 < 1))):\n                k += 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ]; L [ i ] [ j ] = L [ i ] [ j ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i -= 1\n        idx_1u85 = idx_1u85 + 1\n    return llap", "id": "AssignUnfoldding_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_61", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def LCSubStr ( X , Y , m , n ) :\n    LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ]\n    result = 0\n    idx_kdz5 = 0\n    list_wb36 = range ( m + 1 )\n    while idx_kdz5 < len(list_wb36):\n        i = list_wb36[idx_kdz5]\n        idx_5m89 = 0\n        list_h1aq = range ( n + 1 )\n        while idx_5m89 < len(list_h1aq):\n            j = list_h1aq[idx_5m89]\n            if ( i == 0 or j == 0 ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n                LCSuff [ i ] [ j ] = 0\n            elif ( X [ i - 1 ] == Y [ j - 1 ] ) :\n                LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ]; LCSuff [ i ] [ j ] = LCSuff [ i ] [ j ] + 1\n                result = max ( result , LCSuff [ i ] [ j ] )\n            else :\n                LCSuff [ i ] [ j ] = 0\n            idx_5m89 = idx_5m89 + 1\n        idx_kdz5 = idx_kdz5 + 1\n    return result", "id": "AssignUnfoldding_sample_from_LONGEST_COMMON_SUBSTRING_to_62", "old_id": "LONGEST_COMMON_SUBSTRING"}
{"code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    idx_96di = 0\n    list_h0eq = range ( 0 , n )\n    while idx_96di < len(list_h0eq):\n        i = list_h0eq[idx_96di]\n        idx_rs7t = 0\n        list_br1t = range ( i + 1 , n , 2 )\n        while idx_rs7t < len(list_br1t):\n            j = list_br1t[idx_rs7t]\n            length = j - i; length = length + 1\n            leftsum = 0\n            rightsum = 0\n            idx_za7q = 0\n            list_xerb = range ( 0 , int ( length / 2 ) )\n            while idx_za7q < len(list_xerb):\n                k = list_xerb[idx_za7q]\n                leftsum += ( int ( str [ i + k ] ) - int ( '0' ) )\n                rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) )\n                idx_za7q = idx_za7q + 1\n            if ( leftsum == rightsum and maxlen < length ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                maxlen = length\n            idx_rs7t = idx_rs7t + 1\n        idx_96di = idx_96di + 1\n    return maxlen", "id": "AssignUnfoldding_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_to_63", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF"}
{"code": "def findLength ( string ) :\n    n = len ( string )\n    maxlen = 0\n    Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    idx_qjsw = 0\n    list_t534 = range ( 0 , n )\n    while idx_qjsw < len(list_t534):\n        i = list_t534[idx_qjsw]\n        Sum [ i ] [ i ] = int ( string [ i ] )\n        idx_qjsw = idx_qjsw + 1\n    idx_o04i = 0\n    list_mq2e = range ( 2 , n + 1 )\n    while idx_o04i < len(list_mq2e):\n        length = list_mq2e[idx_o04i]\n        idx_fpcm = 0\n        list_gqdi = range ( 0 , n - length + 1 )\n        while idx_fpcm < len(list_gqdi):\n            i = list_gqdi[idx_fpcm]\n            j = i + length; j = j - 1\n            k = length; k = k // 2\n            Sum [ i ] [ j ] = Sum [ i ] [ j - k ]; Sum [ i ] [ j ] = Sum [ i ] [ j ] + Sum [ j - k + 1 ] [ j ]\n            if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n                maxlen = length\n            idx_fpcm = idx_fpcm + 1\n        idx_o04i = idx_o04i + 1\n    return maxlen", "id": "AssignUnfoldding_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1_to_64", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1"}
{"code": "def longOddEvenIncSeq ( arr , n ) :\n    lioes = list ( )\n    maxLen = 0\n    idx_93bk = 0\n    list_0ckp = range ( n )\n    while idx_93bk < len(list_0ckp):\n        i = list_0ckp[idx_93bk]\n        lioes.append ( 1 )\n        idx_93bk = idx_93bk + 1\n    i = 1\n    idx_3epc = 0\n    list_1lwf = range ( n )\n    while idx_3epc < len(list_1lwf):\n        i = list_1lwf[idx_3epc]\n        idx_hzbq = 0\n        list_9x0w = range ( i )\n        while idx_hzbq < len(list_9x0w):\n            j = list_9x0w[idx_hzbq]\n            if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n                lioes [ i ] = lioes [ j ]; lioes [ i ] = lioes [ i ] + 1\n            idx_hzbq = idx_hzbq + 1\n        idx_3epc = idx_3epc + 1\n    idx_t935 = 0\n    list_9g5z = range ( n )\n    while idx_t935 < len(list_9g5z):\n        i = list_9g5z[idx_t935]\n        if maxLen < lioes [ i ] and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n            maxLen = lioes [ i ]\n        idx_t935 = idx_t935 + 1\n    return maxLen", "id": "AssignUnfoldding_sample_from_LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE_to_65", "old_id": "LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE"}
{"code": "def lis ( arr , n ) :\n    lis = [ 1 ]; lis = lis * n\n    idx_g8ka = 0\n    list_rl5f = range ( 1 , n )\n    while idx_g8ka < len(list_rl5f):\n        i = list_rl5f[idx_g8ka]\n        idx_mnj2 = 0\n        list_uycq = range ( 0 , i )\n        while idx_mnj2 < len(list_uycq):\n            j = list_uycq[idx_mnj2]\n            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n            idx_mnj2 = idx_mnj2 + 1\n        idx_g8ka = idx_g8ka + 1\n    maximum = 0\n    idx_xmb9 = 0\n    list_twmi = range ( n )\n    while idx_xmb9 < len(list_twmi):\n        i = list_twmi[idx_xmb9]\n        maximum = max ( maximum , lis [ i ] )\n        idx_xmb9 = idx_xmb9 + 1\n    return maximum", "id": "AssignUnfoldding_sample_from_LONGEST_INCREASING_SUBSEQUENCE_1_to_66", "old_id": "LONGEST_INCREASING_SUBSEQUENCE_1"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_l289 = 0\n    list_lha8 = range ( 1 , n + 1 )\n    while idx_l289 < len(list_lha8):\n        i = list_lha8[idx_l289]\n        idx_jpmz = 0\n        list_06x7 = range ( 1 , n + 1 )\n        while idx_jpmz < len(list_06x7):\n            j = list_06x7[idx_jpmz]\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n                dp [ i ] [ j ] = 1; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            idx_jpmz = idx_jpmz + 1\n        idx_l289 = idx_l289 + 1\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n            i -= 1\n        else :\n            j -= 1\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "AssignUnfoldding_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_67", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def findLongestRepeatingSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 ] * ( n + 1 ) ]; dp = dp * ( n + 1 )\n    idx_tdv9 = 0\n    list_wa3e = range ( 1 , n + 1 )\n    while idx_tdv9 < len(list_wa3e):\n        i = list_wa3e[idx_tdv9]\n        idx_t5dg = 0\n        list_objf = range ( 1 , n + 1 )\n        while idx_t5dg < len(list_objf):\n            j = list_objf[idx_t5dg]\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                dp [ i ] [ j ] = 1; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            idx_t5dg = idx_t5dg + 1\n        idx_tdv9 = idx_tdv9 + 1\n    return dp [ n ] [ n ]", "id": "AssignUnfoldding_sample_from_LONGEST_REPEATING_SUBSEQUENCE_to_68", "old_id": "LONGEST_REPEATING_SUBSEQUENCE"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    idx_5pk7 = 0\n    list_507o = range ( n )\n    while idx_5pk7 < len(list_507o):\n        i = list_507o[idx_5pk7]\n        if arr [ i ] == 0 and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n            sum += - 1\n        else :\n            sum += 1\n        if ( sum == 1 ) and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n            maxLen = i; maxLen = maxLen + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i; maxLen = maxLen - um [ sum - 1 ]\n        idx_5pk7 = idx_5pk7 + 1\n    return maxLen", "id": "AssignUnfoldding_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_69", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    idx_rgpc = 0\n    list_ro92 = range ( n )\n    while idx_rgpc < len(list_ro92):\n        i = list_ro92[idx_rgpc]\n        curr_sum += arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ); mod_arr [ i ] = mod_arr [ i ] % k\n        idx_rgpc = idx_rgpc + 1\n    idx_m1n7 = 0\n    list_fxt8 = range ( n )\n    while idx_m1n7 < len(list_fxt8):\n        i = list_fxt8[idx_m1n7]\n        if ( mod_arr [ i ] == 0 ) and (((True or False) and (False or True)) and ((9 > 7) or (9 < 7))):\n            max = i; max = max + 1\n        elif ( mod_arr [ i ] in um ) :\n            um [ mod_arr [ i ] ] = i\n        else :\n            if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                max = i; max = max - um [ mod_arr [ i ] ]\n        idx_m1n7 = idx_m1n7 + 1\n    return max", "id": "AssignUnfoldding_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_70", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def longLenSub ( arr , n ) :\n    um = defaultdict ( lambda : 0 )\n    longLen = 0\n    idx_4oyl = 0\n    list_c1f4 = range ( n )\n    while idx_4oyl < len(list_c1f4):\n        i = list_c1f4[idx_4oyl]\n        len1 = 0\n        if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n            len1 = um [ arr [ i ] - 1 ]\n        if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            len1 = um [ arr [ i ] + 1 ]\n        um [ arr [ i ] ] = len1; um [ arr [ i ] ] = um [ arr [ i ] ] + 1\n        if longLen < um [ arr [ i ] ] and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n            longLen = um [ arr [ i ] ]\n        idx_4oyl = idx_4oyl + 1\n    return longLen", "id": "AssignUnfoldding_sample_from_LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2_to_71", "old_id": "LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2"}
{"code": "def maxcoefficientvalue ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    idx_ztv3 = 0\n    list_y5mu = range ( n + 1 )\n    while idx_ztv3 < len(list_y5mu):\n        i = list_y5mu[idx_ztv3]\n        idx_s4xa = 0\n        list_is42 = range ( min ( i , n ) + 1 )\n        while idx_s4xa < len(list_is42):\n            j = list_is42[idx_s4xa]\n            if ( j == 0 or j == i ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            idx_s4xa = idx_s4xa + 1\n        idx_ztv3 = idx_ztv3 + 1\n    maxvalue = 0\n    idx_awjx = 0\n    list_xi97 = range ( n + 1 )\n    while idx_awjx < len(list_xi97):\n        i = list_xi97[idx_awjx]\n        maxvalue = max ( maxvalue , C [ n ] [ i ] )\n        idx_awjx = idx_awjx + 1\n    return maxvalue", "id": "AssignUnfoldding_sample_from_MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE_to_72", "old_id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE"}
{"code": "def maxRowDiff ( mat , m , n ) :\n    rowSum = [ 0 ]; rowSum = rowSum * m\n    idx_mn26 = 0\n    list_8r20 = range ( 0 , m )\n    while idx_mn26 < len(list_8r20):\n        i = list_8r20[idx_mn26]\n        sum = 0\n        idx_c74t = 0\n        list_9x5q = range ( 0 , n )\n        while idx_c74t < len(list_9x5q):\n            j = list_9x5q[idx_c74t]\n            sum += mat [ i ] [ j ]\n            idx_c74t = idx_c74t + 1\n        rowSum [ i ] = sum\n        idx_mn26 = idx_mn26 + 1\n    max_diff = rowSum [ 1 ]; max_diff = max_diff - rowSum [ 0 ]\n    min_element = rowSum [ 0 ]\n    idx_5n96 = 0\n    list_x9m6 = range ( 1 , m )\n    while idx_5n96 < len(list_x9m6):\n        i = list_x9m6[idx_5n96]\n        if ( rowSum [ i ] - min_element > max_diff ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            max_diff = rowSum [ i ]; max_diff = max_diff - min_element\n        if ( rowSum [ i ] < min_element ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            min_element = rowSum [ i ]\n        idx_5n96 = idx_5n96 + 1\n    return max_diff", "id": "AssignUnfoldding_sample_from_MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX_to_73", "old_id": "MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX"}
{"code": "def maxLenSub ( arr , n ) :\n    mls = [ ]\n    max = 0\n    idx_812j = 0\n    list_pfgw = range ( n )\n    while idx_812j < len(list_pfgw):\n        i = list_pfgw[idx_812j]\n        mls.append ( 1 )\n        idx_812j = idx_812j + 1\n    idx_qa17 = 0\n    list_pn5q = range ( n )\n    while idx_qa17 < len(list_pn5q):\n        i = list_pn5q[idx_qa17]\n        idx_bhav = 0\n        list_pbjm = range ( i )\n        while idx_bhav < len(list_pbjm):\n            j = list_pbjm[idx_bhav]\n            if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n                mls [ i ] = mls [ j ]; mls [ i ] = mls [ i ] + 1\n            idx_bhav = idx_bhav + 1\n        idx_qa17 = idx_qa17 + 1\n    idx_x3y1 = 0\n    list_j0xd = range ( n )\n    while idx_x3y1 < len(list_j0xd):\n        i = list_j0xd[idx_x3y1]\n        if ( max < mls [ i ] ) and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n            max = mls [ i ]\n        idx_x3y1 = idx_x3y1 + 1\n    return max", "id": "AssignUnfoldding_sample_from_MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1_to_74", "old_id": "MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1"}
{"code": "def maxNumOfChocolates ( arr , n , k ) :\n    um , curr_rem , maxSum = { } , 0 , 0\n    sm = [ 0 ]; sm = sm * n\n    sm [ 0 ] = arr [ 0 ]\n    idx_wzbc = 0\n    list_pxmt = range ( 1 , n )\n    while idx_wzbc < len(list_pxmt):\n        i = list_pxmt[idx_wzbc]\n        sm [ i ] = sm [ i - 1 ]; sm [ i ] = sm [ i ] + arr [ i ]\n        idx_wzbc = idx_wzbc + 1\n    idx_4jly = 0\n    list_b47a = range ( n )\n    while idx_4jly < len(list_b47a):\n        i = list_b47a[idx_4jly]\n        curr_rem = sm [ i ]; curr_rem = curr_rem % k\n        if ( not curr_rem and maxSum < sm [ i ] ) and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            maxSum = sm [ i ]\n        elif ( not curr_rem in um ) :\n            um [ curr_rem ] = i\n        elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :\n            maxSum = sm [ i ]; maxSum = maxSum - sm [ um [ curr_rem ] ]\n        idx_4jly = idx_4jly + 1\n    return maxSum // k", "id": "AssignUnfoldding_sample_from_MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS_to_75", "old_id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS"}
{"code": "def maximumSegments ( n , a , b , c ) :\n    dp = [ - 1 ]; dp = dp * ( n + 10 )\n    dp [ 0 ] = 0\n    idx_fzhr = 0\n    list_3qov = range ( 0 , n )\n    while idx_fzhr < len(list_3qov):\n        i = list_3qov[idx_fzhr]\n        if ( dp [ i ] != - 1 ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            if ( i + a <= n ) :\n                dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] )\n            if ( i + b <= n ) :\n                dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] )\n            if ( i + c <= n ) :\n                dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] )\n        idx_fzhr = idx_fzhr + 1\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C_to_76", "old_id": "MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C"}
{"code": "def lis ( arr , n ) :\n    mpis = [ 0 ]; mpis = mpis * ( n )\n    idx_7r8s = 0\n    list_lo6u = range ( n )\n    while idx_7r8s < len(list_lo6u):\n        i = list_lo6u[idx_7r8s]\n        mpis [ i ] = arr [ i ]\n        idx_7r8s = idx_7r8s + 1\n    idx_o60j = 0\n    list_76r2 = range ( 1 , n )\n    while idx_o60j < len(list_76r2):\n        i = list_76r2[idx_o60j]\n        idx_uts0 = 0\n        list_nifk = range ( i )\n        while idx_uts0 < len(list_nifk):\n            j = list_nifk[idx_uts0]\n            if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n                mpis [ i ] = mpis [ j ]; mpis [ i ] = mpis [ i ] * arr [ i ]\n            idx_uts0 = idx_uts0 + 1\n        idx_o60j = idx_o60j + 1\n    return max ( mpis )", "id": "AssignUnfoldding_sample_from_MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE_to_77", "old_id": "MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE"}
{"code": "def maxProfit ( price , n ) :\n    profit = [ 0 ]; profit = profit * n\n    max_price = price [ n - 1 ]\n    idx_0j75 = 0\n    list_jl4g = range ( n - 2 , 0 , - 1 )\n    while idx_0j75 < len(list_jl4g):\n        i = list_jl4g[idx_0j75]\n        if price [ i ] > max_price and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            max_price = price [ i ]\n        profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] )\n        idx_0j75 = idx_0j75 + 1\n    min_price = price [ 0 ]\n    idx_90vr = 0\n    list_kmq4 = range ( 1 , n )\n    while idx_90vr < len(list_kmq4):\n        i = list_kmq4[idx_90vr]\n        if price [ i ] < min_price and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n            min_price = price [ i ]\n        profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) )\n        idx_90vr = idx_90vr + 1\n    result = profit [ n - 1 ]\n    return result", "id": "AssignUnfoldding_sample_from_MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE_to_78", "old_id": "MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE"}
{"code": "def maxSumWO3Consec ( arr , n ) :\n    sum = [ 0 for k in range ( n ) ]\n    if n >= 1 and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n        sum [ 0 ] = arr [ 0 ]\n    if n >= 2 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        sum [ 1 ] = arr [ 0 ]; sum [ 1 ] = sum [ 1 ] + arr [ 1 ]\n    if n > 2 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n        sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) )\n    idx_69rz = 0\n    list_7g2h = range ( 3 , n )\n    while idx_69rz < len(list_7g2h):\n        i = list_7g2h[idx_69rz]\n        sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] )\n        idx_69rz = idx_69rz + 1\n    return sum [ n - 1 ]", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_to_79", "old_id": "MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE"}
{"code": "def maxSumBitonicSubArr ( arr , n ) :\n    msis = [ None ]; msis = msis * n\n    msds = [ None ]; msds = msds * n\n    max_sum = 0\n    msis [ 0 ] = arr [ 0 ]\n    idx_bctm = 0\n    list_90k7 = range ( 1 , n )\n    while idx_bctm < len(list_90k7):\n        i = list_90k7[idx_bctm]\n        if ( arr [ i ] > arr [ i - 1 ] ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            msis [ i ] = msis [ i - 1 ]; msis [ i ] = msis [ i ] + arr [ i ]\n        else :\n            msis [ i ] = arr [ i ]\n        idx_bctm = idx_bctm + 1\n    msds [ n - 1 ] = arr [ n - 1 ]\n    idx_r6bm = 0\n    list_3n1d = range ( n - 2 , - 1 , - 1 )\n    while idx_r6bm < len(list_3n1d):\n        i = list_3n1d[idx_r6bm]\n        if ( arr [ i ] > arr [ i + 1 ] ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n            msds [ i ] = msds [ i + 1 ]; msds [ i ] = msds [ i ] + arr [ i ]\n        else :\n            msds [ i ] = arr [ i ]\n        idx_r6bm = idx_r6bm + 1\n    idx_yun1 = 0\n    list_tsn1 = range ( n )\n    while idx_yun1 < len(list_tsn1):\n        i = list_tsn1[idx_yun1]\n        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) and (((True or False) and (False or True)) and ((9 > 7) or (9 < 7))):\n            max_sum = msis [ i ] + msds [ i ]; max_sum = max_sum - arr [ i ]\n        idx_yun1 = idx_yun1 + 1\n    return max_sum", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_BITONIC_SUBARRAY_to_80", "old_id": "MAXIMUM_SUM_BITONIC_SUBARRAY"}
{"code": "def maxSumPairWithDifferenceLessThanK ( arr , N , K ) :\n    arr.sort ( )\n    dp = [ 0 ]; dp = dp * N\n    dp [ 0 ] = 0\n    idx_qewi = 0\n    list_kxdp = range ( 1 , N )\n    while idx_qewi < len(list_kxdp):\n        i = list_kxdp[idx_qewi]\n        dp [ i ] = dp [ i - 1 ]\n        if ( arr [ i ] - arr [ i - 1 ] < K ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n            if ( i >= 2 ) :\n                dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] )\n            else :\n                dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] )\n        idx_qewi = idx_qewi + 1\n    return dp [ N - 1 ]", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_to_81", "old_id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE"}
{"code": "def maxTripletSum ( arr , n ) :\n    sm = - 1000000\n    idx_8kcw = 0\n    list_rdy6 = range ( 0 , n )\n    while idx_8kcw < len(list_rdy6):\n        i = list_rdy6[idx_8kcw]\n        idx_w6x3 = 0\n        list_i4gj = range ( i + 1 , n )\n        while idx_w6x3 < len(list_i4gj):\n            j = list_i4gj[idx_w6x3]\n            idx_p8mv = 0\n            list_kovg = range ( j + 1 , n )\n            while idx_p8mv < len(list_kovg):\n                k = list_kovg[idx_p8mv]\n                if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n                    sm = arr [ i ] + arr [ j ]; sm = sm + arr [ k ]\n                idx_p8mv = idx_p8mv + 1\n            idx_w6x3 = idx_w6x3 + 1\n        idx_8kcw = idx_8kcw + 1\n    return sm", "id": "AssignUnfoldding_sample_from_MAXIMUM_TRIPLET_SUM_ARRAY_to_82", "old_id": "MAXIMUM_TRIPLET_SUM_ARRAY"}
{"code": "def maxCost ( mat , N ) :\n    dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ]\n    dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]\n    idx_w6ic = 0\n    list_y0vq = range ( 1 , N )\n    while idx_w6ic < len(list_y0vq):\n        i = list_y0vq[idx_w6ic]\n        dp [ i ] [ 0 ] = mat [ i ] [ 0 ]; dp [ i ] [ 0 ] = dp [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ]\n        idx_w6ic = idx_w6ic + 1\n    idx_pvxj = 0\n    list_p14q = range ( 1 , N )\n    while idx_pvxj < len(list_p14q):\n        i = list_p14q[idx_pvxj]\n        idx_5amh = 0\n        list_yc3o = range ( 1 , min ( i + 1 , N ) )\n        while idx_5amh < len(list_yc3o):\n            j = list_yc3o[idx_5amh]\n            dp [ i ] [ j ] = mat [ i ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] + \\\n                max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            idx_5amh = idx_5amh + 1\n        idx_pvxj = idx_pvxj + 1\n    result = 0\n    idx_wgay = 0\n    list_fze6 = range ( N )\n    while idx_wgay < len(list_fze6):\n        i = list_fze6[idx_wgay]\n        if ( result < dp [ N - 1 ] [ i ] ) and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n            result = dp [ N - 1 ] [ i ]\n        idx_wgay = idx_wgay + 1\n    return result", "id": "AssignUnfoldding_sample_from_MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX_to_83", "old_id": "MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX"}
{"code": "def getMinDiff ( arr , n , k ) :\n    if ( n == 1 ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n        return 0\n    arr.sort ( )\n    ans = arr [ n - 1 ]; ans = ans - arr [ 0 ]\n    small = arr [ 0 ]; small = small + k\n    big = arr [ n - 1 ]; big = big - k\n    if ( small > big ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        small , big = big , small\n    idx_1hj3 = 0\n    list_8eyk = range ( 1 , n - 1 )\n    while idx_1hj3 < len(list_8eyk):\n        i = list_8eyk[idx_1hj3]\n        subtract = arr [ i ]; subtract = subtract - k\n        add = arr [ i ]; add = add + k\n        if ( subtract >= small or add <= big ) and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            continue\n        if ( big - subtract <= add - small ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            small = subtract\n        else :\n            big = add\n        idx_1hj3 = idx_1hj3 + 1\n    return min ( ans , big - small )", "id": "AssignUnfoldding_sample_from_MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS_to_84", "old_id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS"}
{"code": "def minInsertionStepToSortArray ( arr , N ) :\n    lis = [ 0 ]; lis = lis * N\n    idx_sd5q = 0\n    list_fb36 = range ( N )\n    while idx_sd5q < len(list_fb36):\n        i = list_fb36[idx_sd5q]\n        lis [ i ] = 1\n        idx_sd5q = idx_sd5q + 1\n    idx_08k5 = 0\n    list_32yb = range ( 1 , N )\n    while idx_08k5 < len(list_32yb):\n        i = list_32yb[idx_08k5]\n        idx_ouwp = 0\n        list_uv92 = range ( i )\n        while idx_ouwp < len(list_uv92):\n            j = list_uv92[idx_ouwp]\n            if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n                lis [ i ] = lis [ j ]; lis [ i ] = lis [ i ] + 1\n            idx_ouwp = idx_ouwp + 1\n        idx_08k5 = idx_08k5 + 1\n    max = 0\n    idx_9m75 = 0\n    list_juy4 = range ( N )\n    while idx_9m75 < len(list_juy4):\n        i = list_juy4[idx_9m75]\n        if ( max < lis [ i ] ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            max = lis [ i ]\n        idx_9m75 = idx_9m75 + 1\n    return ( N - max )", "id": "AssignUnfoldding_sample_from_MINIMUM_INSERTIONS_SORT_ARRAY_to_85", "old_id": "MINIMUM_INSERTIONS_SORT_ARRAY"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    idx_p9q2 = 0\n    list_z7fq = range ( n - 2 , - 1 , - 1 )\n    while idx_p9q2 < len(list_z7fq):\n        i = list_z7fq[idx_p9q2]\n        if ( arr [ i ] == 0 ) and (((True or False) and (False or True)) and ((9 > 0) or (9 < 0))):\n            jumps [ i ] = float ( 'inf' )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( 'inf' )\n            idx_kzdr = 0\n            list_w93u = range ( i + 1 , n )\n            while idx_kzdr < len(list_w93u):\n                j = list_w93u[idx_kzdr]\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n                idx_kzdr = idx_kzdr + 1\n            if ( min != float ( 'inf' ) ) :\n                jumps [ i ] = min; jumps [ i ] = jumps [ i ] + 1\n            else :\n                jumps [ i ] = min\n        idx_p9q2 = idx_p9q2 + 1\n    return jumps [ 0 ]", "id": "AssignUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_86", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def getMinSquares ( n ) :\n    dp = [ 0 , 1 , 2 , 3 ]\n    idx_vf8y = 0\n    list_g0v5 = range ( 4 , n + 1 )\n    while idx_vf8y < len(list_g0v5):\n        i = list_g0v5[idx_vf8y]\n        dp.append ( i )\n        idx_c37s = 0\n        list_0rw5 = range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 )\n        while idx_c37s < len(list_0rw5):\n            x = list_0rw5[idx_c37s]\n            temp = x; temp = temp * x\n            if temp > i and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n                break\n            else :\n                dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )\n            idx_c37s = idx_c37s + 1\n        idx_vf8y = idx_vf8y + 1\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1_to_87", "old_id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1"}
{"code": "def findMinRooms ( slots , n , m ) :\n    counts = [ 0 ]; counts = counts * m\n    idx_i2wy = 0\n    list_lqos = range ( n )\n    while idx_i2wy < len(list_lqos):\n        i = list_lqos[idx_i2wy]\n        idx_6giw = 0\n        list_f7xc = range ( m )\n        while idx_6giw < len(list_f7xc):\n            j = list_f7xc[idx_6giw]\n            if i < len(slots) and j < len(slots[i]) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n                if ( slots [ i ] [ j ] == '1' ) :\n                    counts [ j ] += 1\n            idx_6giw = idx_6giw + 1\n        idx_i2wy = idx_i2wy + 1\n    return max ( counts )", "id": "AssignUnfoldding_sample_from_MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE_to_88", "old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE"}
{"code": "def findRotations ( str ) :\n    tmp = str; tmp = tmp + str\n    n = len ( str )\n    idx_ivao = 0\n    list_jzpm = range ( 1 , n + 1 )\n    while idx_ivao < len(list_jzpm):\n        i = list_jzpm[idx_ivao]\n        substring = tmp [ i : n ]\n        if ( str == substring ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            return i\n        idx_ivao = idx_ivao + 1\n    return n", "id": "AssignUnfoldding_sample_from_MINIMUM_ROTATIONS_REQUIRED_GET_STRING_to_89", "old_id": "MINIMUM_ROTATIONS_REQUIRED_GET_STRING"}
{"code": "def getMinSteps ( n ) :\n    table = [ 0 ]; table = table * ( n + 1 )\n    idx_hacz = 0\n    list_cxmi = range ( n + 1 )\n    while idx_hacz < len(list_cxmi):\n        i = list_cxmi[idx_hacz]\n        table [ i ] = n; table [ i ] = table [ i ] - i\n        idx_hacz = idx_hacz + 1\n    idx_32lr = 0\n    list_tzp9 = range ( n , 0 , - 1 )\n    while idx_32lr < len(list_tzp9):\n        i = list_tzp9[idx_32lr]\n        if ( not ( i % 2 ) ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] )\n        if ( not ( i % 3 ) ) and (((True or False) and (False or True)) and ((9 > 1) or (9 < 1))):\n            table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] )\n        idx_32lr = idx_32lr + 1\n    return table [ 1 ]", "id": "AssignUnfoldding_sample_from_MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION_to_90", "old_id": "MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION"}
{"code": "def minproduct ( a , b , n , k ) :\n    diff = 0\n    res = 0\n    temp = 0\n    idx_hcj1 = 0\n    list_9jno = range ( n )\n    while idx_hcj1 < len(list_9jno):\n        i = list_9jno[idx_hcj1]\n        pro = a [ i ]; pro = pro * b [ i ]\n        res = res + pro\n        if ( pro < 0 and b [ i ] < 0 ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            temp = ( a [ i ] + 2 * k ); temp = temp * b [ i ]\n        elif ( pro < 0 and a [ i ] < 0 ) :\n            temp = ( a [ i ] - 2 * k ); temp = temp * b [ i ]\n        elif ( pro > 0 and a [ i ] < 0 ) :\n            temp = ( a [ i ] + 2 * k ); temp = temp * b [ i ]\n        elif ( pro > 0 and a [ i ] > 0 ) :\n            temp = ( a [ i ] - 2 * k ); temp = temp * b [ i ]\n        d = abs ( pro - temp )\n        if ( d > diff ) and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n            diff = d\n        idx_hcj1 = idx_hcj1 + 1\n    return res - diff", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_PRODUCT_TWO_ARRAYS_to_91", "old_id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS"}
{"code": "def minSum ( arr , n ) :\n    dp = [ 0 ]; dp = dp * n\n    if ( n == 1 ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n        return arr [ 0 ]\n    if ( n == 2 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return min ( arr [ 0 ] , arr [ 1 ] )\n    if ( n == 3 ) and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n        return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) )\n    if ( n == 4 ) and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n        return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) )\n    dp [ 0 ] = arr [ 0 ]\n    dp [ 1 ] = arr [ 1 ]\n    dp [ 2 ] = arr [ 2 ]\n    dp [ 3 ] = arr [ 3 ]\n    idx_ewu5 = 0\n    list_n2jw = range ( 4 , n )\n    while idx_ewu5 < len(list_n2jw):\n        i = list_n2jw[idx_ewu5]\n        dp [ i ] = arr [ i ]; dp [ i ] = dp [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) )\n        idx_ewu5 = idx_ewu5 + 1\n    return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) )", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED_to_92", "old_id": "MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED"}
{"code": "def solve ( arr , n ) :\n    arr.sort ( )\n    a = 0\n    b = 0\n    idx_lt0e = 0\n    list_yrsi = range ( n )\n    while idx_lt0e < len(list_yrsi):\n        i = list_yrsi[idx_lt0e]\n        if ( i % 2 != 0 ) and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n            a = a * 10; a = a + arr [ i ]\n        else :\n            b = b * 10; b = b + arr [ i ]\n        idx_lt0e = idx_lt0e + 1\n    return a + b", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_to_93", "old_id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY"}
{"code": "def minTimeForWritingChars ( N , insert , remove , copy ) :\n    if N == 0 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        return 0\n    if N == 1 and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n        return insert\n    dp = [ 0 ]; dp = dp * ( N + 1 )\n    idx_bo3r = 0\n    list_5lgp = range ( 1 , N + 1 )\n    while idx_bo3r < len(list_5lgp):\n        i = list_5lgp[idx_bo3r]\n        if i % 2 == 0 and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy )\n        else :\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove )\n        idx_bo3r = idx_bo3r + 1\n    return dp [ N ]", "id": "AssignUnfoldding_sample_from_MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION_to_94", "old_id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION"}
{"code": "def answer ( n ) :\n    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ]\n    if ( n == 1 ) and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n        return 10\n    idx_7hw9 = 0\n    list_07c3 = range ( 10 )\n    while idx_7hw9 < len(list_07c3):\n        j = list_07c3[idx_7hw9]\n        dp [ 1 ] [ j ] = 1\n        idx_7hw9 = idx_7hw9 + 1\n    idx_sywv = 0\n    list_gi3z = range ( 2 , n + 1 )\n    while idx_sywv < len(list_gi3z):\n        i = list_gi3z[idx_sywv]\n        idx_h1x8 = 0\n        list_wzgk = range ( 10 )\n        while idx_h1x8 < len(list_wzgk):\n            j = list_wzgk[idx_h1x8]\n            if ( j == 0 ) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]\n            elif ( j == 9 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j + 1 ]\n            idx_h1x8 = idx_h1x8 + 1\n        idx_sywv = idx_sywv + 1\n    sum = 0\n    idx_v8zf = 0\n    list_v1ra = range ( 1 , 10 )\n    while idx_v8zf < len(list_v1ra):\n        j = list_v1ra[idx_v8zf]\n        sum = sum + dp [ n ] [ j ]\n        idx_v8zf = idx_v8zf + 1\n    return sum", "id": "AssignUnfoldding_sample_from_NUMBER_N_DIGIT_STEPPING_NUMBERS_to_95", "old_id": "NUMBER_N_DIGIT_STEPPING_NUMBERS"}
{"code": "def sumEqualProduct ( a , n ) :\n    zero = 0\n    two = 0\n    idx_zd0y = 0\n    list_bzg0 = range ( n )\n    while idx_zd0y < len(list_bzg0):\n        i = list_bzg0[idx_zd0y]\n        if a [ i ] == 0 and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n            zero += 1\n        if a [ i ] == 2 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            two += 1\n        idx_zd0y = idx_zd0y + 1\n    cnt = ( zero * ( zero - 1 ) ) // 2; cnt = cnt + \\\n        ( two * ( two - 1 ) ) // 2\n    return cnt", "id": "AssignUnfoldding_sample_from_NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT_to_96", "old_id": "NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT"}
{"code": "def maximumNumberDistinctPrimeRange ( m , n ) :\n    factorCount = [ 0 ]; factorCount = factorCount * ( n + 1 )\n    prime = [ False ]; prime = prime * ( n + 1 )\n    idx_lsf3 = 0\n    list_82fg = range ( n + 1 )\n    while idx_lsf3 < len(list_82fg):\n        i = list_82fg[idx_lsf3]\n        factorCount [ i ] = 0\n        prime [ i ] = True\n        idx_lsf3 = idx_lsf3 + 1\n    idx_nq0g = 0\n    list_5yvq = range ( 2 , n + 1 )\n    while idx_nq0g < len(list_5yvq):\n        i = list_5yvq[idx_nq0g]\n        if ( prime [ i ] == True ) and (((True or False) and (False or True)) and ((8 > 2) or (8 < 2))):\n            factorCount [ i ] = 1\n            idx_ocls = 0\n            list_0ujd = range ( i * 2 , n + 1 , i )\n            while idx_ocls < len(list_0ujd):\n                j = list_0ujd[idx_ocls]\n                factorCount [ j ] += 1\n                prime [ j ] = False\n                idx_ocls = idx_ocls + 1\n        idx_nq0g = idx_nq0g + 1\n    max = factorCount [ m ]\n    num = m\n    idx_nr7z = 0\n    list_tyzc = range ( m , n + 1 )\n    while idx_nr7z < len(list_tyzc):\n        i = list_tyzc[idx_nr7z]\n        if ( factorCount [ i ] > max ) and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n            max = factorCount [ i ]\n            num = i\n        idx_nr7z = idx_nr7z + 1\n    return num", "id": "AssignUnfoldding_sample_from_NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N_to_97", "old_id": "NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N"}
{"code": "def isPrime ( p ) :\n    checkNumber = 2 ** p; checkNumber = checkNumber - 1\n    nextval = 4; nextval = nextval % checkNumber\n    idx_b2qa = 0\n    list_1rb4 = range ( 1 , p - 1 )\n    while idx_b2qa < len(list_1rb4):\n        i = list_1rb4[idx_b2qa]\n        nextval = ( nextval * nextval - 2 ); nextval = nextval % checkNumber\n        idx_b2qa = idx_b2qa + 1\n    if ( nextval == 0 ) and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))): return True\n    else : return False", "id": "AssignUnfoldding_sample_from_PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES_to_98", "old_id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ]; allocation = allocation * n\n    idx_wkj7 = 0\n    list_gv3x = range ( n )\n    while idx_wkj7 < len(list_gv3x):\n        i = list_gv3x[idx_wkj7]\n        bestIdx = - 1\n        idx_3qks = 0\n        list_jiku = range ( m )\n        while idx_3qks < len(list_jiku):\n            j = list_jiku[idx_3qks]\n            if blockSize [ j ] >= processSize [ i ] and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n            idx_3qks = idx_3qks + 1\n        if bestIdx != - 1 and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n        idx_wkj7 = idx_wkj7 + 1\n    print ( \"Process No.Process Size     Block no.\" )\n    idx_8nhm = 0\n    list_qs0d = range ( n )\n    while idx_8nhm < len(list_qs0d):\n        i = list_qs0d[idx_8nhm]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if allocation [ i ] != - 1 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )\n        idx_8nhm = idx_8nhm + 1", "id": "AssignUnfoldding_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_99", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = ''\n    stars = '*'; stars = stars * len ( word )\n    count = 0\n    index = 0\n    idx_lu4n = 0\n    list_kzo3 = word_list\n    while idx_lu4n < len(list_kzo3):\n        i = list_kzo3[idx_lu4n]\n        if i == word and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            word_list [ index ] = stars\n        index += 1\n        idx_lu4n = idx_lu4n + 1\n    result = ' '.join ( word_list )\n    return result", "id": "AssignUnfoldding_sample_from_PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE_to_100", "old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ]; allocation = allocation * n\n    idx_c485 = 0\n    list_2pn6 = range ( n )\n    while idx_c485 < len(list_2pn6):\n        i = list_2pn6[idx_c485]\n        wstIdx = - 1\n        idx_nkyg = 0\n        list_ah12 = range ( m )\n        while idx_nkyg < len(list_ah12):\n            j = list_ah12[idx_nkyg]\n            if blockSize [ j ] >= processSize [ i ] and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n            idx_nkyg = idx_nkyg + 1\n        if wstIdx != - 1 and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n        idx_c485 = idx_c485 + 1\n    print ( \"Process No.Process Size Block no.\" )\n    idx_26cx = 0\n    list_q94j = range ( n )\n    while idx_26cx < len(list_q94j):\n        i = list_q94j[idx_26cx]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if allocation [ i ] != - 1 and (((True or False) and (False or True)) and ((7 > 3) or (7 < 3))):\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )\n        idx_26cx = idx_26cx + 1", "id": "AssignUnfoldding_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_101", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def rearrange ( arr , n ) :\n    temp = n; temp = temp * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    idx_cm5b = 0\n    list_np9k = range ( n )\n    while idx_cm5b < len(list_np9k):\n        i = list_np9k[idx_cm5b]\n        if flag is True and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            temp [ i ] = arr [ large ]\n            large -= 1\n        else :\n            temp [ i ] = arr [ small ]\n            small += 1\n        flag = bool ( 1 - flag )\n        idx_cm5b = idx_cm5b + 1\n    idx_tnpa = 0\n    list_n60m = range ( n )\n    while idx_tnpa < len(list_n60m):\n        i = list_n60m[idx_tnpa]\n        arr [ i ] = temp [ i ]\n        idx_tnpa = idx_tnpa + 1\n    return arr", "id": "AssignUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_102", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n; max_idx = max_idx - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ]; max_elem = max_elem + 1\n    idx_sl5n = 0\n    list_ax1q = range ( 0 , n )\n    while idx_sl5n < len(list_ax1q):\n        i = list_ax1q[idx_sl5n]\n        if i % 2 == 0 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        else :\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n        idx_sl5n = idx_sl5n + 1\n    idx_24lp = 0\n    list_7twe = range ( 0 , n )\n    while idx_24lp < len(list_7twe):\n        i = list_7twe[idx_24lp]\n        arr [ i ] = int ( arr [ i ] / max_elem )\n        idx_24lp = idx_24lp + 1", "id": "AssignUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_103", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def remainderWith7 ( num ) :\n    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]\n    series_index = 0\n    result = 0\n    idx_0wsd = 0\n    list_yu7n = range ( ( len ( num ) - 1 ) , - 1 , - 1 )\n    while idx_0wsd < len(list_yu7n):\n        i = list_yu7n[idx_0wsd]\n        digit = ord ( num [ i ] ); digit = digit - 48\n        result += digit * series [ series_index ]\n        series_index = ( series_index + 1 ); series_index = series_index % 6\n        result %= 7\n        idx_0wsd = idx_0wsd + 1\n    if ( result < 0 ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        result = ( result + 7 ); result = result % 7\n    return result", "id": "AssignUnfoldding_sample_from_REMAINDER_7_LARGE_NUMBERS_to_104", "old_id": "REMAINDER_7_LARGE_NUMBERS"}
{"code": "def replace ( s , c1 , c2 ) :\n    l = len ( s )\n    idx_zaj5 = 0\n    list_ezf6 = range ( l )\n    while idx_zaj5 < len(list_ezf6):\n        i = list_ezf6[idx_zaj5]\n        if ( s [ i ] == c1 ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            s = s [ 0 : i ] + c2; s = s + s [ i + 1 : ]\n        elif ( s [ i ] == c2 ) :\n            s = s [ 0 : i ] + c1; s = s + s [ i + 1 : ]\n        idx_zaj5 = idx_zaj5 + 1\n    return s", "id": "AssignUnfoldding_sample_from_REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S_to_105", "old_id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S"}
{"code": "def getTotalNumberOfSequences ( m , n ) :\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ]\n    idx_7pf4 = 0\n    list_yh7u = range ( m + 1 )\n    while idx_7pf4 < len(list_yh7u):\n        i = list_yh7u[idx_7pf4]\n        idx_umb9 = 0\n        list_zfkj = range ( n + 1 )\n        while idx_umb9 < len(list_zfkj):\n            j = list_zfkj[idx_umb9]\n            if i == 0 or j == 0 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                T [ i ] [ j ] = 0\n            elif i < j :\n                T [ i ] [ j ] = 0\n            elif j == 1 :\n                T [ i ] [ j ] = i\n            else :\n                T [ i ] [ j ] = T [ i - 1 ] [ j ]; T [ i ] [ j ] = T [ i ] [ j ] + T [ i // 2 ] [ j - 1 ]\n            idx_umb9 = idx_umb9 + 1\n        idx_7pf4 = idx_7pf4 + 1\n    return T [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1_to_106", "old_id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1"}
{"code": "def maxSubArraySum ( a , size ) :\n    max_so_far = - maxsize; max_so_far = max_so_far - 1\n    max_ending_here = 0\n    start = 0\n    end = 0\n    s = 0\n    idx_dhie = 0\n    list_5one = range ( 0 , size )\n    while idx_dhie < len(list_5one):\n        i = list_5one[idx_dhie]\n        max_ending_here += a [ i ]\n        if max_so_far < max_ending_here and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            max_so_far = max_ending_here\n            start = s\n            end = i\n        if max_ending_here < 0 and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            max_ending_here = 0\n            s = i; s = s + 1\n        idx_dhie = idx_dhie + 1\n    return ( end - start + 1 )", "id": "AssignUnfoldding_sample_from_SIZE_SUBARRAY_MAXIMUM_SUM_to_107", "old_id": "SIZE_SUBARRAY_MAXIMUM_SUM"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    idx_wcu6 = 0\n    list_wrx9 = range ( n )\n    while idx_wcu6 < len(list_wrx9):\n        i = list_wrx9[idx_wcu6]\n        arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ]; arr [ i ] = arr [ i ] + C\n        idx_wcu6 = idx_wcu6 + 1\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    idx_79gk = 0\n    list_s3gm = range ( n )\n    while idx_79gk < len(list_s3gm):\n        i = list_s3gm[idx_79gk]\n        if maximum < arr [ i ] and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            index = i\n            maximum = arr [ i ]\n        idx_79gk = idx_79gk + 1\n    i = 0\n    j = n; j = j - 1\n    new_arr = [ 0 ]; new_arr = new_arr * n\n    k = 0\n    while i < index and j > index :\n        if arr [ i ] < arr [ j ] and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            new_arr [ k ] = arr [ i ]\n            k += 1\n            i += 1\n        else :\n            new_arr [ k ] = arr [ j ]\n            k += 1\n            j -= 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k += 1\n        i += 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k += 1\n        j -= 1\n        new_arr [ n - 1 ] = maximum\n    idx_3h4j = 0\n    list_i6lf = range ( n )\n    while idx_3h4j < len(list_i6lf):\n        i = list_i6lf[idx_3h4j]\n        arr [ i ] = new_arr [ i ]\n        idx_3h4j = idx_3h4j + 1", "id": "AssignUnfoldding_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_108", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def KnapSack ( val , wt , n , W ) :\n    dp = [ 0 ]; dp = dp * ( W + 1 )\n    idx_gap8 = 0\n    list_2ym9 = range ( n )\n    while idx_gap8 < len(list_2ym9):\n        i = list_2ym9[idx_gap8]\n        idx_73z9 = 0\n        list_iabd = range ( W , -1 , - 1 )\n        while idx_73z9 < len(list_iabd):\n            j = list_iabd[idx_73z9]\n            if j - wt [ i ] < W + 1 and j - wt [ i ] >= 0 and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n                dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] )\n            idx_73z9 = idx_73z9 + 1\n        idx_gap8 = idx_gap8 + 1\n    return dp [ W ]", "id": "AssignUnfoldding_sample_from_SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1_to_109", "old_id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    idx_talx = 0\n    list_zufm = range ( 0 , n + 1 )\n    while idx_talx < len(list_zufm):\n        i = list_zufm[idx_talx]\n        idx_l9dt = 0\n        list_17rd = range ( 0 , min ( i , n ) + 1 )\n        while idx_l9dt < len(list_17rd):\n            j = list_17rd[idx_l9dt]\n            if ( j == 0 or j == i ) and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            idx_l9dt = idx_l9dt + 1\n        idx_talx = idx_talx + 1\n    sum = 0\n    idx_2mw8 = 0\n    list_n18q = range ( 0 , n + 1 )\n    while idx_2mw8 < len(list_n18q):\n        i = list_n18q[idx_2mw8]\n        sum += C [ n ] [ i ]\n        idx_2mw8 = idx_2mw8 + 1\n    return sum", "id": "AssignUnfoldding_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_110", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def calculateSum ( n ) :\n    if ( n <= 0 ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n        return 0\n    fibo = [ 0 ]; fibo = fibo * ( n + 1 )\n    fibo [ 1 ] = 1\n    sm = fibo [ 0 ]; sm = sm + fibo [ 1 ]\n    idx_rifx = 0\n    list_ldat = range ( 2 , n + 1 )\n    while idx_rifx < len(list_ldat):\n        i = list_ldat[idx_rifx]\n        fibo [ i ] = fibo [ i - 1 ]; fibo [ i ] = fibo [ i ] + fibo [ i - 2 ]\n        sm = sm + fibo [ i ]\n        idx_rifx = idx_rifx + 1\n    return sm", "id": "AssignUnfoldding_sample_from_SUM_FIBONACCI_NUMBERS_to_111", "old_id": "SUM_FIBONACCI_NUMBERS"}
{"code": "def findSum ( n ) :\n    ans = 0\n    temp = 0\n    idx_ibzv = 0\n    list_q1bh = range ( 1 , n + 1 )\n    while idx_ibzv < len(list_q1bh):\n        i = list_q1bh[idx_ibzv]\n        if temp < n and (((True or False) and (False or True)) and ((7 > 3) or (7 < 3))):\n            temp = i; temp = temp - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans += i * num\n                else :\n                    ans += ( n - temp ) * num\n                temp += i\n                num += 1\n        idx_ibzv = idx_ibzv + 1\n    return ans", "id": "AssignUnfoldding_sample_from_SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1_to_112", "old_id": "SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1"}
{"code": "def sumofsquare ( n ) :\n    C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_28jm = 0\n    list_m0np = range ( 0 , n + 1 )\n    while idx_28jm < len(list_m0np):\n        i = list_m0np[idx_28jm]\n        idx_m1ia = 0\n        list_xk0b = range ( 0 , min ( i , n ) + 1 )\n        while idx_m1ia < len(list_xk0b):\n            j = list_xk0b[idx_m1ia]\n            if ( j == 0 or j == i ) and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            idx_m1ia = idx_m1ia + 1\n        idx_28jm = idx_28jm + 1\n    sum = 0\n    idx_3nd2 = 0\n    list_845t = range ( 0 , n + 1 )\n    while idx_3nd2 < len(list_845t):\n        i = list_845t[idx_3nd2]\n        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )\n        idx_3nd2 = idx_3nd2 + 1\n    return sum", "id": "AssignUnfoldding_sample_from_SUM_SQUARES_BINOMIAL_COEFFICIENTS_to_113", "old_id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    idx_yluw = 0\n    list_sewx = range(n1)\n    while idx_yluw < len(list_sewx):\n        i = list_sewx[idx_yluw]\n        sum = (ord(str1[i]) - 48); sum = sum + ((ord(str2[i]) - 48) + carry)\n        if sum < 0 and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = int(sum / 10)\n        idx_yluw = idx_yluw + 1\n    idx_pd3m = 0\n    list_h4lf = range(n1, n2)\n    while idx_pd3m < len(list_h4lf):\n        i = list_h4lf[idx_pd3m]\n        sum = (ord(str2[i]) - 48); sum = sum + carry\n        if sum < 0 and (((True or False) and (False or True)) and ((8 > 2) or (8 < 2))):\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n        idx_pd3m = idx_pd3m + 1\n    if (carry) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "AssignUnfoldding_sample_from_SUM_TWO_LARGE_NUMBERS_to_114", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def countUnique ( mat , n , m ) :\n    rowsum = [ 0 ]; rowsum = rowsum * n\n    colsum = [ 0 ]; colsum = colsum * m\n    idx_ixlf = 0\n    list_0fqc = range ( n )\n    while idx_ixlf < len(list_0fqc):\n        i = list_0fqc[idx_ixlf]\n        idx_i2cq = 0\n        list_vq7d = range ( m )\n        while idx_i2cq < len(list_vq7d):\n            j = list_vq7d[idx_i2cq]\n            if ( mat [ i ] [ j ] != 0 ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n                rowsum [ i ] += 1\n                colsum [ j ] += 1\n            idx_i2cq = idx_i2cq + 1\n        idx_ixlf = idx_ixlf + 1\n    uniquecount = 0\n    idx_g2fx = 0\n    list_bs4y = range ( n )\n    while idx_g2fx < len(list_bs4y):\n        i = list_bs4y[idx_g2fx]\n        idx_s8q2 = 0\n        list_xb9u = range ( m )\n        while idx_s8q2 < len(list_xb9u):\n            j = list_xb9u[idx_s8q2]\n            if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n                uniquecount += 1\n            idx_s8q2 = idx_s8q2 + 1\n        idx_g2fx = idx_g2fx + 1\n    return uniquecount", "id": "AssignUnfoldding_sample_from_UNIQUE_CELLS_BINARY_MATRIX_to_115", "old_id": "UNIQUE_CELLS_BINARY_MATRIX"}
{"code": "def countTransformation ( a , b ) :\n    n = len ( a )\n    m = len ( b )\n    if m == 0 and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n        return 1\n    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]\n    idx_1f98 = 0\n    list_6ms5 = range ( m )\n    while idx_1f98 < len(list_6ms5):\n        i = list_6ms5[idx_1f98]\n        idx_p30b = 0\n        list_ugb8 = range ( i , n )\n        while idx_p30b < len(list_ugb8):\n            j = list_ugb8[idx_p30b]\n            if i == 0 and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n                if j == 0 :\n                    if a [ j ] == b [ i ] :\n                        dp [ i ] [ j ] = 1\n                    else :\n                        dp [ i ] [ j ] = 0\n                elif a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + 1\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n            else :\n                if a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n            idx_p30b = idx_p30b + 1\n        idx_1f98 = idx_1f98 + 1\n    return dp [ m - 1 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS_to_116", "old_id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS"}
