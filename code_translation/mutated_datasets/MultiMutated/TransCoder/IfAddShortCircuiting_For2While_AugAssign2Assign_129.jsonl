{"code": "def winner ( a , n , k ) :\n    if k >= n - 1 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        return n\n    best = 0\n    times = 0\n    idx_iosz = 0\n    list_3vjs = range ( n )\n    while idx_iosz < len(list_3vjs):\n        i = list_3vjs[idx_iosz]\n        if a [ i ] > best and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n            best = a [ i ]\n            if i == True :\n                times = 1\n        else :\n            times = times + 1\n        if times >= k and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n            return best\n        idx_iosz = idx_iosz + 1\n    return best", "id": "AugAssign2Assign_sample_from_ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES_to_0", "old_id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES"}
{"code": "def solveQuery ( start , end , arr ) :\n    frequency = dict ( )\n    idx_n13w = 0\n    list_6one = range ( start , end + 1 )\n    while idx_n13w < len(list_6one):\n        i = list_6one[idx_n13w]\n        if arr [ i ] in frequency.keys ( ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n            frequency [ arr [ i ] ] = frequency [ arr [ i ] ] + 1\n        else :\n            frequency [ arr [ i ] ] = 1\n        idx_n13w = idx_n13w + 1\n    count = 0\n    idx_83jk = 0\n    list_3dp5 = frequency\n    while idx_83jk < len(list_3dp5):\n        x = list_3dp5[idx_83jk]\n        if x == frequency [ x ] and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n            count = count + 1\n        idx_83jk = idx_83jk + 1\n    return count", "id": "AugAssign2Assign_sample_from_ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE_to_1", "old_id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE"}
{"code": "def encrypt ( text , s ) :\n    result = \"\"\n    idx_31gm = 0\n    list_lrd5 = range ( len ( text ) )\n    while idx_31gm < len(list_lrd5):\n        i = list_lrd5[idx_31gm]\n        char = text [ i ]\n        if ( char.isupper ( ) ) and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n            result = result + chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        else :\n            result = result + chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n        idx_31gm = idx_31gm + 1\n    return result", "id": "AugAssign2Assign_sample_from_CAESAR_CIPHER_to_2", "old_id": "CAESAR_CIPHER"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    idx_wiyk = 0\n    list_i50n = range ( 1 , len ( str ) )\n    while idx_wiyk < len(list_i50n):\n        i = list_i50n[idx_wiyk]\n        if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n            res = res + ord ( str [ i ] ) - 48\n        else :\n            res = res + ord ( str [ i ] ) - 48\n        idx_wiyk = idx_wiyk + 1\n    return res", "id": "AugAssign2Assign_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_3", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = \"0\"\n    Sum = 0\n    idx_ur3m = 0\n    list_t0j7 = str\n    while idx_ur3m < len(list_t0j7):\n        ch = list_t0j7[idx_ur3m]\n        if ( ch.isdigit ( ) ) and (((True or False) and (False or True)) and ((10 > 9) or (10 < 9))):\n            temp = temp + ch\n        else :\n            Sum = Sum + int ( temp )\n            temp = \"0\"\n        idx_ur3m = idx_ur3m + 1\n    return Sum + int ( temp )", "id": "AugAssign2Assign_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_4", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def isMajority ( a, n ) :\n    mp = { }\n    idx_nfhi = 0\n    list_jvqf = range(n)\n    while idx_nfhi < len(list_jvqf):\n        i = list_jvqf[idx_nfhi]\n        if a[i] in mp and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))): mp [ a[i] ] = mp [ a[i] ] + 1\n        else : mp [ a[i] ] = 1\n        idx_nfhi = idx_nfhi + 1\n    idx_iftl = 0\n    list_0ou7 = mp\n    while idx_iftl < len(list_0ou7):\n        x = list_0ou7[idx_iftl]\n        if mp [ x ] >= len ( a ) // 2 and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            return True\n        idx_iftl = idx_iftl + 1\n    return False", "id": "AugAssign2Assign_sample_from_CHECK_ARRAY_MAJORITY_ELEMENT_to_5", "old_id": "CHECK_ARRAY_MAJORITY_ELEMENT"}
{"code": "def isDivisible ( str , k ) :\n    n = len ( str )\n    c = 0\n    idx_lmb1 = 0\n    list_mtnj = range ( 0 , k )\n    while idx_lmb1 < len(list_mtnj):\n        i = list_mtnj[idx_lmb1]\n        if ( str [ n - i - 1 ] == '0' ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            c = c + 1\n        idx_lmb1 = idx_lmb1 + 1\n    return ( c == k )", "id": "AugAssign2Assign_sample_from_CHECK_DIVISIBILITY_BINARY_STRING_2K_to_6", "old_id": "CHECK_DIVISIBILITY_BINARY_STRING_2K"}
{"code": "def isDivisible999 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '0' ) and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        return True\n    if ( ( n % 3 ) == 1 ) and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n        num = \"00\" + num\n    if ( ( n % 3 ) == 2 ) and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        num = \"0\" + num\n    gSum = 0\n    idx_gl05 = 0\n    list_o24n = range ( 0 , n , 3 )\n    while idx_gl05 < len(list_o24n):\n        i = list_o24n[idx_gl05]\n        group = 0\n        group = group + ( ord ( num [ i ] ) - 48 ) * 100\n        group = group + ( ord ( num [ i + 1 ] ) - 48 ) * 10\n        group = group + ( ord ( num [ i + 2 ] ) - 48 )\n        gSum = gSum + group\n        idx_gl05 = idx_gl05 + 1\n    if ( gSum > 1000 ) and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n        num = str ( gSum )\n        n = len ( num )\n        gSum = isDivisible999 ( num )\n    return ( gSum == 999 )", "id": "AugAssign2Assign_sample_from_CHECK_DIVISIBILITY_LARGE_NUMBER_999_to_7", "old_id": "CHECK_DIVISIBILITY_LARGE_NUMBER_999"}
{"code": "def flipsPossible ( a , n ) :\n    count_odd = 0\n    count_even = 0\n    idx_vd4l = 0\n    list_dati = range ( n )\n    while idx_vd4l < len(list_dati):\n        i = list_dati[idx_vd4l]\n        if ( a [ i ] & 1 ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n            count_odd = count_odd + 1\n        else :\n            count_even = count_even + 1\n        idx_vd4l = idx_vd4l + 1\n    if ( count_odd % 2 and count_even % 2 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        return False\n    else :\n        return True", "id": "AugAssign2Assign_sample_from_CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS_to_8", "old_id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS"}
{"code": "def isChangeable ( notes , n ) :\n    fiveCount = 0\n    tenCount = 0\n    idx_xcym = 0\n    list_buf1 = range ( n )\n    while idx_xcym < len(list_buf1):\n        i = list_buf1[idx_xcym]\n        if ( notes [ i ] == 5 ) and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n            fiveCount = fiveCount + 1\n        elif ( notes [ i ] == 10 ) :\n            if ( fiveCount > 0 ) :\n                fiveCount = fiveCount - 1\n                tenCount = tenCount + 1\n            else :\n                return 0\n        else :\n            if ( fiveCount > 0 and tenCount > 0 ) :\n                fiveCount = fiveCount - 1\n                tenCount = tenCount - 1\n            elif ( fiveCount >= 3 ) :\n                fiveCount = fiveCount - 3\n            else :\n                return 0\n        idx_xcym = idx_xcym + 1\n    return 1", "id": "AugAssign2Assign_sample_from_CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE_to_9", "old_id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n        return True\n    if ( length % 3 == 1 ) and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n        num = str ( num ) + \"00\"\n        length = length + 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        length = length + 1\n    sum = 0\n    p = 1\n    idx_sev8 = 0\n    list_zobl = range ( length - 1 , - 1 , - 3 )\n    while idx_sev8 < len(list_zobl):\n        i = list_zobl[idx_sev8]\n        group = 0\n        group = group + ord ( num [ i ] ) - ord ( '0' )\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p = p * ( - 1 )\n        idx_sev8 = idx_sev8 + 1\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "AugAssign2Assign_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_10", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def checkReverse ( arr , n ) :\n    if ( n == 1 ) and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n        return True\n    i = 1\n    idx_7vzk = 0\n    list_lhiw = range ( 1 , n )\n    while idx_7vzk < len(list_lhiw):\n        i = list_lhiw[idx_7vzk]\n        if arr [ i - 1 ] >= arr [ i ] and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            break\n        else:\n            if ( i == n ) :\n                return True\n        idx_7vzk = idx_7vzk + 1\n    j = i\n    i = i + 1\n    while ( arr [ j ] < arr [ j - 1 ] ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n            return False\n        j = j + 1\n    if ( j == n ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n            return False\n        k = k + 1\n    return True", "id": "AugAssign2Assign_sample_from_CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1_to_11", "old_id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1"}
{"code": "def areSumSame ( a , n , m ) :\n    sum1 = 0\n    sum2 = 0\n    idx_qypt = 0\n    list_5lya = range ( 0 , n )\n    while idx_qypt < len(list_5lya):\n        i = list_5lya[idx_qypt]\n        sum1 = 0\n        sum2 = 0\n        idx_f2se = 0\n        list_38by = range ( 0 , m )\n        while idx_f2se < len(list_38by):\n            j = list_38by[idx_f2se]\n            sum1 = sum1 + a [ i ] [ j ]\n            sum2 = sum2 + a [ j ] [ i ]\n            idx_f2se = idx_f2se + 1\n        if ( sum1 == sum2 ) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n            return 1\n        idx_qypt = idx_qypt + 1\n    return 0", "id": "AugAssign2Assign_sample_from_CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX_to_12", "old_id": "CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX"}
{"code": "def check ( degree , n ) :\n    deg_sum = 0\n    idx_0gs8 = 0\n    list_8kew = range(n)\n    while idx_0gs8 < len(list_8kew):\n        i = list_8kew[idx_0gs8]\n        deg_sum = deg_sum + degree[i]\n        idx_0gs8 = idx_0gs8 + 1\n    if ( 2 * ( n - 1 ) == deg_sum ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        return True\n    else :\n        return False", "id": "AugAssign2Assign_sample_from_CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE_to_13", "old_id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n        return 1\n    if ( n % 3 == 1 ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        num = str ( num ) + \"00\"\n        n = n + 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        n = n + 1\n    GSum = 0\n    p = 1\n    idx_9qpe = 0\n    list_i62r = range ( n - 1 , - 1 , - 1 )\n    while idx_9qpe < len(list_i62r):\n        i = list_i62r[idx_9qpe]\n        group = 0\n        group = group + ord ( num [ i ] ) - ord ( '0' )\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p = p * ( - 1 )\n        idx_9qpe = idx_9qpe + 1\n    return ( GSum % 7 == 0 )", "id": "AugAssign2Assign_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_14", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def spiralFill ( m , n , a ) :\n    val = 1\n    k , l = 0 , 0\n    while ( k < m and l < n ) :\n        idx_nfr3 = 0\n        list_1ovy = range ( l , n )\n        while idx_nfr3 < len(list_1ovy):\n            i = list_1ovy[idx_nfr3]\n            a [ k ] [ i ] = val\n            val = val + 1\n            idx_nfr3 = idx_nfr3 + 1\n        k = k + 1\n        idx_poix = 0\n        list_j6sq = range ( k , m )\n        while idx_poix < len(list_j6sq):\n            i = list_j6sq[idx_poix]\n            a [ i ] [ n - 1 ] = val\n            val = val + 1\n            idx_poix = idx_poix + 1\n        n = n - 1\n        if ( k < m ) and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n            idx_vyz5 = 0\n            list_n7a2 = range ( n - 1 , l - 1 , - 1 )\n            while idx_vyz5 < len(list_n7a2):\n                i = list_n7a2[idx_vyz5]\n                a [ m - 1 ] [ i ] = val\n                val = val + 1\n                idx_vyz5 = idx_vyz5 + 1\n            m = m - 1\n        if ( l < n ) and (((True or False) and (False or True)) and ((9 > 4) or (9 < 4))):\n            idx_orbp = 0\n            list_cot7 = range ( m - 1 , k - 1 , - 1 )\n            while idx_orbp < len(list_cot7):\n                i = list_cot7[idx_orbp]\n                a [ i ] [ l ] = val\n                val = val + 1\n                idx_orbp = idx_orbp + 1\n            l = l + 1", "id": "AugAssign2Assign_sample_from_CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY_to_15", "old_id": "CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    idx_twa2 = 0\n    list_7d41 = range ( 2 , n + 1 )\n    while idx_twa2 < len(list_7d41):\n        i = list_7d41[idx_twa2]\n        idx_9dv2 = 0\n        list_vk3r = range ( k + 1 )\n        while idx_9dv2 < len(list_vk3r):\n            j = list_vk3r[idx_9dv2]\n            if j >= i and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n                break\n            else:\n                dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j ] [ 1 ] + dp [ i - 1 ] [ j - 1 ] [ 1 ]\n            idx_9dv2 = idx_9dv2 + 1\n        idx_twa2 = idx_twa2 + 1\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]", "id": "AugAssign2Assign_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_16", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def countPairs ( str ) :\n    result = 0 ;\n    n = len ( str )\n    idx_0c9v = 0\n    list_0z2l = range ( 0 , n )\n    while idx_0c9v < len(list_0z2l):\n        i = list_0z2l[idx_0c9v]\n        idx_476t = 0\n        list_0x4c = range ( i + 1 , n )\n        while idx_476t < len(list_0x4c):\n            j = list_0x4c[idx_476t]\n            if ( abs ( ord ( str [ i ] ) - ord ( str [ j ] ) ) == abs ( i - j ) ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n                result = result + 1\n            idx_476t = idx_476t + 1\n        idx_0c9v = idx_0c9v + 1\n    return result ;", "id": "AugAssign2Assign_sample_from_COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_to_17", "old_id": "COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS"}
{"code": "def findDigits ( n ) :\n    if ( n < 0 ) and (((True or False) and (False or True)) and ((10 > 9) or (10 < 9))):\n        return 0\n    if ( n <= 1 ) and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n        return 1\n    digits = 0\n    idx_idmo = 0\n    list_2lai = range ( 2 , n + 1 )\n    while idx_idmo < len(list_2lai):\n        i = list_2lai[idx_idmo]\n        digits = digits + math.log10 ( i )\n        idx_idmo = idx_idmo + 1\n    return math.floor ( digits ) + 1", "id": "AugAssign2Assign_sample_from_COUNT_DIGITS_FACTORIAL_SET_1_to_18", "old_id": "COUNT_DIGITS_FACTORIAL_SET_1"}
{"code": "def count ( n , x ) :\n    cnt = 0\n    idx_cap6 = 0\n    list_c0lr = range ( 1 , n + 1 )\n    while idx_cap6 < len(list_c0lr):\n        i = list_c0lr[idx_cap6]\n        if i <= x and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            if x // i <= n and x % i == 0 :\n                cnt = cnt + 1\n        idx_cap6 = idx_cap6 + 1\n    return cnt", "id": "AugAssign2Assign_sample_from_COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX_to_19", "old_id": "COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX"}
{"code": "def countPairs ( arr , n ) :\n    ans = 0\n    idx_yf9g = 0\n    list_dxnc = range ( 0 , n )\n    while idx_yf9g < len(list_dxnc):\n        i = list_dxnc[idx_yf9g]\n        idx_w9pl = 0\n        list_z578 = range ( i + 1 , n )\n        while idx_w9pl < len(list_z578):\n            j = list_z578[idx_w9pl]\n            if ( arr [ i ] == arr [ j ] ) and (((True or False) and (False or True)) and ((10 > 1) or (10 < 1))):\n                ans = ans + 1\n            idx_w9pl = idx_w9pl + 1\n        idx_yf9g = idx_yf9g + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_to_20", "old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY"}
{"code": "def countPairs ( arr , n ) :\n    mp = dict ( )\n    idx_97mr = 0\n    list_ju30 = range ( n )\n    while idx_97mr < len(list_ju30):\n        i = list_ju30[idx_97mr]\n        if arr [ i ] in mp.keys ( ) and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n            mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n        else :\n            mp [ arr [ i ] ] = 1\n        idx_97mr = idx_97mr + 1\n    ans = 0\n    idx_rlcz = 0\n    list_yh2x = mp\n    while idx_rlcz < len(list_yh2x):\n        it = list_yh2x[idx_rlcz]\n        count = mp [ it ]\n        ans = ans + ( count * ( count - 1 ) ) // 2\n        idx_rlcz = idx_rlcz + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1_to_21", "old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1"}
{"code": "def getInvCount ( arr , n ) :\n    invcount = 0\n    idx_5rpm = 0\n    list_wtu6 = range ( 1 , n - 1 )\n    while idx_5rpm < len(list_wtu6):\n        i = list_wtu6[idx_5rpm]\n        small = 0\n        idx_qtbk = 0\n        list_0r2p = range ( i + 1 , n )\n        while idx_qtbk < len(list_0r2p):\n            j = list_0r2p[idx_qtbk]\n            if ( arr [ i ] > arr [ j ] ) and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n                small = small + 1\n            idx_qtbk = idx_qtbk + 1\n        great = 0\n        idx_6y0j = 0\n        list_7smx = range ( i - 1 , - 1 , - 1 )\n        while idx_6y0j < len(list_7smx):\n            j = list_7smx[idx_6y0j]\n            if ( arr [ i ] < arr [ j ] ) and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n                great = great + 1\n            idx_6y0j = idx_6y0j + 1\n        invcount = invcount + great * small\n        idx_5rpm = idx_5rpm + 1\n    return invcount", "id": "AugAssign2Assign_sample_from_COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1_to_22", "old_id": "COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1"}
{"code": "def countNumber ( n ) :\n    result = 0\n    idx_mfj0 = 0\n    list_t3d6 = range ( 1 , 10 )\n    while idx_mfj0 < len(list_t3d6):\n        i = list_t3d6[idx_mfj0]\n        s = [ ]\n        if ( i <= n ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n            s.append ( i )\n            result = result + 1\n        while len ( s ) != 0 :\n            tp = s [ - 1 ]\n            s.pop ( )\n            idx_31rl = 0\n            list_o2vx = range ( tp % 10 , 10 )\n            while idx_31rl < len(list_o2vx):\n                j = list_o2vx[idx_31rl]\n                x = tp * 10 + j\n                if ( x <= n ) and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n                    s.append ( x )\n                    result = result + 1\n                idx_31rl = idx_31rl + 1\n        idx_mfj0 = idx_mfj0 + 1\n    return result", "id": "AugAssign2Assign_sample_from_COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER_to_23", "old_id": "COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER"}
{"code": "def countNegative ( M , n , m ) :\n    count = 0\n    idx_hzuk = 0\n    list_ruo9 = range ( n )\n    while idx_hzuk < len(list_ruo9):\n        i = list_ruo9[idx_hzuk]\n        idx_16j8 = 0\n        list_9kpn = range ( m )\n        while idx_16j8 < len(list_9kpn):\n            j = list_9kpn[idx_16j8]\n            if M [ i ] [ j ] < 0 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                count = count + 1\n            else :\n                break\n            idx_16j8 = idx_16j8 + 1\n        idx_hzuk = idx_hzuk + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_to_24", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX"}
{"code": "def numOfIncSubseqOfSizeK ( arr , n , k ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ]\n    idx_tclp = 0\n    list_anqy = range ( n )\n    while idx_tclp < len(list_anqy):\n        i = list_anqy[idx_tclp]\n        dp [ 0 ] [ i ] = 1\n        idx_tclp = idx_tclp + 1\n    idx_9y0g = 0\n    list_i4ta = range ( 1 , k )\n    while idx_9y0g < len(list_i4ta):\n        l = list_i4ta[idx_9y0g]\n        idx_z3ry = 0\n        list_qoyw = range ( l , n )\n        while idx_z3ry < len(list_qoyw):\n            i = list_qoyw[idx_z3ry]\n            dp [ l ] [ i ] = 0\n            idx_9t7l = 0\n            list_4l8s = range ( l - 1 , i )\n            while idx_9t7l < len(list_4l8s):\n                j = list_4l8s[idx_9t7l]\n                if ( arr [ j ] < arr [ i ] ) and (((True or False) and (False or True)) and ((10 > 2) or (10 < 2))):\n                    dp [ l ] [ i ] = dp [ l ] [ i ] + dp [ l - 1 ] [ j ]\n                idx_9t7l = idx_9t7l + 1\n            idx_z3ry = idx_z3ry + 1\n        idx_9y0g = idx_9y0g + 1\n    Sum = 0\n    idx_bjy4 = 0\n    list_wgr1 = range ( k - 1 , n )\n    while idx_bjy4 < len(list_wgr1):\n        i = list_wgr1[idx_bjy4]\n        Sum = Sum + dp [ k - 1 ] [ i ]\n        idx_bjy4 = idx_bjy4 + 1\n    return Sum", "id": "AugAssign2Assign_sample_from_COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K_to_25", "old_id": "COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K"}
{"code": "def countOccurrences ( arr , n , x ) :\n    res = 0\n    idx_4ekq = 0\n    list_d2ik = range ( n )\n    while idx_4ekq < len(list_d2ik):\n        i = list_d2ik[idx_4ekq]\n        if x == arr [ i ] and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n            res = res + 1\n        idx_4ekq = idx_4ekq + 1\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY_to_26", "old_id": "COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    idx_bapx = 0\n    list_9cvy = range ( n )\n    while idx_bapx < len(list_9cvy):\n        i = list_9cvy[idx_bapx]\n        if ( str [ i ] == 'a' ) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n            a_index = i + 1\n            ans = ans - min ( b_index , c_index )\n        elif ( str [ i ] == 'b' ) :\n            b_index = i + 1\n            ans = ans - min ( a_index , c_index )\n        else :\n            c_index = i + 1\n            ans = ans - min ( a_index , b_index )\n        idx_bapx = idx_bapx + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_27", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    idx_apfn = 0\n    list_ihfu = range ( len ( s ) )\n    while idx_apfn < len(list_ihfu):\n        i = list_ihfu[idx_apfn]\n        if s [ ~ i ] == 'a' and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n        else :\n            b_count = b_count + 1\n        idx_apfn = idx_apfn + 1\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_28", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def countPairsWithDiffK ( arr , n , k ) :\n    count = 0\n    idx_ipso = 0\n    list_o8vp = range ( 0 , n )\n    while idx_ipso < len(list_o8vp):\n        i = list_o8vp[idx_ipso]\n        idx_218g = 0\n        list_1qwm = range ( i + 1 , n )\n        while idx_218g < len(list_1qwm):\n            j = list_1qwm[idx_218g]\n            if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n                count = count + 1\n            idx_218g = idx_218g + 1\n        idx_ipso = idx_ipso + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_PAIRS_DIFFERENCE_EQUAL_K_to_29", "old_id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K"}
{"code": "def countPairs ( arr1 , arr2 , m , n , x ) :\n    count = 0\n    us = set ( )\n    idx_2q0r = 0\n    list_3omu = range ( m )\n    while idx_2q0r < len(list_3omu):\n        i = list_3omu[idx_2q0r]\n        us.add ( arr1 [ i ] )\n        idx_2q0r = idx_2q0r + 1\n    idx_27z5 = 0\n    list_nd0f = range ( n )\n    while idx_27z5 < len(list_nd0f):\n        j = list_nd0f[idx_27z5]\n        if x - arr2 [ j ] in us and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            count = count + 1\n        idx_27z5 = idx_27z5 + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1_to_30", "old_id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1"}
{"code": "def countPairs ( arr , n ) :\n    result = 0\n    Hash = set ( )\n    idx_6o3s = 0\n    list_xbih = range ( n )\n    while idx_6o3s < len(list_xbih):\n        i = list_xbih[idx_6o3s]\n        Hash.add ( arr [ i ] )\n        idx_6o3s = idx_6o3s + 1\n    idx_qpiv = 0\n    list_noxm = range ( n )\n    while idx_qpiv < len(list_noxm):\n        i = list_noxm[idx_qpiv]\n        idx_wrek = 0\n        list_9x5v = range ( i + 1 , n )\n        while idx_wrek < len(list_9x5v):\n            j = list_9x5v[idx_wrek]\n            product = arr [ i ] * arr [ j ]\n            if product in ( Hash ) and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n                result = result + 1\n            idx_wrek = idx_wrek + 1\n        idx_qpiv = idx_qpiv + 1\n    return result", "id": "AugAssign2Assign_sample_from_COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1_to_31", "old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1"}
{"code": "def countDecodingDP ( digits , n ) :\n    count = [ 0 ] * ( n + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == '0' and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n        return 0\n    idx_u64x = 0\n    list_ux6c = range ( 2 , n + 1 )\n    while idx_u64x < len(list_ux6c):\n        i = list_ux6c[idx_u64x]\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > '0' ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            count [ i ] = count [ i ] + count [ i - 2 ]\n        idx_u64x = idx_u64x + 1\n    return count [ n ]", "id": "AugAssign2Assign_sample_from_COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1_to_32", "old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1"}
{"code": "def countRotationsDivBy8 ( n ) :\n    l = len ( n )\n    count = 0\n    if ( l == 1 ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n        oneDigit = int ( n [ 0 ] )\n        if ( oneDigit % 8 == 0 ) :\n            return 1\n        return 0\n    if ( l == 2 ) and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n        first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] )\n        second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] )\n        if ( first % 8 == 0 ) :\n            count = count + 1\n        if ( second % 8 == 0 ) :\n            count = count + 1\n        return count\n    threeDigit = 0\n    idx_4nsf = 0\n    list_civk = range ( 0 , ( l - 2 ) )\n    while idx_4nsf < len(list_civk):\n        i = list_civk[idx_4nsf]\n        threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) )\n        if ( threeDigit % 8 == 0 ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            count = count + 1\n        idx_4nsf = idx_4nsf + 1\n    threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) )\n    if ( threeDigit % 8 == 0 ) and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        count = count + 1\n    threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) )\n    if ( threeDigit % 8 == 0 ) and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n        count = count + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_ROTATIONS_DIVISIBLE_8_to_33", "old_id": "COUNT_ROTATIONS_DIVISIBLE_8"}
{"code": "def sortedCount ( mat , r , c ) :\n    result = 0\n    idx_8rb0 = 0\n    list_bclu = range ( r )\n    while idx_8rb0 < len(list_bclu):\n        i = list_bclu[idx_8rb0]\n        j = 0\n        idx_t8pu = 0\n        list_gy7t = range ( c - 1 )\n        while idx_t8pu < len(list_gy7t):\n            j = list_gy7t[idx_t8pu]\n            if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                break\n            idx_t8pu = idx_t8pu + 1\n        if j == c - 2 and (((True or False) and (False or True)) and ((8 > 6) or (8 < 6))):\n            result = result + 1\n        idx_8rb0 = idx_8rb0 + 1\n    idx_i2wy = 0\n    list_txp5 = range ( 0 , r )\n    while idx_i2wy < len(list_txp5):\n        i = list_txp5[idx_i2wy]\n        j = 0\n        idx_ga84 = 0\n        list_u1v0 = range ( c - 1 , 0 , - 1 )\n        while idx_ga84 < len(list_u1v0):\n            j = list_u1v0[idx_ga84]\n            if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n                break\n            idx_ga84 = idx_ga84 + 1\n        if c > 1 and j == 1 and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n            result = result + 1\n        idx_i2wy = idx_i2wy + 1\n    return result", "id": "AugAssign2Assign_sample_from_COUNT_SORTED_ROWS_MATRIX_to_34", "old_id": "COUNT_SORTED_ROWS_MATRIX"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ] * ( n + 1 )\n    hash_negative = [ 0 ] * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    idx_i1d3 = 0\n    list_er4k = range ( n )\n    while idx_i1d3 < len(list_er4k):\n        i = list_er4k[idx_i1d3]\n        if ( arr [ i ] & 1 == 1 ) and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n            difference = difference + 1\n        else :\n            difference = difference - 1\n        if ( difference < 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            ans = ans + hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n        else :\n            ans = ans + hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ] + 1\n        idx_i1d3 = idx_i1d3 + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_35", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1 << i\n        idx_eiwn = 0\n        list_8y34 = range ( 0 , n + 1 )\n        while idx_eiwn < len(list_8y34):\n            j = list_8y34[idx_eiwn]\n            ans = ans + k\n            if change == 1 and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n                k = not k\n                change = 1 << i\n            else :\n                change = change - 1\n            idx_eiwn = idx_eiwn + 1\n        i = i + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_36", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def countWords ( str , n ) :\n    m = dict ( )\n    idx_w3hq = 0\n    list_0ubv = range ( n )\n    while idx_w3hq < len(list_0ubv):\n        i = list_0ubv[idx_w3hq]\n        m [ str [ i ] ] = m.get ( str [ i ] , 0 ) + 1\n        idx_w3hq = idx_w3hq + 1\n    res = 0\n    idx_4qst = 0\n    list_63k5 = m.values ( )\n    while idx_4qst < len(list_63k5):\n        i = list_63k5[idx_4qst]\n        if i == 2 and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n            res = res + 1\n        idx_4qst = idx_4qst + 1\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS_to_37", "old_id": "COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS"}
{"code": "def countWords ( str , len ) :\n    count = 1 ;\n    if ( len == 1 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return count\n    if ( str [ 0 ] == str [ 1 ] ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        count = count * 1\n    else :\n        count = count * 2\n    idx_we9a = 0\n    list_3xg9 = range ( 1 , len - 1 )\n    while idx_we9a < len(list_3xg9):\n        j = list_3xg9[idx_we9a]\n        if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            count = count * 1\n        elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :\n            count = count * 2\n        else :\n            count = count * 3\n        idx_we9a = idx_we9a + 1\n    if ( str [ len - 1 ] == str [ len - 2 ] ) and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n        count = count * 1\n    else :\n        count = count * 2\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD_to_38", "old_id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ] * NO_OF_CHARS\n    idx_to3f = 0\n    list_uhpd = range ( len ( str ) )\n    while idx_to3f < len(list_uhpd):\n        i = list_uhpd[idx_to3f]\n        count [ ord ( str [ i ] ) ] = count [ ord ( str [ i ] ) ] + 1\n        idx_to3f = idx_to3f + 1\n    first , second = 0 , 0\n    idx_dts2 = 0\n    list_fg5h = range ( NO_OF_CHARS )\n    while idx_dts2 < len(list_fg5h):\n        i = list_fg5h[idx_dts2]\n        if count [ i ] > count [ first ] and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            second = first\n            first = i\n        elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n            second = i\n        idx_dts2 = idx_dts2 + 1\n    return chr ( second )", "id": "AugAssign2Assign_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_39", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    idx_zkoj = 0\n    list_56ul = range ( len ( Str ) )\n    while idx_zkoj < len(list_56ul):\n        i = list_56ul[idx_zkoj]\n        count = 0\n        if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( '0' )\n                i = i + 1\n            i = i - 1\n            integerstack.append ( count )\n        elif ( Str [ i ] == ']' ) :\n            temp = \"\"\n            count = 0\n            if ( len ( integerstack ) != 0 ) :\n                count = integerstack [ - 1 ]\n                integerstack.pop ( )\n            while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                temp = stringstack [ - 1 ] + temp\n                stringstack.pop ( )\n            if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                stringstack.pop ( )\n            idx_u8ic = 0\n            list_b7pf = range ( count )\n            while idx_u8ic < len(list_b7pf):\n                j = list_b7pf[idx_u8ic]\n                result = result + temp\n                idx_u8ic = idx_u8ic + 1\n            idx_f0zw = 0\n            list_z5o6 = range ( len ( result ) )\n            while idx_f0zw < len(list_z5o6):\n                j = list_z5o6[idx_f0zw]\n                stringstack.append ( result [ j ] )\n                idx_f0zw = idx_f0zw + 1\n            result = \"\"\n        elif ( Str [ i ] == '[' ) :\n            if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                stringstack.append ( Str [ i ] )\n            else :\n                stringstack.append ( Str [ i ] )\n                integerstack.append ( 1 )\n        else :\n            stringstack.append ( Str [ i ] )\n        idx_zkoj = idx_zkoj + 1\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "AugAssign2Assign_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_40", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def findDiff ( arr , n ) :\n    arr.sort ( )\n    count = 0\n    max_count = 0\n    min_count = n\n    idx_ghxu = 0\n    list_d3u1 = range ( 0 , ( n - 1 ) )\n    while idx_ghxu < len(list_d3u1):\n        i = list_d3u1[idx_ghxu]\n        if arr [ i ] == arr [ i + 1 ] and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            count = count + 1\n            continue\n        else :\n            max_count = max ( max_count , count )\n            min_count = min ( min_count , count )\n            count = 0\n        idx_ghxu = idx_ghxu + 1\n    return max_count - min_count", "id": "AugAssign2Assign_sample_from_DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_to_41", "old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY"}
{"code": "def checkCount ( arr , n , k ) :\n    mp = defaultdict ( lambda : 0 )\n    idx_xmsr = 0\n    list_q6rw = range ( n )\n    while idx_xmsr < len(list_q6rw):\n        i = list_q6rw[idx_xmsr]\n        mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n        idx_xmsr = idx_xmsr + 1\n    idx_o7jm = 0\n    list_n4of = list(mp.items ( ))\n    while idx_o7jm < len(list_n4of):\n        key , values = list_n4of[idx_o7jm]\n        if values > 2 * k and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            return False\n        idx_o7jm = idx_o7jm + 1\n    return True", "id": "AugAssign2Assign_sample_from_DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1_to_42", "old_id": "DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1"}
{"code": "def isDvisibleBy12 ( num ) :\n    if ( len ( num ) >= 3 ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        d1 = int ( num [ len ( num ) - 1 ] )\n        if ( d1 % 2 != 0 ) :\n            return False\n        d2 = int ( num [ len ( num ) - 2 ] )\n        sum = 0\n        idx_ygvk = 0\n        list_k509 = range ( 0 , len ( num ) )\n        while idx_ygvk < len(list_k509):\n            i = list_k509[idx_ygvk]\n            sum = sum + int ( num [ i ] )\n            idx_ygvk = idx_ygvk + 1\n        return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )\n    else :\n        number = int ( num )\n        return ( number % 12 == 0 )", "id": "AugAssign2Assign_sample_from_DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER_to_43", "old_id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER"}
{"code": "def doublefactorial ( n ) :\n    res = 1\n    idx_sg5l = 0\n    list_ja8o = range ( n , - 1 , - 2 )\n    while idx_sg5l < len(list_ja8o):\n        i = list_ja8o[idx_sg5l]\n        if ( i == 0 or i == 1 ) and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n            return res\n        else :\n            res = res * i\n        idx_sg5l = idx_sg5l + 1\n    return res;", "id": "AugAssign2Assign_sample_from_DOUBLE_FACTORIAL_1_to_44", "old_id": "DOUBLE_FACTORIAL_1"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    idx_czwt = 0\n    list_t654 = range ( n )\n    while idx_czwt < len(list_t654):\n        i = list_t654[idx_czwt]\n        if symb [ i ] == 'F' and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == 'T' and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n        idx_czwt = idx_czwt + 1\n    idx_142v = 0\n    list_gszv = range ( 1 , n )\n    while idx_142v < len(list_gszv):\n        gap = list_gszv[idx_142v]\n        i = 0\n        idx_zjxa = 0\n        list_1jrc = range ( gap , n )\n        while idx_zjxa < len(list_1jrc):\n            j = list_1jrc[idx_zjxa]\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            idx_bcwy = 0\n            list_ky59 = range ( gap )\n            while idx_bcwy < len(list_ky59):\n                g = list_ky59[idx_bcwy]\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n                    T [ i ] [ j ] = T [ i ] [ j ] + T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] = F [ i ] [ j ] + ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n                    F [ i ] [ j ] = F [ i ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] = T [ i ] [ j ] + ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n                    T [ i ] [ j ] = T [ i ] [ j ] + ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] = F [ i ] [ j ] + ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                idx_bcwy = idx_bcwy + 1\n            i = i + 1\n            idx_zjxa = idx_zjxa + 1\n        idx_142v = idx_142v + 1\n    return T [ 0 ] [ n - 1 ]", "id": "AugAssign2Assign_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_45", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def countNum ( arr , n ) :\n    count = 0\n    arr = arr[:n]\n    arr.sort ( )\n    idx_8cme = 0\n    list_9jrq = range ( 0 , n - 1 )\n    while idx_8cme < len(list_9jrq):\n        i = list_9jrq[idx_8cme]\n        if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            count = count + arr [ i + 1 ] - arr [ i ] - 1\n        idx_8cme = idx_8cme + 1\n    return count", "id": "AugAssign2Assign_sample_from_ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_to_46", "old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY"}
{"code": "def countNum ( arr , n ) :\n    s = dict ( )\n    count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9\n    idx_le1y = 0\n    list_6sw3 = range ( n )\n    while idx_le1y < len(list_6sw3):\n        i = list_6sw3[idx_le1y]\n        s [ arr [ i ] ] = 1\n        if ( arr [ i ] < minm ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            minm = arr [ i ]\n        if ( arr [ i ] > maxm ) and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n            maxm = arr [ i ]\n        idx_le1y = idx_le1y + 1\n    idx_3sql = 0\n    list_nahb = range ( minm , maxm + 1 )\n    while idx_3sql < len(list_nahb):\n        i = list_nahb[idx_3sql]\n        if i not in s.keys ( ) and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n            count = count + 1\n        idx_3sql = idx_3sql + 1\n    return count", "id": "AugAssign2Assign_sample_from_ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1_to_47", "old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1"}
{"code": "def equilibrium ( arr , n) :\n    leftsum = 0\n    rightsum = 0\n    idx_scr0 = 0\n    list_go6e = range ( n )\n    while idx_scr0 < len(list_go6e):\n        i = list_go6e[idx_scr0]\n        leftsum = 0\n        rightsum = 0\n        idx_lztc = 0\n        list_6jg9 = range ( i )\n        while idx_lztc < len(list_6jg9):\n            j = list_6jg9[idx_lztc]\n            leftsum = leftsum + arr [ j ]\n            idx_lztc = idx_lztc + 1\n        idx_whz8 = 0\n        list_2u7b = range ( i + 1 , n )\n        while idx_whz8 < len(list_2u7b):\n            j = list_2u7b[idx_whz8]\n            rightsum = rightsum + arr [ j ]\n            idx_whz8 = idx_whz8 + 1\n        if leftsum == rightsum and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            return i\n        idx_scr0 = idx_scr0 + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_EQUILIBRIUM_INDEX_OF_AN_ARRAY_to_48", "old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY"}
{"code": "def equilibrium ( arr ,n) :\n    total_sum = sum ( arr )\n    leftsum = 0\n    idx_zpgj = 0\n    list_r20v = list(enumerate ( arr ))\n    while idx_zpgj < len(list_r20v):\n        i , num = list_r20v[idx_zpgj]\n        total_sum = total_sum - num\n        if leftsum == total_sum and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n            return i\n        leftsum = leftsum + num\n        idx_zpgj = idx_zpgj + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_EQUILIBRIUM_INDEX_OF_AN_ARRAY_1_to_49", "old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY_1"}
{"code": "def maxHamming ( arr , n ) :\n    brr = [ 0 ] * ( 2 * n + 1 )\n    idx_kjl5 = 0\n    list_hsj6 = range ( n )\n    while idx_kjl5 < len(list_hsj6):\n        i = list_hsj6[idx_kjl5]\n        brr [ i ] = arr [ i ]\n        idx_kjl5 = idx_kjl5 + 1\n    idx_4ys7 = 0\n    list_ypl0 = range ( n )\n    while idx_4ys7 < len(list_ypl0):\n        i = list_ypl0[idx_4ys7]\n        brr [ n + i ] = arr [ i ]\n        idx_4ys7 = idx_4ys7 + 1\n    maxHam = 0\n    idx_9v46 = 0\n    list_0czm = range ( 1 , n )\n    while idx_9v46 < len(list_0czm):\n        i = list_0czm[idx_9v46]\n        currHam = 0\n        k = 0\n        idx_0yhf = 0\n        list_vhnm = range ( i , i + n )\n        while idx_0yhf < len(list_vhnm):\n            j = list_vhnm[idx_0yhf]\n            if brr [ j ] != arr [ k ] and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n                currHam = currHam + 1\n                k = k + 1\n            idx_0yhf = idx_0yhf + 1\n        if currHam == n and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n            return n\n        maxHam = max ( maxHam , currHam )\n        idx_9v46 = idx_9v46 + 1\n    return maxHam", "id": "AugAssign2Assign_sample_from_FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE_to_50", "old_id": "FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    idx_93x8 = 0\n    list_csai = string\n    while idx_93x8 < len(list_csai):\n        ch = list_csai[idx_93x8]\n        if ch == ')' and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != '(' :\n                elementsInside = elementsInside + 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n        else :\n            Stack.append ( ch )\n        idx_93x8 = idx_93x8 + 1\n    return False", "id": "AugAssign2Assign_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_51", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def maxPrimeFactors ( n ) :\n    maxPrime = - 1\n    while n % 2 == 0 :\n        maxPrime = 2\n        n = n >> 1\n    idx_ozty = 0\n    list_hf2t = range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 )\n    while idx_ozty < len(list_hf2t):\n        i = list_hf2t[idx_ozty]\n        while n % i == 0 :\n            maxPrime = i\n            n = n / i\n        idx_ozty = idx_ozty + 1\n    if n > 2 and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n        maxPrime = n\n    return int ( maxPrime )", "id": "AugAssign2Assign_sample_from_FIND_LARGEST_PRIME_FACTOR_NUMBER_to_52", "old_id": "FIND_LARGEST_PRIME_FACTOR_NUMBER"}
{"code": "def findMaxAverage ( arr , n , k ) :\n    if ( k > n ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n        return - 1\n    sum = arr [ 0 ]\n    idx_taug = 0\n    list_mtaj = range ( 1 , k )\n    while idx_taug < len(list_mtaj):\n        i = list_mtaj[idx_taug]\n        sum = sum + arr [ i ]\n        idx_taug = idx_taug + 1\n    max_sum = sum\n    max_end = k - 1\n    idx_z5nr = 0\n    list_q1w5 = range ( k , n )\n    while idx_z5nr < len(list_q1w5):\n        i = list_q1w5[idx_z5nr]\n        sum = sum + arr [ i ] - arr [ i - k ]\n        if ( sum > max_sum ) and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n            max_sum = sum\n            max_end = i\n        idx_z5nr = idx_z5nr + 1\n    return max_end - k + 1", "id": "AugAssign2Assign_sample_from_FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1_to_53", "old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1"}
{"code": "def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :\n    sum1 , sum2 , sum3 = 0 , 0 , 0\n    idx_swgq = 0\n    list_5fvi = range ( n1 )\n    while idx_swgq < len(list_5fvi):\n        i = list_5fvi[idx_swgq]\n        sum1 = sum1 + stack1 [ i ]\n        idx_swgq = idx_swgq + 1\n    idx_xeug = 0\n    list_w6ou = range ( n2 )\n    while idx_xeug < len(list_w6ou):\n        i = list_w6ou[idx_xeug]\n        sum2 = sum2 + stack2 [ i ]\n        idx_xeug = idx_xeug + 1\n    idx_46ej = 0\n    list_9pub = range ( n3 )\n    while idx_46ej < len(list_9pub):\n        i = list_9pub[idx_46ej]\n        sum3 = sum3 + stack3 [ i ]\n        idx_46ej = idx_46ej + 1\n    top1 , top2 , top3 = 0 , 0 , 0\n    ans = 0\n    while ( 1 ) :\n        if ( top1 == n1 or top2 == n2 or top3 == n3 ) and (((True or False) and (False or True)) and ((9 > 0) or (9 < 0))):\n            return 0\n        if ( sum1 == sum2 and sum2 == sum3 ) and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            return sum1\n        if ( sum1 >= sum2 and sum1 >= sum3 ) and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n            sum1 = sum1 - stack1 [ top1 ]\n            top1 = top1 + 1\n        elif ( sum2 >= sum3 and sum2 >= sum3 ) :\n            sum2 = sum2 - stack2 [ top2 ]\n            top2 = top2 + 1\n        elif ( sum3 >= sum2 and sum3 >= sum1 ) :\n            sum3 = sum3 - stack3 [ top3 ]\n            top3 = top3 + 1", "id": "AugAssign2Assign_sample_from_FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS_to_54", "old_id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS"}
{"code": "def findMinNumber ( n ) :\n    count = 0\n    ans = 1\n    while n % 2 == 0 :\n        count = count + 1\n        n = n // 2\n    if count % 2 is not 0 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n        ans = ans * 2\n    idx_zdmb = 0\n    list_5o6f = range ( 3 , ( int ) ( math.sqrt ( n ) ) + 1 , 2 )\n    while idx_zdmb < len(list_5o6f):\n        i = list_5o6f[idx_zdmb]\n        count = 0\n        while n % i == 0 :\n            count = count + 1\n            n = n // i\n        if count % 2 is not 0 and (((True or False) and (False or True)) and ((8 > 6) or (8 < 6))):\n            ans = ans * i\n        idx_zdmb = idx_zdmb + 1\n    if n > 2 and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        ans = ans * n\n    return ans", "id": "AugAssign2Assign_sample_from_FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE_to_55", "old_id": "FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE"}
{"code": "def countEndless ( input , n ) :\n    row = np.zeros ( ( n , n ) )\n    col = np.zeros ( ( n , n ) )\n    idx_csy0 = 0\n    list_iu5b = range ( n )\n    while idx_csy0 < len(list_iu5b):\n        j = list_iu5b[idx_csy0]\n        isEndless = 1\n        idx_dcn9 = 0\n        list_flid = range ( n - 1 , - 1 , - 1 )\n        while idx_dcn9 < len(list_flid):\n            i = list_flid[idx_dcn9]\n            if ( input [ i ] [ j ] == 0 ) and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n                isEndless = 0\n            col [ i ] [ j ] = isEndless\n            idx_dcn9 = idx_dcn9 + 1\n        idx_csy0 = idx_csy0 + 1\n    idx_67zc = 0\n    list_l4ms = range ( n )\n    while idx_67zc < len(list_l4ms):\n        i = list_l4ms[idx_67zc]\n        isEndless = 1\n        idx_9js7 = 0\n        list_cngd = range ( n - 1 , - 1 , - 1 )\n        while idx_9js7 < len(list_cngd):\n            j = list_cngd[idx_9js7]\n            if ( input [ i ] [ j ] == 0 ) and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n                isEndless = 0\n            row [ i ] [ j ] = isEndless\n            idx_9js7 = idx_9js7 + 1\n        idx_67zc = idx_67zc + 1\n    ans = 0\n    idx_wxua = 0\n    list_qadr = range ( n )\n    while idx_wxua < len(list_qadr):\n        i = list_qadr[idx_wxua]\n        idx_58mu = 0\n        list_pwqk = range ( 1 , n )\n        while idx_58mu < len(list_pwqk):\n            j = list_pwqk[idx_58mu]\n            if ( row [ i ] [ j ] and col [ i ] [ j ] ) and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n                ans = ans + 1\n            idx_58mu = idx_58mu + 1\n        idx_wxua = idx_wxua + 1\n    return ans", "id": "AugAssign2Assign_sample_from_FIND_NUMBER_ENDLESS_POINTS_to_56", "old_id": "FIND_NUMBER_ENDLESS_POINTS"}
{"code": "def countOps ( A , B , m , n ) :\n    idx_flzt = 0\n    list_ovkm = range ( n )\n    while idx_flzt < len(list_ovkm):\n        i = list_ovkm[idx_flzt]\n        idx_l5c3 = 0\n        list_j8x7 = range ( m )\n        while idx_l5c3 < len(list_j8x7):\n            j = list_j8x7[idx_l5c3]\n            A [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]\n            idx_l5c3 = idx_l5c3 + 1\n        idx_flzt = idx_flzt + 1\n    idx_qmyk = 0\n    list_send = range ( 1 , n )\n    while idx_qmyk < len(list_send):\n        i = list_send[idx_qmyk]\n        idx_q3hb = 0\n        list_4g5h = range ( 1 , n )\n        while idx_q3hb < len(list_4g5h):\n            j = list_4g5h[idx_q3hb]\n            if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                return - 1\n            idx_q3hb = idx_q3hb + 1\n        idx_qmyk = idx_qmyk + 1\n    result = 0\n    idx_rhnz = 0\n    list_fn8e = range ( n )\n    while idx_rhnz < len(list_fn8e):\n        i = list_fn8e[idx_rhnz]\n        result = result + abs ( A [ i ] [ 0 ] )\n        idx_rhnz = idx_rhnz + 1\n    idx_qvfs = 0\n    list_jcg2 = range ( m )\n    while idx_qvfs < len(list_jcg2):\n        j = list_jcg2[idx_qvfs]\n        result = result + abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] )\n        idx_qvfs = idx_qvfs + 1\n    return ( result )", "id": "AugAssign2Assign_sample_from_FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL_to_57", "old_id": "FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL"}
{"code": "def pairSum ( mat , n , sum ) :\n    idx_uk8v = 0\n    list_fzeg = range ( n )\n    while idx_uk8v < len(list_fzeg):\n        i = list_fzeg[idx_uk8v]\n        mat [ i ].sort ( )\n        idx_uk8v = idx_uk8v + 1\n    idx_37sw = 0\n    list_38sk = range ( n - 1 )\n    while idx_37sw < len(list_38sk):\n        i = list_38sk[idx_37sw]\n        idx_d8ts = 0\n        list_o0de = range ( i + 1 , n )\n        while idx_d8ts < len(list_o0de):\n            j = list_o0de[idx_d8ts]\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left = left + 1\n                    right = right - 1\n                else :\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left = left + 1\n                    else :\n                        right = right - 1\n            idx_d8ts = idx_d8ts + 1\n        idx_37sw = idx_37sw + 1", "id": "AugAssign2Assign_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_58", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    idx_q5lm = 0\n    list_bv1x = range ( 0 , n )\n    while idx_q5lm < len(list_bv1x):\n        i = list_bv1x[idx_q5lm]\n        high = max ( high , arr [ i ] )\n        idx_q5lm = idx_q5lm + 1\n    count = [ 0 ] * ( high + 1 )\n    idx_tbpa = 0\n    list_p2gy = range ( 0 , n )\n    while idx_tbpa < len(list_p2gy):\n        i = list_p2gy[idx_tbpa]\n        count [ arr [ i ] ] = count [ arr [ i ] ] + 1\n        idx_tbpa = idx_tbpa + 1\n    counter = 0\n    idx_rh0u = 0\n    list_u74h = range ( high , 0 , - 1 )\n    while idx_rh0u < len(list_u74h):\n        i = list_u74h[idx_rh0u]\n        j = i\n        while ( j <= high ) :\n            if ( count [ j ] > 0 ) and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n                counter = counter + count [ j ]\n            j = j + i\n            if ( counter == 2 ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n                return i\n        counter = 0\n        idx_rh0u = idx_rh0u + 1\n    return 1\n", "id": "AugAssign2Assign_sample_from_FIND_PAIR_MAXIMUM_GCD_ARRAY_1_to_59", "old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY_1"}
{"code": "def subArraySum ( arr , n , sum ) :\n    idx_mg3j = 0\n    list_0gql = range ( n )\n    while idx_mg3j < len(list_0gql):\n        i = list_0gql[idx_mg3j]\n        curr_sum = arr [ i ]\n        j = i + 1\n        while j <= n :\n            if curr_sum == sum and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n                print ( \"Sum found between\" )\n                print ( \"indexes %d and %d\" % ( i , j - 1 ) )\n                return 1\n            if curr_sum > sum or j == n and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n                break\n            curr_sum = curr_sum + arr [ j ]\n            j = j + 1\n        idx_mg3j = idx_mg3j + 1\n    print ( \"No subarray found\" )\n    return 0", "id": "AugAssign2Assign_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_to_60", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM"}
{"code": "def sumofoddFactors ( n ) :\n    res = 1\n    while n % 2 == 0 :\n        n = n // 2\n    idx_caky = 0\n    list_283b = range ( 3 , int ( math.sqrt ( n ) + 1 ) )\n    while idx_caky < len(list_283b):\n        i = list_283b[idx_caky]\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0 :\n            count = count + 1\n            n = n // i\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n        idx_caky = idx_caky + 1\n    if n >= 2 and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n        res = res * ( 1 + n )\n    return res", "id": "AugAssign2Assign_sample_from_FIND_SUM_ODD_FACTORS_NUMBER_to_61", "old_id": "FIND_SUM_ODD_FACTORS_NUMBER"}
{"code": "def findSubarraySum ( arr , n ) :\n    res = 0\n    m = dict ( )\n    idx_618q = 0\n    list_g1n5 = range ( n )\n    while idx_618q < len(list_g1n5):\n        i = list_g1n5[idx_618q]\n        Sum = 0\n        idx_awme = 0\n        list_2nvy = range ( i , n )\n        while idx_awme < len(list_2nvy):\n            j = list_2nvy[idx_awme]\n            Sum = Sum + arr [ j ]\n            m [ Sum ] = m.get ( Sum , 0 ) + 1\n            idx_awme = idx_awme + 1\n        idx_618q = idx_618q + 1\n    idx_g42l = 0\n    list_3fgs = m\n    while idx_g42l < len(list_3fgs):\n        x = list_3fgs[idx_g42l]\n        if m [ x ] == 1 and (((True or False) and (False or True)) and ((7 > 3) or (7 < 3))):\n            res = res + x\n        idx_g42l = idx_g42l + 1\n    return res", "id": "AugAssign2Assign_sample_from_FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY_to_62", "old_id": "FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY"}
{"code": "def maxLen ( arr , n ) :\n    max_len = 0\n    idx_mtvq = 0\n    list_uk21 = range ( n )\n    while idx_mtvq < len(list_uk21):\n        i = list_uk21[idx_mtvq]\n        curr_sum = 0\n        idx_vqgh = 0\n        list_roxf = range ( i , n )\n        while idx_vqgh < len(list_roxf):\n            j = list_roxf[idx_vqgh]\n            curr_sum = curr_sum + arr [ j ]\n            if curr_sum == 0 and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n                max_len = max ( max_len , j - i + 1 )\n            idx_vqgh = idx_vqgh + 1\n        idx_mtvq = idx_mtvq + 1\n    return max_len\n", "id": "AugAssign2Assign_sample_from_FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_to_63", "old_id": "FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM"}
{"code": "def getOddOccurrence ( arr , arr_size ) :\n    idx_isw2 = 0\n    list_9bvm = range ( 0 , arr_size )\n    while idx_isw2 < len(list_9bvm):\n        i = list_9bvm[idx_isw2]\n        count = 0\n        idx_p6lb = 0\n        list_hqcp = range ( 0 , arr_size )\n        while idx_p6lb < len(list_hqcp):\n            j = list_hqcp[idx_p6lb]\n            if arr [ i ] == arr [ j ] and (((True or False) and (False or True)) and ((9 > 4) or (9 < 4))):\n                count = count + 1\n            idx_p6lb = idx_p6lb + 1\n        if ( count % 2 != 0 ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n            return arr [ i ]\n        idx_isw2 = idx_isw2 + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_to_64", "old_id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    idx_yuz0 = 0\n    list_ol0s = range ( 0 , n - 1 )\n    while idx_yuz0 < len(list_ol0s):\n        i = list_ol0s[idx_yuz0]\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if ( x + arr [ l ] + arr [ r ] == 0 ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n                print ( x , arr [ l ] , arr [ r ] )\n                l = l + 1\n                r = r - 1\n                found = True\n            elif ( x + arr [ l ] + arr [ r ] < 0 ) :\n                l = l + 1\n            else :\n                r = r - 1\n        idx_yuz0 = idx_yuz0 + 1\n    if ( found == False ) and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n        print ( \" No Triplet Found\" )", "id": "AugAssign2Assign_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_65", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def firstElement ( arr , n , k ) :\n    count_map = { }\n    idx_yzs1 = 0\n    list_5uvn = range ( 0 , n )\n    while idx_yzs1 < len(list_5uvn):\n        i = list_5uvn[idx_yzs1]\n        if ( arr [ i ] in count_map.keys ( ) ) and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n            count_map [ arr [ i ] ] = count_map [ arr [ i ] ] + 1\n        else :\n            count_map [ arr [ i ] ] = 1\n        i = i + 1\n        idx_yzs1 = idx_yzs1 + 1\n    idx_7cqx = 0\n    list_qmha = range ( 0 , n )\n    while idx_7cqx < len(list_qmha):\n        i = list_qmha[idx_7cqx]\n        if ( count_map [ arr [ i ] ] == k ) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            return arr [ i ]\n        i = i + 1\n        idx_7cqx = idx_7cqx + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY_to_66", "old_id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    idx_glz1 = 0\n    list_rhug = range ( n + 1 )\n    while idx_glz1 < len(list_rhug):\n        i = list_rhug[idx_glz1]\n        if ( i == n or seq [ i ] == 'I' ) and (((True or False) and (False or True)) and ((8 > 6) or (8 < 6))):\n            idx_brqc = 0\n            list_jw1i = range ( i - 1 , - 2 , - 1 )\n            while idx_brqc < len(list_jw1i):\n                j = list_jw1i[idx_brqc]\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count = count + 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n                idx_brqc = idx_brqc + 1\n        idx_glz1 = idx_glz1 + 1\n    return result", "id": "AugAssign2Assign_sample_from_FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1_to_67", "old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1"}
{"code": "def mostFrequent ( arr , n ) :\n    Hash = dict ( )\n    idx_zokj = 0\n    list_0glf = range ( n )\n    while idx_zokj < len(list_0glf):\n        i = list_0glf[idx_zokj]\n        if arr [ i ] in Hash.keys ( ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            Hash [ arr [ i ] ] = Hash [ arr [ i ] ] + 1\n        else :\n            Hash [ arr [ i ] ] = 1\n        idx_zokj = idx_zokj + 1\n    max_count = 0\n    res = - 1\n    idx_yf6n = 0\n    list_2vox = Hash\n    while idx_yf6n < len(list_2vox):\n        i = list_2vox[idx_yf6n]\n        if ( max_count < Hash [ i ] ) and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n            res = i\n            max_count = Hash [ i ]\n        idx_yf6n = idx_yf6n + 1\n    return res", "id": "AugAssign2Assign_sample_from_FREQUENT_ELEMENT_ARRAY_1_to_68", "old_id": "FREQUENT_ELEMENT_ARRAY_1"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    idx_ub92 = 0\n    list_htdf = range ( n + 1 )\n    while idx_ub92 < len(list_htdf):\n        i = list_htdf[idx_ub92]\n        if ( i == n or seq [ i ] == 'I' ) and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n            idx_ot5c = 0\n            list_1asz = range ( i - 1 , - 2 , - 1 )\n            while idx_ot5c < len(list_1asz):\n                j = list_1asz[idx_ot5c]\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count = count + 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n                idx_ot5c = idx_ot5c + 1\n        idx_ub92 = idx_ub92 + 1\n    return \"\".join(str(i) for i in result)", "id": "AugAssign2Assign_sample_from_GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1_to_69", "old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0\n    idx_fiuw = 0\n    list_xow9 = range ( 1 , m + 1 )\n    while idx_fiuw < len(list_xow9):\n        i = list_xow9[idx_fiuw]\n        if ( nxtbb < n ) and (((True or False) and (False or True)) and ((8 > 2) or (8 < 2))):\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb = nxtbb + 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n        idx_fiuw = idx_fiuw + 1\n    return maxRev [ m ]", "id": "AugAssign2Assign_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_70", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    idx_ydi4 = 0\n    list_i0nc = arr\n    while idx_ydi4 < len(list_i0nc):\n        i = list_i0nc[idx_ydi4]\n        if ( i < 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] = hash [ abs ( i ) ] - 1\n        else :\n            hash [ i ] = hash.get ( i , 0 ) + 1\n        idx_ydi4 = idx_ydi4 + 1\n    idx_l04r = 0\n    list_x86l = arr\n    while idx_l04r < len(list_x86l):\n        i = list_x86l[idx_l04r]\n        if i in hash.keys ( ) and hash [ i ] > 0 and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n            return i\n        idx_l04r = idx_l04r + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_71", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def find ( a , b , k , n1 , n2 ) :\n    s = set ( )\n    idx_be26 = 0\n    list_nu15 = range ( n2 )\n    while idx_be26 < len(list_nu15):\n        i = list_nu15[idx_be26]\n        s.add ( b [ i ] )\n        idx_be26 = idx_be26 + 1\n    missing = 0\n    idx_109e = 0\n    list_n1ol = range ( n1 )\n    while idx_109e < len(list_n1ol):\n        i = list_n1ol[idx_109e]\n        if a [ i ] not in s and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n            missing = missing + 1\n        if missing == k and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            return a [ i ]\n        idx_109e = idx_109e + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE_to_72", "old_id": "K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE"}
{"code": "def largestGCDSubsequence ( arr , n ) :\n    ans = 0\n    maxele = max ( arr )\n    idx_zkad = 0\n    list_vfz2 = range ( 2 , maxele + 1 )\n    while idx_zkad < len(list_vfz2):\n        i = list_vfz2[idx_zkad]\n        count = 0\n        idx_0f34 = 0\n        list_m2wz = range ( n )\n        while idx_0f34 < len(list_m2wz):\n            j = list_m2wz[idx_0f34]\n            if ( arr [ j ] % i == 0 ) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n                count = count + 1\n            idx_0f34 = idx_0f34 + 1\n        ans = max ( ans , count )\n        idx_zkad = idx_zkad + 1\n    return ans", "id": "AugAssign2Assign_sample_from_LARGEST_SUBSEQUENCE_GCD_GREATER_1_to_73", "old_id": "LARGEST_SUBSEQUENCE_GCD_GREATER_1"}
{"code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    idx_fcdb = 0\n    list_yxaf = range ( n - 1 )\n    while idx_fcdb < len(list_yxaf):\n        i = list_yxaf[idx_fcdb]\n        if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n            dp [ i ] [ i + 1 ] = 2\n        idx_fcdb = idx_fcdb + 1\n    idx_jl49 = 0\n    list_nxo1 = range ( 2 , n )\n    while idx_jl49 < len(list_nxo1):\n        l = list_nxo1[idx_jl49]\n        i = - 1\n        idx_os2m = 0\n        list_rh8m = range ( l , n )\n        while idx_os2m < len(list_rh8m):\n            j = list_rh8m[idx_os2m]\n            i = i + 1\n            if ( s [ i ] == '(' and s [ j ] == ')' ) and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]\n            idx_t12o = 0\n            list_w2oc = range ( i , j )\n            while idx_t12o < len(list_w2oc):\n                k = list_w2oc[idx_t12o]\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n                idx_t12o = idx_t12o + 1\n            idx_os2m = idx_os2m + 1\n        idx_jl49 = idx_jl49 + 1\n    return dp [ 0 ] [ n - 1 ]", "id": "AugAssign2Assign_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_to_74", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    idx_xzof = 0\n    list_s39t = range ( n )\n    while idx_xzof < len(list_s39t):\n        i = list_s39t[idx_xzof]\n        if ( s [ i ] == '(' ) and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n            invalidOpenBraces = invalidOpenBraces + 1\n        else :\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces = invalidCloseBraces + 1\n            else :\n                invalidOpenBraces = invalidOpenBraces - 1\n        idx_xzof = idx_xzof + 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "AugAssign2Assign_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_75", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    idx_q9tu = 0\n    list_inxu = range ( n )\n    while idx_q9tu < len(list_inxu):\n        i = list_inxu[idx_q9tu]\n        L [ i ] [ n - 1 ] = 2\n        idx_q9tu = idx_q9tu + 1\n    idx_ndyz = 0\n    list_gpbz = range ( n - 2 , 0 , - 1 )\n    while idx_ndyz < len(list_gpbz):\n        j = list_gpbz[idx_ndyz]\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n                k = k + 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i = i - 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i = i - 1\n                k = k + 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i = i - 1\n        idx_ndyz = idx_ndyz + 1\n    return llap", "id": "AugAssign2Assign_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_76", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def subsequence ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n    idx_09sa = 0\n    list_y12s = string\n    while idx_09sa < len(list_y12s):\n        ch = list_y12s[idx_09sa]\n        cnt = 0\n        idx_xahy = 0\n        list_ql78 = range ( last , n )\n        while idx_xahy < len(list_ql78):\n            i = list_ql78[idx_xahy]\n            if s [ i ] == ch and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n                cnt = cnt + 1\n            idx_xahy = idx_xahy + 1\n        if cnt >= k and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n            idx_g9z1 = 0\n            list_hywe = range ( last , n )\n            while idx_g9z1 < len(list_hywe):\n                i = list_hywe[idx_g9z1]\n                if s [ i ] == ch :\n                    t [ size ] = ch\n                    new_last = i\n                    size = size + 1\n                idx_g9z1 = idx_g9z1 + 1\n            last = new_last\n        idx_09sa = idx_09sa + 1\n    t[size] = '\\0';", "id": "AugAssign2Assign_sample_from_LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES_to_77", "old_id": "LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES"}
{"code": "def minimizeWithKSwaps ( arr , n , k ) :\n    idx_s1df = 0\n    list_x1tf = range ( n - 1 )\n    while idx_s1df < len(list_x1tf):\n        i = list_x1tf[idx_s1df]\n        pos = i\n        idx_7jh8 = 0\n        list_sioq = range ( i + 1 , n )\n        while idx_7jh8 < len(list_sioq):\n            j = list_sioq[idx_7jh8]\n            if ( j - i > k ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n                break\n            if ( arr [ j ] < arr [ pos ] ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n                pos = j\n            idx_7jh8 = idx_7jh8 + 1\n        idx_42jq = 0\n        list_8mck = range ( pos , i , - 1 )\n        while idx_42jq < len(list_8mck):\n            j = list_8mck[idx_42jq]\n            arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ]\n            idx_42jq = idx_42jq + 1\n        k = k - pos - i\n        idx_s1df = idx_s1df + 1", "id": "AugAssign2Assign_sample_from_LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS_to_78", "old_id": "LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS"}
{"code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    idx_8ude = 0\n    list_c87h = range ( 0 , n )\n    while idx_8ude < len(list_c87h):\n        i = list_c87h[idx_8ude]\n        idx_klh6 = 0\n        list_63rc = range ( i + 1 , n , 2 )\n        while idx_klh6 < len(list_63rc):\n            j = list_63rc[idx_klh6]\n            length = j - i + 1\n            leftsum = 0\n            rightsum = 0\n            idx_xkaq = 0\n            list_yzk1 = range ( 0 , int ( length / 2 ) )\n            while idx_xkaq < len(list_yzk1):\n                k = list_yzk1[idx_xkaq]\n                leftsum = leftsum + ( int ( str [ i + k ] ) - int ( '0' ) )\n                rightsum = rightsum + ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) )\n                idx_xkaq = idx_xkaq + 1\n            if ( leftsum == rightsum and maxlen < length ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n                maxlen = length\n            idx_klh6 = idx_klh6 + 1\n        idx_8ude = idx_8ude + 1\n    return maxlen", "id": "AugAssign2Assign_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_to_79", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_o90y = 0\n    list_bpyj = range ( 1 , n + 1 )\n    while idx_o90y < len(list_bpyj):\n        i = list_bpyj[idx_o90y]\n        idx_cd1p = 0\n        list_wvjb = range ( 1 , n + 1 )\n        while idx_cd1p < len(list_wvjb):\n            j = list_wvjb[idx_cd1p]\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            idx_cd1p = idx_cd1p + 1\n        idx_o90y = idx_o90y + 1\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n            res = res + str [ i - 1 ]\n            i = i - 1\n            j = j - 1\n        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n            i = i - 1\n        else :\n            j = j - 1\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "AugAssign2Assign_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_80", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    idx_1lwt = 0\n    list_2b5u = range ( n )\n    while idx_1lwt < len(list_2b5u):\n        i = list_2b5u[idx_1lwt]\n        if arr [ i ] == 0 and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n            sum = sum + - 1\n        else :\n            sum = sum + 1\n        if ( sum == 1 ) and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n            maxLen = i + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n        idx_1lwt = idx_1lwt + 1\n    return maxLen", "id": "AugAssign2Assign_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_81", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    idx_bi2z = 0\n    list_cx9a = range ( n )\n    while idx_bi2z < len(list_cx9a):\n        i = list_cx9a[idx_bi2z]\n        curr_sum = curr_sum + arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k\n        idx_bi2z = idx_bi2z + 1\n    idx_n1ro = 0\n    list_vq21 = range ( n )\n    while idx_n1ro < len(list_vq21):\n        i = list_vq21[idx_n1ro]\n        if ( mod_arr [ i ] == 0 ) and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n            max = i + 1\n        elif ( mod_arr [ i ] in um ) :\n            um [ mod_arr [ i ] ] = i\n        else :\n            if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                max = i - um [ mod_arr [ i ] ]\n        idx_n1ro = idx_n1ro + 1\n    return max", "id": "AugAssign2Assign_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_82", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def findLongestConseqSubseq ( arr , n ) :\n    S = set ( )\n    idx_wv5o = 0\n    list_st5g = range ( n )\n    while idx_wv5o < len(list_st5g):\n        i = list_st5g[idx_wv5o]\n        S.add ( arr [ i ] )\n        idx_wv5o = idx_wv5o + 1\n    ans = 0\n    idx_xlf5 = 0\n    list_fz6r = range ( n )\n    while idx_xlf5 < len(list_fz6r):\n        i = list_fz6r[idx_xlf5]\n        if S.__contains__ ( arr [ i ] ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            j = arr [ i ]\n            while ( S.__contains__ ( j ) ) :\n                j = j + 1\n            ans = max ( ans , j - arr [ i ] )\n        idx_xlf5 = idx_xlf5 + 1\n    return ans", "id": "AugAssign2Assign_sample_from_MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY_to_83", "old_id": "MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY"}
{"code": "def maxRepeating ( str ) :\n    n = len ( str )\n    count = 0\n    res = str [ 0 ]\n    cur_count = 1\n    idx_pwge = 0\n    list_54ec = range ( n )\n    while idx_pwge < len(list_54ec):\n        i = list_54ec[idx_pwge]\n        if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n            cur_count = cur_count + 1\n        else :\n            if cur_count > count :\n                count = cur_count\n                res = str [ i ]\n            cur_count = 1\n        idx_pwge = idx_pwge + 1\n    return res", "id": "AugAssign2Assign_sample_from_MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1_to_84", "old_id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1"}
{"code": "def maxdiff ( arr , n ) :\n    freq = defaultdict ( lambda : 0 )\n    idx_x9jp = 0\n    list_l6k2 = range ( n )\n    while idx_x9jp < len(list_l6k2):\n        i = list_l6k2[idx_x9jp]\n        freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1\n        idx_x9jp = idx_x9jp + 1\n    ans = 0\n    idx_92rf = 0\n    list_elqf = range ( n )\n    while idx_92rf < len(list_elqf):\n        i = list_elqf[idx_92rf]\n        idx_v0wx = 0\n        list_uzeo = range ( n )\n        while idx_v0wx < len(list_uzeo):\n            j = list_uzeo[idx_v0wx]\n            if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )\n            elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :\n                ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )\n            idx_v0wx = idx_v0wx + 1\n        idx_92rf = idx_92rf + 1\n    return ans", "id": "AugAssign2Assign_sample_from_MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER_to_85", "old_id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER"}
{"code": "def maxRowDiff ( mat , m , n ) :\n    rowSum = [ 0 ] * m\n    idx_68wv = 0\n    list_0dzw = range ( 0 , m )\n    while idx_68wv < len(list_0dzw):\n        i = list_0dzw[idx_68wv]\n        sum = 0\n        idx_xmvg = 0\n        list_h1tx = range ( 0 , n )\n        while idx_xmvg < len(list_h1tx):\n            j = list_h1tx[idx_xmvg]\n            sum = sum + mat [ i ] [ j ]\n            idx_xmvg = idx_xmvg + 1\n        rowSum [ i ] = sum\n        idx_68wv = idx_68wv + 1\n    max_diff = rowSum [ 1 ] - rowSum [ 0 ]\n    min_element = rowSum [ 0 ]\n    idx_zi2u = 0\n    list_9e1q = range ( 1 , m )\n    while idx_zi2u < len(list_9e1q):\n        i = list_9e1q[idx_zi2u]\n        if ( rowSum [ i ] - min_element > max_diff ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            max_diff = rowSum [ i ] - min_element\n        if ( rowSum [ i ] < min_element ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            min_element = rowSum [ i ]\n        idx_zi2u = idx_zi2u + 1\n    return max_diff", "id": "AugAssign2Assign_sample_from_MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX_to_86", "old_id": "MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX"}
{"code": "def maxDiff ( arr , n ) :\n    SubsetSum_1 = 0\n    SubsetSum_2 = 0\n    idx_wnik = 0\n    list_9mrg = range ( 0 , n )\n    while idx_wnik < len(list_9mrg):\n        i = list_9mrg[idx_wnik]\n        isSingleOccurance = True\n        idx_n0u1 = 0\n        list_61j7 = range ( i + 1 , n )\n        while idx_n0u1 < len(list_61j7):\n            j = list_61j7[idx_n0u1]\n            if ( arr [ i ] == arr [ j ] ) and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n                isSingleOccurance = False\n                arr [ i ] = arr [ j ] = 0\n                break\n            idx_n0u1 = idx_n0u1 + 1\n        if ( isSingleOccurance == True ) and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n            if ( arr [ i ] > 0 ) :\n                SubsetSum_1 = SubsetSum_1 + arr [ i ]\n            else :\n                SubsetSum_2 = SubsetSum_2 + arr [ i ]\n        idx_wnik = idx_wnik + 1\n    return abs ( SubsetSum_1 - SubsetSum_2 )", "id": "AugAssign2Assign_sample_from_MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_to_87", "old_id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY"}
{"code": "def maxProductSubset ( a , n ) :\n    if n == 1 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        return a [ 0 ]\n    max_neg = - 999999999999\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    idx_2r04 = 0\n    list_rbav = range ( n )\n    while idx_2r04 < len(list_rbav):\n        i = list_rbav[idx_2r04]\n        if a [ i ] == 0 and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            count_zero = count_zero + 1\n            continue\n        if a [ i ] < 0 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            count_neg = count_neg + 1\n            max_neg = max ( max_neg , a [ i ] )\n        prod = prod + a [ i ]\n        idx_2r04 = idx_2r04 + 1\n    if count_zero == n and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return 0\n    if count_neg & 1 and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :\n            return 0\n        prod = int(prod / max_neg)\n    return prod", "id": "AugAssign2Assign_sample_from_MAXIMUM_PRODUCT_SUBSET_ARRAY_to_88", "old_id": "MAXIMUM_PRODUCT_SUBSET_ARRAY"}
{"code": "def MinimumCost ( cost , n , W ) :\n    val = list ( )\n    wt = list ( )\n    size = 0\n    idx_y2md = 0\n    list_a8md = range ( n )\n    while idx_y2md < len(list_a8md):\n        i = list_a8md[idx_y2md]\n        if ( cost [ i ] != - 1 ) and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n            val.append ( cost [ i ] )\n            wt.append ( i + 1 )\n            size = size + 1\n        idx_y2md = idx_y2md + 1\n    n = size\n    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]\n    idx_d4eu = 0\n    list_hmuv = range ( W + 1 )\n    while idx_d4eu < len(list_hmuv):\n        i = list_hmuv[idx_d4eu]\n        min_cost [ 0 ] [ i ] = INF\n        idx_d4eu = idx_d4eu + 1\n    idx_xzkm = 0\n    list_xvru = range ( 1 , n + 1 )\n    while idx_xzkm < len(list_xvru):\n        i = list_xvru[idx_xzkm]\n        min_cost [ i ] [ 0 ] = 0\n        idx_xzkm = idx_xzkm + 1\n    idx_3c5i = 0\n    list_oqp8 = range ( 1 , n + 1 )\n    while idx_3c5i < len(list_oqp8):\n        i = list_oqp8[idx_3c5i]\n        idx_q9ks = 0\n        list_b8pr = range ( 1 , W + 1 )\n        while idx_q9ks < len(list_b8pr):\n            j = list_b8pr[idx_q9ks]\n            if ( wt [ i - 1 ] > j ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]\n            else :\n                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )\n            idx_q9ks = idx_q9ks + 1\n        idx_3c5i = idx_3c5i + 1\n    if ( min_cost [ n ] [ W ] == INF ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        return - 1\n    else :\n        return min_cost [ n ] [ W ]", "id": "AugAssign2Assign_sample_from_MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG_to_89", "old_id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG"}
{"code": "def minimumflip ( mat , n ) :\n    flip = 0\n    idx_q97p = 0\n    list_pows = range ( n )\n    while idx_q97p < len(list_pows):\n        i = list_pows[idx_q97p]\n        idx_1605 = 0\n        list_xhi9 = range ( i )\n        while idx_1605 < len(list_xhi9):\n            j = list_xhi9[idx_1605]\n            if mat [ i ] [ j ] != mat [ j ] [ i ] and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n                flip = flip + 1\n            idx_1605 = idx_1605 + 1\n        idx_q97p = idx_q97p + 1\n    return flip", "id": "AugAssign2Assign_sample_from_MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1_to_90", "old_id": "MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1"}
{"code": "def minOps ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    idx_2utb = 0\n    list_g24y = range ( 0 , n )\n    while idx_2utb < len(list_g24y):\n        i = list_g24y[idx_2utb]\n        if ( ( max1 - arr [ i ] ) % k != 0 ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            return - 1\n        else :\n            res = res + ( max1 - arr [ i ] ) / k\n        idx_2utb = idx_2utb + 1\n    return int ( res )", "id": "AugAssign2Assign_sample_from_MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL_to_91", "old_id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL"}
{"code": "def minOperation ( arr , n ) :\n    Hash = defaultdict ( lambda : 0 )\n    idx_d7lu = 0\n    list_3ina = range ( 0 , n )\n    while idx_d7lu < len(list_3ina):\n        i = list_3ina[idx_d7lu]\n        Hash [ arr [ i ] ] = Hash [ arr [ i ] ] + 1\n        idx_d7lu = idx_d7lu + 1\n    max_count = 0\n    idx_sv09 = 0\n    list_5l23 = Hash\n    while idx_sv09 < len(list_5l23):\n        i = list_5l23[idx_sv09]\n        if max_count < Hash [ i ] and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n            max_count = Hash [ i ]\n        idx_sv09 = idx_sv09 + 1\n    return n - max_count", "id": "AugAssign2Assign_sample_from_MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY_to_92", "old_id": "MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY"}
{"code": "def findMinRooms ( slots , n , m ) :\n    counts = [ 0 ] * m\n    idx_8jos = 0\n    list_x7vu = range ( n )\n    while idx_8jos < len(list_x7vu):\n        i = list_x7vu[idx_8jos]\n        idx_3ijp = 0\n        list_umty = range ( m )\n        while idx_3ijp < len(list_umty):\n            j = list_umty[idx_3ijp]\n            if i < len(slots) and j < len(slots[i]) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n                if ( slots [ i ] [ j ] == '1' ) :\n                    counts [ j ] = counts [ j ] + 1\n            idx_3ijp = idx_3ijp + 1\n        idx_8jos = idx_8jos + 1\n    return max ( counts )", "id": "AugAssign2Assign_sample_from_MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE_to_93", "old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE"}
{"code": "def segregateElements ( arr , n ) :\n    temp = [ 0 for k in range ( n ) ]\n    j = 0\n    idx_vowa = 0\n    list_kqyd = range ( n )\n    while idx_vowa < len(list_kqyd):\n        i = list_kqyd[idx_vowa]\n        if ( arr [ i ] >= 0 ) and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n            temp [ j ] = arr [ i ]\n            j = j + 1\n        idx_vowa = idx_vowa + 1\n    if ( j == n or j == 0 ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n        return\n    idx_fjug = 0\n    list_cdv8 = range ( n )\n    while idx_fjug < len(list_cdv8):\n        i = list_cdv8[idx_fjug]\n        if ( arr [ i ] < 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            temp [ j ] = arr [ i ]\n            j = j + 1\n        idx_fjug = idx_fjug + 1\n    idx_ldjh = 0\n    list_syfk = range ( n )\n    while idx_ldjh < len(list_syfk):\n        k = list_syfk[idx_ldjh]\n        arr [ k ] = temp [ k ]\n        idx_ldjh = idx_ldjh + 1", "id": "AugAssign2Assign_sample_from_MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED_to_94", "old_id": "MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED"}
{"code": "def firstNonRepeating ( arr , n ) :\n    idx_jlat = 0\n    list_upl9 = range ( n )\n    while idx_jlat < len(list_upl9):\n        i = list_upl9[idx_jlat]\n        j = 0\n        while ( j < n ) :\n            if ( i != j and arr [ i ] == arr [ j ] ) and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n                break\n            j = j + 1\n        if ( j == n ) and (((True or False) and (False or True)) and ((10 > 9) or (10 < 9))):\n            return arr [ i ]\n        idx_jlat = idx_jlat + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_NON_REPEATING_ELEMENT_to_95", "old_id": "NON_REPEATING_ELEMENT"}
{"code": "def firstNonRepeating ( arr , n ) :\n    mp = defaultdict ( lambda : 0 )\n    idx_hx6w = 0\n    list_i26q = range ( n )\n    while idx_hx6w < len(list_i26q):\n        i = list_i26q[idx_hx6w]\n        mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n        idx_hx6w = idx_hx6w + 1\n    idx_7syv = 0\n    list_gc70 = range ( n )\n    while idx_7syv < len(list_gc70):\n        i = list_gc70[idx_7syv]\n        if mp [ arr [ i ] ] == 1 and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n            return arr [ i ]\n        idx_7syv = idx_7syv + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_NON_REPEATING_ELEMENT_1_to_96", "old_id": "NON_REPEATING_ELEMENT_1"}
{"code": "def divisible ( num ) :\n    n = len ( num )\n    sum = 0\n    idx_81jn = 0\n    list_j15x = range ( n )\n    while idx_81jn < len(list_j15x):\n        i = list_j15x[idx_81jn]\n        sum = sum + ord ( num [ i ] )\n        idx_81jn = idx_81jn + 1\n    if ( sum % 3 == 0 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        return 0\n    if ( n == 1 ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        return - 1\n    idx_rkvs = 0\n    list_7bt2 = range ( n )\n    while idx_rkvs < len(list_7bt2):\n        i = list_7bt2[idx_rkvs]\n        if ( sum % 3 == ord ( num [ i ] ) % 3 ) and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n            return 1\n        idx_rkvs = idx_rkvs + 1\n    if ( n == 2 ) and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n        return - 1\n    return 2", "id": "AugAssign2Assign_sample_from_NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3_to_97", "old_id": "NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3"}
{"code": "def answer_query ( a , n , l , r ) :\n    count = 0\n    idx_jkyq = 0\n    list_i8t6 = range ( l , r )\n    while idx_jkyq < len(list_i8t6):\n        i = list_i8t6[idx_jkyq]\n        if ( a [ i ] == a [ i + 1 ] ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            count = count + 1\n        idx_jkyq = idx_jkyq + 1\n    return count", "id": "AugAssign2Assign_sample_from_NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE_to_98", "old_id": "NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE"}
{"code": "def countIntegralSolutions ( n ) :\n    result = 0\n    idx_bt6h = 0\n    list_0vog = range ( n + 1 )\n    while idx_bt6h < len(list_0vog):\n        i = list_0vog[idx_bt6h]\n        idx_uf6a = 0\n        list_qojn = range ( n + 1 )\n        while idx_uf6a < len(list_qojn):\n            j = list_qojn[idx_uf6a]\n            idx_s8ld = 0\n            list_su0h = range ( n + 1 )\n            while idx_s8ld < len(list_su0h):\n                k = list_su0h[idx_s8ld]\n                if i + j + k == n and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n                    result = result + 1\n                idx_s8ld = idx_s8ld + 1\n            idx_uf6a = idx_uf6a + 1\n        idx_bt6h = idx_bt6h + 1\n    return result", "id": "AugAssign2Assign_sample_from_NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_to_99", "old_id": "NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N"}
{"code": "def sumEqualProduct ( a , n ) :\n    zero = 0\n    two = 0\n    idx_jr7a = 0\n    list_btep = range ( n )\n    while idx_jr7a < len(list_btep):\n        i = list_btep[idx_jr7a]\n        if a [ i ] == 0 and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n            zero = zero + 1\n        if a [ i ] == 2 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            two = two + 1\n        idx_jr7a = idx_jr7a + 1\n    cnt = ( zero * ( zero - 1 ) ) // 2 + \\\n        ( two * ( two - 1 ) ) // 2\n    return cnt", "id": "AugAssign2Assign_sample_from_NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT_to_100", "old_id": "NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT"}
{"code": "def countOccurrences ( s , K ) :\n    n = len ( s )\n    c1 = 0\n    c2 = 0\n    C = 0\n    idx_2gcr = 0\n    list_r6lx = range ( n )\n    while idx_2gcr < len(list_r6lx):\n        i = list_r6lx[idx_2gcr]\n        if s [ i ] == 'a' and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n            c1 = c1 + 1\n        if s [ i ] == 'b' and (((True or False) and (False or True)) and ((9 > 7) or (9 < 7))):\n            c2 = c2 + 1\n            C = C + c1\n        idx_2gcr = idx_2gcr + 1\n    return C * K + int ( K * ( K - 1 ) / 2 ) * c1 * c2", "id": "AugAssign2Assign_sample_from_NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES_to_101", "old_id": "NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES"}
{"code": "def maximumNumberDistinctPrimeRange ( m , n ) :\n    factorCount = [ 0 ] * ( n + 1 )\n    prime = [ False ] * ( n + 1 )\n    idx_tahf = 0\n    list_2v87 = range ( n + 1 )\n    while idx_tahf < len(list_2v87):\n        i = list_2v87[idx_tahf]\n        factorCount [ i ] = 0\n        prime [ i ] = True\n        idx_tahf = idx_tahf + 1\n    idx_fm4u = 0\n    list_s8zm = range ( 2 , n + 1 )\n    while idx_fm4u < len(list_s8zm):\n        i = list_s8zm[idx_fm4u]\n        if ( prime [ i ] == True ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            factorCount [ i ] = 1\n            idx_24lf = 0\n            list_0rge = range ( i * 2 , n + 1 , i )\n            while idx_24lf < len(list_0rge):\n                j = list_0rge[idx_24lf]\n                factorCount [ j ] = factorCount [ j ] + 1\n                prime [ j ] = False\n                idx_24lf = idx_24lf + 1\n        idx_fm4u = idx_fm4u + 1\n    max = factorCount [ m ]\n    num = m\n    idx_zh56 = 0\n    list_w56c = range ( m , n + 1 )\n    while idx_zh56 < len(list_w56c):\n        i = list_w56c[idx_zh56]\n        if ( factorCount [ i ] > max ) and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            max = factorCount [ i ]\n            num = i\n        idx_zh56 = idx_zh56 + 1\n    return num", "id": "AugAssign2Assign_sample_from_NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N_to_102", "old_id": "NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N"}
{"code": "def findSum ( A , B , n ) :\n    Hash = defaultdict ( lambda : 0 )\n    idx_pd4o = 0\n    list_knsl = range ( 0 , n )\n    while idx_pd4o < len(list_knsl):\n        i = list_knsl[idx_pd4o]\n        Hash [ A [ i ] ] = Hash [ A [ i ] ] + 1\n        Hash [ B [ i ] ] = Hash [ B [ i ] ] + 1\n        idx_pd4o = idx_pd4o + 1\n    Sum = 0\n    idx_b2d4 = 0\n    list_5jlb = Hash\n    while idx_b2d4 < len(list_5jlb):\n        x = list_5jlb[idx_b2d4]\n        if Hash [ x ] == 1 and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            Sum = Sum + x\n        idx_b2d4 = idx_b2d4 + 1\n    return Sum", "id": "AugAssign2Assign_sample_from_OVERLAPPING_SUM_TWO_ARRAY_to_103", "old_id": "OVERLAPPING_SUM_TWO_ARRAY"}
{"code": "def noAdjacentDup ( s ) :\n    n = len ( s )\n    idx_8acr = 0\n    list_unox = range ( 1 , n )\n    while idx_8acr < len(list_unox):\n        i = list_unox[idx_8acr]\n        if ( s [ i ] == s [ i - 1 ] ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            s [ i ] = \"a\"\n            while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) :\n                s [ i ] = s [ i ] + 1\n            i = i + 1\n        idx_8acr = idx_8acr + 1\n    return s", "id": "AugAssign2Assign_sample_from_PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES_to_104", "old_id": "PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES"}
{"code": "def antiSpiralTraversal ( m , n , a ) :\n    k = 0\n    l = 0\n    stk = [ ]\n    while ( k <= m and l <= n ) :\n        idx_odbj = 0\n        list_aj65 = range ( l , n + 1 )\n        while idx_odbj < len(list_aj65):\n            i = list_aj65[idx_odbj]\n            stk.append ( a [ k ] [ i ] )\n            idx_odbj = idx_odbj + 1\n        k = k + 1\n        idx_v57j = 0\n        list_krtq = range ( k , m + 1 )\n        while idx_v57j < len(list_krtq):\n            i = list_krtq[idx_v57j]\n            stk.append ( a [ i ] [ n ] )\n            idx_v57j = idx_v57j + 1\n        n = n - 1\n        if ( k <= m ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n            idx_g4y0 = 0\n            list_sdb8 = range ( n , l - 1 , - 1 )\n            while idx_g4y0 < len(list_sdb8):\n                i = list_sdb8[idx_g4y0]\n                stk.append ( a [ m ] [ i ] )\n                idx_g4y0 = idx_g4y0 + 1\n            m = m - 1\n        if ( l <= n ) and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n            idx_imb5 = 0\n            list_ijyg = range ( m , k - 1 , - 1 )\n            while idx_imb5 < len(list_ijyg):\n                i = list_ijyg[idx_imb5]\n                stk.append ( a [ i ] [ l ] )\n                idx_imb5 = idx_imb5 + 1\n            l = l + 1\n    while len ( stk ) != 0 :\n        print ( str ( stk [ - 1 ] ) , end = \" \" )\n        stk.pop ( )", "id": "AugAssign2Assign_sample_from_PRINT_MATRIX_ANTISPIRAL_FORM_to_105", "old_id": "PRINT_MATRIX_ANTISPIRAL_FORM"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_xtdm = 0\n    list_1jsk = range ( n )\n    while idx_xtdm < len(list_1jsk):\n        i = list_1jsk[idx_xtdm]\n        bestIdx = - 1\n        idx_c9sz = 0\n        list_t3mb = range ( m )\n        while idx_c9sz < len(list_t3mb):\n            j = list_t3mb[idx_c9sz]\n            if blockSize [ j ] >= processSize [ i ] and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n            idx_c9sz = idx_c9sz + 1\n        if bestIdx != - 1 and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] = blockSize [ bestIdx ] - processSize [ i ]\n        idx_xtdm = idx_xtdm + 1\n    print ( \"Process No.Process Size     Block no.\" )\n    idx_1myq = 0\n    list_nle5 = range ( n )\n    while idx_1myq < len(list_nle5):\n        i = list_nle5[idx_1myq]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if allocation [ i ] != - 1 and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )\n        idx_1myq = idx_1myq + 1", "id": "AugAssign2Assign_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_106", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def binaryToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base1 = 1\n    len1 = len ( num )\n    idx_pimc = 0\n    list_li4k = range ( len1 - 1 , - 1 , - 1 )\n    while idx_pimc < len(list_li4k):\n        i = list_li4k[idx_pimc]\n        if ( num [ i ] == '1' ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            dec_value = dec_value + base1\n        base1 = base1 * 2\n        idx_pimc = idx_pimc + 1\n    return dec_value", "id": "AugAssign2Assign_sample_from_PROGRAM_BINARY_DECIMAL_CONVERSION_1_to_107", "old_id": "PROGRAM_BINARY_DECIMAL_CONVERSION_1"}
{"code": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = ''\n    stars = '*' * len ( word )\n    count = 0\n    index = 0\n    idx_40gm = 0\n    list_incj = word_list\n    while idx_40gm < len(list_incj):\n        i = list_incj[idx_40gm]\n        if i == word and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            word_list [ index ] = stars\n        index = index + 1\n        idx_40gm = idx_40gm + 1\n    result = ' '.join ( word_list )\n    return result", "id": "AugAssign2Assign_sample_from_PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE_to_108", "old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        return False\n    _sum = 0\n    idx_vi0o = 0\n    list_qoyl = range ( 9 )\n    while idx_vi0o < len(list_qoyl):\n        i = list_qoyl[idx_vi0o]\n        if 0 <= int ( isbn [ i ] ) <= 9 and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n            _sum = _sum + int ( isbn [ i ] ) * ( 10 - i )\n        else :\n            return False\n        idx_vi0o = idx_vi0o + 1\n    if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return False\n    _sum = _sum + 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )", "id": "AugAssign2Assign_sample_from_PROGRAM_CHECK_ISBN_to_109", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_hqf0 = 0\n    list_detj = range ( n )\n    while idx_hqf0 < len(list_detj):\n        i = list_detj[idx_hqf0]\n        wstIdx = - 1\n        idx_h3qa = 0\n        list_yz6n = range ( m )\n        while idx_h3qa < len(list_yz6n):\n            j = list_yz6n[idx_h3qa]\n            if blockSize [ j ] >= processSize [ i ] and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n            idx_h3qa = idx_h3qa + 1\n        if wstIdx != - 1 and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] = blockSize [ wstIdx ] - processSize [ i ]\n        idx_hqf0 = idx_hqf0 + 1\n    print ( \"Process No.Process Size Block no.\" )\n    idx_cw54 = 0\n    list_64br = range ( n )\n    while idx_cw54 < len(list_64br):\n        i = list_64br[idx_cw54]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if allocation [ i ] != - 1 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )\n        idx_cw54 = idx_cw54 + 1", "id": "AugAssign2Assign_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_110", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def countInRange ( arr , n , x , y ) :\n    count = 0 ;\n    idx_a8yf = 0\n    list_t10j = range ( n )\n    while idx_a8yf < len(list_t10j):\n        i = list_t10j[idx_a8yf]\n        if ( arr [ i ] >= x and arr [ i ] <= y ) and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n            count = count + 1\n        idx_a8yf = idx_a8yf + 1\n    return count", "id": "AugAssign2Assign_sample_from_QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE_to_111", "old_id": "QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE"}
{"code": "def rearrange ( arr , n ) :\n    temp = n * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    idx_zrfo = 0\n    list_0cna = range ( n )\n    while idx_zrfo < len(list_0cna):\n        i = list_0cna[idx_zrfo]\n        if flag is True and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            temp [ i ] = arr [ large ]\n            large = large - 1\n        else :\n            temp [ i ] = arr [ small ]\n            small = small + 1\n        flag = bool ( 1 - flag )\n        idx_zrfo = idx_zrfo + 1\n    idx_i3k5 = 0\n    list_ox7k = range ( n )\n    while idx_i3k5 < len(list_ox7k):\n        i = list_ox7k[idx_i3k5]\n        arr [ i ] = temp [ i ]\n        idx_i3k5 = idx_i3k5 + 1\n    return arr", "id": "AugAssign2Assign_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_112", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    idx_g5ae = 0\n    list_jm1x = range ( 0 , n )\n    while idx_g5ae < len(list_jm1x):\n        i = list_jm1x[idx_g5ae]\n        if i % 2 == 0 and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n            arr [ i ] = arr [ i ] + ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx = max_idx - 1\n        else :\n            arr [ i ] = arr [ i ] + ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx = min_idx + 1\n        idx_g5ae = idx_g5ae + 1\n    idx_c3d1 = 0\n    list_pb4h = range ( 0 , n )\n    while idx_c3d1 < len(list_pb4h):\n        i = list_pb4h[idx_c3d1]\n        arr [ i ] = int ( arr [ i ] / max_elem )\n        idx_c3d1 = idx_c3d1 + 1", "id": "AugAssign2Assign_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_113", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def rearrange ( arr , n ) :\n    i = - 1\n    idx_kmwt = 0\n    list_rw4h = range ( n )\n    while idx_kmwt < len(list_rw4h):\n        j = list_rw4h[idx_kmwt]\n        if ( arr [ j ] < 0 ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            i = i + 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n        idx_kmwt = idx_kmwt + 1\n    pos , neg = i + 1 , 0\n    while ( pos < n and neg < pos and arr [ neg ] < 0 ) :\n        arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ]\n        pos = pos + 1\n        neg = neg + 2", "id": "AugAssign2Assign_sample_from_REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH_to_114", "old_id": "REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH"}
{"code": "def remainderWith7 ( num ) :\n    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]\n    series_index = 0\n    result = 0\n    idx_und6 = 0\n    list_9nd4 = range ( ( len ( num ) - 1 ) , - 1 , - 1 )\n    while idx_und6 < len(list_9nd4):\n        i = list_9nd4[idx_und6]\n        digit = ord ( num [ i ] ) - 48\n        result = result + digit * series [ series_index ]\n        series_index = ( series_index + 1 ) % 6\n        result = result % 7\n        idx_und6 = idx_und6 + 1\n    if ( result < 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        result = ( result + 7 ) % 7\n    return result", "id": "AugAssign2Assign_sample_from_REMAINDER_7_LARGE_NUMBERS_to_115", "old_id": "REMAINDER_7_LARGE_NUMBERS"}
{"code": "def removeDuplicates ( S ) :\n    n = len ( S )\n    if ( n < 2 ) and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n        return\n    j = 0\n    idx_b5zc = 0\n    list_40yj = range ( 1 , n )\n    while idx_b5zc < len(list_40yj):\n        i = list_40yj[idx_b5zc]\n        if ( S [ j ] != S [ i ] ) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            j = j + 1\n            S [ j ] = S [ i ]\n        idx_b5zc = idx_b5zc + 1\n    j = j + 1\n    S = S [ : j ]", "id": "AugAssign2Assign_sample_from_REMOVE_CONSECUTIVE_DUPLICATES_STRING_to_116", "old_id": "REMOVE_CONSECUTIVE_DUPLICATES_STRING"}
{"code": "def maxSubArraySum ( a , size ) :\n    max_so_far = - maxsize - 1\n    max_ending_here = 0\n    start = 0\n    end = 0\n    s = 0\n    idx_gj2u = 0\n    list_6mnu = range ( 0 , size )\n    while idx_gj2u < len(list_6mnu):\n        i = list_6mnu[idx_gj2u]\n        max_ending_here = max_ending_here + a [ i ]\n        if max_so_far < max_ending_here and (((True or False) and (False or True)) and ((9 > 1) or (9 < 1))):\n            max_so_far = max_ending_here\n            start = s\n            end = i\n        if max_ending_here < 0 and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            max_ending_here = 0\n            s = i + 1\n        idx_gj2u = idx_gj2u + 1\n    return ( end - start + 1 )", "id": "AugAssign2Assign_sample_from_SIZE_SUBARRAY_MAXIMUM_SUM_to_117", "old_id": "SIZE_SUBARRAY_MAXIMUM_SUM"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    idx_uq3j = 0\n    list_wvdl = range ( n )\n    while idx_uq3j < len(list_wvdl):\n        i = list_wvdl[idx_uq3j]\n        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )\n        idx_uq3j = idx_uq3j + 1\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    idx_frpb = 0\n    list_69sq = range ( n )\n    while idx_frpb < len(list_69sq):\n        i = list_69sq[idx_frpb]\n        if maximum < arr [ i ] and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            index = i\n            maximum = arr [ i ]\n        idx_frpb = idx_frpb + 1\n    i = 0\n    j = n - 1\n    new_arr = [ 0 ] * n\n    k = 0\n    while i < index and j > index :\n        if arr [ i ] < arr [ j ] and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n            new_arr [ k ] = arr [ i ]\n            k = k + 1\n            i = i + 1\n        else :\n            new_arr [ k ] = arr [ j ]\n            k = k + 1\n            j = j - 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k = k + 1\n        i = i + 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k = k + 1\n        j = j - 1\n        new_arr [ n - 1 ] = maximum\n    idx_ohqe = 0\n    list_8t0a = range ( n )\n    while idx_ohqe < len(list_8t0a):\n        i = list_8t0a[idx_ohqe]\n        arr [ i ] = new_arr [ i ]\n        idx_ohqe = idx_ohqe + 1", "id": "AugAssign2Assign_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_118", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def twoWaySort ( arr , n ) :\n    idx_0y9u = 0\n    list_5hik = range ( 0 , n )\n    while idx_0y9u < len(list_5hik):\n        i = list_5hik[idx_0y9u]\n        if ( arr [ i ] & 1 ) and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            arr [ i ] = arr [ i ] * - 1\n        idx_0y9u = idx_0y9u + 1\n    arr.sort ( )\n    idx_8nzx = 0\n    list_yisd = range ( 0 , n )\n    while idx_8nzx < len(list_yisd):\n        i = list_yisd[idx_8nzx]\n        if ( arr [ i ] & 1 ) and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n            arr [ i ] = arr [ i ] * - 1\n        idx_8nzx = idx_8nzx + 1", "id": "AugAssign2Assign_sample_from_SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1_to_119", "old_id": "SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1"}
{"code": "def bitonicGenerator ( arr , n ) :\n    evenArr = [ ]\n    oddArr = [ ]\n    idx_kgaq = 0\n    list_r3oq = range ( n )\n    while idx_kgaq < len(list_r3oq):\n        i = list_r3oq[idx_kgaq]\n        if ( ( i % 2 ) == 0 ) and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n            evenArr.append ( arr [ i ] )\n        else :\n            oddArr.append ( arr [ i ] )\n        idx_kgaq = idx_kgaq + 1\n    evenArr = sorted ( evenArr )\n    oddArr = sorted ( oddArr )\n    oddArr = oddArr [ : : - 1 ]\n    i = 0\n    idx_23d8 = 0\n    list_edjq = range ( len ( evenArr ) )\n    while idx_23d8 < len(list_edjq):\n        j = list_edjq[idx_23d8]\n        arr [ i ] = evenArr [ j ]\n        i = i + 1\n        idx_23d8 = idx_23d8 + 1\n    idx_9dxi = 0\n    list_qorx = range ( len ( oddArr ) )\n    while idx_9dxi < len(list_qorx):\n        j = list_qorx[idx_9dxi]\n        arr [ i ] = oddArr [ j ]\n        i = i + 1\n        idx_9dxi = idx_9dxi + 1", "id": "AugAssign2Assign_sample_from_SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_to_120", "old_id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER"}
{"code": "def firstLetterWord ( str ) :\n    result = \"\"\n    v = True\n    idx_ao6k = 0\n    list_trpq = range ( len ( str ) )\n    while idx_ao6k < len(list_trpq):\n        i = list_trpq[idx_ao6k]\n        if ( str [ i ] == ' ' ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            v = True\n        elif ( str [ i ] != ' ' and v == True ) :\n            result = result + ( str [ i ] )\n            v = False\n        idx_ao6k = idx_ao6k + 1\n    return result", "id": "AugAssign2Assign_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_121", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    idx_it2j = 0\n    list_4xt5 = range ( 0 , n + 1 )\n    while idx_it2j < len(list_4xt5):\n        i = list_4xt5[idx_it2j]\n        idx_wt2y = 0\n        list_1cgd = range ( 0 , min ( i , n ) + 1 )\n        while idx_wt2y < len(list_1cgd):\n            j = list_1cgd[idx_wt2y]\n            if ( j == 0 or j == i ) and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n            idx_wt2y = idx_wt2y + 1\n        idx_it2j = idx_it2j + 1\n    sum = 0\n    idx_sy6a = 0\n    list_zt30 = range ( 0 , n + 1 )\n    while idx_sy6a < len(list_zt30):\n        i = list_zt30[idx_sy6a]\n        sum = sum + C [ n ] [ i ]\n        idx_sy6a = idx_sy6a + 1\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_122", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def findSum ( n ) :\n    ans = 0\n    temp = 0\n    idx_1j0m = 0\n    list_sr2c = range ( 1 , n + 1 )\n    while idx_1j0m < len(list_sr2c):\n        i = list_sr2c[idx_1j0m]\n        if temp < n and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            temp = i - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans = ans + i * num\n                else :\n                    ans = ans + ( n - temp ) * num\n                temp = temp + i\n                num = num + 1\n        idx_1j0m = idx_1j0m + 1\n    return ans", "id": "AugAssign2Assign_sample_from_SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1_to_123", "old_id": "SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    idx_lrhx = 0\n    list_awsz = range ( n )\n    while idx_lrhx < len(list_awsz):\n        i = list_awsz[idx_lrhx]\n        if ( tree [ i ] == '(' ) and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n            level = level + 1\n        elif ( tree [ i ] == ')' ) :\n            level = level - 1\n        else :\n            if ( level == k ) :\n                sum = sum + ( ord ( tree [ i ] ) - ord ( '0' ) )\n        idx_lrhx = idx_lrhx + 1\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_124", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    idx_7uf0 = 0\n    list_nwaz = range(n1)\n    while idx_7uf0 < len(list_nwaz):\n        i = list_nwaz[idx_7uf0]\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if sum < 0 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            str = str + chr(sum % -10 + 48)\n        else:\n            str = str + chr(sum % 10 + 48)\n        carry = int(sum / 10)\n        idx_7uf0 = idx_7uf0 + 1\n    idx_nu69 = 0\n    list_oprh = range(n1, n2)\n    while idx_nu69 < len(list_oprh):\n        i = list_oprh[idx_nu69]\n        sum = ((ord(str2[i]) - 48) + carry)\n        if sum < 0 and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n            str = str + chr(sum % -10 + 48)\n        else:\n            str = str + chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n        idx_nu69 = idx_nu69 + 1\n    if (carry) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        str = str + chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "AugAssign2Assign_sample_from_SUM_TWO_LARGE_NUMBERS_to_125", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def offeringNumber ( n , templeHeight ) :\n    sum = 0\n    idx_kt7q = 0\n    list_is9b = range ( n )\n    while idx_kt7q < len(list_is9b):\n        i = list_is9b[idx_kt7q]\n        left = 0\n        right = 0\n        idx_fzrp = 0\n        list_qz2f = range ( i - 1 , - 1 , - 1 )\n        while idx_fzrp < len(list_qz2f):\n            j = list_qz2f[idx_fzrp]\n            if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n                left = left + 1\n            else :\n                break\n            idx_fzrp = idx_fzrp + 1\n        idx_g5yx = 0\n        list_msx5 = range ( i + 1 , n )\n        while idx_g5yx < len(list_msx5):\n            j = list_msx5[idx_g5yx]\n            if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n                right = right + 1\n            else :\n                break\n            idx_g5yx = idx_g5yx + 1\n        sum = sum + max ( right , left ) + 1\n        idx_kt7q = idx_kt7q + 1\n    return sum", "id": "AugAssign2Assign_sample_from_TEMPLE_OFFERINGS_to_126", "old_id": "TEMPLE_OFFERINGS"}
{"code": "def countUnique ( mat , n , m ) :\n    rowsum = [ 0 ] * n\n    colsum = [ 0 ] * m\n    idx_4vmr = 0\n    list_oxs0 = range ( n )\n    while idx_4vmr < len(list_oxs0):\n        i = list_oxs0[idx_4vmr]\n        idx_it4q = 0\n        list_k3y7 = range ( m )\n        while idx_it4q < len(list_k3y7):\n            j = list_k3y7[idx_it4q]\n            if ( mat [ i ] [ j ] != 0 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                rowsum [ i ] = rowsum [ i ] + 1\n                colsum [ j ] = colsum [ j ] + 1\n            idx_it4q = idx_it4q + 1\n        idx_4vmr = idx_4vmr + 1\n    uniquecount = 0\n    idx_bskt = 0\n    list_8mlp = range ( n )\n    while idx_bskt < len(list_8mlp):\n        i = list_8mlp[idx_bskt]\n        idx_udkg = 0\n        list_klj8 = range ( m )\n        while idx_udkg < len(list_klj8):\n            j = list_klj8[idx_udkg]\n            if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                uniquecount = uniquecount + 1\n            idx_udkg = idx_udkg + 1\n        idx_bskt = idx_bskt + 1\n    return uniquecount", "id": "AugAssign2Assign_sample_from_UNIQUE_CELLS_BINARY_MATRIX_to_127", "old_id": "UNIQUE_CELLS_BINARY_MATRIX"}
{"code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    idx_tlx4 = 0\n    list_u043 = range ( 0 , n , 1 )\n    while idx_tlx4 < len(list_u043):\n        i = list_u043[idx_tlx4]\n        if ( str [ i ] == '1' ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            one_count = one_count + 1\n        else :\n            zero_count = zero_count + 1\n        idx_tlx4 = idx_tlx4 + 1\n    if ( one_count % 2 == 0 ) and (((True or False) and (False or True)) and ((9 > 7) or (9 < 7))):\n        return zero_count\n    return one_count", "id": "AugAssign2Assign_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_128", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
