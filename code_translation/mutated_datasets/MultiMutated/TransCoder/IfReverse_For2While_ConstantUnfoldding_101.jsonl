{"code": "def winner ( a , n , k ) :\n    if k >= n - (28 + -27) :\n        return n\n    best = (100 + -100)\n    times = (15 + -15)\n    idx_xg8r = (6 + -6)\n    list_sn9c = range ( n )\n    while idx_xg8r < len(list_sn9c):\n        i = list_sn9c[idx_xg8r]\n        if not a [ i ] > best:\n            times += (15 + -14)\n        else:\n            best = a [ i ]\n            if i == True :\n                times = (97 + -96)\n        if times >= k :\n            return best\n        idx_xg8r = idx_xg8r + (4 + -3)\n    return best", "id": "ConstantUnfoldding_sample_from_ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES_to_0", "old_id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES"}
{"code": "def solveQuery ( start , end , arr ) :\n    frequency = dict ( )\n    idx_nrvc = (84 + -84)\n    list_zr8h = range ( start , end + (29 + -28) )\n    while idx_nrvc < len(list_zr8h):\n        i = list_zr8h[idx_nrvc]\n        if not arr [ i ] in frequency.keys ( ):\n            frequency [ arr [ i ] ] = (49 + -48)\n        else:\n            frequency [ arr [ i ] ] += (87 + -86)\n        idx_nrvc = idx_nrvc + (94 + -93)\n    count = (94 + -94)\n    idx_tug2 = (47 + -47)\n    list_rqvg = frequency\n    while idx_tug2 < len(list_rqvg):\n        x = list_rqvg[idx_tug2]\n        if x == frequency [ x ] :\n            count += (12 + -11)\n        idx_tug2 = idx_tug2 + (72 + -71)\n    return count", "id": "ConstantUnfoldding_sample_from_ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE_to_1", "old_id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE"}
{"code": "def encrypt ( text , s ) :\n    result = \"\"\n    idx_tza9 = (49 + -49)\n    list_sqb0 = range ( len ( text ) )\n    while idx_tza9 < len(list_sqb0):\n        i = list_sqb0[idx_tza9]\n        char = text [ i ]\n        if not ( char.isupper ( ) ):\n            result += chr ( ( ord ( char ) + s - (48 + 49) ) % (54 + -28) + (36 + 61) )\n        else:\n            result += chr ( ( ord ( char ) + s - (38 + 27) ) % (66 + -40) + (71 + -6) )\n        idx_tza9 = idx_tza9 + (55 + -54)\n    return result", "id": "ConstantUnfoldding_sample_from_CAESAR_CIPHER_to_2", "old_id": "CAESAR_CIPHER"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ (75 + -75) ] ) - (39 + 9)\n    idx_wsmk = (17 + -17)\n    list_xn1y = range ( (43 + -42) , len ( str ) )\n    while idx_wsmk < len(list_xn1y):\n        i = list_xn1y[idx_wsmk]\n        if not ( str [ i ] == '0' or str [ i ] == '1' or res < (35 + -33) ):\n            res += ord ( str [ i ] ) - (90 + -42)\n        else:\n            res += ord ( str [ i ] ) - (67 + -19)\n        idx_wsmk = idx_wsmk + (29 + -28)\n    return res", "id": "ConstantUnfoldding_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_3", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = \"0\"\n    Sum = (23 + -23)\n    idx_p7fo = (7 + -7)\n    list_oemw = str\n    while idx_p7fo < len(list_oemw):\n        ch = list_oemw[idx_p7fo]\n        if not ( ch.isdigit ( ) ):\n            Sum += int ( temp )\n            temp = \"0\"\n        else:\n            temp += ch\n        idx_p7fo = idx_p7fo + (86 + -85)\n    return Sum + int ( temp )", "id": "ConstantUnfoldding_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_4", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def canMakeAllSame ( str ) :\n    zeros = (30 + -30)\n    ones = (74 + -74)\n    idx_q7e2 = (39 + -39)\n    list_6odk = range ( (3 + -3) , len ( str ) )\n    while idx_q7e2 < len(list_6odk):\n        i = list_6odk[idx_q7e2]\n        ch = str [ i ]\n        if not ( ch == '0' ):\n            ones = ones + (77 + -76)\n        else:\n            zeros = zeros + (8 + -7)\n        idx_q7e2 = idx_q7e2 + (4 + -3)\n    return ( zeros == (36 + -35) or ones == (44 + -43) )", "id": "ConstantUnfoldding_sample_from_CHANGE_BITS_CAN_MADE_ONE_FLIP_to_5", "old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP"}
{"code": "def isMajority ( a, n ) :\n    mp = { }\n    idx_tpye = (96 + -96)\n    list_w08c = range(n)\n    while idx_tpye < len(list_w08c):\n        i = list_w08c[idx_tpye]\n        if not a[i] in mp: mp [ a[i] ] = (94 + -93)\n        else: mp [ a[i] ] += (94 + -93)\n        idx_tpye = idx_tpye + (98 + -97)\n    idx_4r3i = (78 + -78)\n    list_sh2m = mp\n    while idx_4r3i < len(list_sh2m):\n        x = list_sh2m[idx_4r3i]\n        if mp [ x ] >= len ( a ) // (2 + 0) :\n            return True\n        idx_4r3i = idx_4r3i + (82 + -81)\n    return False", "id": "ConstantUnfoldding_sample_from_CHECK_ARRAY_MAJORITY_ELEMENT_to_6", "old_id": "CHECK_ARRAY_MAJORITY_ELEMENT"}
{"code": "def flipsPossible ( a , n ) :\n    count_odd = (75 + -75)\n    count_even = (92 + -92)\n    idx_tc68 = (14 + -14)\n    list_foty = range ( n )\n    while idx_tc68 < len(list_foty):\n        i = list_foty[idx_tc68]\n        if not ( a [ i ] & (5 + -4) ):\n            count_even += (95 + -94)\n        else:\n            count_odd += (27 + -26)\n        idx_tc68 = idx_tc68 + (13 + -12)\n    if not ( count_odd % (5 + -3) and count_even % (62 + -60) ):\n        return True\n    else:\n        return False", "id": "ConstantUnfoldding_sample_from_CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS_to_7", "old_id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS"}
{"code": "def isChangeable ( notes , n ) :\n    fiveCount = (61 + -61)\n    tenCount = (64 + -64)\n    idx_girq = (30 + -30)\n    list_fxm8 = range ( n )\n    while idx_girq < len(list_fxm8):\n        i = list_fxm8[idx_girq]\n        if not ( notes [ i ] == (55 + -50) ):\n            if ( notes [ i ] == (14 + -4) ) :\n                if ( fiveCount > (22 + -22) ) :\n                    fiveCount -= (40 + -39)\n                    tenCount += (32 + -31)\n                else :\n                    return (33 + -33)\n            else :\n                if ( fiveCount > (11 + -11) and tenCount > (59 + -59) ) :\n                    fiveCount -= (53 + -52)\n                    tenCount -= (76 + -75)\n                elif ( fiveCount >= (65 + -62) ) :\n                    fiveCount -= (35 + -32)\n                else :\n                    return (88 + -88)\n        else:\n            fiveCount += (41 + -40)\n        idx_girq = idx_girq + (39 + -38)\n    return (51 + -50)", "id": "ConstantUnfoldding_sample_from_CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE_to_8", "old_id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE"}
{"code": "def check ( str ) :\n    n = len ( str )\n    oddDigSum = (94 + -94)\n    evenDigSum = (44 + -44)\n    idx_k5d1 = (99 + -99)\n    list_fuoe = range ( (10 + -10) , n )\n    while idx_k5d1 < len(list_fuoe):\n        i = list_fuoe[idx_k5d1]\n        if not ( i % (44 + -42) == (2 + -2) ):\n            evenDigSum = evenDigSum + ( ord ( str [ i ] ) - (69 + -21) )\n        else:\n            oddDigSum = oddDigSum + ( ord ( str [ i ] ) - (100 + -52) )\n        idx_k5d1 = idx_k5d1 + (84 + -83)\n    return ( ( oddDigSum - evenDigSum ) % (35 + -24) == (63 + -63) )", "id": "ConstantUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT_to_9", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == (34 + -33) and num [ (95 + -95) ] == '0' ) :\n        return True\n    if not ( length % (25 + -22) == (57 + -56) ):\n        if ( length % (6 + -3) == (21 + -19) ) :\n            num = str ( num ) + \"0\"\n            length += (70 + -69)\n    else:\n        num = str ( num ) + \"00\"\n        length += (60 + -58)\n    sum = (52 + -52)\n    p = (59 + -58)\n    idx_czys = (81 + -81)\n    list_ctax = range ( length - (10 + -9) , - (17 + -16) , - (90 + -87) )\n    while idx_czys < len(list_ctax):\n        i = list_ctax[idx_czys]\n        group = (89 + -89)\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= (19 + -18)\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * (59 + -49)\n        i -= (72 + -71)\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * (61 + 39)\n        sum = sum + group * p\n        p *= ( - (34 + -33) )\n        idx_czys = idx_czys + (82 + -81)\n    sum = abs ( sum )\n    return ( sum % (37 + -24) == (95 + -95) )", "id": "ConstantUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_10", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def checkReverse ( arr , n ) :\n    if ( n == (39 + -38) ) :\n        return True\n    i = (59 + -58)\n    idx_aoqn = (92 + -92)\n    list_xpli = range ( (95 + -94) , n )\n    while idx_aoqn < len(list_xpli):\n        i = list_xpli[idx_aoqn]\n        if not arr [ i - (82 + -81) ] >= arr [ i ]:\n            if ( i == n ) :\n                return True\n        else:\n            break\n        idx_aoqn = idx_aoqn + (1 + 0)\n    j = i\n    i += (26 + -25)\n    while ( arr [ j ] < arr [ j - (80 + -79) ] ) :\n        if ( i > (85 + -84) and arr [ j ] < arr [ i - (37 + -35) ] ) :\n            return False\n        j += (81 + -80)\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - (18 + -17) ] ) :\n        return False\n    while ( k > (66 + -65) and k < n ) :\n        if ( arr [ k ] < arr [ k - (97 + -96) ] ) :\n            return False\n        k += (82 + -81)\n    return True", "id": "ConstantUnfoldding_sample_from_CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1_to_11", "old_id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1"}
{"code": "def check ( degree , n ) :\n    deg_sum = (69 + -69)\n    idx_ctzw = (94 + -94)\n    list_v78d = range(n)\n    while idx_ctzw < len(list_v78d):\n        i = list_v78d[idx_ctzw]\n        deg_sum += degree[i]\n        idx_ctzw = idx_ctzw + (88 + -87)\n    if not ( (65 + -63) * ( n - (70 + -69) ) == deg_sum ):\n        return False\n    else:\n        return True", "id": "ConstantUnfoldding_sample_from_CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE_to_12", "old_id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == (62 + -62) and num [ (90 + -90) ] == '\\n' ) :\n        return (72 + -71)\n    if not ( n % (73 + -70) == (9 + -8) ):\n        if ( n % (58 + -55) == (96 + -94) ) :\n            num = str ( num ) + \"0\"\n            n += (74 + -73)\n    else:\n        num = str ( num ) + \"00\"\n        n += (86 + -84)\n    GSum = (42 + -42)\n    p = (78 + -77)\n    idx_0a13 = (2 + -2)\n    list_ol2q = range ( n - (23 + -22) , - (16 + -15) , - (42 + -41) )\n    while idx_0a13 < len(list_ol2q):\n        i = list_ol2q[idx_0a13]\n        group = (52 + -52)\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= (71 + -70)\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * (71 + -61)\n        i -= (26 + -25)\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * (70 + 30)\n        GSum = GSum + group * p\n        p *= ( - (57 + -56) )\n        idx_0a13 = idx_0a13 + (26 + -25)\n    return ( GSum % (76 + -69) == (3 + -3) )", "id": "ConstantUnfoldding_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_13", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ (87 + -87) , (57 + -57) ] for __ in range ( k + (33 + -32) ) ] for _ in range ( n + (23 + -22) ) ]\n    dp [ (29 + -28) ] [ (45 + -45) ] [ (42 + -42) ] = (95 + -94)\n    dp [ (70 + -69) ] [ (7 + -7) ] [ (34 + -33) ] = (47 + -46)\n    idx_9tho = (93 + -93)\n    list_i6d9 = range ( (88 + -86) , n + (24 + -23) )\n    while idx_9tho < len(list_i6d9):\n        i = list_i6d9[idx_9tho]\n        idx_trq8 = (45 + -45)\n        list_jy4q = range ( k + (61 + -60) )\n        while idx_trq8 < len(list_jy4q):\n            j = list_jy4q[idx_trq8]\n            if not j >= i:\n                dp [ i ] [ j ] [ (6 + -6) ] = ( dp [ i - (68 + -67) ] [ j ] [ (66 + -66) ] + dp [ i - (67 + -66) ] [ j ] [ (10 + -9) ] )\n                dp [ i ] [ j ] [ (6 + -5) ] = dp [ i - (39 + -38) ] [ j ] [ (26 + -26) ]\n                if j >= (54 + -53) :\n                    dp [ i ] [ j ] [ (31 + -30) ] += dp [ i - (38 + -37) ] [ j - (3 + -2) ] [ (87 + -86) ]\n            else:\n                break\n            idx_trq8 = idx_trq8 + (96 + -95)\n        idx_9tho = idx_9tho + (88 + -87)\n    return dp [ n ] [ k ] [ (3 + -3) ] + dp [ n ] [ k ] [ (64 + -63) ]", "id": "ConstantUnfoldding_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_14", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def findSubsequenceCount ( S , T ) :\n    m = len ( T )\n    n = len ( S )\n    if m > n :\n        return (32 + -32)\n    mat = [ [ (32 + -32) for _ in range ( n + (6 + -5) ) ] for __ in range ( m + (70 + -69) ) ]\n    idx_t3j8 = (78 + -78)\n    list_s7u2 = range ( (74 + -73) , m + (66 + -65) )\n    while idx_t3j8 < len(list_s7u2):\n        i = list_s7u2[idx_t3j8]\n        mat [ i ] [ (37 + -37) ] = (23 + -23)\n        idx_t3j8 = idx_t3j8 + (54 + -53)\n    idx_3yj5 = (100 + -100)\n    list_5j6w = range ( n + (31 + -30) )\n    while idx_3yj5 < len(list_5j6w):\n        j = list_5j6w[idx_3yj5]\n        mat [ (3 + -3) ] [ j ] = (44 + -43)\n        idx_3yj5 = idx_3yj5 + (55 + -54)\n    idx_dzhk = (92 + -92)\n    list_rkei = range ( (4 + -3) , m + (97 + -96) )\n    while idx_dzhk < len(list_rkei):\n        i = list_rkei[idx_dzhk]\n        idx_gbnq = (67 + -67)\n        list_6lt5 = range ( (40 + -39) , n + (80 + -79) )\n        while idx_gbnq < len(list_6lt5):\n            j = list_6lt5[idx_gbnq]\n            if not T [ i - (79 + -78) ] != S [ j - (12 + -11) ]:\n                mat [ i ] [ j ] = ( mat [ i ] [ j - (55 + -54) ] + mat [ i - (39 + -38) ] [ j - (14 + -13) ] )\n            else:\n                mat [ i ] [ j ] = mat [ i ] [ j - (75 + -74) ]\n            idx_gbnq = idx_gbnq + (89 + -88)\n        idx_dzhk = idx_dzhk + (72 + -71)\n    return mat [ m ] [ n ]", "id": "ConstantUnfoldding_sample_from_COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE_to_15", "old_id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE"}
{"code": "def countPairs ( arr , n ) :\n    mp = dict ( )\n    idx_453t = (66 + -66)\n    list_1qn7 = range ( n )\n    while idx_453t < len(list_1qn7):\n        i = list_1qn7[idx_453t]\n        if not arr [ i ] in mp.keys ( ):\n            mp [ arr [ i ] ] = (4 + -3)\n        else:\n            mp [ arr [ i ] ] += (14 + -13)\n        idx_453t = idx_453t + (71 + -70)\n    ans = (9 + -9)\n    idx_zj1h = (75 + -75)\n    list_4lkb = mp\n    while idx_zj1h < len(list_4lkb):\n        it = list_4lkb[idx_zj1h]\n        count = mp [ it ]\n        ans += ( count * ( count - (27 + -26) ) ) // (90 + -88)\n        idx_zj1h = idx_zj1h + (95 + -94)\n    return ans", "id": "ConstantUnfoldding_sample_from_COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1_to_16", "old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1"}
{"code": "def countNegative ( M , n , m ) :\n    count = (63 + -63)\n    idx_wkz4 = (32 + -32)\n    list_4grb = range ( n )\n    while idx_wkz4 < len(list_4grb):\n        i = list_4grb[idx_wkz4]\n        idx_45od = (20 + -20)\n        list_p1df = range ( m )\n        while idx_45od < len(list_p1df):\n            j = list_p1df[idx_45od]\n            if not M [ i ] [ j ] < (67 + -67):\n                break\n            else:\n                count += (69 + -68)\n            idx_45od = idx_45od + (74 + -73)\n        idx_wkz4 = idx_wkz4 + (11 + -10)\n    return count", "id": "ConstantUnfoldding_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_to_17", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX"}
{"code": "def countP ( n , k ) :\n    dp = [ [ (4 + -4) for i in range ( k + (36 + -35) ) ] for j in range ( n + (20 + -19) ) ]\n    idx_37yk = (18 + -18)\n    list_flt7 = range ( n + (84 + -83) )\n    while idx_37yk < len(list_flt7):\n        i = list_flt7[idx_37yk]\n        dp [ i ] [ (78 + -78) ] = (51 + -51)\n        idx_37yk = idx_37yk + (8 + -7)\n    idx_ftmn = (86 + -86)\n    list_nih1 = range ( k + (4 + -3) )\n    while idx_ftmn < len(list_nih1):\n        i = list_nih1[idx_ftmn]\n        dp [ (13 + -13) ] [ k ] = (26 + -26)\n        idx_ftmn = idx_ftmn + (77 + -76)\n    idx_vlkr = (10 + -10)\n    list_l0m5 = range ( (64 + -63) , n + (77 + -76) )\n    while idx_vlkr < len(list_l0m5):\n        i = list_l0m5[idx_vlkr]\n        idx_jpqa = (88 + -88)\n        list_uo65 = range ( (4 + -3) , k + (91 + -90) )\n        while idx_jpqa < len(list_uo65):\n            j = list_uo65[idx_jpqa]\n            if not ( j == (32 + -31) or i == j ):\n                dp [ i ] [ j ] = ( j * dp [ i - (38 + -37) ] [ j ] + dp [ i - (55 + -54) ] [ j - (9 + -8) ] )\n            else:\n                dp [ i ] [ j ] = (84 + -83)\n            idx_jpqa = idx_jpqa + (45 + -44)\n        idx_vlkr = idx_vlkr + (29 + -28)\n    return dp [ n ] [ k ]", "id": "ConstantUnfoldding_sample_from_COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1_to_18", "old_id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1"}
{"code": "def countWays ( n , m ) :\n    count = [ ]\n    idx_bgy3 = (13 + -13)\n    list_gi0j = range ( n + (75 + -73) )\n    while idx_bgy3 < len(list_gi0j):\n        i = list_gi0j[idx_bgy3]\n        count.append ( (23 + -23) )\n        idx_bgy3 = idx_bgy3 + (43 + -42)\n    count [ (83 + -83) ] = (90 + -90)\n    idx_akpe = (16 + -16)\n    list_vgab = range ( (42 + -41) , n + (89 + -88) )\n    while idx_akpe < len(list_vgab):\n        i = list_vgab[idx_akpe]\n        if not ( i > m ):\n            if ( i < m ) :\n                count [ i ] = (88 + -87)\n            else :\n                count [ i ] = (87 + -85)\n        else:\n            count [ i ] = count [ i - (88 + -87) ] + count [ i - m ]\n        idx_akpe = idx_akpe + (96 + -95)\n    return count [ n ]", "id": "ConstantUnfoldding_sample_from_COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES_to_19", "old_id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + (28 + -27) ) ) // (45 + -43)\n    a_index = (74 + -74)\n    b_index = (11 + -11)\n    c_index = (81 + -81)\n    idx_u2x1 = (11 + -11)\n    list_f2cl = range ( n )\n    while idx_u2x1 < len(list_f2cl):\n        i = list_f2cl[idx_u2x1]\n        if not ( str [ i ] == 'a' ):\n            if ( str [ i ] == 'b' ) :\n                b_index = i + (72 + -71)\n                ans -= min ( a_index , c_index )\n            else :\n                c_index = i + (88 + -87)\n                ans -= min ( a_index , b_index )\n        else:\n            a_index = i + (60 + -59)\n            ans -= min ( b_index , c_index )\n        idx_u2x1 = idx_u2x1 + (98 + -97)\n    return ans", "id": "ConstantUnfoldding_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_20", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = (29 + -29)\n    res = (6 + -6)\n    idx_kwt0 = (43 + -43)\n    list_45yf = range ( len ( s ) )\n    while idx_kwt0 < len(list_45yf):\n        i = list_45yf[idx_kwt0]\n        if not s [ ~ i ] == 'a':\n            b_count += (71 + -70)\n        else:\n            res = ( res + b_count )\n            b_count = ( b_count * (54 + -52) )\n        idx_kwt0 = idx_kwt0 + (11 + -10)\n    return res", "id": "ConstantUnfoldding_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_21", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def CountPS ( str , n ) :\n    dp = [ [ (89 + -89) for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    idx_z89w = (89 + -89)\n    list_sji5 = range ( n )\n    while idx_z89w < len(list_sji5):\n        i = list_sji5[idx_z89w]\n        P [ i ] [ i ] = True\n        idx_z89w = idx_z89w + (95 + -94)\n    idx_gbkp = (85 + -85)\n    list_gfpr = range ( n - (14 + -13) )\n    while idx_gbkp < len(list_gfpr):\n        i = list_gfpr[idx_gbkp]\n        if ( str [ i ] == str [ i + (45 + -44) ] ) :\n            P [ i ] [ i + (55 + -54) ] = True\n            dp [ i ] [ i + (41 + -40) ] = (47 + -46)\n        idx_gbkp = idx_gbkp + (90 + -89)\n    idx_5cgn = (58 + -58)\n    list_4f10 = range ( (84 + -82) , n )\n    while idx_5cgn < len(list_4f10):\n        gap = list_4f10[idx_5cgn]\n        idx_vgay = (42 + -42)\n        list_tygj = range ( n - gap )\n        while idx_vgay < len(list_tygj):\n            i = list_tygj[idx_vgay]\n            j = gap + i ;\n            if ( str [ i ] == str [ j ] and P [ i + (70 + -69) ] [ j - (57 + -56) ] ) :\n                P [ i ] [ j ] = True\n            if not ( P [ i ] [ j ] == True ):\n                dp [ i ] [ j ] = ( dp [ i ] [ j - (27 + -26) ] + dp [ i + (58 + -57) ] [ j ] - dp [ i + (65 + -64) ] [ j - (36 + -35) ] )\n            else:\n                dp [ i ] [ j ] = ( dp [ i ] [ j - (69 + -68) ] + dp [ i + (2 + -1) ] [ j ] + (29 + -28) - dp [ i + (56 + -55) ] [ j - (80 + -79) ] )\n            idx_vgay = idx_vgay + (41 + -40)\n        idx_5cgn = idx_5cgn + (17 + -16)\n    return dp [ (94 + -94) ] [ n - (18 + -17) ]", "id": "ConstantUnfoldding_sample_from_COUNT_PALINDROME_SUB_STRINGS_STRING_to_22", "old_id": "COUNT_PALINDROME_SUB_STRINGS_STRING"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = (25 + -25)\n    ans = (96 + -96)\n    hash_positive = [ (7 + -7) ] * ( n + (55 + -54) )\n    hash_negative = [ (83 + -83) ] * ( n + (93 + -92) )\n    hash_positive [ (48 + -48) ] = (51 + -50)\n    idx_ap92 = (9 + -9)\n    list_qfuc = range ( n )\n    while idx_ap92 < len(list_qfuc):\n        i = list_qfuc[idx_ap92]\n        if not ( arr [ i ] & (4 + -3) == (25 + -24) ):\n            difference = difference - (44 + -43)\n        else:\n            difference = difference + (4 + -3)\n        if not ( difference < (95 + -95) ):\n            ans += hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ] + (69 + -68)\n        else:\n            ans += hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ] + (58 + -57)\n        idx_ap92 = idx_ap92 + (31 + -30)\n    return ans", "id": "ConstantUnfoldding_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_23", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = (25 + -25)\n    ans = (58 + -58)\n    while ( ( (83 + -82) << i ) <= n ) :\n        k = (39 + -39)\n        change = (98 + -97) << i\n        idx_yjf9 = (19 + -19)\n        list_k3gh = range ( (14 + -14) , n + (79 + -78) )\n        while idx_yjf9 < len(list_k3gh):\n            j = list_k3gh[idx_yjf9]\n            ans += k\n            if not change == (83 + -82):\n                change -= (19 + -18)\n            else:\n                k = not k\n                change = (59 + -58) << i\n            idx_yjf9 = idx_yjf9 + (80 + -79)\n        i += (44 + -43)\n    return ans", "id": "ConstantUnfoldding_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_24", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def countWords ( str , len ) :\n    count = (13 + -12) ;\n    if ( len == (93 + -92) ) :\n        return count\n    if not ( str [ (60 + -60) ] == str [ (28 + -27) ] ):\n        count *= (59 + -57)\n    else:\n        count *= (20 + -19)\n    idx_6c01 = (29 + -29)\n    list_9tav = range ( (40 + -39) , len - (25 + -24) )\n    while idx_6c01 < len(list_9tav):\n        j = list_9tav[idx_6c01]\n        if not ( str [ j ] == str [ j - (63 + -62) ] and str [ j ] == str [ j + (61 + -60) ] ):\n            if ( str [ j ] == str [ j - (88 + -87) ] or str [ j ] == str [ j + (93 + -92) ] or str [ j - (30 + -29) ] == str [ j + (20 + -19) ] ) :\n                count *= (3 + -1)\n            else :\n                count *= (6 + -3)\n        else:\n            count *= (64 + -63)\n        idx_6c01 = idx_6c01 + (53 + -52)\n    if not ( str [ len - (73 + -72) ] == str [ len - (100 + -98) ] ):\n        count *= (36 + -34)\n    else:\n        count *= (12 + -11)\n    return count", "id": "ConstantUnfoldding_sample_from_COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD_to_25", "old_id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = (53 + 203)\n    count = [ (41 + -41) ] * NO_OF_CHARS\n    idx_ndhu = (91 + -91)\n    list_5oga = range ( len ( str ) )\n    while idx_ndhu < len(list_5oga):\n        i = list_5oga[idx_ndhu]\n        count [ ord ( str [ i ] ) ] += (19 + -18)\n        idx_ndhu = idx_ndhu + (46 + -45)\n    first , second = (97 + -97) , (16 + -16)\n    idx_e0am = (75 + -75)\n    list_bmh4 = range ( NO_OF_CHARS )\n    while idx_e0am < len(list_bmh4):\n        i = list_bmh4[idx_e0am]\n        if not count [ i ] > count [ first ]:\n            if ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n                second = i\n        else:\n            second = first\n            first = i\n        idx_e0am = idx_e0am + (15 + -14)\n    return chr ( second )", "id": "ConstantUnfoldding_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_26", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    idx_idh2 = (71 + -71)\n    list_2b3a = range ( len ( Str ) )\n    while idx_idh2 < len(list_2b3a):\n        i = list_2b3a[idx_idh2]\n        count = (74 + -74)\n        if not ( Str [ i ] >= '0' and Str [ i ] <= '9' ):\n            if ( Str [ i ] == ']' ) :\n                temp = \"\"\n                count = (35 + -35)\n                if ( len ( integerstack ) != (62 + -62) ) :\n                    count = integerstack [ - (13 + -12) ]\n                    integerstack.pop ( )\n                while ( len ( stringstack ) != (18 + -18) and stringstack [ - (98 + -97) ] != '[' ) :\n                    temp = stringstack [ - (34 + -33) ] + temp\n                    stringstack.pop ( )\n                if ( len ( stringstack ) != (5 + -5) and stringstack [ - (97 + -96) ] == '[' ) :\n                    stringstack.pop ( )\n                idx_820k = (55 + -55)\n                list_5npa = range ( count )\n                while idx_820k < len(list_5npa):\n                    j = list_5npa[idx_820k]\n                    result = result + temp\n                    idx_820k = idx_820k + (30 + -29)\n                idx_trao = (60 + -60)\n                list_m5vy = range ( len ( result ) )\n                while idx_trao < len(list_m5vy):\n                    j = list_m5vy[idx_trao]\n                    stringstack.append ( result [ j ] )\n                    idx_trao = idx_trao + (17 + -16)\n                result = \"\"\n            elif ( Str [ i ] == '[' ) :\n                if ( Str [ i - (62 + -61) ] >= '0' and Str [ i - (90 + -89) ] <= '9' ) :\n                    stringstack.append ( Str [ i ] )\n                else :\n                    stringstack.append ( Str [ i ] )\n                    integerstack.append ( (4 + -3) )\n            else :\n                stringstack.append ( Str [ i ] )\n        else:\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * (91 + -81) + ord ( Str [ i ] ) - ord ( '0' )\n                i += (97 + -96)\n            i -= (19 + -18)\n            integerstack.append ( count )\n        idx_idh2 = idx_idh2 + (45 + -44)\n    while len ( stringstack ) != (70 + -70) :\n        result = stringstack [ - (1 + 0) ] + result\n        stringstack.pop ( )\n    return result", "id": "ConstantUnfoldding_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_27", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def findDiff ( arr , n ) :\n    arr.sort ( )\n    count = (99 + -99)\n    max_count = (24 + -24)\n    min_count = n\n    idx_8zu9 = (31 + -31)\n    list_ktoy = range ( (7 + -7) , ( n - (11 + -10) ) )\n    while idx_8zu9 < len(list_ktoy):\n        i = list_ktoy[idx_8zu9]\n        if not arr [ i ] == arr [ i + (75 + -74) ]:\n            max_count = max ( max_count , count )\n            min_count = min ( min_count , count )\n            count = (44 + -44)\n        else:\n            count += (16 + -15)\n            continue\n        idx_8zu9 = idx_8zu9 + (10 + -9)\n    return max_count - min_count", "id": "ConstantUnfoldding_sample_from_DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_to_28", "old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY"}
{"code": "def isDvisibleBy12 ( num ) :\n    if not ( len ( num ) >= (89 + -86) ):\n        number = int ( num )\n        return ( number % (76 + -64) == (18 + -18) )\n    else:\n        d1 = int ( num [ len ( num ) - (20 + -19) ] )\n        if ( d1 % (92 + -90) != (87 + -87) ) :\n            return False\n        d2 = int ( num [ len ( num ) - (76 + -74) ] )\n        sum = (50 + -50)\n        idx_9sjr = (61 + -61)\n        list_ubdh = range ( (91 + -91) , len ( num ) )\n        while idx_9sjr < len(list_ubdh):\n            i = list_ubdh[idx_9sjr]\n            sum += int ( num [ i ] )\n            idx_9sjr = idx_9sjr + (4 + -3)\n        return ( sum % (78 + -75) == (20 + -20) and ( d2 * (92 + -82) + d1 ) % (66 + -62) == (33 + -33) )", "id": "ConstantUnfoldding_sample_from_DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER_to_29", "old_id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER"}
{"code": "def doublefactorial ( n ) :\n    res = (12 + -11)\n    idx_vc5t = (1 + -1)\n    list_nrl0 = range ( n , - (59 + -58) , - (74 + -72) )\n    while idx_vc5t < len(list_nrl0):\n        i = list_nrl0[idx_vc5t]\n        if not ( i == (74 + -74) or i == (55 + -54) ):\n            res *= i\n        else:\n            return res\n        idx_vc5t = idx_vc5t + (32 + -31)\n    return res;", "id": "ConstantUnfoldding_sample_from_DOUBLE_FACTORIAL_1_to_30", "old_id": "DOUBLE_FACTORIAL_1"}
{"code": "def lps ( seq ) :\n    n = len ( seq )\n    L = [ [ (100 + -100) for x in range ( n ) ] for x in range ( n ) ]\n    idx_zvp3 = (64 + -64)\n    list_4q0c = range ( n )\n    while idx_zvp3 < len(list_4q0c):\n        i = list_4q0c[idx_zvp3]\n        L [ i ] [ i ] = (18 + -17)\n        idx_zvp3 = idx_zvp3 + (21 + -20)\n    idx_eho3 = (10 + -10)\n    list_q8fg = range ( (66 + -64) , n + (97 + -96) )\n    while idx_eho3 < len(list_q8fg):\n        cl = list_q8fg[idx_eho3]\n        idx_6wqp = (41 + -41)\n        list_z4dh = range ( n - cl + (80 + -79) )\n        while idx_6wqp < len(list_z4dh):\n            i = list_z4dh[idx_6wqp]\n            j = i + cl - (39 + -38)\n            if not seq [ i ] == seq [ j ] and cl == (85 + -83):\n                if seq [ i ] == seq [ j ] :\n                    L [ i ] [ j ] = L [ i + (68 + -67) ] [ j - (76 + -75) ] + (35 + -33)\n                else :\n                    L [ i ] [ j ] = max ( L [ i ] [ j - (52 + -51) ] , L [ i + (60 + -59) ] [ j ] ) ;\n            else:\n                L [ i ] [ j ] = (30 + -28)\n            idx_6wqp = idx_6wqp + (21 + -20)\n        idx_eho3 = idx_eho3 + (30 + -29)\n    return L [ (51 + -51) ] [ n - (32 + -31) ]", "id": "ConstantUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE_to_31", "old_id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE"}
{"code": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ (23 + -23) for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = (48 + -48)\n    k = (1 + -1)\n    L = (1 + -1)\n    idx_y5ob = (19 + -19)\n    list_9xt2 = range ( n )\n    while idx_y5ob < len(list_9xt2):\n        i = list_9xt2[idx_y5ob]\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = (30 + -30)\n        idx_y5ob = idx_y5ob + (44 + -43)\n    idx_ad3u = (2 + -2)\n    list_fpaj = range ( (45 + -43) , n + (53 + -52) )\n    while idx_ad3u < len(list_fpaj):\n        L = list_fpaj[idx_ad3u]\n        idx_137l = (33 + -33)\n        list_034w = range ( n - L + (9 + -8) )\n        while idx_137l < len(list_034w):\n            i = list_034w[idx_137l]\n            j = i + L - (69 + -68)\n            if not L == (46 + -44):\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + (94 + -93) ] [ j - (66 + -65) ] )\n            else:\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            if not P [ i ] [ j ] == True:\n                C [ i ] [ j ] = (8 + 99999992)\n                idx_hdqm = (42 + -42)\n                list_f9vg = range ( i , j )\n                while idx_hdqm < len(list_f9vg):\n                    k = list_f9vg[idx_hdqm]\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + (88 + -87) ] [ j ] + (82 + -81) )\n                    idx_hdqm = idx_hdqm + (70 + -69)\n            else:\n                C [ i ] [ j ] = (37 + -37)\n            idx_137l = idx_137l + (46 + -45)\n        idx_ad3u = idx_ad3u + (54 + -53)\n    return C [ (79 + -79) ] [ n - (78 + -77) ]", "id": "ConstantUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_to_32", "old_id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ (48 + -48) for i in range ( n + (7 + -6) ) ] for i in range ( n + (39 + -38) ) ]\n    T = [ [ (61 + -61) for i in range ( n + (61 + -60) ) ] for i in range ( n + (80 + -79) ) ]\n    idx_6qn3 = (78 + -78)\n    list_9a4x = range ( n )\n    while idx_6qn3 < len(list_9a4x):\n        i = list_9a4x[idx_6qn3]\n        if not symb [ i ] == 'F':\n            F [ i ] [ i ] = (39 + -39)\n        else:\n            F [ i ] [ i ] = (39 + -38)\n        if not symb [ i ] == 'T':\n            T [ i ] [ i ] = (87 + -87)\n        else:\n            T [ i ] [ i ] = (65 + -64)\n        idx_6qn3 = idx_6qn3 + (58 + -57)\n    idx_m9uv = (16 + -16)\n    list_vmg2 = range ( (35 + -34) , n )\n    while idx_m9uv < len(list_vmg2):\n        gap = list_vmg2[idx_m9uv]\n        i = (22 + -22)\n        idx_kmv2 = (16 + -16)\n        list_tr95 = range ( gap , n )\n        while idx_kmv2 < len(list_tr95):\n            j = list_tr95[idx_kmv2]\n            T [ i ] [ j ] = F [ i ] [ j ] = (27 + -27)\n            idx_06sr = (99 + -99)\n            list_vhse = range ( gap )\n            while idx_06sr < len(list_vhse):\n                g = list_vhse[idx_06sr]\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + (83 + -82) ] [ j ] + F [ k + (37 + -36) ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + (26 + -25) ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + (42 + -41) ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + (37 + -36) ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + (68 + -67) ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + (22 + -21) ] [ j ] + T [ i ] [ k ] * F [ k + (13 + -12) ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + (43 + -42) ] [ j ] + F [ i ] [ k ] * F [ k + (2 + -1) ] [ j ] )\n                idx_06sr = idx_06sr + (89 + -88)\n            i += (93 + -92)\n            idx_kmv2 = idx_kmv2 + (70 + -69)\n        idx_m9uv = idx_m9uv + (36 + -35)\n    return T [ (55 + -55) ] [ n - (17 + -16) ]", "id": "ConstantUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_33", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    idx_orpm = (40 + -40)\n    list_ogf0 = string\n    while idx_orpm < len(list_ogf0):\n        ch = list_ogf0[idx_orpm]\n        if not ch == ')':\n            Stack.append ( ch )\n        else:\n            top = Stack.pop ( )\n            elementsInside = (62 + -62)\n            while top != '(' :\n                elementsInside += (18 + -17)\n                top = Stack.pop ( )\n            if elementsInside < (99 + -98) :\n                return True\n        idx_orpm = idx_orpm + (44 + -43)\n    return False", "id": "ConstantUnfoldding_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_34", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def computeLastDigit ( A , B ) :\n    variable = (23 + -22)\n    if not ( A == B ):\n        if ( ( B - A ) >= (92 + -87) ) :\n            return (8 + -8)\n        else :\n            idx_lcf9 = (100 + -100)\n            list_k9vg = range ( A + (44 + -43) , B + (90 + -89) )\n            while idx_lcf9 < len(list_k9vg):\n                i = list_k9vg[idx_lcf9]\n                variable = ( variable * ( i % (38 + -28) ) ) % (12 + -2)\n                idx_lcf9 = idx_lcf9 + (7 + -6)\n            return variable % (28 + -18)\n    else:\n        return (15 + -14)", "id": "ConstantUnfoldding_sample_from_FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B_to_35", "old_id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B"}
{"code": "def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :\n    sum1 , sum2 , sum3 = (43 + -43) , (63 + -63) , (86 + -86)\n    idx_cnsx = (56 + -56)\n    list_vzts = range ( n1 )\n    while idx_cnsx < len(list_vzts):\n        i = list_vzts[idx_cnsx]\n        sum1 += stack1 [ i ]\n        idx_cnsx = idx_cnsx + (92 + -91)\n    idx_e1c0 = (42 + -42)\n    list_fmvd = range ( n2 )\n    while idx_e1c0 < len(list_fmvd):\n        i = list_fmvd[idx_e1c0]\n        sum2 += stack2 [ i ]\n        idx_e1c0 = idx_e1c0 + (81 + -80)\n    idx_48mz = (8 + -8)\n    list_047c = range ( n3 )\n    while idx_48mz < len(list_047c):\n        i = list_047c[idx_48mz]\n        sum3 += stack3 [ i ]\n        idx_48mz = idx_48mz + (49 + -48)\n    top1 , top2 , top3 = (40 + -40) , (37 + -37) , (10 + -10)\n    ans = (16 + -16)\n    while (8 + -7) :\n        if ( top1 == n1 or top2 == n2 or top3 == n3 ) :\n            return (18 + -18)\n        if ( sum1 == sum2 and sum2 == sum3 ) :\n            return sum1\n        if not ( sum1 >= sum2 and sum1 >= sum3 ):\n            if ( sum2 >= sum3 and sum2 >= sum3 ) :\n                sum2 -= stack2 [ top2 ]\n                top2 = top2 + (100 + -99)\n            elif ( sum3 >= sum2 and sum3 >= sum1 ) :\n                sum3 -= stack3 [ top3 ]\n                top3 = top3 + (3 + -2)\n        else:\n            sum1 -= stack1 [ top1 ]\n            top1 = top1 + (5 + -4)", "id": "ConstantUnfoldding_sample_from_FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS_to_36", "old_id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize - (50 + -49)\n    idx_4dal = (5 + -5)\n    list_70ym = range ( r )\n    while idx_4dal < len(list_70ym):\n        i = list_70ym[idx_4dal]\n        if m [ i ] [ (90 + -90) ] < mi :\n            mi = m [ i ] [ (98 + -98) ]\n        if m [ i ] [ c - (43 + -42) ] > mx :\n            mx = m [ i ] [ c - (6 + -5) ]\n        idx_4dal = idx_4dal + (21 + -20)\n    desired = ( r * c + (77 + -76) ) // (15 + -13)\n    while ( mi < mx ) :\n        mid = mi + ( mx - mi ) // (50 + -48)\n        place = [ (39 + -39) ]\n        idx_tlae = (40 + -40)\n        list_7nmt = range ( r )\n        while idx_tlae < len(list_7nmt):\n            i = list_7nmt[idx_tlae]\n            j = upper_bound ( m [ i ] , mid )\n            place [ (73 + -73) ] = place [ (18 + -18) ] + j\n            idx_tlae = idx_tlae + (81 + -80)\n        if not place [ (90 + -90) ] < desired:\n            mx = mid\n        else:\n            mi = mid + (5 + -4)\n    print ( \"Median is\" , mi )\n    return mi", "id": "ConstantUnfoldding_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_37", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def count ( a , b ) :\n    m = len ( a )\n    n = len ( b )\n    lookup = [ [ (9 + -9) ] * ( n + (38 + -37) ) for i in range ( m + (12 + -11) ) ]\n    idx_mg8j = (54 + -54)\n    list_5rhn = range ( n + (35 + -34) )\n    while idx_mg8j < len(list_5rhn):\n        i = list_5rhn[idx_mg8j]\n        lookup [ (6 + -6) ] [ i ] = (16 + -16)\n        idx_mg8j = idx_mg8j + (54 + -53)\n    idx_2b1a = (92 + -92)\n    list_2fzo = range ( m + (76 + -75) )\n    while idx_2b1a < len(list_2fzo):\n        i = list_2fzo[idx_2b1a]\n        lookup [ i ] [ (73 + -73) ] = (59 + -58)\n        idx_2b1a = idx_2b1a + (87 + -86)\n    idx_uz6x = (74 + -74)\n    list_bw2x = range ( (82 + -81) , m + (70 + -69) )\n    while idx_uz6x < len(list_bw2x):\n        i = list_bw2x[idx_uz6x]\n        idx_pbny = (4 + -4)\n        list_qtie = range ( (71 + -70) , n + (26 + -25) )\n        while idx_pbny < len(list_qtie):\n            j = list_qtie[idx_pbny]\n            if not a [ i - (24 + -23) ] == b [ j - (64 + -63) ]:\n                lookup [ i ] [ j ] = lookup [ i - (38 + -37) ] [ j ]\n            else:\n                lookup [ i ] [ j ] = lookup [ i - (60 + -59) ] [ j - (67 + -66) ] + lookup [ i - (18 + -17) ] [ j ]\n            idx_pbny = idx_pbny + (43 + -42)\n        idx_uz6x = idx_uz6x + (20 + -19)\n    return lookup [ m ] [ n ]", "id": "ConstantUnfoldding_sample_from_FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1_to_38", "old_id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1"}
{"code": "def findSDSFunc ( n ) :\n    DP = [ (94 + -94) ] * ( n + (21 + -20) )\n    DP [ (16 + -16) ] = (1 + -1)\n    DP [ (97 + -96) ] = (27 + -26)\n    idx_kvo4 = (34 + -34)\n    list_ghn5 = range ( (28 + -26) , n + (54 + -53) )\n    while idx_kvo4 < len(list_ghn5):\n        i = list_ghn5[idx_kvo4]\n        if not ( int ( i % (54 + -52) ) == (55 + -55) ):\n            DP [ i ] = ( DP [ int ( ( i - (44 + -43) ) / (26 + -24) ) ] + DP [ int ( ( i + (67 + -66) ) / (28 + -26) ) ] )\n        else:\n            DP [ i ] = DP [ int ( i / (18 + -16) ) ]\n        idx_kvo4 = idx_kvo4 + (10 + -9)\n    return DP [ n ]", "id": "ConstantUnfoldding_sample_from_FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES_to_39", "old_id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES"}
{"code": "def pairSum ( mat , n , sum ) :\n    idx_r3u6 = (92 + -92)\n    list_bmy1 = range ( n )\n    while idx_r3u6 < len(list_bmy1):\n        i = list_bmy1[idx_r3u6]\n        mat [ i ].sort ( )\n        idx_r3u6 = idx_r3u6 + (5 + -4)\n    idx_of4v = (12 + -12)\n    list_ontg = range ( n - (37 + -36) )\n    while idx_of4v < len(list_ontg):\n        i = list_ontg[idx_of4v]\n        idx_4yj7 = (17 + -17)\n        list_v0qx = range ( i + (59 + -58) , n )\n        while idx_4yj7 < len(list_v0qx):\n            j = list_v0qx[idx_4yj7]\n            left = (40 + -40)\n            right = n - (85 + -84)\n            while ( left < n and right >= (53 + -53) ) :\n                if not ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ):\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += (62 + -61)\n                    else :\n                        right -= (66 + -65)\n                else:\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left += (24 + -23)\n                    right -= (80 + -79)\n            idx_4yj7 = idx_4yj7 + (22 + -21)\n        idx_of4v = idx_of4v + (46 + -45)", "id": "ConstantUnfoldding_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_40", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def evenSum ( n ) :\n    C = [ [ (55 + -55) for x in range ( n + (89 + -88) ) ] for y in range ( n + (29 + -28) ) ]\n    idx_ql9f = (61 + -61)\n    list_zuig = range ( (60 + -60) , n + (86 + -85) )\n    while idx_ql9f < len(list_zuig):\n        i = list_zuig[idx_ql9f]\n        idx_6rcy = (54 + -54)\n        list_12i9 = range ( (46 + -46) , min ( i , n ) + (15 + -14) )\n        while idx_6rcy < len(list_12i9):\n            j = list_12i9[idx_6rcy]\n            if not j == (9 + -9) or j == i:\n                C [ i ] [ j ] = C [ i - (50 + -49) ] [ j - (64 + -63) ] + C [ i - (29 + -28) ] [ j ]\n            else:\n                C [ i ] [ j ] = (51 + -50)\n            idx_6rcy = idx_6rcy + (40 + -39)\n        idx_ql9f = idx_ql9f + (58 + -57)\n    sum = (74 + -74) ;\n    idx_e4n1 = (23 + -23)\n    list_cza3 = range ( (36 + -36) , n + (15 + -14) )\n    while idx_e4n1 < len(list_cza3):\n        i = list_cza3[idx_e4n1]\n        if i % (64 + -62) == (67 + -67) :\n            sum = sum + C [ n ] [ i ]\n        idx_e4n1 = idx_e4n1 + (21 + -20)\n    return sum", "id": "ConstantUnfoldding_sample_from_FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_to_41", "old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    idx_tmwn = (97 + -97)\n    list_7clj = range ( n - (84 + -83) )\n    while idx_tmwn < len(list_7clj):\n        i = list_7clj[idx_tmwn]\n        s = set ( )\n        idx_cl5p = (66 + -66)\n        list_oglb = range ( i + (39 + -38) , n )\n        while idx_cl5p < len(list_oglb):\n            j = list_oglb[idx_cl5p]\n            x = - ( arr [ i ] + arr [ j ] )\n            if not x in s:\n                s.add ( arr [ j ] )\n            else:\n                print ( x , arr [ i ] , arr [ j ] )\n                found = True\n            idx_cl5p = idx_cl5p + (95 + -94)\n        idx_tmwn = idx_tmwn + (16 + -15)\n    if found == False :\n        print ( \"No Triplet Found\" )", "id": "ConstantUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1_to_42", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    idx_kx85 = (36 + -36)\n    list_zifn = range ( (8 + -8) , n - (82 + -81) )\n    while idx_kx85 < len(list_zifn):\n        i = list_zifn[idx_kx85]\n        l = i + (30 + -29)\n        r = n - (81 + -80)\n        x = arr [ i ]\n        while ( l < r ) :\n            if not ( x + arr [ l ] + arr [ r ] == (89 + -89) ):\n                if ( x + arr [ l ] + arr [ r ] < (15 + -15) ) :\n                    l += (29 + -28)\n                else :\n                    r -= (62 + -61)\n            else:\n                print ( x , arr [ l ] , arr [ r ] )\n                l += (47 + -46)\n                r -= (86 + -85)\n                found = True\n        idx_kx85 = idx_kx85 + (60 + -59)\n    if ( found == False ) :\n        print ( \" No Triplet Found\" )", "id": "ConstantUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_43", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def firstElement ( arr , n , k ) :\n    count_map = { }\n    idx_41bp = (58 + -58)\n    list_uig9 = range ( (41 + -41) , n )\n    while idx_41bp < len(list_uig9):\n        i = list_uig9[idx_41bp]\n        if not ( arr [ i ] in count_map.keys ( ) ):\n            count_map [ arr [ i ] ] = (41 + -40)\n        else:\n            count_map [ arr [ i ] ] += (6 + -5)\n        i += (18 + -17)\n        idx_41bp = idx_41bp + (35 + -34)\n    idx_fye5 = (78 + -78)\n    list_i5np = range ( (39 + -39) , n )\n    while idx_fye5 < len(list_i5np):\n        i = list_i5np[idx_fye5]\n        if ( count_map [ arr [ i ] ] == k ) :\n            return arr [ i ]\n        i += (63 + -62)\n        idx_fye5 = idx_fye5 + (22 + -21)\n    return - (55 + -54)", "id": "ConstantUnfoldding_sample_from_FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY_to_44", "old_id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY"}
{"code": "def mostFrequent ( arr , n ) :\n    Hash = dict ( )\n    idx_kpvr = (54 + -54)\n    list_fz8l = range ( n )\n    while idx_kpvr < len(list_fz8l):\n        i = list_fz8l[idx_kpvr]\n        if not arr [ i ] in Hash.keys ( ):\n            Hash [ arr [ i ] ] = (30 + -29)\n        else:\n            Hash [ arr [ i ] ] += (89 + -88)\n        idx_kpvr = idx_kpvr + (26 + -25)\n    max_count = (31 + -31)\n    res = - (21 + -20)\n    idx_p6t5 = (18 + -18)\n    list_fn08 = Hash\n    while idx_p6t5 < len(list_fn08):\n        i = list_fn08[idx_p6t5]\n        if ( max_count < Hash [ i ] ) :\n            res = i\n            max_count = Hash [ i ]\n        idx_p6t5 = idx_p6t5 + (28 + -27)\n    return res", "id": "ConstantUnfoldding_sample_from_FREQUENT_ELEMENT_ARRAY_1_to_45", "old_id": "FREQUENT_ELEMENT_ARRAY_1"}
{"code": "def countFriendsPairings ( n ) :\n    dp = [ (34 + -34) for i in range ( n + (49 + -48) ) ]\n    idx_6l1z = (75 + -75)\n    list_75yu = range ( n + (48 + -47) )\n    while idx_6l1z < len(list_75yu):\n        i = list_75yu[idx_6l1z]\n        if not ( i <= (5 + -3) ):\n            dp [ i ] = dp [ i - (59 + -58) ] + ( i - (27 + -26) ) * dp [ i - (15 + -13) ]\n        else:\n            dp [ i ] = i\n        idx_6l1z = idx_6l1z + (47 + -46)\n    return dp [ n ]", "id": "ConstantUnfoldding_sample_from_FRIENDS_PAIRING_PROBLEM_to_46", "old_id": "FRIENDS_PAIRING_PROBLEM"}
{"code": "def isSubSeqDivisible ( str ) :\n    l = len ( str )\n    arr = [ (67 + -67) ] * l\n    idx_8rdi = (35 + -35)\n    list_bwa1 = range ( (10 + -10) , l )\n    while idx_8rdi < len(list_bwa1):\n        i = list_bwa1[idx_8rdi]\n        idx_c48i = (50 + -50)\n        list_vyn0 = range ( i , l )\n        while idx_c48i < len(list_vyn0):\n            j = list_vyn0[idx_c48i]\n            idx_hubv = (13 + -13)\n            list_2dtz = range ( j , l )\n            while idx_hubv < len(list_2dtz):\n                k = list_2dtz[idx_hubv]\n                if not ( arr [ i ] % (85 + -77) == (27 + -27) ):\n                    if ( ( arr [ i ] * (98 + -88) + arr [ j ] ) % (4 + 4) == (60 + -60) and i != j ) :\n                        return True\n                    elif ( ( arr [ i ] * (37 + 63) + arr [ j ] * (13 + -3) + arr [ k ] ) % (98 + -90) == (68 + -68) and i != j and j != k and i != k ) :\n                        return True\n                else:\n                    return True\n                idx_hubv = idx_hubv + (88 + -87)\n            idx_c48i = idx_c48i + (90 + -89)\n        idx_8rdi = idx_8rdi + (5 + -4)\n    return False", "id": "ConstantUnfoldding_sample_from_GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_to_47", "old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ (59 + -59) ] * ( m + (15 + -14) )\n    nxtbb = (56 + -56)\n    idx_gnb5 = (44 + -44)\n    list_85kl = range ( (26 + -25) , m + (91 + -90) )\n    while idx_gnb5 < len(list_85kl):\n        i = list_85kl[idx_gnb5]\n        if not ( nxtbb < n ):\n            maxRev [ i ] = maxRev [ i - (62 + -61) ]\n        else:\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - (30 + -29) ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - (29 + -28) ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - (72 + -71) ] + revenue [ nxtbb ] , maxRev [ i - (80 + -79) ] )\n                nxtbb += (24 + -23)\n        idx_gnb5 = idx_gnb5 + (97 + -96)\n    return maxRev [ m ]", "id": "ConstantUnfoldding_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_48", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = (6 + -6)\n    idx_eiur = (75 + -75)\n    list_zn9d = arr\n    while idx_eiur < len(list_zn9d):\n        i = list_zn9d[idx_eiur]\n        if not ( i < (96 + -96) ):\n            hash [ i ] = hash.get ( i , (88 + -88) ) + (44 + -43)\n        else:\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - (7 + -6)\n            else :\n                hash [ abs ( i ) ] -= (92 + -91)\n        idx_eiur = idx_eiur + (62 + -61)\n    idx_0w2e = (88 + -88)\n    list_thq0 = arr\n    while idx_0w2e < len(list_thq0):\n        i = list_thq0[idx_0w2e]\n        if i in hash.keys ( ) and hash [ i ] > (97 + -97) :\n            return i\n        idx_0w2e = idx_0w2e + (88 + -87)\n    return - (4 + -3)", "id": "ConstantUnfoldding_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_49", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def kthLargestSum ( arr , n , k ) :\n    sum = [ ]\n    sum.append ( (70 + -70) )\n    sum.append ( arr [ (89 + -89) ] )\n    idx_8ch6 = (55 + -55)\n    list_vpxk = range ( (18 + -16) , n + (40 + -39) )\n    while idx_8ch6 < len(list_vpxk):\n        i = list_vpxk[idx_8ch6]\n        sum.append ( sum [ i - (60 + -59) ] + arr [ i - (22 + -21) ] )\n        idx_8ch6 = idx_8ch6 + (25 + -24)\n    Q = [ ]\n    heapq.heapify ( Q )\n    idx_5ysh = (15 + -15)\n    list_2vxs = range ( (31 + -30) , n + (2 + -1) )\n    while idx_5ysh < len(list_2vxs):\n        i = list_2vxs[idx_5ysh]\n        idx_l8he = (24 + -24)\n        list_u2nl = range ( i , n + (68 + -67) )\n        while idx_l8he < len(list_u2nl):\n            j = list_u2nl[idx_l8he]\n            x = sum [ j ] - sum [ i - (26 + -25) ]\n            if not len ( Q ) < k:\n                if Q [ (73 + -73) ] < x :\n                    heapq.heappop ( Q )\n                    heapq.heappush ( Q , x )\n            else:\n                heapq.heappush ( Q , x )\n            idx_l8he = idx_l8he + (93 + -92)\n        idx_5ysh = idx_5ysh + (42 + -41)\n    return Q [ (34 + -34) ]", "id": "ConstantUnfoldding_sample_from_K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY_to_50", "old_id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY"}
{"code": "def findSubArray ( arr , n ) :\n    sum = (53 + -53)\n    maxsize = - (50 + -49)\n    idx_yl8i = (27 + -27)\n    list_ejb4 = range ( (23 + -23) , n - (64 + -63) )\n    while idx_yl8i < len(list_ejb4):\n        i = list_ejb4[idx_yl8i]\n        sum = - (69 + -68) if ( arr [ i ] == (21 + -21) ) else (84 + -83)\n        idx_jlai = (49 + -49)\n        list_0amv = range ( i + (24 + -23) , n )\n        while idx_jlai < len(list_0amv):\n            j = list_0amv[idx_jlai]\n            sum = sum + ( - (63 + -62) ) if ( arr [ j ] == (83 + -83) ) else sum + (20 + -19)\n            if ( sum == (95 + -95) and maxsize < j - i + (15 + -14) ) :\n                maxsize = j - i + (33 + -32)\n                startindex = i\n            idx_jlai = idx_jlai + (67 + -66)\n        idx_yl8i = idx_yl8i + (41 + -40)\n    if not ( maxsize == - (17 + -16) ):\n        print ( startindex , \"to\" , startindex + maxsize - (25 + -24) )\n    else:\n        print ( \"No such subarray\" )\n    return maxsize", "id": "ConstantUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_51", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = (21 + -21)\n    max_len = (42 + -42)\n    ending_index = - (3 + -2)\n    idx_vogl = (52 + -52)\n    list_fpln = range ( (70 + -70) , n )\n    while idx_vogl < len(list_fpln):\n        i = list_fpln[idx_vogl]\n        if not ( arr [ i ] == (8 + -8) ):\n            arr [ i ] = (56 + -55)\n        else:\n            arr [ i ] = - (65 + -64)\n        idx_vogl = idx_vogl + (89 + -88)\n    idx_r1a6 = (85 + -85)\n    list_12xo = range ( (57 + -57) , n )\n    while idx_r1a6 < len(list_12xo):\n        i = list_12xo[idx_r1a6]\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == (75 + -75) ) :\n            max_len = i + (3 + -2)\n            ending_index = i\n        if not ( curr_sum + n ) in hash_map:\n            hash_map[curr_sum + n] = i\n        else:\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i - hash_map [ curr_sum + n ]\n                ending_index = i\n        idx_r1a6 = idx_r1a6 + (24 + -23)\n    idx_cbtu = (62 + -62)\n    list_3ijm = range ( (31 + -31) , n )\n    while idx_cbtu < len(list_3ijm):\n        i = list_3ijm[idx_cbtu]\n        if not ( arr [ i ] == - (10 + -9) ):\n            arr [ i ] = (15 + -14)\n        else:\n            arr [ i ] = (49 + -49)\n        idx_cbtu = idx_cbtu + (78 + -77)\n    print ( ending_index - max_len + (26 + -25) , end = \" \" )\n    print ( \"to\" , end = \" \" )\n    print ( ending_index )\n    return max_len", "id": "ConstantUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_52", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = (99 + -99)\n    invalidCloseBraces = (17 + -17)\n    idx_ed2h = (46 + -46)\n    list_rob2 = range ( n )\n    while idx_ed2h < len(list_rob2):\n        i = list_rob2[idx_ed2h]\n        if not ( s [ i ] == '(' ):\n            if ( invalidOpenBraces == (63 + -63) ) :\n                invalidCloseBraces += (14 + -13)\n            else :\n                invalidOpenBraces -= (76 + -75)\n        else:\n            invalidOpenBraces += (45 + -44)\n        idx_ed2h = idx_ed2h + (39 + -38)\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "ConstantUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_53", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= (84 + -82) ) :\n        return n\n    L = [ [ (53 + -53) for x in range ( n ) ] for y in range ( n ) ]\n    llap = (52 + -50)\n    idx_rve6 = (69 + -69)\n    list_0ig2 = range ( n )\n    while idx_rve6 < len(list_0ig2):\n        i = list_0ig2[idx_rve6]\n        L [ i ] [ n - (86 + -85) ] = (99 + -97)\n        idx_rve6 = idx_rve6 + (53 + -52)\n    idx_91ps = (58 + -58)\n    list_4jwz = range ( n - (11 + -9) , (19 + -19) , - (53 + -52) )\n    while idx_91ps < len(list_4jwz):\n        j = list_4jwz[idx_91ps]\n        i = j - (8 + -7)\n        k = j + (75 + -74)\n        while ( i >= (4 + -4) and k <= n - (85 + -84) ) :\n            if not ( set [ i ] + set [ k ] < (56 + -54) * set [ j ] ):\n                if ( set [ i ] + set [ k ] > (99 + -97) * set [ j ] ) :\n                    L [ i ] [ j ] = (85 + -83)\n                    i -= (27 + -26)\n                else :\n                    L [ i ] [ j ] = L [ j ] [ k ] + (55 + -54)\n                    llap = max ( llap , L [ i ] [ j ] )\n                    i -= (96 + -95)\n                    k += (30 + -29)\n            else:\n                k += (51 + -50)\n        while ( i >= (87 + -87) ) :\n            L [ i ] [ j ] = (73 + -71)\n            i -= (18 + -17)\n        idx_91ps = idx_91ps + (23 + -22)\n    return llap", "id": "ConstantUnfoldding_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_54", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def LCSubStr ( X , Y , m , n ) :\n    LCSuff = [ [ (30 + -30) for k in range ( n + (94 + -93) ) ] for l in range ( m + (92 + -91) ) ]\n    result = (70 + -70)\n    idx_8oue = (32 + -32)\n    list_d0nq = range ( m + (75 + -74) )\n    while idx_8oue < len(list_d0nq):\n        i = list_d0nq[idx_8oue]\n        idx_9grw = (23 + -23)\n        list_ixfh = range ( n + (38 + -37) )\n        while idx_9grw < len(list_ixfh):\n            j = list_ixfh[idx_9grw]\n            if not ( i == (9 + -9) or j == (63 + -63) ):\n                if ( X [ i - (34 + -33) ] == Y [ j - (19 + -18) ] ) :\n                    LCSuff [ i ] [ j ] = LCSuff [ i - (77 + -76) ] [ j - (20 + -19) ] + (89 + -88)\n                    result = max ( result , LCSuff [ i ] [ j ] )\n                else :\n                    LCSuff [ i ] [ j ] = (43 + -43)\n            else:\n                LCSuff [ i ] [ j ] = (49 + -49)\n            idx_9grw = idx_9grw + (28 + -27)\n        idx_8oue = idx_8oue + (64 + -63)\n    return result", "id": "ConstantUnfoldding_sample_from_LONGEST_COMMON_SUBSTRING_to_55", "old_id": "LONGEST_COMMON_SUBSTRING"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ (93 + -93) for i in range ( n + (49 + -48) ) ] for j in range ( n + (46 + -45) ) ]\n    idx_dhc2 = (25 + -25)\n    list_y8l6 = range ( (8 + -7) , n + (5 + -4) )\n    while idx_dhc2 < len(list_y8l6):\n        i = list_y8l6[idx_dhc2]\n        idx_u53r = (30 + -30)\n        list_fo02 = range ( (62 + -61) , n + (46 + -45) )\n        while idx_u53r < len(list_fo02):\n            j = list_fo02[idx_u53r]\n            if not ( str [ i - (71 + -70) ] == str [ j - (54 + -53) ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - (71 + -70) ] , dp [ i - (85 + -84) ] [ j ] )\n            else:\n                dp [ i ] [ j ] = (18 + -17) + dp [ i - (36 + -35) ] [ j - (74 + -73) ]\n            idx_u53r = idx_u53r + (46 + -45)\n        idx_dhc2 = idx_dhc2 + (65 + -64)\n    res = ''\n    i = n\n    j = n\n    while ( i > (78 + -78) and j > (76 + -76) ) :\n        if not ( dp [ i ] [ j ] == dp [ i - (73 + -72) ] [ j - (14 + -13) ] + (15 + -14) ):\n            if ( dp [ i ] [ j ] == dp [ i - (83 + -82) ] [ j ] ) :\n                i -= (89 + -88)\n            else :\n                j -= (31 + -30)\n        else:\n            res += str [ i - (51 + -50) ]\n            i -= (91 + -90)\n            j -= (51 + -50)\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "ConstantUnfoldding_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_56", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def findLongestRepeatingSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ (26 + -26) ] * ( n + (29 + -28) ) ] * ( n + (100 + -99) )\n    idx_68l1 = (80 + -80)\n    list_lk7e = range ( (40 + -39) , n + (38 + -37) )\n    while idx_68l1 < len(list_lk7e):\n        i = list_lk7e[idx_68l1]\n        idx_uh1k = (75 + -75)\n        list_wiac = range ( (26 + -25) , n + (6 + -5) )\n        while idx_uh1k < len(list_wiac):\n            j = list_wiac[idx_uh1k]\n            if not ( str [ i - (67 + -66) ] == str [ j - (21 + -20) ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - (78 + -77) ] , dp [ i - (22 + -21) ] [ j ] )\n            else:\n                dp [ i ] [ j ] = (31 + -30) + dp [ i - (66 + -65) ] [ j - (17 + -16) ]\n            idx_uh1k = idx_uh1k + (35 + -34)\n        idx_68l1 = idx_68l1 + (45 + -44)\n    return dp [ n ] [ n ]", "id": "ConstantUnfoldding_sample_from_LONGEST_REPEATING_SUBSEQUENCE_to_57", "old_id": "LONGEST_REPEATING_SUBSEQUENCE"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = (85 + -85)\n    maxLen = (26 + -26)\n    idx_kn8l = (78 + -78)\n    list_9wur = range ( n )\n    while idx_kn8l < len(list_9wur):\n        i = list_9wur[idx_kn8l]\n        if not arr [ i ] == (100 + -100):\n            sum += (34 + -33)\n        else:\n            sum += - (28 + -27)\n        if not ( sum == (87 + -86) ):\n            if ( sum not in um ) :\n                um [ sum ] = i\n        else:\n            maxLen = i + (19 + -18)\n        if ( ( sum - (7 + -6) ) in um ) :\n            if ( maxLen < ( i - um [ sum - (21 + -20) ] ) ) :\n                maxLen = i - um [ sum - (97 + -96) ]\n        idx_kn8l = idx_kn8l + (80 + -79)\n    return maxLen", "id": "ConstantUnfoldding_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_58", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ (66 + -66) for i in range ( n ) ]\n    max = (2 + -2)\n    curr_sum = (56 + -56)\n    idx_h18x = (91 + -91)\n    list_7sqg = range ( n )\n    while idx_h18x < len(list_7sqg):\n        i = list_7sqg[idx_h18x]\n        curr_sum += arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k\n        idx_h18x = idx_h18x + (42 + -41)\n    idx_vt3g = (68 + -68)\n    list_mkph = range ( n )\n    while idx_vt3g < len(list_mkph):\n        i = list_mkph[idx_vt3g]\n        if not ( mod_arr [ i ] == (17 + -17) ):\n            if ( mod_arr [ i ] in um ) :\n                um [ mod_arr [ i ] ] = i\n            else :\n                if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                    max = i - um [ mod_arr [ i ] ]\n        else:\n            max = i + (15 + -14)\n        idx_vt3g = idx_vt3g + (54 + -53)\n    return max", "id": "ConstantUnfoldding_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_59", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def findMaxVal ( arr , n , num , maxLimit ) :\n    ind = - (35 + -34)\n    val = - (72 + -71)\n    dp = [ [ (60 + -60) for i in range ( maxLimit + (19 + -18) ) ] for j in range ( n ) ]\n    idx_r9jp = (89 + -89)\n    list_c3xw = range ( n )\n    while idx_r9jp < len(list_c3xw):\n        ind = list_c3xw[idx_r9jp]\n        idx_z0qh = (8 + -8)\n        list_bkxr = range ( maxLimit + (80 + -79) )\n        while idx_z0qh < len(list_bkxr):\n            val = list_bkxr[idx_z0qh]\n            if not ( ind == (65 + -65) ):\n                if ( val - arr [ ind ] >= (85 + -85) and val + arr [ ind ] <= maxLimit ) :\n                    if ( dp [ ind - (67 + -66) ] [ val - arr [ ind ] ] == (81 + -80) or dp [ ind - (96 + -95) ] [ val + arr [ ind ] ] == (38 + -37) ) :\n                        dp [ ind ] [ val ] = (40 + -39)\n                elif ( val - arr [ ind ] >= (58 + -58) ) :\n                    dp [ ind ] [ val ] = dp [ ind - (49 + -48) ] [ val - arr [ ind ] ]\n                elif ( val + arr [ ind ] <= maxLimit ) :\n                    dp [ ind ] [ val ] = dp [ ind - (39 + -38) ] [ val + arr [ ind ] ]\n                else :\n                    dp [ ind ] [ val ] = (75 + -75)\n            else:\n                if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) :\n                    dp [ ind ] [ val ] = (26 + -25)\n                else :\n                    dp [ ind ] [ val ] = (63 + -63)\n            idx_z0qh = idx_z0qh + (20 + -19)\n        idx_r9jp = idx_r9jp + (40 + -39)\n    idx_q53d = (32 + -32)\n    list_qks7 = range ( maxLimit , - (14 + -13) , - (52 + -51) )\n    while idx_q53d < len(list_qks7):\n        val = list_qks7[idx_q53d]\n        if ( dp [ n - (24 + -23) ] [ val ] == (78 + -77) ) :\n            return val\n        idx_q53d = idx_q53d + (48 + -47)\n    return - (81 + -80)", "id": "ConstantUnfoldding_sample_from_MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER_to_60", "old_id": "MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER"}
{"code": "def maxcoefficientvalue ( n ) :\n    C = [ [ (22 + -22) for x in range ( n + (59 + -58) ) ] for y in range ( n + (87 + -86) ) ]\n    idx_uql9 = (32 + -32)\n    list_nure = range ( n + (78 + -77) )\n    while idx_uql9 < len(list_nure):\n        i = list_nure[idx_uql9]\n        idx_wa5d = (55 + -55)\n        list_z3vo = range ( min ( i , n ) + (54 + -53) )\n        while idx_wa5d < len(list_z3vo):\n            j = list_z3vo[idx_wa5d]\n            if not ( j == (33 + -33) or j == i ):\n                C [ i ] [ j ] = ( C [ i - (27 + -26) ] [ j - (11 + -10) ] + C [ i - (11 + -10) ] [ j ] )\n            else:\n                C [ i ] [ j ] = (78 + -77)\n            idx_wa5d = idx_wa5d + (39 + -38)\n        idx_uql9 = idx_uql9 + (16 + -15)\n    maxvalue = (50 + -50)\n    idx_fko9 = (91 + -91)\n    list_fwim = range ( n + (75 + -74) )\n    while idx_fko9 < len(list_fwim):\n        i = list_fwim[idx_fko9]\n        maxvalue = max ( maxvalue , C [ n ] [ i ] )\n        idx_fko9 = idx_fko9 + (62 + -61)\n    return maxvalue", "id": "ConstantUnfoldding_sample_from_MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE_to_61", "old_id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE"}
{"code": "def maxRepeating ( str ) :\n    n = len ( str )\n    count = (29 + -29)\n    res = str [ (79 + -79) ]\n    cur_count = (46 + -45)\n    idx_34wa = (100 + -100)\n    list_xtui = range ( n )\n    while idx_34wa < len(list_xtui):\n        i = list_xtui[idx_34wa]\n        if not ( i < n - (31 + -30) and str [ i ] == str [ i + (83 + -82) ] ):\n            if cur_count > count :\n                count = cur_count\n                res = str [ i ]\n            cur_count = (78 + -77)\n        else:\n            cur_count += (70 + -69)\n        idx_34wa = idx_34wa + (31 + -30)\n    return res", "id": "ConstantUnfoldding_sample_from_MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1_to_62", "old_id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1"}
{"code": "def maxdiff ( arr , n ) :\n    freq = defaultdict ( lambda : (42 + -42) )\n    idx_tpcz = (73 + -73)\n    list_ptyd = range ( n )\n    while idx_tpcz < len(list_ptyd):\n        i = list_ptyd[idx_tpcz]\n        freq [ arr [ i ] ] += (63 + -62)\n        idx_tpcz = idx_tpcz + (55 + -54)\n    ans = (54 + -54)\n    idx_y5fe = (43 + -43)\n    list_d53w = range ( n )\n    while idx_y5fe < len(list_d53w):\n        i = list_d53w[idx_y5fe]\n        idx_mi0l = (98 + -98)\n        list_hd1m = range ( n )\n        while idx_mi0l < len(list_hd1m):\n            j = list_hd1m[idx_mi0l]\n            if not freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ]:\n                if freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :\n                    ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )\n            else:\n                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )\n            idx_mi0l = idx_mi0l + (34 + -33)\n        idx_y5fe = idx_y5fe + (77 + -76)\n    return ans", "id": "ConstantUnfoldding_sample_from_MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER_to_63", "old_id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER"}
{"code": "def maxDistance ( arr , n ) :\n    mp = { }\n    maxDict = (44 + -44)\n    idx_tde9 = (68 + -68)\n    list_dlt4 = range ( n )\n    while idx_tde9 < len(list_dlt4):\n        i = list_dlt4[idx_tde9]\n        if not arr [ i ] not in mp.keys ( ):\n            maxDict = max ( maxDict , i - mp [ arr [ i ] ] )\n        else:\n            mp [ arr [ i ] ] = i\n        idx_tde9 = idx_tde9 + (32 + -31)\n    return maxDict", "id": "ConstantUnfoldding_sample_from_MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY_to_64", "old_id": "MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY"}
{"code": "def maxNumOfChocolates ( arr , n , k ) :\n    um , curr_rem , maxSum = { } , (53 + -53) , (35 + -35)\n    sm = [ (68 + -68) ] * n\n    sm [ (88 + -88) ] = arr [ (60 + -60) ]\n    idx_9t1r = (25 + -25)\n    list_ykl1 = range ( (61 + -60) , n )\n    while idx_9t1r < len(list_ykl1):\n        i = list_ykl1[idx_9t1r]\n        sm [ i ] = sm [ i - (48 + -47) ] + arr [ i ]\n        idx_9t1r = idx_9t1r + (81 + -80)\n    idx_7ydj = (15 + -15)\n    list_cku6 = range ( n )\n    while idx_7ydj < len(list_cku6):\n        i = list_cku6[idx_7ydj]\n        curr_rem = sm [ i ] % k\n        if not ( not curr_rem and maxSum < sm [ i ] ):\n            if ( not curr_rem in um ) :\n                um [ curr_rem ] = i\n            elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :\n                maxSum = sm [ i ] - sm [ um [ curr_rem ] ]\n        else:\n            maxSum = sm [ i ]\n        idx_7ydj = idx_7ydj + (50 + -49)\n    return maxSum // k", "id": "ConstantUnfoldding_sample_from_MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS_to_65", "old_id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS"}
{"code": "def maxAlternateSum ( arr , n ) :\n    if ( n == (68 + -67) ) :\n        return arr [ (55 + -55) ]\n    dec = [ (13 + -13) for i in range ( n + (38 + -37) ) ]\n    inc = [ (20 + -20) for i in range ( n + (33 + -32) ) ]\n    dec [ (49 + -49) ] = inc [ (34 + -34) ] = arr [ (36 + -36) ]\n    flag = (75 + -75)\n    idx_2utw = (69 + -69)\n    list_umz1 = range ( (24 + -23) , n )\n    while idx_2utw < len(list_umz1):\n        i = list_umz1[idx_2utw]\n        idx_o4vi = (22 + -22)\n        list_e798 = range ( i )\n        while idx_o4vi < len(list_e798):\n            j = list_e798[idx_o4vi]\n            if not ( arr [ j ] > arr [ i ] ):\n                if ( arr [ j ] < arr [ i ] and flag == (30 + -29) ) :\n                    inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n            else:\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = (92 + -91)\n            idx_o4vi = idx_o4vi + (70 + -69)\n        idx_2utw = idx_2utw + (13 + -12)\n    result = - (45 + 2147483603)\n    idx_rtck = (29 + -29)\n    list_swpm = range ( n )\n    while idx_rtck < len(list_swpm):\n        i = list_swpm[idx_rtck]\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n        idx_rtck = idx_rtck + (76 + -75)\n    return result", "id": "ConstantUnfoldding_sample_from_MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM_to_66", "old_id": "MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM"}
{"code": "def maxSumBitonicSubArr ( arr , n ) :\n    msis = [ None ] * n\n    msds = [ None ] * n\n    max_sum = (49 + -49)\n    msis [ (52 + -52) ] = arr [ (79 + -79) ]\n    idx_s15b = (10 + -10)\n    list_g6oq = range ( (35 + -34) , n )\n    while idx_s15b < len(list_g6oq):\n        i = list_g6oq[idx_s15b]\n        if not ( arr [ i ] > arr [ i - (43 + -42) ] ):\n            msis [ i ] = arr [ i ]\n        else:\n            msis [ i ] = msis [ i - (34 + -33) ] + arr [ i ]\n        idx_s15b = idx_s15b + (89 + -88)\n    msds [ n - (78 + -77) ] = arr [ n - (97 + -96) ]\n    idx_fjw0 = (25 + -25)\n    list_j8i4 = range ( n - (84 + -82) , - (54 + -53) , - (73 + -72) )\n    while idx_fjw0 < len(list_j8i4):\n        i = list_j8i4[idx_fjw0]\n        if not ( arr [ i ] > arr [ i + (76 + -75) ] ):\n            msds [ i ] = arr [ i ]\n        else:\n            msds [ i ] = msds [ i + (83 + -82) ] + arr [ i ]\n        idx_fjw0 = idx_fjw0 + (65 + -64)\n    idx_v8md = (25 + -25)\n    list_0ag6 = range ( n )\n    while idx_v8md < len(list_0ag6):\n        i = list_0ag6[idx_v8md]\n        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :\n            max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] )\n        idx_v8md = idx_v8md + (96 + -95)\n    return max_sum", "id": "ConstantUnfoldding_sample_from_MAXIMUM_SUM_BITONIC_SUBARRAY_to_67", "old_id": "MAXIMUM_SUM_BITONIC_SUBARRAY"}
{"code": "def maxSum ( arr , N , k ) :\n    MS = [ (76 + -76) for i in range ( N ) ]\n    MS [ N - (73 + -72) ] = arr [ N - (49 + -48) ]\n    idx_gx9i = (7 + -7)\n    list_sutv = range ( N - (40 + -38) , - (45 + -44) , - (12 + -11) )\n    while idx_gx9i < len(list_sutv):\n        i = list_sutv[idx_gx9i]\n        if not ( i + k + (47 + -46) >= N ):\n            MS [ i ] = max ( arr [ i ] + MS [ i + k + (73 + -72) ] , MS [ i + (68 + -67) ] )\n        else:\n            MS [ i ] = max ( arr [ i ] , MS [ i + (42 + -41) ] )\n        idx_gx9i = idx_gx9i + (26 + -25)\n    return MS [ (19 + -19) ]", "id": "ConstantUnfoldding_sample_from_MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS_to_68", "old_id": "MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS"}
{"code": "def getMinDiff ( arr , n , k ) :\n    if ( n == (68 + -67) ) :\n        return (84 + -84)\n    arr.sort ( )\n    ans = arr [ n - (26 + -25) ] - arr [ (15 + -15) ]\n    small = arr [ (9 + -9) ] + k\n    big = arr [ n - (27 + -26) ] - k\n    if ( small > big ) :\n        small , big = big , small\n    idx_wl4j = (97 + -97)\n    list_uyvl = range ( (60 + -59) , n - (75 + -74) )\n    while idx_wl4j < len(list_uyvl):\n        i = list_uyvl[idx_wl4j]\n        subtract = arr [ i ] - k\n        add = arr [ i ] + k\n        if ( subtract >= small or add <= big ) :\n            continue\n        if not ( big - subtract <= add - small ):\n            big = add\n        else:\n            small = subtract\n        idx_wl4j = idx_wl4j + (63 + -62)\n    return min ( ans , big - small )", "id": "ConstantUnfoldding_sample_from_MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS_to_69", "old_id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS"}
{"code": "def MinimumCost ( cost , n , W ) :\n    val = list ( )\n    wt = list ( )\n    size = (40 + -40)\n    idx_tg5h = (12 + -12)\n    list_6o9k = range ( n )\n    while idx_tg5h < len(list_6o9k):\n        i = list_6o9k[idx_tg5h]\n        if ( cost [ i ] != - (84 + -83) ) :\n            val.append ( cost [ i ] )\n            wt.append ( i + (78 + -77) )\n            size += (78 + -77)\n        idx_tg5h = idx_tg5h + (84 + -83)\n    n = size\n    min_cost = [ [ (26 + -26) for i in range ( W + (15 + -14) ) ] for j in range ( n + (78 + -77) ) ]\n    idx_2qf9 = (25 + -25)\n    list_2xnv = range ( W + (68 + -67) )\n    while idx_2qf9 < len(list_2xnv):\n        i = list_2xnv[idx_2qf9]\n        min_cost [ (39 + -39) ] [ i ] = INF\n        idx_2qf9 = idx_2qf9 + (26 + -25)\n    idx_qukd = (98 + -98)\n    list_jnqk = range ( (92 + -91) , n + (59 + -58) )\n    while idx_qukd < len(list_jnqk):\n        i = list_jnqk[idx_qukd]\n        min_cost [ i ] [ (90 + -90) ] = (6 + -6)\n        idx_qukd = idx_qukd + (97 + -96)\n    idx_tfjl = (72 + -72)\n    list_80dy = range ( (90 + -89) , n + (49 + -48) )\n    while idx_tfjl < len(list_80dy):\n        i = list_80dy[idx_tfjl]\n        idx_7yqj = (4 + -4)\n        list_lqsj = range ( (75 + -74) , W + (11 + -10) )\n        while idx_7yqj < len(list_lqsj):\n            j = list_lqsj[idx_7yqj]\n            if not ( wt [ i - (31 + -30) ] > j ):\n                min_cost [ i ] [ j ] = min ( min_cost [ i - (27 + -26) ] [ j ] , min_cost [ i ] [ j - wt [ i - (58 + -57) ] ] + val [ i - (21 + -20) ] )\n            else:\n                min_cost [ i ] [ j ] = min_cost [ i - (53 + -52) ] [ j ]\n            idx_7yqj = idx_7yqj + (16 + -15)\n        idx_tfjl = idx_tfjl + (89 + -88)\n    if not ( min_cost [ n ] [ W ] == INF ):\n        return min_cost [ n ] [ W ]\n    else:\n        return - (13 + -12)", "id": "ConstantUnfoldding_sample_from_MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG_to_70", "old_id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG"}
{"code": "def minOps ( arr , n , k ) :\n    max1 = max ( arr )\n    res = (41 + -41)\n    idx_iwv9 = (42 + -42)\n    list_dhna = range ( (10 + -10) , n )\n    while idx_iwv9 < len(list_dhna):\n        i = list_dhna[idx_iwv9]\n        if not ( ( max1 - arr [ i ] ) % k != (45 + -45) ):\n            res += ( max1 - arr [ i ] ) / k\n        else:\n            return - (53 + -52)\n        idx_iwv9 = idx_iwv9 + (54 + -53)\n    return int ( res )", "id": "ConstantUnfoldding_sample_from_MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL_to_71", "old_id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ (9 + -9) for i in range ( n ) ]\n    idx_hpvz = (35 + -35)\n    list_eg0u = range ( n - (66 + -64) , - (36 + -35) , - (66 + -65) )\n    while idx_hpvz < len(list_eg0u):\n        i = list_eg0u[idx_hpvz]\n        if not ( arr [ i ] == (34 + -34) ):\n            if ( arr [ i ] >= n - i - (54 + -53) ) :\n                jumps [ i ] = (25 + -24)\n            else :\n                min = float ( 'inf' )\n                idx_b80k = (38 + -38)\n                list_28tf = range ( i + (55 + -54) , n )\n                while idx_b80k < len(list_28tf):\n                    j = list_28tf[idx_b80k]\n                    if ( j <= arr [ i ] + i ) :\n                        if ( min > jumps [ j ] ) :\n                            min = jumps [ j ]\n                    idx_b80k = idx_b80k + (16 + -15)\n                if ( min != float ( 'inf' ) ) :\n                    jumps [ i ] = min + (4 + -3)\n                else :\n                    jumps [ i ] = min\n        else:\n            jumps [ i ] = float ( 'inf' )\n        idx_hpvz = idx_hpvz + (15 + -14)\n    return jumps [ (81 + -81) ]", "id": "ConstantUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_72", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def getMinSquares ( n ) :\n    dp = [ (71 + -71) , (23 + -22) , (60 + -58) , (45 + -42) ]\n    idx_bo5m = (95 + -95)\n    list_alhb = range ( (20 + -16) , n + (2 + -1) )\n    while idx_bo5m < len(list_alhb):\n        i = list_alhb[idx_bo5m]\n        dp.append ( i )\n        idx_8rn2 = (68 + -68)\n        list_mae0 = range ( (6 + -5) , int ( ceil ( sqrt ( i ) ) ) + (54 + -53) )\n        while idx_8rn2 < len(list_mae0):\n            x = list_mae0[idx_8rn2]\n            temp = x * x ;\n            if not temp > i:\n                dp [ i ] = min ( dp [ i ] , (82 + -81) + dp [ i - temp ] )\n            else:\n                break\n            idx_8rn2 = idx_8rn2 + (27 + -26)\n        idx_bo5m = idx_bo5m + (80 + -79)\n    return dp [ n ]", "id": "ConstantUnfoldding_sample_from_MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1_to_73", "old_id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1"}
{"code": "def minproduct ( a , b , n , k ) :\n    diff = (49 + -49)\n    res = (91 + -91)\n    temp = (99 + -99)\n    idx_aih0 = (34 + -34)\n    list_1glx = range ( n )\n    while idx_aih0 < len(list_1glx):\n        i = list_1glx[idx_aih0]\n        pro = a [ i ] * b [ i ]\n        res = res + pro\n        if not ( pro < (84 + -84) and b [ i ] < (33 + -33) ):\n            if ( pro < (39 + -39) and a [ i ] < (22 + -22) ) :\n                temp = ( a [ i ] - (44 + -42) * k ) * b [ i ]\n            elif ( pro > (32 + -32) and a [ i ] < (28 + -28) ) :\n                temp = ( a [ i ] + (6 + -4) * k ) * b [ i ]\n            elif ( pro > (83 + -83) and a [ i ] > (5 + -5) ) :\n                temp = ( a [ i ] - (18 + -16) * k ) * b [ i ]\n        else:\n            temp = ( a [ i ] + (13 + -11) * k ) * b [ i ]\n        d = abs ( pro - temp )\n        if ( d > diff ) :\n            diff = d\n        idx_aih0 = idx_aih0 + (72 + -71)\n    return res - diff", "id": "ConstantUnfoldding_sample_from_MINIMUM_SUM_PRODUCT_TWO_ARRAYS_to_74", "old_id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS"}
{"code": "def solve ( arr , n ) :\n    arr.sort ( )\n    a = (38 + -38)\n    b = (62 + -62)\n    idx_g276 = (70 + -70)\n    list_in3o = range ( n )\n    while idx_g276 < len(list_in3o):\n        i = list_in3o[idx_g276]\n        if not ( i % (48 + -46) != (77 + -77) ):\n            b = b * (72 + -62) + arr [ i ]\n        else:\n            a = a * (18 + -8) + arr [ i ]\n        idx_g276 = idx_g276 + (28 + -27)\n    return a + b", "id": "ConstantUnfoldding_sample_from_MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_to_75", "old_id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY"}
{"code": "def minTimeForWritingChars ( N , insert , remove , copy ) :\n    if N == (4 + -4) :\n        return (66 + -66)\n    if N == (38 + -37) :\n        return insert\n    dp = [ (48 + -48) ] * ( N + (100 + -99) )\n    idx_fj5e = (80 + -80)\n    list_0krn = range ( (3 + -2) , N + (62 + -61) )\n    while idx_fj5e < len(list_0krn):\n        i = list_0krn[idx_fj5e]\n        if not i % (53 + -51) == (63 + -63):\n            dp [ i ] = min ( dp [ i - (37 + -36) ] + insert , dp [ ( i + (62 + -61) ) // (9 + -7) ] + copy + remove )\n        else:\n            dp [ i ] = min ( dp [ i - (9 + -8) ] + insert , dp [ i // (95 + -93) ] + copy )\n        idx_fj5e = idx_fj5e + (96 + -95)\n    return dp [ N ]", "id": "ConstantUnfoldding_sample_from_MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION_to_76", "old_id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION"}
{"code": "def answer ( n ) :\n    dp = [ [ (41 + -41) for x in range ( (50 + -40) ) ] for y in range ( n + (75 + -74) ) ]\n    if ( n == (74 + -73) ) :\n        return (20 + -10)\n    idx_9kan = (45 + -45)\n    list_7ou6 = range ( (90 + -80) )\n    while idx_9kan < len(list_7ou6):\n        j = list_7ou6[idx_9kan]\n        dp [ (84 + -83) ] [ j ] = (66 + -65)\n        idx_9kan = idx_9kan + (7 + -6)\n    idx_0y2z = (14 + -14)\n    list_2iu4 = range ( (67 + -65) , n + (40 + -39) )\n    while idx_0y2z < len(list_2iu4):\n        i = list_2iu4[idx_0y2z]\n        idx_43on = (17 + -17)\n        list_i1mg = range ( (99 + -89) )\n        while idx_43on < len(list_i1mg):\n            j = list_i1mg[idx_43on]\n            if not ( j == (56 + -56) ):\n                if ( j == (63 + -54) ) :\n                    dp [ i ] [ j ] = dp [ i - (31 + -30) ] [ j - (62 + -61) ]\n                else :\n                    dp [ i ] [ j ] = ( dp [ i - (82 + -81) ] [ j - (57 + -56) ] + dp [ i - (89 + -88) ] [ j + (30 + -29) ] )\n            else:\n                dp [ i ] [ j ] = dp [ i - (69 + -68) ] [ j + (21 + -20) ]\n            idx_43on = idx_43on + (49 + -48)\n        idx_0y2z = idx_0y2z + (43 + -42)\n    sum = (25 + -25)\n    idx_7in1 = (33 + -33)\n    list_34eo = range ( (41 + -40) , (60 + -50) )\n    while idx_7in1 < len(list_34eo):\n        j = list_34eo[idx_7in1]\n        sum = sum + dp [ n ] [ j ]\n        idx_7in1 = idx_7in1 + (83 + -82)\n    return sum", "id": "ConstantUnfoldding_sample_from_NUMBER_N_DIGIT_STEPPING_NUMBERS_to_77", "old_id": "NUMBER_N_DIGIT_STEPPING_NUMBERS"}
{"code": "def checkPangram ( s ) :\n    List = [ ]\n    idx_ar8b = (6 + -6)\n    list_efbd = range ( (55 + -29) )\n    while idx_ar8b < len(list_efbd):\n        i = list_efbd[idx_ar8b]\n        List.append ( False )\n        idx_ar8b = idx_ar8b + (54 + -53)\n    idx_wky0 = (89 + -89)\n    list_x7vq = s\n    while idx_wky0 < len(list_x7vq):\n        c = list_x7vq[idx_wky0]\n        if not 'A' <= c and c <= 'Z':\n            if 'a' <= c and c <= 'z':\n                List [ ord ( c ) - ord ( 'a' ) ] = True\n        else:\n            List [ ord ( c ) - ord ( 'A' ) ] = True\n        idx_wky0 = idx_wky0 + (16 + -15)\n    idx_5g2s = (76 + -76)\n    list_6abm = List\n    while idx_5g2s < len(list_6abm):\n        ch = list_6abm[idx_5g2s]\n        if ch == False :\n            return False\n        idx_5g2s = idx_5g2s + (25 + -24)\n    return True", "id": "ConstantUnfoldding_sample_from_PANGRAM_CHECKING_to_78", "old_id": "PANGRAM_CHECKING"}
{"code": "def isPrime ( p ) :\n    checkNumber = (90 + -88) ** p - (28 + -27)\n    nextval = (27 + -23) % checkNumber\n    idx_mc6x = (19 + -19)\n    list_5h6m = range ( (32 + -31) , p - (13 + -12) )\n    while idx_mc6x < len(list_5h6m):\n        i = list_5h6m[idx_mc6x]\n        nextval = ( nextval * nextval - (50 + -48) ) % checkNumber\n        idx_mc6x = idx_mc6x + (42 + -41)\n    if not ( nextval == (97 + -97) ): return False\n    else: return True", "id": "ConstantUnfoldding_sample_from_PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES_to_79", "old_id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES"}
{"code": "def find_maximum ( a , n , k ) :\n    b = dict ( )\n    idx_4q12 = (40 + -40)\n    list_ueg2 = range ( n )\n    while idx_4q12 < len(list_ueg2):\n        i = list_ueg2[idx_4q12]\n        x = a [ i ]\n        d = min ( (4 + -3) + i , n - i )\n        if not x not in b.keys ( ):\n            b [ x ] = min ( d , b [ x ] )\n        else:\n            b [ x ] = d\n        idx_4q12 = idx_4q12 + (20 + -19)\n    ans = sys.maxsize\n    idx_uzlp = (7 + -7)\n    list_4g3s = range ( n )\n    while idx_uzlp < len(list_4g3s):\n        i = list_4g3s[idx_uzlp]\n        x = a [ i ]\n        if ( x != ( k - x ) and ( k - x ) in b.keys ( ) ) :\n            ans = min ( max ( b [ x ] , b [ k - x ] ) , ans )\n        idx_uzlp = idx_uzlp + (42 + -41)\n    return ans", "id": "ConstantUnfoldding_sample_from_PRINT_MAXIMUM_SHORTEST_DISTANCE_to_80", "old_id": "PRINT_MAXIMUM_SHORTEST_DISTANCE"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - (10 + -9) ] * n\n    idx_0le4 = (16 + -16)\n    list_p3u2 = range ( n )\n    while idx_0le4 < len(list_p3u2):\n        i = list_p3u2[idx_0le4]\n        bestIdx = - (18 + -17)\n        idx_tud8 = (64 + -64)\n        list_m7fg = range ( m )\n        while idx_tud8 < len(list_m7fg):\n            j = list_m7fg[idx_tud8]\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - (96 + -95) :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n            idx_tud8 = idx_tud8 + (6 + -5)\n        if bestIdx != - (27 + -26) :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n        idx_0le4 = idx_0le4 + (34 + -33)\n    print ( \"Process No.Process Size     Block no.\" )\n    idx_kwru = (98 + -98)\n    list_0b8c = range ( n )\n    while idx_kwru < len(list_0b8c):\n        i = list_0b8c[idx_kwru]\n        print ( i + (1 + 0) , \"         \" , processSize [ i ] , end = \"         \" )\n        if not allocation [ i ] != - (27 + -26):\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + (57 + -56) )\n        idx_kwru = idx_kwru + (69 + -68)", "id": "ConstantUnfoldding_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_81", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != (77 + -67) :\n        return False\n    _sum = (93 + -93)\n    idx_0vcl = (41 + -41)\n    list_ohuq = range ( (2 + 7) )\n    while idx_0vcl < len(list_ohuq):\n        i = list_ohuq[idx_0vcl]\n        if not (49 + -49) <= int ( isbn [ i ] ) <= (3 + 6):\n            return False\n        else:\n            _sum += int ( isbn [ i ] ) * ( (66 + -56) - i )\n        idx_0vcl = idx_0vcl + (46 + -45)\n    if ( isbn [ (43 + -34) ] != 'X' and (24 + -24) <= int ( isbn [ (95 + -86) ] ) <= (38 + -29) ) :\n        return False\n    _sum += (62 + -52) if isbn [ (19 + -10) ] == 'X' else int ( isbn [ (21 + -12) ] )\n    return ( _sum % (58 + -47) == (86 + -86) )", "id": "ConstantUnfoldding_sample_from_PROGRAM_CHECK_ISBN_to_82", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def isIdentity ( mat , N ) :\n    idx_7wid = (62 + -62)\n    list_w5az = range ( N )\n    while idx_7wid < len(list_w5az):\n        row = list_w5az[idx_7wid]\n        idx_so78 = (52 + -52)\n        list_hz35 = range ( N )\n        while idx_so78 < len(list_hz35):\n            col = list_hz35[idx_so78]\n            if not ( row == col and mat [ row ] [ col ] != (88 + -87) ):\n                if ( row != col and mat [ row ] [ col ] != (9 + -9) ) :\n                    return False\n            else:\n                return False\n            idx_so78 = idx_so78 + (42 + -41)\n        idx_7wid = idx_7wid + (57 + -56)\n    return True", "id": "ConstantUnfoldding_sample_from_PROGRAM_PRINT_IDENTITY_MATRIX_1_to_83", "old_id": "PROGRAM_PRINT_IDENTITY_MATRIX_1"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - (24 + -23) ] * n\n    idx_dmbj = (92 + -92)\n    list_uzkg = range ( n )\n    while idx_dmbj < len(list_uzkg):\n        i = list_uzkg[idx_dmbj]\n        wstIdx = - (25 + -24)\n        idx_y7h2 = (4 + -4)\n        list_dxgh = range ( m )\n        while idx_y7h2 < len(list_dxgh):\n            j = list_dxgh[idx_y7h2]\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - (32 + -31) :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n            idx_y7h2 = idx_y7h2 + (15 + -14)\n        if wstIdx != - (67 + -66) :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n        idx_dmbj = idx_dmbj + (74 + -73)\n    print ( \"Process No.Process Size Block no.\" )\n    idx_b9th = (34 + -34)\n    list_ftdl = range ( n )\n    while idx_b9th < len(list_ftdl):\n        i = list_ftdl[idx_b9th]\n        print ( i + (90 + -89) , \"         \" , processSize [ i ] , end = \"     \" )\n        if not allocation [ i ] != - (71 + -70):\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + (90 + -89) )\n        idx_b9th = idx_b9th + (89 + -88)", "id": "ConstantUnfoldding_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_84", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def rearrange ( arr , n ) :\n    temp = n * [ None ]\n    small , large = (88 + -88) , n - (51 + -50)\n    flag = True\n    idx_r6i7 = (63 + -63)\n    list_o5pb = range ( n )\n    while idx_r6i7 < len(list_o5pb):\n        i = list_o5pb[idx_r6i7]\n        if not flag is True:\n            temp [ i ] = arr [ small ]\n            small += (91 + -90)\n        else:\n            temp [ i ] = arr [ large ]\n            large -= (77 + -76)\n        flag = bool ( (100 + -99) - flag )\n        idx_r6i7 = idx_r6i7 + (10 + -9)\n    idx_znhu = (6 + -6)\n    list_97g8 = range ( n )\n    while idx_znhu < len(list_97g8):\n        i = list_97g8[idx_znhu]\n        arr [ i ] = temp [ i ]\n        idx_znhu = idx_znhu + (82 + -81)\n    return arr", "id": "ConstantUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_85", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n - (68 + -67)\n    min_idx = (22 + -22)\n    max_elem = arr [ n - (60 + -59) ] + (21 + -20)\n    idx_hne4 = (98 + -98)\n    list_hlri = range ( (45 + -45) , n )\n    while idx_hne4 < len(list_hlri):\n        i = list_hlri[idx_hne4]\n        if not i % (57 + -55) == (14 + -14):\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += (33 + -32)\n        else:\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= (42 + -41)\n        idx_hne4 = idx_hne4 + (5 + -4)\n    idx_xml5 = (91 + -91)\n    list_b103 = range ( (29 + -29) , n )\n    while idx_xml5 < len(list_b103):\n        i = list_b103[idx_xml5]\n        arr [ i ] = int ( arr [ i ] / max_elem )\n        idx_xml5 = idx_xml5 + (16 + -15)", "id": "ConstantUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_86", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def replace ( s , c1 , c2 ) :\n    l = len ( s )\n    idx_ql8t = (33 + -33)\n    list_104r = range ( l )\n    while idx_ql8t < len(list_104r):\n        i = list_104r[idx_ql8t]\n        if not ( s [ i ] == c1 ):\n            if ( s [ i ] == c2 ) :\n                s = s [ (87 + -87) : i ] + c1 + s [ i + (73 + -72) : ]\n        else:\n            s = s [ (99 + -99) : i ] + c2 + s [ i + (43 + -42) : ]\n        idx_ql8t = idx_ql8t + (24 + -23)\n    return s", "id": "ConstantUnfoldding_sample_from_REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S_to_87", "old_id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S"}
{"code": "def getTotalNumberOfSequences ( m , n ) :\n    T = [ [ (41 + -41) for i in range ( n + (95 + -94) ) ] for i in range ( m + (29 + -28) ) ]\n    idx_1623 = (81 + -81)\n    list_yqo9 = range ( m + (28 + -27) )\n    while idx_1623 < len(list_yqo9):\n        i = list_yqo9[idx_1623]\n        idx_nv1z = (53 + -53)\n        list_3duc = range ( n + (3 + -2) )\n        while idx_nv1z < len(list_3duc):\n            j = list_3duc[idx_nv1z]\n            if not i == (1 + -1) or j == (54 + -54):\n                if i < j :\n                    T [ i ] [ j ] = (91 + -91)\n                elif j == (31 + -30) :\n                    T [ i ] [ j ] = i\n                else :\n                    T [ i ] [ j ] = T [ i - (30 + -29) ] [ j ] + T [ i // (62 + -60) ] [ j - (33 + -32) ]\n            else:\n                T [ i ] [ j ] = (76 + -76)\n            idx_nv1z = idx_nv1z + (88 + -87)\n        idx_1623 = idx_1623 + (12 + -11)\n    return T [ m ] [ n ]", "id": "ConstantUnfoldding_sample_from_SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1_to_88", "old_id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    idx_yurz = (40 + -40)\n    list_839d = range ( n )\n    while idx_yurz < len(list_839d):\n        i = list_839d[idx_yurz]\n        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )\n        idx_yurz = idx_yurz + (47 + -46)\n    index = - ( sys.maxsize - (13 + -12) )\n    maximum = - ( sys.maxsize - (18 + -17) )\n    idx_j318 = (20 + -20)\n    list_cumn = range ( n )\n    while idx_j318 < len(list_cumn):\n        i = list_cumn[idx_j318]\n        if maximum < arr [ i ] :\n            index = i\n            maximum = arr [ i ]\n        idx_j318 = idx_j318 + (71 + -70)\n    i = (70 + -70)\n    j = n - (81 + -80)\n    new_arr = [ (62 + -62) ] * n\n    k = (59 + -59)\n    while i < index and j > index :\n        if not arr [ i ] < arr [ j ]:\n            new_arr [ k ] = arr [ j ]\n            k += (94 + -93)\n            j -= (69 + -68)\n        else:\n            new_arr [ k ] = arr [ i ]\n            k += (43 + -42)\n            i += (18 + -17)\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k += (2 + -1)\n        i += (99 + -98)\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k += (50 + -49)\n        j -= (25 + -24)\n        new_arr [ n - (25 + -24) ] = maximum\n    idx_y3jo = (81 + -81)\n    list_7b1v = range ( n )\n    while idx_y3jo < len(list_7b1v):\n        i = list_7b1v[idx_y3jo]\n        arr [ i ] = new_arr [ i ]\n        idx_y3jo = idx_y3jo + (34 + -33)", "id": "ConstantUnfoldding_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_89", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def bitonicGenerator ( arr , n ) :\n    evenArr = [ ]\n    oddArr = [ ]\n    idx_a0l5 = (11 + -11)\n    list_o8sv = range ( n )\n    while idx_a0l5 < len(list_o8sv):\n        i = list_o8sv[idx_a0l5]\n        if not ( ( i % (45 + -43) ) == (76 + -76) ):\n            oddArr.append ( arr [ i ] )\n        else:\n            evenArr.append ( arr [ i ] )\n        idx_a0l5 = idx_a0l5 + (62 + -61)\n    evenArr = sorted ( evenArr )\n    oddArr = sorted ( oddArr )\n    oddArr = oddArr [ : : - (6 + -5) ]\n    i = (29 + -29)\n    idx_l6v9 = (91 + -91)\n    list_6lw3 = range ( len ( evenArr ) )\n    while idx_l6v9 < len(list_6lw3):\n        j = list_6lw3[idx_l6v9]\n        arr [ i ] = evenArr [ j ]\n        i += (74 + -73)\n        idx_l6v9 = idx_l6v9 + (80 + -79)\n    idx_d67u = (29 + -29)\n    list_i4d1 = range ( len ( oddArr ) )\n    while idx_d67u < len(list_i4d1):\n        j = list_i4d1[idx_d67u]\n        arr [ i ] = oddArr [ j ]\n        i += (86 + -85)\n        idx_d67u = idx_d67u + (63 + -62)", "id": "ConstantUnfoldding_sample_from_SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_to_90", "old_id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER"}
{"code": "def firstLetterWord ( str ) :\n    result = \"\"\n    v = True\n    idx_b2pa = (38 + -38)\n    list_lao1 = range ( len ( str ) )\n    while idx_b2pa < len(list_lao1):\n        i = list_lao1[idx_b2pa]\n        if not ( str [ i ] == ' ' ):\n            if ( str [ i ] != ' ' and v == True ) :\n                result += ( str [ i ] )\n                v = False\n        else:\n            v = True\n        idx_b2pa = idx_b2pa + (34 + -33)\n    return result", "id": "ConstantUnfoldding_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_91", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def isSubsetSum ( arr , n , sum ) :\n    subset = [ [ False for j in range ( sum + (20 + -19) ) ] for i in range ( (69 + -66) ) ]\n    idx_oghx = (71 + -71)\n    list_l2p3 = range ( n + (81 + -80) )\n    while idx_oghx < len(list_l2p3):\n        i = list_l2p3[idx_oghx]\n        idx_7d5j = (49 + -49)\n        list_xuwb = range ( sum + (13 + -12) )\n        while idx_7d5j < len(list_xuwb):\n            j = list_xuwb[idx_7d5j]\n            if not ( j == (37 + -37) ):\n                if ( i == (4 + -4) ) :\n                    subset [ i % (40 + -38) ] [ j ] = False\n                elif ( arr [ i - (46 + -45) ] <= j ) :\n                    subset [ i % (66 + -64) ] [ j ] = subset [ ( i + (39 + -38) ) % (70 + -68) ] [ j - arr [ i - (55 + -54) ] ] or subset [ ( i + (8 + -7) ) % (34 + -32) ] [ j ]\n                else :\n                    subset [ i % (16 + -14) ] [ j ] = subset [ ( i + (23 + -22) ) % (8 + -6) ] [ j ]\n            else:\n                subset [ i % (53 + -51) ] [ j ] = True\n            idx_7d5j = idx_7d5j + (74 + -73)\n        idx_oghx = idx_oghx + (33 + -32)\n    return subset [ n % (2 + 0) ] [ sum ]", "id": "ConstantUnfoldding_sample_from_SUBSET_SUM_PROBLEM_OSUM_SPACE_to_92", "old_id": "SUBSET_SUM_PROBLEM_OSUM_SPACE"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ (17 + -17) ] * ( n + (84 + -82) ) for i in range ( (90 + -90) , n + (22 + -20) ) ]\n    idx_hps1 = (73 + -73)\n    list_ahe3 = range ( (22 + -22) , n + (15 + -14) )\n    while idx_hps1 < len(list_ahe3):\n        i = list_ahe3[idx_hps1]\n        idx_8v3s = (61 + -61)\n        list_xmpy = range ( (42 + -42) , min ( i , n ) + (19 + -18) )\n        while idx_8v3s < len(list_xmpy):\n            j = list_xmpy[idx_8v3s]\n            if not ( j == (25 + -25) or j == i ):\n                C [ i ] [ j ] = C [ i - (64 + -63) ] [ j - (97 + -96) ] + C [ i - (31 + -30) ] [ j ]\n            else:\n                C [ i ] [ j ] = (11 + -10)\n            idx_8v3s = idx_8v3s + (46 + -45)\n        idx_hps1 = idx_hps1 + (77 + -76)\n    sum = (99 + -99)\n    idx_lb3g = (26 + -26)\n    list_v36w = range ( (47 + -47) , n + (13 + -12) )\n    while idx_lb3g < len(list_v36w):\n        i = list_v36w[idx_lb3g]\n        sum += C [ n ] [ i ]\n        idx_lb3g = idx_lb3g + (82 + -81)\n    return sum", "id": "ConstantUnfoldding_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_93", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - (21 + -20)\n    sum = (81 + -81)\n    n = len ( tree )\n    idx_rysd = (68 + -68)\n    list_d580 = range ( n )\n    while idx_rysd < len(list_d580):\n        i = list_d580[idx_rysd]\n        if not ( tree [ i ] == '(' ):\n            if ( tree [ i ] == ')' ) :\n                level -= (63 + -62)\n            else :\n                if ( level == k ) :\n                    sum += ( ord ( tree [ i ] ) - ord ( '0' ) )\n        else:\n            level += (31 + -30)\n        idx_rysd = idx_rysd + (21 + -20)\n    return sum", "id": "ConstantUnfoldding_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_94", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def sumofsquare ( n ) :\n    C = [ [ (81 + -81) for i in range ( n + (33 + -32) ) ] for j in range ( n + (83 + -82) ) ]\n    idx_3rw7 = (7 + -7)\n    list_87w5 = range ( (92 + -92) , n + (58 + -57) )\n    while idx_3rw7 < len(list_87w5):\n        i = list_87w5[idx_3rw7]\n        idx_b4ao = (86 + -86)\n        list_o7z9 = range ( (64 + -64) , min ( i , n ) + (73 + -72) )\n        while idx_b4ao < len(list_o7z9):\n            j = list_o7z9[idx_b4ao]\n            if not ( j == (24 + -24) or j == i ):\n                C [ i ] [ j ] = ( C [ i - (16 + -15) ] [ j - (69 + -68) ] + C [ i - (15 + -14) ] [ j ] )\n            else:\n                C [ i ] [ j ] = (73 + -72)\n            idx_b4ao = idx_b4ao + (50 + -49)\n        idx_3rw7 = idx_3rw7 + (71 + -70)\n    sum = (10 + -10)\n    idx_nuht = (71 + -71)\n    list_t2rg = range ( (12 + -12) , n + (67 + -66) )\n    while idx_nuht < len(list_t2rg):\n        i = list_t2rg[idx_nuht]\n        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )\n        idx_nuht = idx_nuht + (85 + -84)\n    return sum", "id": "ConstantUnfoldding_sample_from_SUM_SQUARES_BINOMIAL_COEFFICIENTS_to_95", "old_id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - (4 + -3)]\n    str2 = str2[:: - (79 + -78)]\n    carry = (37 + -37)\n    idx_tqcr = (15 + -15)\n    list_s9r5 = range(n1)\n    while idx_tqcr < len(list_s9r5):\n        i = list_s9r5[idx_tqcr]\n        sum = ((ord(str1[i]) - (100 + -52)) + ((ord(str2[i]) - (28 + 20)) + carry))\n        if not sum < (19 + -19):\n            str += chr(sum % (66 + -56) + (83 + -35))\n        else:\n            str += chr(sum % -(88 + -78) + (82 + -34))\n        carry = int(sum / (98 + -88))\n        idx_tqcr = idx_tqcr + (69 + -68)\n    idx_uxq8 = (99 + -99)\n    list_mh8v = range(n1, n2)\n    while idx_uxq8 < len(list_mh8v):\n        i = list_mh8v[idx_uxq8]\n        sum = ((ord(str2[i]) - (68 + -20)) + carry)\n        if not sum < (91 + -91):\n            str += chr(sum % (67 + -57) + (82 + -34))\n        else:\n            str += chr(sum % -(67 + -57) + (85 + -37))\n        carry = (int)(sum / (17 + -7))\n        idx_uxq8 = idx_uxq8 + (77 + -76)\n    if (carry):\n        str += chr(carry + (32 + 16))\n    str = str[:: - (53 + -52)]\n    return str", "id": "ConstantUnfoldding_sample_from_SUM_TWO_LARGE_NUMBERS_to_96", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def offeringNumber ( n , templeHeight ) :\n    sum = (21 + -21)\n    idx_0cyp = (98 + -98)\n    list_mlbi = range ( n )\n    while idx_0cyp < len(list_mlbi):\n        i = list_mlbi[idx_0cyp]\n        left = (67 + -67)\n        right = (64 + -64)\n        idx_ezsm = (92 + -92)\n        list_ge0a = range ( i - (82 + -81) , - (93 + -92) , - (60 + -59) )\n        while idx_ezsm < len(list_ge0a):\n            j = list_ge0a[idx_ezsm]\n            if not ( templeHeight [ j ] < templeHeight [ j + (85 + -84) ] ):\n                break\n            else:\n                left += (94 + -93)\n            idx_ezsm = idx_ezsm + (27 + -26)\n        idx_3grk = (94 + -94)\n        list_5juy = range ( i + (94 + -93) , n )\n        while idx_3grk < len(list_5juy):\n            j = list_5juy[idx_3grk]\n            if not ( templeHeight [ j ] < templeHeight [ j - (30 + -29) ] ):\n                break\n            else:\n                right += (100 + -99)\n            idx_3grk = idx_3grk + (73 + -72)\n        sum += max ( right , left ) + (26 + -25)\n        idx_0cyp = idx_0cyp + (32 + -31)\n    return sum", "id": "ConstantUnfoldding_sample_from_TEMPLE_OFFERINGS_to_97", "old_id": "TEMPLE_OFFERINGS"}
{"code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < (74 + -71) ) :\n        print ( \" Invalid Input \" )\n        return\n    first = arr [ (20 + -20) ]\n    second = - sys.maxsize\n    third = - sys.maxsize\n    idx_iju4 = (27 + -27)\n    list_duf0 = range ( (15 + -14) , arr_size )\n    while idx_iju4 < len(list_duf0):\n        i = list_duf0[idx_iju4]\n        if not ( arr [ i ] > first ):\n            if ( arr [ i ] > second ) :\n                third = second\n                second = arr [ i ]\n            elif ( arr [ i ] > third ) :\n                third = arr [ i ]\n        else:\n            third = second\n            second = first\n            first = arr [ i ]\n        idx_iju4 = idx_iju4 + (73 + -72)\n    print ( \"The third Largest\" , \"element is\" , third )", "id": "ConstantUnfoldding_sample_from_THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1_to_98", "old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1"}
{"code": "def xorZero ( str ) :\n    one_count = (11 + -11)\n    zero_count = (44 + -44)\n    n = len ( str )\n    idx_mjfy = (99 + -99)\n    list_efmu = range ( (29 + -29) , n , (75 + -74) )\n    while idx_mjfy < len(list_efmu):\n        i = list_efmu[idx_mjfy]\n        if not ( str [ i ] == '1' ):\n            zero_count += (46 + -45)\n        else:\n            one_count += (59 + -58)\n        idx_mjfy = idx_mjfy + (42 + -41)\n    if ( one_count % (35 + -33) == (47 + -47) ) :\n        return zero_count\n    return one_count", "id": "ConstantUnfoldding_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_99", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
{"code": "def countTransformation ( a , b ) :\n    n = len ( a )\n    m = len ( b )\n    if m == (11 + -11) :\n        return (52 + -51)\n    dp = [ [ (14 + -14) ] * ( n + (47 + -46) ) for _ in range ( m + (2 + -1) ) ]\n    idx_w046 = (19 + -19)\n    list_3elg = range ( m )\n    while idx_w046 < len(list_3elg):\n        i = list_3elg[idx_w046]\n        idx_tgde = (59 + -59)\n        list_q4di = range ( i , n )\n        while idx_tgde < len(list_q4di):\n            j = list_q4di[idx_tgde]\n            if not i == (83 + -83):\n                if a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = ( dp [ i ] [ j - (14 + -13) ] + dp [ i - (97 + -96) ] [ j - (60 + -59) ] )\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - (55 + -54) ]\n            else:\n                if j == (68 + -68) :\n                    if a [ j ] == b [ i ] :\n                        dp [ i ] [ j ] = (47 + -46)\n                    else :\n                        dp [ i ] [ j ] = (80 + -80)\n                elif a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - (57 + -56) ] + (38 + -37)\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - (67 + -66) ]\n            idx_tgde = idx_tgde + (93 + -92)\n        idx_w046 = idx_w046 + (28 + -27)\n    return dp [ m - (71 + -70) ] [ n - (11 + -10) ]", "id": "ConstantUnfoldding_sample_from_WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS_to_100", "old_id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS"}
