{"old_id": "ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS", "code": "def LFj ( rre , MGq , WRI ) :\n    WOI = (7 + -7)\n    WCm = (61 + -61)\n    SmO = range ( WOI , MGq )\n    while WCm < len(SmO):\n        WOI = SmO[WCm]\n        if ( rre [ WOI ] == WRI ) :\n            return WOI\n        WCm = WCm + (49 + -48)\n    return - (50 + -49)"}
{"old_id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES", "code": "def WHA ( Rye , ozx , pDK ) :\n    if pDK >= ozx - (82 + -81) :\n        return ozx\n    OBL = (49 + -49)\n    HzE = (65 + -65)\n    Nge = (83 + -83)\n    NiB = range ( ozx )\n    while Nge < len(NiB):\n        eFs = NiB[Nge]\n        if Rye [ eFs ] > OBL :\n            OBL = Rye [ eFs ]\n            if eFs == True :\n                HzE = (14 + -13)\n        else :\n            HzE += (81 + -80)\n        if HzE >= pDK :\n            return OBL\n        Nge = Nge + (10 + -9)\n    return OBL"}
{"old_id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE", "code": "def bGR ( Hkj , RId , bqx ) :\n    Zcy = dict ( )\n    ypS = (62 + -62)\n    Buc = range ( Hkj , RId + (91 + -90) )\n    while ypS < len(Buc):\n        aso = Buc[ypS]\n        if bqx [ aso ] in Zcy.keys ( ) :\n            Zcy [ bqx [ aso ] ] += (38 + -37)\n        else :\n            Zcy [ bqx [ aso ] ] = (6 + -5)\n        ypS = ypS + (78 + -77)\n    count = (91 + -91)\n    xpD = (58 + -58)\n    ovv = Zcy\n    while xpD < len(ovv):\n        zlI = ovv[xpD]\n        if zlI == Zcy [ zlI ] :\n            count += (14 + -13)\n        xpD = xpD + (93 + -92)\n    return count"}
{"old_id": "BREAK_NUMBER_THREE_PARTS", "code": "def Udy ( DjC ) :\n    count = (36 + -36)\n    jTX = (75 + -75)\n    mQF = range ( (91 + -91) , DjC + (23 + -22) )\n    while jTX < len(mQF):\n        BCk = mQF[jTX]\n        eGQ = (4 + -4)\n        xJT = range ( (62 + -62) , DjC + (5 + -4) )\n        while eGQ < len(xJT):\n            CxP = xJT[eGQ]\n            MLK = (82 + -82)\n            SKm = range ( (97 + -97) , DjC + (27 + -26) )\n            while MLK < len(SKm):\n                sRI = SKm[MLK]\n                if ( BCk + CxP + sRI == DjC ) :\n                    count = count + (91 + -90)\n                MLK = MLK + (63 + -62)\n            eGQ = eGQ + (4 + -3)\n        jTX = jTX + (69 + -68)\n    return count"}
{"old_id": "CAESAR_CIPHER", "code": "def RIB ( wPa , mox ) :\n    CJt = \"\"\n    Luc = (64 + -64)\n    QQR = range ( len ( wPa ) )\n    while Luc < len(QQR):\n        rQC = QQR[Luc]\n        ZPN = wPa [ rQC ]\n        if ( ZPN.isupper ( ) ) :\n            CJt += chr ( ( ord ( ZPN ) + mox - (44 + 21) ) % (63 + -37) + (38 + 27) )\n        else :\n            CJt += chr ( ( ord ( ZPN ) + mox - (60 + 37) ) % (65 + -39) + (47 + 50) )\n        Luc = Luc + (22 + -21)\n    return CJt"}
{"old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING", "code": "def sUQ ( str ) :\n    xoe = ord ( str [ (41 + -41) ] ) - (43 + 5)\n    RZL = (52 + -52)\n    fbb = range ( (39 + -38) , len ( str ) )\n    while RZL < len(fbb):\n        jyi = fbb[RZL]\n        if ( str [ jyi ] == '0' or str [ jyi ] == '1' or xoe < (6 + -4) ) :\n            xoe += ord ( str [ jyi ] ) - (71 + -23)\n        else :\n            xoe += ord ( str [ jyi ] ) - (2 + 46)\n        RZL = RZL + (37 + -36)\n    return xoe"}
{"old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING", "code": "def PtU ( str ) :\n    fZG = \"0\"\n    CXq = (90 + -90)\n    CPW = (63 + -63)\n    owT = str\n    while CPW < len(owT):\n        RbB = owT[CPW]\n        if ( RbB.isdigit ( ) ) :\n            fZG += RbB\n        else :\n            CXq += int ( fZG )\n            fZG = \"0\"\n        CPW = CPW + (66 + -65)\n    return CXq + int ( fZG )"}
{"old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP", "code": "def vJO ( str ) :\n    eNN = (38 + -38)\n    EqU = (28 + -28)\n    tap = (51 + -51)\n    mnG = range ( (7 + -7) , len ( str ) )\n    while tap < len(mnG):\n        wjl = mnG[tap]\n        kYf = str [ wjl ]\n        if ( kYf == '0' ) :\n            eNN = eNN + (44 + -43)\n        else :\n            EqU = EqU + (53 + -52)\n        tap = tap + (75 + -74)\n    return ( eNN == (91 + -90) or EqU == (71 + -70) )"}
{"old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP_1", "code": "def qKW ( str ) :\n    sum = (99 + -99)\n    KAd = len ( str )\n    xYy = (18 + -18)\n    fVS = range ( (88 + -88) , KAd )\n    while xYy < len(fVS):\n        iNp = fVS[xYy]\n        sum += ord ( str [ iNp ] ) - ord ( '0' )\n        xYy = xYy + (69 + -68)\n    return ( sum == KAd - (67 + -66) or sum == (19 + -18) )"}
{"old_id": "CHECK_ARRAY_MAJORITY_ELEMENT", "code": "def KPF ( wFC, acJ ) :\n    PLF = { }\n    igj = (18 + -18)\n    wQX = range(acJ)\n    while igj < len(wQX):\n        aDS = wQX[igj]\n        if wFC[aDS] in PLF : PLF [ wFC[aDS] ] += (47 + -46)\n        else : PLF [ wFC[aDS] ] = (11 + -10)\n        igj = igj + (83 + -82)\n    Zjm = (76 + -76)\n    YoO = PLF\n    while Zjm < len(YoO):\n        WMn = YoO[Zjm]\n        if PLF [ WMn ] >= len ( wFC ) // (72 + -70) :\n            return True\n        Zjm = Zjm + (7 + -6)\n    return False"}
{"old_id": "CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT", "code": "def wtM ( NWB , Mrf ) :\n    if ( Mrf == (55 + -55) or Mrf == (59 + -58) ) :\n        return True\n    nQP = (58 + -58)\n    FXS = range ( (71 + -70) , Mrf , (71 + -70) )\n    while nQP < len(FXS):\n        ShI = FXS[nQP]\n        if ( NWB [ ShI - (56 + -55) ] > NWB [ ShI ] ) :\n            return False\n        nQP = nQP + (69 + -68)\n    return True"}
{"old_id": "CHECK_DIVISIBILITY_BINARY_STRING_2K", "code": "def VOq ( str , ihT ) :\n    ixz = len ( str )\n    RNW = (82 + -82)\n    iRK = (11 + -11)\n    xrB = range ( (70 + -70) , ihT )\n    while iRK < len(xrB):\n        TSz = xrB[iRK]\n        if ( str [ ixz - TSz - (73 + -72) ] == '0' ) :\n            RNW += (2 + -1)\n        iRK = iRK + (1 + 0)\n    return ( RNW == ihT )"}
{"old_id": "CHECK_DIVISIBILITY_LARGE_NUMBER_999", "code": "def oeJ ( DnB ) :\n    AHM = len ( DnB )\n    if ( AHM == (29 + -29) and DnB [ (27 + -27) ] == '0' ) :\n        return True\n    if ( ( AHM % (15 + -12) ) == (42 + -41) ) :\n        DnB = \"00\" + DnB\n    if ( ( AHM % (48 + -45) ) == (72 + -70) ) :\n        DnB = \"0\" + DnB\n    Kjf = (84 + -84)\n    MnL = (77 + -77)\n    anU = range ( (66 + -66) , AHM , (46 + -43) )\n    while MnL < len(anU):\n        Tfw = anU[MnL]\n        gky = (38 + -38)\n        gky += ( ord ( DnB [ Tfw ] ) - (96 + -48) ) * (10 + 90)\n        gky += ( ord ( DnB [ Tfw + (95 + -94) ] ) - (48 + 0) ) * (20 + -10)\n        gky += ( ord ( DnB [ Tfw + (85 + -83) ] ) - (68 + -20) )\n        Kjf += gky\n        MnL = MnL + (7 + -6)\n    if ( Kjf > (9 + 991) ) :\n        DnB = str ( Kjf )\n        AHM = len ( DnB )\n        Kjf = oeJ ( DnB )\n    return ( Kjf == (60 + 939) )"}
{"old_id": "CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS", "code": "def Wdo ( xwG ) :\n    if ( len ( xwG ) >= (69 + -59) ) :\n        return True\n    Orn = (66 + -66)\n    GQF = range ( (34 + -33) , len ( xwG ) )\n    while Orn < len(GQF):\n        nKG = GQF[Orn]\n        tLX = (45 + -45)\n        iCg = range ( nKG + (77 + -76) , len ( xwG ) )\n        while tLX < len(iCg):\n            gtX = iCg[tLX]\n            Loc = (27 + -27)\n            Tqr = range ( gtX + (23 + -22) , len ( xwG ) )\n            while Loc < len(Tqr):\n                anN = Tqr[Loc]\n                aQf = xwG [ (32 + -32) : nKG ]\n                PTH = xwG [ nKG : gtX ]\n                PSe = xwG [ gtX : anN ]\n                bPg = xwG [ anN : len ( xwG ) ]\n                if ( aQf != PTH and aQf != PSe and aQf != bPg and PTH != PSe and PTH != bPg and PSe != bPg ) :\n                    return True\n                Loc = Loc + (20 + -19)\n            tLX = tLX + (60 + -59)\n        Orn = Orn + (57 + -56)\n    return False"}
{"old_id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS", "code": "def mNG ( KFY , rAR ) :\n    DKD = (1 + -1)\n    qUW = (41 + -41)\n    vuM = (94 + -94)\n    mxy = range ( rAR )\n    while vuM < len(mxy):\n        yTY = mxy[vuM]\n        if ( KFY [ yTY ] & (85 + -84) ) :\n            DKD += (49 + -48)\n        else :\n            qUW += (54 + -53)\n        vuM = vuM + (92 + -91)\n    if ( DKD % (92 + -90) and qUW % (12 + -10) ) :\n        return False\n    else :\n        return True"}
{"old_id": "CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE", "code": "def lnN ( XYp , zSJ ) :\n    if ( zSJ < (57 + -56) ) :\n        return False\n    Gxf = min ( XYp )\n    ogK = max ( XYp )\n    if ( ogK - Gxf + (53 + -52) == zSJ ) :\n        MIz = [ False for llj in range ( zSJ ) ]\n        BoM = (54 + -54)\n        feu = range ( zSJ )\n        while BoM < len(feu):\n            llj = feu[BoM]\n            if ( MIz [ XYp [ llj ] - Gxf ] != False ) :\n                return False\n            MIz [ XYp [ llj ] - Gxf ] = True\n            BoM = BoM + (68 + -67)\n        return True\n    return False"}
{"old_id": "CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE", "code": "def saC ( IfW, SXo ) :\n    LoJ = [ ]\n    WZs = -(7 + 2147483641)\n    gYn = (97 + -97)\n    pvN = range(SXo)\n    while gYn < len(pvN):\n        Hmx = pvN[gYn]\n        if IfW[Hmx] < WZs :\n            return False\n        while ( len ( LoJ ) > (78 + -78) and LoJ [ - (25 + -24) ] < IfW[Hmx] ) :\n            WZs = LoJ.pop ( )\n        LoJ.append ( IfW[Hmx] )\n        gYn = gYn + (90 + -89)\n    return True"}
{"old_id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE", "code": "def LHp ( apX , Syy ) :\n    lpm = (73 + -73)\n    GlT = (80 + -80)\n    Coq = (20 + -20)\n    HST = range ( Syy )\n    while Coq < len(HST):\n        QFX = HST[Coq]\n        if ( apX [ QFX ] == (51 + -46) ) :\n            lpm += (5 + -4)\n        elif ( apX [ QFX ] == (53 + -43) ) :\n            if ( lpm > (8 + -8) ) :\n                lpm -= (17 + -16)\n                GlT += (92 + -91)\n            else :\n                return (76 + -76)\n        else :\n            if ( lpm > (53 + -53) and GlT > (62 + -62) ) :\n                lpm -= (36 + -35)\n                GlT -= (55 + -54)\n            elif ( lpm >= (5 + -2) ) :\n                lpm -= (58 + -55)\n            else :\n                return (8 + -8)\n        Coq = Coq + (52 + -51)\n    return (11 + -10)"}
{"old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT", "code": "def URE ( str ) :\n    RoR = len ( str )\n    HsZ = (74 + -74)\n    uyA = (10 + -10)\n    LsG = (72 + -72)\n    aFw = range ( (76 + -76) , RoR )\n    while LsG < len(aFw):\n        MVF = aFw[LsG]\n        if ( MVF % (55 + -53) == (41 + -41) ) :\n            HsZ = HsZ + ( ord ( str [ MVF ] ) - (20 + 28) )\n        else :\n            uyA = uyA + ( ord ( str [ MVF ] ) - (13 + 35) )\n        LsG = LsG + (38 + -37)\n    return ( ( HsZ - uyA ) % (37 + -26) == (34 + -34) )"}
{"old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT", "code": "def nBc ( faq ) :\n    HFf = len ( faq )\n    if ( HFf == (30 + -29) and faq [ (1 + -1) ] == '0' ) :\n        return True\n    if ( HFf % (17 + -14) == (54 + -53) ) :\n        faq = str ( faq ) + \"00\"\n        HFf += (37 + -35)\n    elif ( HFf % (12 + -9) == (70 + -68) ) :\n        faq = str ( faq ) + \"0\"\n        HFf += (45 + -44)\n    sum = (41 + -41)\n    xZV = (18 + -17)\n    Lfd = (95 + -95)\n    LQX = range ( HFf - (13 + -12) , - (7 + -6) , - (9 + -6) )\n    while Lfd < len(LQX):\n        GTo = LQX[Lfd]\n        Hcx = (60 + -60)\n        Hcx += ord ( faq [ GTo ] ) - ord ( '0' )\n        GTo -= (66 + -65)\n        Hcx += ( ord ( faq [ GTo ] ) - ord ( '0' ) ) * (52 + -42)\n        GTo -= (90 + -89)\n        Hcx += ( ord ( faq [ GTo ] ) - ord ( '0' ) ) * (91 + 9)\n        sum = sum + Hcx * xZV\n        xZV *= ( - (26 + -25) )\n        Lfd = Lfd + (73 + -72)\n    sum = abs ( sum )\n    return ( sum % (62 + -49) == (18 + -18) )"}
{"old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT", "code": "def NBo ( str ) :\n    sJk = len ( str )\n    FCL = (3 + -3)\n    rLA = (23 + -23)\n    jOR = range ( (3 + -3) , sJk )\n    while rLA < len(jOR):\n        VRm = jOR[rLA]\n        FCL = FCL + ord ( str [ VRm ] ) - (44 + 4)\n        rLA = rLA + (86 + -85)\n    return ( FCL % (50 + -41) == (42 + -42) )"}
{"old_id": "CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER", "code": "def xUm ( kYE , HxN ) :\n    yHE = len ( kYE )\n    mLj = len ( HxN )\n    pOv = ( [ [ False for rGz in range ( mLj + (51 + -50) ) ] for rGz in range ( yHE + (46 + -45) ) ] )\n    pOv [ (49 + -49) ] [ (77 + -77) ] = True\n    tEA = (68 + -68)\n    Ibs = range ( len ( kYE ) )\n    while tEA < len(Ibs):\n        rGz = Ibs[tEA]\n        ofT = (34 + -34)\n        fXn = range ( len ( HxN ) + (78 + -77) )\n        while ofT < len(fXn):\n            WSL = fXn[ofT]\n            if ( pOv [ rGz ] [ WSL ] ) :\n                if ( ( WSL < len ( HxN ) and ( kYE [ rGz ].upper ( ) == HxN [ WSL ] ) ) ) :\n                    pOv [ rGz + (21 + -20) ] [ WSL + (60 + -59) ] = True\n                if ( kYE [ rGz ].isupper ( ) == False ) :\n                    pOv [ rGz + (80 + -79) ] [ WSL ] = True\n            ofT = ofT + (50 + -49)\n        tEA = tEA + (40 + -39)\n    return ( pOv [ yHE ] [ mLj ] )"}
{"old_id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1", "code": "def new ( DYo , CVO ) :\n    if ( CVO == (38 + -37) ) :\n        return True\n    mNj = (47 + -46)\n    xmA = (30 + -30)\n    Zjw = range ( (6 + -5) , CVO )\n    while xmA < len(Zjw):\n        mNj = Zjw[xmA]\n        if DYo [ mNj - (78 + -77) ] >= DYo [ mNj ] :\n            break\n        else:\n            if ( mNj == CVO ) :\n                return True\n        xmA = xmA + (49 + -48)\n    VvM = mNj\n    mNj += (79 + -78)\n    while ( DYo [ VvM ] < DYo [ VvM - (88 + -87) ] ) :\n        if ( mNj > (81 + -80) and DYo [ VvM ] < DYo [ mNj - (33 + -31) ] ) :\n            return False\n        VvM += (12 + -11)\n    if ( VvM == CVO ) :\n        return True\n    svU = VvM\n    if ( DYo [ svU ] < DYo [ mNj - (20 + -19) ] ) :\n        return False\n    while ( svU > (67 + -66) and svU < CVO ) :\n        if ( DYo [ svU ] < DYo [ svU - (65 + -64) ] ) :\n            return False\n        svU += (32 + -31)\n    return True"}
{"old_id": "CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT", "code": "def yPr ( tcW ) :\n    wgb = len ( tcW )\n    wOm = (47 + -47)\n    bbF = range ( wgb )\n    while wOm < len(bbF):\n        HGd = bbF[wOm]\n        if ( tcW [ HGd ] != 'a' ) :\n            break\n        wOm = wOm + (95 + -94)\n    if ( HGd * (68 + -66) != wgb ) :\n        return False\n    asM = (36 + -36)\n    isW = range ( HGd , wgb )\n    while asM < len(isW):\n        chP = isW[asM]\n        if ( tcW [ chP ] != 'b' ) :\n            return False\n        asM = asM + (63 + -62)\n    return True"}
{"old_id": "CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX", "code": "def VMA ( vEZ , EkR , ECo ) :\n    PjC = (48 + -48)\n    pBE = (86 + -86)\n    VuS = (16 + -16)\n    bYV = range ( (48 + -48) , EkR )\n    while VuS < len(bYV):\n        vRM = bYV[VuS]\n        PjC = (5 + -5)\n        pBE = (92 + -92)\n        RXs = (90 + -90)\n        VmN = range ( (1 + -1) , ECo )\n        while RXs < len(VmN):\n            lzl = VmN[RXs]\n            PjC += vEZ [ vRM ] [ lzl ]\n            pBE += vEZ [ lzl ] [ vRM ]\n            RXs = RXs + (27 + -26)\n        if ( PjC == pBE ) :\n            return (45 + -44)\n        VuS = VuS + (75 + -74)\n    return (49 + -49)"}
{"old_id": "CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY", "code": "def SvL ( hxO , xsf ) :\n    if ( xsf == (2 + -1) ) : return True\n    hxO.sort ( )\n    ACt = hxO [ (82 + -81) ] - hxO [ (17 + -17) ]\n    tyT = (61 + -61)\n    BCZ = range ( (7 + -5) , xsf )\n    while tyT < len(BCZ):\n        doX = BCZ[tyT]\n        if ( hxO [ doX ] - hxO [ doX - (96 + -95) ] != ACt ) :\n            return False\n        tyT = tyT + (89 + -88)\n    return True"}
{"old_id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE", "code": "def vad ( RUz , wUk ) :\n    CME = (39 + -39)\n    VHb = (78 + -78)\n    hIT = range(wUk)\n    while VHb < len(hIT):\n        cQJ = hIT[VHb]\n        CME += RUz[cQJ]\n        VHb = VHb + (77 + -76)\n    if ( (13 + -11) * ( wUk - (79 + -78) ) == CME ) :\n        return True\n    else :\n        return False"}
{"old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7", "code": "def rnX ( hnQ ) :\n    MLF = len ( hnQ )\n    if ( MLF == (97 + -97) and hnQ [ (33 + -33) ] == '\\n' ) :\n        return (50 + -49)\n    if ( MLF % (45 + -42) == (74 + -73) ) :\n        hnQ = str ( hnQ ) + \"00\"\n        MLF += (33 + -31)\n    elif ( MLF % (45 + -42) == (82 + -80) ) :\n        hnQ = str ( hnQ ) + \"0\"\n        MLF += (92 + -91)\n    AVZ = (70 + -70)\n    qtp = (62 + -61)\n    Pmm = (45 + -45)\n    OcE = range ( MLF - (53 + -52) , - (32 + -31) , - (79 + -78) )\n    while Pmm < len(OcE):\n        ngw = OcE[Pmm]\n        nZY = (27 + -27)\n        nZY += ord ( hnQ [ ngw ] ) - ord ( '0' )\n        ngw -= (72 + -71)\n        nZY += ( ord ( hnQ [ ngw ] ) - ord ( '0' ) ) * (79 + -69)\n        ngw -= (25 + -24)\n        nZY += ( ord ( hnQ [ ngw ] ) - ord ( '0' ) ) * (86 + 14)\n        AVZ = AVZ + nZY * qtp\n        qtp *= ( - (31 + -30) )\n        Pmm = Pmm + (88 + -87)\n    return ( AVZ % (3 + 4) == (52 + -52) )"}
{"old_id": "CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY", "code": "def yyf ( qVJ , kZq , fZQ ) :\n    SfX = (11 + -10)\n    HqK , JYs = (23 + -23) , (27 + -27)\n    while ( HqK < qVJ and JYs < kZq ) :\n        cfI = (72 + -72)\n        PZX = range ( JYs , kZq )\n        while cfI < len(PZX):\n            YIG = PZX[cfI]\n            fZQ [ HqK ] [ YIG ] = SfX\n            SfX += (1 + 0)\n            cfI = cfI + (96 + -95)\n        HqK += (33 + -32)\n        tBp = (82 + -82)\n        joy = range ( HqK , qVJ )\n        while tBp < len(joy):\n            YIG = joy[tBp]\n            fZQ [ YIG ] [ kZq - (19 + -18) ] = SfX\n            SfX += (59 + -58)\n            tBp = tBp + (71 + -70)\n        kZq -= (33 + -32)\n        if ( HqK < qVJ ) :\n            ucl = (10 + -10)\n            Mam = range ( kZq - (20 + -19) , JYs - (29 + -28) , - (73 + -72) )\n            while ucl < len(Mam):\n                YIG = Mam[ucl]\n                fZQ [ qVJ - (36 + -35) ] [ YIG ] = SfX\n                SfX += (22 + -21)\n                ucl = ucl + (12 + -11)\n            qVJ -= (93 + -92)\n        if ( JYs < kZq ) :\n            SlV = (71 + -71)\n            PuR = range ( qVJ - (39 + -38) , HqK - (54 + -53) , - (91 + -90) )\n            while SlV < len(PuR):\n                YIG = PuR[SlV]\n                fZQ [ YIG ] [ JYs ] = SfX\n                SfX += (72 + -71)\n                SlV = SlV + (32 + -31)\n            JYs += (33 + -32)"}
{"old_id": "COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION", "code": "def PMi ( BOq , SiE , YFo ) :\n    lhD = [ (99 + -99) for AaO in range ( SiE + (30 + -29) ) ]\n    lhD [ (25 + -25) ] = (93 + -92)\n    xHY = (12 + -12)\n    GWu = range ( (3 + -2) , BOq + (29 + -28) )\n    while xHY < len(GWu):\n        AaO = GWu[xHY]\n        HZJ = (20 + -20)\n        Ytn = range ( min ( AaO , SiE ) , (7 + -7) , - (81 + -80) )\n        while HZJ < len(Ytn):\n            Wvl = Ytn[HZJ]\n            lhD [ Wvl ] = ( lhD [ Wvl ] + lhD [ Wvl - (29 + -28) ] ) % YFo\n            HZJ = HZJ + (25 + -24)\n        xHY = xHY + (88 + -87)\n    return lhD [ SiE ]"}
{"old_id": "CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES", "code": "def ACz ( dnX , Gfo ) :\n    wxW = [ (96 + -96) for OHt in range ( Gfo ) ]\n    len = (14 + -14)\n    fMQ = (32 + -32)\n    HMh = range ( Gfo )\n    while fMQ < len(HMh):\n        OHt = HMh[fMQ]\n        wxW [ OHt ] = (63 + -62)\n        fMQ = fMQ + (83 + -82)\n    ukB = (12 + -12)\n    JsB = range ( (37 + -36) , Gfo )\n    while ukB < len(JsB):\n        OHt = JsB[ukB]\n        GWd = (58 + -58)\n        KiA = range ( OHt )\n        while GWd < len(KiA):\n            Npd = KiA[GWd]\n            if ( dnX [ OHt ] > dnX [ Npd ] and ( OHt - Npd ) <= ( dnX [ OHt ] - dnX [ Npd ] ) ) :\n                wxW [ OHt ] = max ( wxW [ OHt ] , wxW [ Npd ] + (77 + -76) )\n            GWd = GWd + (69 + -68)\n        len = max ( len , wxW [ OHt ] )\n        ukB = ukB + (60 + -59)\n    return ( Gfo - len )"}
{"old_id": "COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1", "code": "def Kko ( sPZ ) :\n    keq = [ (57 + -57) for qOz in range (sPZ + (69 + -68))]\n    keq[(90 + -90)] = keq[(75 + -74)] = (58 + -57)\n    daY = (78 + -78)\n    AcJ = range((18 + -16), sPZ + (98 + -97))\n    while daY < len(AcJ):\n        IiP = AcJ[daY]\n        keq[IiP] = keq[IiP - (89 + -88)] + (IiP - (44 + -43)) * keq[IiP - (88 + -86)]\n        daY = daY + (40 + -39)\n    return keq[sPZ]"}
{"old_id": "COUNT_BALANCED_BINARY_TREES_HEIGHT_H", "code": "def cJN ( GPf ) :\n    vjo = (98 + 999999909)\n    PtX = [ (17 + -17) for FGy in range ( GPf + (14 + -13) ) ]\n    PtX [ (18 + -18) ] = (17 + -16)\n    PtX [ (93 + -92) ] = (91 + -90)\n    Tuh = (90 + -90)\n    Dqd = range ( (85 + -83) , GPf + (38 + -37) )\n    while Tuh < len(Dqd):\n        FGy = Dqd[Tuh]\n        PtX [ FGy ] = ( PtX [ FGy - (66 + -65) ] * ( ( (29 + -27) * PtX [ FGy - (55 + -53) ] ) % vjo + PtX [ FGy - (85 + -84) ] ) % vjo ) % vjo\n        Tuh = Tuh + (49 + -48)\n    return PtX [ GPf ]"}
{"old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS", "code": "def OMK ( tfE , NBS ) :\n    zyN = [ [ [ (23 + -23) , (80 + -80) ] for XAX in range ( NBS + (78 + -77) ) ] for xGa in range ( tfE + (53 + -52) ) ]\n    zyN [ (23 + -22) ] [ (62 + -62) ] [ (8 + -8) ] = (97 + -96)\n    zyN [ (11 + -10) ] [ (56 + -56) ] [ (53 + -52) ] = (13 + -12)\n    WUD = (81 + -81)\n    Dcn = range ( (95 + -93) , tfE + (37 + -36) )\n    while WUD < len(Dcn):\n        YlM = Dcn[WUD]\n        ldE = (5 + -5)\n        hqk = range ( NBS + (87 + -86) )\n        while ldE < len(hqk):\n            IpH = hqk[ldE]\n            if IpH >= YlM:\n                break\n            else:\n                zyN [ YlM ] [ IpH ] [ (28 + -28) ] = ( zyN [ YlM - (7 + -6) ] [ IpH ] [ (75 + -75) ] + zyN [ YlM - (5 + -4) ] [ IpH ] [ (80 + -79) ] )\n                zyN [ YlM ] [ IpH ] [ (23 + -22) ] = zyN [ YlM - (72 + -71) ] [ IpH ] [ (51 + -51) ]\n                if IpH >= (42 + -41) :\n                    zyN [ YlM ] [ IpH ] [ (31 + -30) ] += zyN [ YlM - (63 + -62) ] [ IpH - (65 + -64) ] [ (31 + -30) ]\n            ldE = ldE + (47 + -46)\n        WUD = WUD + (60 + -59)\n    return zyN [ tfE ] [ NBS ] [ (43 + -43) ] + zyN [ tfE ] [ NBS ] [ (95 + -94) ]"}
{"old_id": "COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS", "code": "def uMJ ( str ) :\n    HaO = (84 + -84) ;\n    bwt = len ( str )\n    WlH = (75 + -75)\n    paz = range ( (28 + -28) , bwt )\n    while WlH < len(paz):\n        zRa = paz[WlH]\n        xyu = (92 + -92)\n        vxu = range ( zRa + (89 + -88) , bwt )\n        while xyu < len(vxu):\n            HoA = vxu[xyu]\n            if ( abs ( ord ( str [ zRa ] ) - ord ( str [ HoA ] ) ) == abs ( zRa - HoA ) ) :\n                HaO += (23 + -22) ;\n            xyu = xyu + (76 + -75)\n        WlH = WlH + (18 + -17)\n    return HaO ;"}
{"old_id": "COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1", "code": "def uUq ( IPS ) :\n    NTm = [ (71 + -71) for pIo in range ( IPS + (15 + -14) ) ]\n    NTm [ (56 + -56) ] = (42 + -41)\n    NTm [ (8 + -7) ] = (14 + -14)\n    NTm [ (61 + -59) ] = (22 + -21)\n    Olz = (50 + -50)\n    Hon = range ( (35 + -32) , IPS + (45 + -44) )\n    while Olz < len(Hon):\n        pIo = Hon[Olz]\n        NTm [ pIo ] = ( pIo - (51 + -50) ) * ( NTm [ pIo - (1 + 0) ] + NTm [ pIo - (53 + -51) ] )\n        Olz = Olz + (64 + -63)\n    return NTm [ IPS ]"}
{"old_id": "COUNT_DIGITS_FACTORIAL_SET_1", "code": "def gyT ( HPS ) :\n    if ( HPS < (62 + -62) ) :\n        return (99 + -99)\n    if ( HPS <= (89 + -88) ) :\n        return (75 + -74)\n    tAi = (46 + -46)\n    BFq = (32 + -32)\n    Mbi = range ( (89 + -87) , HPS + (25 + -24) )\n    while BFq < len(Mbi):\n        VAU = Mbi[BFq]\n        tAi += math.Ijg ( VAU )\n        BFq = BFq + (63 + -62)\n    return math.xVj ( tAi ) + (67 + -66)"}
{"old_id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE", "code": "def urU ( LeY , ilT ) :\n    WGa = len ( ilT )\n    DQa = len ( LeY )\n    if WGa > DQa :\n        return (40 + -40)\n    nfZ = [ [ (16 + -16) for THn in range ( DQa + (22 + -21) ) ] for jJO in range ( WGa + (61 + -60) ) ]\n    SEf = (99 + -99)\n    Mei = range ( (33 + -32) , WGa + (11 + -10) )\n    while SEf < len(Mei):\n        Wjn = Mei[SEf]\n        nfZ [ Wjn ] [ (13 + -13) ] = (49 + -49)\n        SEf = SEf + (41 + -40)\n    etn = (3 + -3)\n    nud = range ( DQa + (11 + -10) )\n    while etn < len(nud):\n        Nbh = nud[etn]\n        nfZ [ (44 + -44) ] [ Nbh ] = (5 + -4)\n        etn = etn + (72 + -71)\n    fYJ = (26 + -26)\n    zko = range ( (71 + -70) , WGa + (11 + -10) )\n    while fYJ < len(zko):\n        Wjn = zko[fYJ]\n        Zjm = (53 + -53)\n        XCs = range ( (26 + -25) , DQa + (14 + -13) )\n        while Zjm < len(XCs):\n            Nbh = XCs[Zjm]\n            if ilT [ Wjn - (41 + -40) ] != LeY [ Nbh - (59 + -58) ] :\n                nfZ [ Wjn ] [ Nbh ] = nfZ [ Wjn ] [ Nbh - (97 + -96) ]\n            else :\n                nfZ [ Wjn ] [ Nbh ] = ( nfZ [ Wjn ] [ Nbh - (62 + -61) ] + nfZ [ Wjn - (13 + -12) ] [ Nbh - (75 + -74) ] )\n            Zjm = Zjm + (56 + -55)\n        fYJ = fYJ + (65 + -64)\n    return nfZ [ WGa ] [ DQa ]"}
{"old_id": "COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX", "code": "def count ( AxH , Qbo ) :\n    kjX = (44 + -44)\n    xkz = (12 + -12)\n    Xgs = range ( (28 + -27) , AxH + (70 + -69) )\n    while xkz < len(Xgs):\n        GVB = Xgs[xkz]\n        if GVB <= Qbo :\n            if Qbo // GVB <= AxH and Qbo % GVB == (87 + -87) :\n                kjX += (95 + -94)\n        xkz = xkz + (73 + -72)\n    return kjX"}
{"old_id": "COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1", "code": "def cgE ( GqG ) :\n    BeU = (50 + -49)\n    HmD = (23 + -22)\n    SmX = (71 + -71)\n    ntg = range ( (46 + -45) , GqG + (21 + -20) )\n    while SmX < len(ntg):\n        ITM = ntg[SmX]\n        BeU = int ( ( BeU * ( GqG + (7 + -6) - ITM ) ) / ITM )\n        HmD += BeU * BeU \n        SmX = SmX + (59 + -58)\n    return HmD "}
{"old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY", "code": "def Dbd ( Kfc , kAD ) :\n    TTQ = (10 + -10)\n    cCm = (23 + -23)\n    VOR = range ( (85 + -85) , kAD )\n    while cCm < len(VOR):\n        nWL = VOR[cCm]\n        IWM = (30 + -30)\n        Rmh = range ( nWL + (25 + -24) , kAD )\n        while IWM < len(Rmh):\n            mOB = Rmh[IWM]\n            if ( Kfc [ nWL ] == Kfc [ mOB ] ) :\n                TTQ += (34 + -33)\n            IWM = IWM + (1 + 0)\n        cCm = cCm + (57 + -56)\n    return TTQ"}
{"old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1", "code": "def YNU ( rXg , bNd ) :\n    kfe = dict ( )\n    vgL = (66 + -66)\n    aKV = range ( bNd )\n    while vgL < len(aKV):\n        jGY = aKV[vgL]\n        if rXg [ jGY ] in kfe.keys ( ) :\n            kfe [ rXg [ jGY ] ] += (84 + -83)\n        else :\n            kfe [ rXg [ jGY ] ] = (67 + -66)\n        vgL = vgL + (29 + -28)\n    PjA = (43 + -43)\n    xNA = (45 + -45)\n    WpO = kfe\n    while xNA < len(WpO):\n        QMr = WpO[xNA]\n        count = kfe [ QMr ]\n        PjA += ( count * ( count - (62 + -61) ) ) // (49 + -47)\n        xNA = xNA + (8 + -7)\n    return PjA"}
{"old_id": "COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1", "code": "def PJx ( kKU , yZA ) :\n    Bmo = (30 + -30)\n    AxH = (24 + -24)\n    vsV = range ( (35 + -34) , yZA - (11 + -10) )\n    while AxH < len(vsV):\n        lwO = vsV[AxH]\n        YHD = (91 + -91)\n        FYp = (91 + -91)\n        KvU = range ( lwO + (95 + -94) , yZA )\n        while FYp < len(KvU):\n            waa = KvU[FYp]\n            if ( kKU [ lwO ] > kKU [ waa ] ) :\n                YHD += (38 + -37)\n            FYp = FYp + (53 + -52)\n        qJp = (72 + -72)\n        bLp = (51 + -51)\n        yiR = range ( lwO - (30 + -29) , - (1 + 0) , - (82 + -81) )\n        while bLp < len(yiR):\n            waa = yiR[bLp]\n            if ( kKU [ lwO ] < kKU [ waa ] ) :\n                qJp += (67 + -66)\n            bLp = bLp + (25 + -24)\n        Bmo += qJp * YHD\n        AxH = AxH + (76 + -75)\n    return Bmo"}
{"old_id": "COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS", "code": "def DRG ( JQc , Ace ) :\n    dMB = sorted ( JQc )\n    count = (21 + -20)\n    CNX = (16 + -16)\n    hZA = range ( (3 + -3) , Ace - (59 + -58) )\n    while CNX < len(hZA):\n        khS = hZA[CNX]\n        if ( dMB [ khS ] + (93 + -92) != dMB [ khS + (40 + -39) ] ) :\n            count = count + (72 + -71)\n        CNX = CNX + (10 + -9)\n    return count"}
{"old_id": "COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER", "code": "def Jxa ( wXC ) :\n    WGn = (38 + -38)\n    BSH = (7 + -7)\n    PNW = range ( (29 + -28) , (75 + -65) )\n    while BSH < len(PNW):\n        pFW = PNW[BSH]\n        gDi = [ ]\n        if ( pFW <= wXC ) :\n            gDi.append ( pFW )\n            WGn += (100 + -99)\n        while len ( gDi ) != (2 + -2) :\n            KmJ = gDi [ - (11 + -10) ]\n            gDi.pop ( )\n            jCP = (15 + -15)\n            Vxn = range ( KmJ % (9 + 1) , (68 + -58) )\n            while jCP < len(Vxn):\n                NnJ = Vxn[jCP]\n                bFZ = KmJ * (95 + -85) + NnJ\n                if ( bFZ <= wXC ) :\n                    gDi.append ( bFZ )\n                    WGn += (30 + -29)\n                jCP = jCP + (65 + -64)\n        BSH = BSH + (99 + -98)\n    return WGn"}
{"old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX", "code": "def MIf ( Qbw , uod , ekr ) :\n    count = (15 + -15)\n    CFm = (59 + -59)\n    QhJ = range ( uod )\n    while CFm < len(QhJ):\n        RwO = QhJ[CFm]\n        UTy = (47 + -47)\n        kXf = range ( ekr )\n        while UTy < len(kXf):\n            iUl = kXf[UTy]\n            if Qbw [ RwO ] [ iUl ] < (93 + -93) :\n                count += (92 + -91)\n            else :\n                break\n            UTy = UTy + (92 + -91)\n        CFm = CFm + (33 + -32)\n    return count"}
{"old_id": "COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS", "code": "def OhC ( Ths , eLs , Kcw ) :\n    ssU = [ False for ocl in range ( Ths + (73 + -71) ) ]\n    if ( eLs <= Ths ) :\n        ssU [ eLs ] = True\n    if ( Kcw <= Ths ) :\n        ssU [ Kcw ] = True\n    Att = (67 + -67)\n    Yqt = (99 + -99)\n    YON = range ( min ( eLs , Kcw ) , Ths + (22 + -21) )\n    while Yqt < len(YON):\n        ocl = YON[Yqt]\n        if ( ssU [ ocl ] ) :\n            if ( ocl + eLs <= Ths ) :\n                ssU [ ocl + eLs ] = True\n            if ( ocl + Kcw <= Ths ) :\n                ssU [ ocl + Kcw ] = True\n            Att = Att + (12 + -11)\n        Yqt = Yqt + (35 + -34)\n    return Att"}
{"old_id": "COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S", "code": "def fCh ( YcB ) :\n    obO = [ (11 + -11) for NEr in range ( YcB ) ]\n    yKd = [ (87 + -87) for NEr in range ( YcB ) ]\n    obO [ (68 + -68) ] = yKd [ (1 + -1) ] = (96 + -95)\n    ehx = (9 + -9)\n    AQd = range ( (52 + -51) , YcB )\n    while ehx < len(AQd):\n        NEr = AQd[ehx]\n        obO [ NEr ] = obO [ NEr - (82 + -81) ] + yKd [ NEr - (7 + -6) ]\n        yKd [ NEr ] = obO [ NEr - (60 + -59) ]\n        ehx = ehx + (83 + -82)\n    return obO [ YcB - (58 + -57) ] + yKd [ YcB - (63 + -62) ]"}
{"old_id": "COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K", "code": "def NSR ( VeK , eGv , mjR ) :\n    OEm = [ [ (6 + -6) for Gwx in range ( eGv ) ] for Gwx in range ( mjR ) ]\n    yyF = (7 + -7)\n    udy = range ( eGv )\n    while yyF < len(udy):\n        Gwx = udy[yyF]\n        OEm [ (20 + -20) ] [ Gwx ] = (88 + -87)\n        yyF = yyF + (4 + -3)\n    pav = (14 + -14)\n    dsx = range ( (87 + -86) , mjR )\n    while pav < len(dsx):\n        Ahy = dsx[pav]\n        Cqf = (97 + -97)\n        QJY = range ( Ahy , eGv )\n        while Cqf < len(QJY):\n            Gwx = QJY[Cqf]\n            OEm [ Ahy ] [ Gwx ] = (95 + -95)\n            PfM = (99 + -99)\n            ZoI = range ( Ahy - (98 + -97) , Gwx )\n            while PfM < len(ZoI):\n                ovG = ZoI[PfM]\n                if ( VeK [ ovG ] < VeK [ Gwx ] ) :\n                    OEm [ Ahy ] [ Gwx ] += OEm [ Ahy - (51 + -50) ] [ ovG ]\n                PfM = PfM + (21 + -20)\n            Cqf = Cqf + (11 + -10)\n        pav = pav + (36 + -35)\n    WxA = (95 + -95)\n    kMR = (49 + -49)\n    Ing = range ( mjR - (90 + -89) , eGv )\n    while kMR < len(Ing):\n        Gwx = Ing[kMR]\n        WxA += OEm [ mjR - (57 + -56) ] [ Gwx ]\n        kMR = kMR + (81 + -80)\n    return WxA"}
{"old_id": "COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY", "code": "def tdt ( cLm , wZM , yOW ) :\n    WGA = (6 + -6)\n    GsO = (81 + -81)\n    gxM = range ( wZM )\n    while GsO < len(gxM):\n        NQV = gxM[GsO]\n        if yOW == cLm [ NQV ] :\n            WGA += (64 + -63)\n        GsO = GsO + (4 + -3)\n    return WGA"}
{"old_id": "COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION", "code": "def FCS ( bGU , Mii , pOb , QeL ) :\n    Bwg = [ (81 + -81) for PCM in range ( bGU + (17 + -16) ) ]\n    Bwg [ (32 + -32) ] = (37 + -36)\n    Ynz = (100 + -100)\n    DZD = range ( (19 + -18) , bGU + (3 + -2) , (96 + -95) )\n    while Ynz < len(DZD):\n        PCM = DZD[Ynz]\n        Bwg [ PCM ] = Bwg [ PCM - (51 + -50) ] + PCM\n        Ynz = Ynz + (64 + -63)\n    TcK = bGU - ( Mii + QeL + pOb )\n    sum = (4 + -4)\n    CeU = (31 + -31)\n    rqk = range ( (59 + -59) , TcK + (23 + -22) , (46 + -45) )\n    while CeU < len(rqk):\n        PCM = rqk[CeU]\n        pGA = (5 + -5)\n        yhT = range ( (72 + -72) , TcK - PCM + (13 + -12) , (100 + -99) )\n        while pGA < len(yhT):\n            aLj = yhT[pGA]\n            vbH = TcK - ( PCM + aLj )\n            sum = int ( sum + Bwg [ bGU ] / ( Bwg [ PCM + Mii ] + Bwg [ aLj + pOb ] + Bwg [ vbH + QeL ] ) )\n            pGA = pGA + (61 + -60)\n        CeU = CeU + (45 + -44)\n    return sum"}
{"old_id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1", "code": "def fgT ( SYG , xnt ) :\n    ZCB = [ [ (18 + -18) for JiX in range ( xnt + (48 + -47) ) ] for YTt in range ( SYG + (66 + -65) ) ]\n    IAs = (46 + -46)\n    qbj = range ( SYG + (46 + -45) )\n    while IAs < len(qbj):\n        JiX = qbj[IAs]\n        ZCB [ JiX ] [ (28 + -28) ] = (9 + -9)\n        IAs = IAs + (99 + -98)\n    oJt = (22 + -22)\n    ApI = range ( xnt + (44 + -43) )\n    while oJt < len(ApI):\n        JiX = ApI[oJt]\n        ZCB [ (69 + -69) ] [ xnt ] = (58 + -58)\n        oJt = oJt + (20 + -19)\n    luZ = (34 + -34)\n    tjq = range ( (1 + 0) , SYG + (88 + -87) )\n    while luZ < len(tjq):\n        JiX = tjq[luZ]\n        WLO = (99 + -99)\n        lGK = range ( (63 + -62) , xnt + (96 + -95) )\n        while WLO < len(lGK):\n            YTt = lGK[WLO]\n            if ( YTt == (16 + -15) or JiX == YTt ) :\n                ZCB [ JiX ] [ YTt ] = (35 + -34)\n            else :\n                ZCB [ JiX ] [ YTt ] = ( YTt * ZCB [ JiX - (58 + -57) ] [ YTt ] + ZCB [ JiX - (25 + -24) ] [ YTt - (77 + -76) ] )\n            WLO = WLO + (11 + -10)\n        luZ = luZ + (1 + 0)\n    return ZCB [ SYG ] [ xnt ]"}
{"old_id": "COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME", "code": "def count ( ZKP ) :\n    PzG = [ (28 + -28) for xSI in range ( ZKP + (74 + -73) ) ]\n    PzG [ (45 + -45) ] = (22 + -21)\n    LBF = (48 + -48)\n    idj = range ( (64 + -61) , ZKP + (58 + -57) )\n    while LBF < len(idj):\n        xSI = idj[LBF]\n        PzG [ xSI ] += PzG [ xSI - (55 + -52) ]\n        LBF = LBF + (18 + -17)\n    yNv = (41 + -41)\n    ikj = range ( (64 + -59) , ZKP + (51 + -50) )\n    while yNv < len(ikj):\n        xSI = ikj[yNv]\n        PzG [ xSI ] += PzG [ xSI - (28 + -23) ]\n        yNv = yNv + (13 + -12)\n    cwA = (94 + -94)\n    xXm = range ( (6 + 4) , ZKP + (92 + -91) )\n    while cwA < len(xXm):\n        xSI = xXm[cwA]\n        PzG [ xSI ] += PzG [ xSI - (46 + -36) ]\n        cwA = cwA + (54 + -53)\n    return PzG [ ZKP ]"}
{"old_id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES", "code": "def NZw ( cXt , VbY ) :\n    count = [ ]\n    HXs = (12 + -12)\n    tNe = range ( cXt + (35 + -33) )\n    while HXs < len(tNe):\n        yzH = tNe[HXs]\n        count.append ( (69 + -69) )\n        HXs = HXs + (74 + -73)\n    count [ (41 + -41) ] = (1 + -1)\n    kDb = (45 + -45)\n    LWb = range ( (3 + -2) , cXt + (13 + -12) )\n    while kDb < len(LWb):\n        yzH = LWb[kDb]\n        if ( yzH > VbY ) :\n            count [ yzH ] = count [ yzH - (21 + -20) ] + count [ yzH - VbY ]\n        elif ( yzH < VbY ) :\n            count [ yzH ] = (30 + -29)\n        else :\n            count [ yzH ] = (73 + -71)\n        kDb = kDb + (5 + -4)\n    return count [ cXt ]"}
{"old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME", "code": "def YKj ( str , WYh ) :\n    aal = ( WYh * ( WYh + (17 + -16) ) ) // (91 + -89)\n    EAz = (54 + -54)\n    LAf = (69 + -69)\n    kXB = (96 + -96)\n    Jze = (72 + -72)\n    rKm = range ( WYh )\n    while Jze < len(rKm):\n        rMv = rKm[Jze]\n        if ( str [ rMv ] == 'a' ) :\n            EAz = rMv + (20 + -19)\n            aal -= min ( LAf , kXB )\n        elif ( str [ rMv ] == 'b' ) :\n            LAf = rMv + (55 + -54)\n            aal -= min ( EAz , kXB )\n        else :\n            kXB = rMv + (47 + -46)\n            aal -= min ( EAz , LAf )\n        Jze = Jze + (67 + -66)\n    return aal"}
{"old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE", "code": "def CuJ ( iFa ) :\n    xYQ = (39 + -39)\n    fSO = (94 + -94)\n    gCS = (23 + -23)\n    xRr = range ( len ( iFa ) )\n    while gCS < len(xRr):\n        jui = xRr[gCS]\n        if iFa [ ~ jui ] == 'a' :\n            fSO = ( fSO + xYQ )\n            xYQ = ( xYQ * (97 + -95) )\n        else :\n            xYQ += (34 + -33)\n        gCS = gCS + (8 + -7)\n    return fSO"}
{"old_id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K", "code": "def Zok ( Tco , ywF , TAG ) :\n    count = (41 + -41)\n    MIL = (51 + -51)\n    JEZ = range ( (48 + -48) , ywF )\n    while MIL < len(JEZ):\n        AZJ = JEZ[MIL]\n        Jux = (6 + -6)\n        Utl = range ( AZJ + (84 + -83) , ywF )\n        while Jux < len(Utl):\n            uXH = Utl[Jux]\n            if Tco [ AZJ ] - Tco [ uXH ] == TAG or Tco [ uXH ] - Tco [ AZJ ] == TAG :\n                count += (8 + -7)\n            Jux = Jux + (88 + -87)\n        MIL = MIL + (1 + 0)\n    return count"}
{"old_id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X", "code": "def cad ( zRx , oNS , jzT , NUu , cyA ) :\n    count = (42 + -42)\n    naf = (55 + -55)\n    XIK = range ( jzT )\n    while naf < len(XIK):\n        uKG = XIK[naf]\n        YkH = (88 + -88)\n        HXj = range ( NUu )\n        while YkH < len(HXj):\n            boo = HXj[YkH]\n            if zRx [ uKG ] + oNS [ boo ] == cyA :\n                count = count + (15 + -14)\n            YkH = YkH + (90 + -89)\n        naf = naf + (24 + -23)\n    return count"}
{"old_id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1", "code": "def IKO ( qlB , ZGT , XVc , iFg , MFy ) :\n    count = (61 + -61)\n    dAp = set ( )\n    hxW = (96 + -96)\n    YZt = range ( XVc )\n    while hxW < len(YZt):\n        Mwv = YZt[hxW]\n        dAp.add ( qlB [ Mwv ] )\n        hxW = hxW + (3 + -2)\n    PvV = (44 + -44)\n    hig = range ( iFg )\n    while PvV < len(hig):\n        Mrl = hig[PvV]\n        if MFy - ZGT [ Mrl ] in dAp :\n            count += (78 + -77)\n        PvV = PvV + (14 + -13)\n    return count"}
{"old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY", "code": "def GBm ( cIZ , Jgp ) :\n    Rrz = (46 + -46) ;\n    HER = (73 + -73)\n    MZQ = range ( (44 + -44) , Jgp )\n    while HER < len(MZQ):\n        ruX = MZQ[HER]\n        Lql = (20 + -20)\n        JEN = range ( ruX + (22 + -21) , Jgp )\n        while Lql < len(JEN):\n            ZPz = JEN[Lql]\n            zfs = cIZ [ ruX ] * cIZ [ ZPz ] ;\n            zlh = (8 + -8)\n            ges = range ( (22 + -22) , Jgp )\n            while zlh < len(ges):\n                AGS = ges[zlh]\n                if ( cIZ [ AGS ] == zfs ) :\n                    Rrz = Rrz + (40 + -39) ;\n                    break ;\n                zlh = zlh + (64 + -63)\n            Lql = Lql + (60 + -59)\n        HER = HER + (20 + -19)\n    return Rrz ;"}
{"old_id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1", "code": "def thJ ( bII , Ogy ) :\n    veC = (63 + -63)\n    WMy = set ( )\n    Eog = (80 + -80)\n    iAK = range ( Ogy )\n    while Eog < len(iAK):\n        mxG = iAK[Eog]\n        WMy.add ( bII [ mxG ] )\n        Eog = Eog + (5 + -4)\n    aaP = (45 + -45)\n    Tir = range ( Ogy )\n    while aaP < len(Tir):\n        mxG = Tir[aaP]\n        WpY = (45 + -45)\n        mdt = range ( mxG + (95 + -94) , Ogy )\n        while WpY < len(mdt):\n            BNp = mdt[WpY]\n            qcK = bII [ mxG ] * bII [ BNp ]\n            if qcK in ( WMy ) :\n                veC += (43 + -42)\n            WpY = WpY + (44 + -43)\n        aaP = aaP + (6 + -5)\n    return veC"}
{"old_id": "COUNT_PALINDROME_SUB_STRINGS_STRING", "code": "def RKK ( str , kHe ) :\n    RtI = [ [ (14 + -14) for BLo in range ( kHe ) ] for eMN in range ( kHe ) ]\n    gXK = [ [ False for BLo in range ( kHe ) ] for eMN in range ( kHe ) ]\n    rHB = (97 + -97)\n    fmM = range ( kHe )\n    while rHB < len(fmM):\n        JVb = fmM[rHB]\n        gXK [ JVb ] [ JVb ] = True\n        rHB = rHB + (52 + -51)\n    YSj = (53 + -53)\n    MFe = range ( kHe - (64 + -63) )\n    while YSj < len(MFe):\n        JVb = MFe[YSj]\n        if ( str [ JVb ] == str [ JVb + (60 + -59) ] ) :\n            gXK [ JVb ] [ JVb + (92 + -91) ] = True\n            RtI [ JVb ] [ JVb + (81 + -80) ] = (27 + -26)\n        YSj = YSj + (26 + -25)\n    TJq = (14 + -14)\n    iGr = range ( (6 + -4) , kHe )\n    while TJq < len(iGr):\n        Elc = iGr[TJq]\n        UlW = (69 + -69)\n        kvh = range ( kHe - Elc )\n        while UlW < len(kvh):\n            JVb = kvh[UlW]\n            RBz = Elc + JVb ;\n            if ( str [ JVb ] == str [ RBz ] and gXK [ JVb + (8 + -7) ] [ RBz - (62 + -61) ] ) :\n                gXK [ JVb ] [ RBz ] = True\n            if ( gXK [ JVb ] [ RBz ] == True ) :\n                RtI [ JVb ] [ RBz ] = ( RtI [ JVb ] [ RBz - (33 + -32) ] + RtI [ JVb + (77 + -76) ] [ RBz ] + (31 + -30) - RtI [ JVb + (68 + -67) ] [ RBz - (92 + -91) ] )\n            else :\n                RtI [ JVb ] [ RBz ] = ( RtI [ JVb ] [ RBz - (70 + -69) ] + RtI [ JVb + (11 + -10) ] [ RBz ] - RtI [ JVb + (50 + -49) ] [ RBz - (69 + -68) ] )\n            UlW = UlW + (66 + -65)\n        TJq = TJq + (44 + -43)\n    return RtI [ (98 + -98) ] [ kHe - (13 + -12) ]"}
{"old_id": "COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING", "code": "def hou ( str ) :\n    Fkm = len ( str )\n    eeZ = [ [ (71 + -71) for kGo in range ( Fkm + (30 + -28) ) ] for GEa in range ( Fkm + (51 + -49) ) ]\n    NYU = (38 + -38)\n    cPL = range ( Fkm )\n    while NYU < len(cPL):\n        kGo = cPL[NYU]\n        eeZ [ kGo ] [ kGo ] = (79 + -78)\n        NYU = NYU + (84 + -83)\n    AUW = (45 + -45)\n    VNu = range ( (55 + -53) , Fkm + (2 + -1) )\n    while AUW < len(VNu):\n        bri = VNu[AUW]\n        jkS = (87 + -87)\n        miV = range ( Fkm )\n        while jkS < len(miV):\n            kGo = miV[jkS]\n            tkC = bri + kGo - (6 + -5)\n            if ( tkC < Fkm ) :\n                if ( str [ kGo ] == str [ tkC ] ) :\n                    eeZ [ kGo ] [ tkC ] = ( eeZ [ kGo ] [ tkC - (33 + -32) ] + eeZ [ kGo + (94 + -93) ] [ tkC ] + (16 + -15) )\n                else :\n                    eeZ [ kGo ] [ tkC ] = ( eeZ [ kGo ] [ tkC - (43 + -42) ] + eeZ [ kGo + (66 + -65) ] [ tkC ] - eeZ [ kGo + (17 + -16) ] [ tkC - (44 + -43) ] )\n            jkS = jkS + (8 + -7)\n        AUW = AUW + (76 + -75)\n    return eeZ [ (13 + -13) ] [ Fkm - (48 + -47) ]"}
{"old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1", "code": "def rze ( Vax , AYP ) :\n    count = [ (42 + -42) ] * ( AYP + (74 + -73) )\n    count [ (61 + -61) ] = (36 + -35)\n    count [ (100 + -99) ] = (82 + -81)\n    if Vax [ (99 + -99) ] == '0' :\n        return (33 + -33)\n    UOk = (23 + -23)\n    sQS = range ( (62 + -60) , AYP + (40 + -39) )\n    while UOk < len(sQS):\n        jgo = sQS[UOk]\n        count [ jgo ] = (24 + -24)\n        if ( Vax [ jgo - (1 + 0) ] > '0' ) :\n            count [ jgo ] = count [ jgo - (27 + -26) ]\n        if ( Vax [ jgo - (89 + -87) ] == '1' or ( Vax [ jgo - (22 + -20) ] == '2' and Vax [ jgo - (88 + -87) ] < '7' ) ) :\n            count [ jgo ] += count [ jgo - (20 + -18) ]\n        UOk = UOk + (36 + -35)\n    return count [ AYP ]"}
{"old_id": "COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3", "code": "def PMA ( kqg , pKD ) :\n    cUU = [ (81 + -81) , (63 + -63) , (13 + -13) ]\n    dFc = (74 + -74)\n    ZJA = (64 + -64)\n    vtG = range ( (36 + -36) , pKD )\n    while ZJA < len(vtG):\n        wPt = vtG[ZJA]\n        cUU [ kqg [ wPt ] % (20 + -17) ] += (24 + -23)\n        ZJA = ZJA + (4 + -3)\n    dFc += ( ( cUU [ (8 + -8) ] * ( cUU [ (78 + -78) ] - (5 + -4) ) ) >> (64 + -63) )\n    dFc += cUU [ (24 + -23) ] * cUU [ (48 + -46) ]\n    dFc += ( cUU [ (29 + -29) ] * ( cUU [ (72 + -72) ] - (28 + -27) ) * ( cUU [ (4 + -4) ] - (72 + -70) ) ) / (70 + -64)\n    dFc += ( cUU [ (69 + -68) ] * ( cUU [ (36 + -35) ] - (76 + -75) ) * ( cUU [ (89 + -88) ] - (30 + -28) ) ) / (63 + -57)\n    dFc += ( ( cUU [ (75 + -73) ] * ( cUU [ (69 + -67) ] - (6 + -5) ) * ( cUU [ (14 + -12) ] - (12 + -10) ) ) / (42 + -36) )\n    dFc += cUU [ (58 + -58) ] * cUU [ (61 + -60) ] * cUU [ (31 + -29) ]\n    return dFc"}
{"old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1", "code": "def KkD ( yzt , rjL ) :\n    count = [ [ (55 + -55) for LAk in range ( yzt ) ] for RGc in range ( rjL ) ]\n    hZB = (28 + -28)\n    ArM = range ( yzt )\n    while hZB < len(ArM):\n        gYZ = ArM[hZB]\n        count [ gYZ ] [ (3 + -3) ] = (17 + -16) ;\n        hZB = hZB + (92 + -91)\n    GMm = (25 + -25)\n    rFL = range ( rjL )\n    while GMm < len(rFL):\n        iod = rFL[GMm]\n        count [ (21 + -21) ] [ iod ] = (35 + -34) ;\n        GMm = GMm + (3 + -2)\n    yuF = (48 + -48)\n    NkE = range ( (59 + -58) , yzt )\n    while yuF < len(NkE):\n        gYZ = NkE[yuF]\n        suR = (37 + -37)\n        aSi = range ( rjL )\n        while suR < len(aSi):\n            iod = aSi[suR]\n            count [ gYZ ] [ iod ] = count [ gYZ - (38 + -37) ] [ iod ] + count [ gYZ ] [ iod - (84 + -83) ]\n            suR = suR + (48 + -47)\n        yuF = yuF + (19 + -18)\n    return count [ yzt - (64 + -63) ] [ rjL - (98 + -97) ]"}
{"old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2", "code": "def EwN ( ICJ , wGU ) :\n    DCH = [ (42 + -42) for kmw in range ( wGU ) ]\n    DCH[(57 + -57)]=(97 + -96)\n    ITP = (45 + -45)\n    WpW = range ( ICJ  )\n    while ITP < len(WpW):\n        kmw = WpW[ITP]\n        RVl = (1 + -1)\n        RxB = range ( (97 + -96) , wGU )\n        while RVl < len(RxB):\n            Ply = RxB[RVl]\n            DCH [ Ply ] += DCH [ Ply - (24 + -23) ]\n            RVl = RVl + (6 + -5)\n        ITP = ITP + (67 + -66)\n    return DCH [ wGU - (85 + -84) ]"}
{"old_id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3", "code": "def KaO ( VPI , nDu ) :\n    wtT = (14 + -14)\n    rcG = range ( nDu , ( VPI + nDu - (56 + -55) ) )\n    while wtT < len(rcG):\n        hie = rcG[wtT]\n        TcE *= hie\n        TcE //= ( hie - nDu + (20 + -19) )\n        wtT = wtT + (54 + -53)\n    return TcE"}
{"old_id": "COUNT_ROTATIONS_DIVISIBLE_4", "code": "def Baa ( aZM ) :\n    pko = len ( aZM )\n    if ( pko == (42 + -41) ) :\n        gJv = ( int ) ( aZM [ (37 + -37) ] )\n        if ( gJv % (82 + -78) == (73 + -73) ) :\n            return (22 + -21)\n        return (21 + -21)\n    count = (63 + -63)\n    NIA = (98 + -98)\n    Yer = range ( (55 + -55) , pko - (7 + -6) )\n    while NIA < len(Yer):\n        pWI = Yer[NIA]\n        slD = ( int ) ( aZM [ pWI ] ) * (24 + -14) + ( int ) ( aZM [ pWI + (82 + -81) ] )\n        if ( slD % (17 + -13) == (46 + -46) ) :\n            count = count + (95 + -94)\n        NIA = NIA + (15 + -14)\n    slD = ( int ) ( aZM [ pko - (51 + -50) ] ) * (54 + -44) + ( int ) ( aZM [ (37 + -37) ] )\n    if ( slD % (75 + -71) == (44 + -44) ) :\n        count = count + (23 + -22)\n    return count"}
{"old_id": "COUNT_ROTATIONS_DIVISIBLE_8", "code": "def rjs ( Nzo ) :\n    rjg = len ( Nzo )\n    count = (51 + -51)\n    if ( rjg == (35 + -34) ) :\n        KuM = int ( Nzo [ (61 + -61) ] )\n        if ( KuM % (53 + -45) == (30 + -30) ) :\n            return (29 + -28)\n        return (51 + -51)\n    if ( rjg == (75 + -73) ) :\n        EtY = int ( Nzo [ (32 + -32) ] ) * (17 + -7) + int ( Nzo [ (83 + -82) ] )\n        DQa = int ( Nzo [ (9 + -8) ] ) * (77 + -67) + int ( Nzo [ (45 + -45) ] )\n        if ( EtY % (80 + -72) == (54 + -54) ) :\n            count += (64 + -63)\n        if ( DQa % (25 + -17) == (100 + -100) ) :\n            count += (72 + -71)\n        return count\n    ACz = (40 + -40)\n    SUg = (85 + -85)\n    uGZ = range ( (73 + -73) , ( rjg - (88 + -86) ) )\n    while SUg < len(uGZ):\n        XeD = uGZ[SUg]\n        ACz = ( int ( Nzo [ XeD ] ) * (30 + 70) + int ( Nzo [ XeD + (67 + -66) ] ) * (67 + -57) + int ( Nzo [ XeD + (46 + -44) ] ) )\n        if ( ACz % (12 + -4) == (25 + -25) ) :\n            count += (5 + -4)\n        SUg = SUg + (17 + -16)\n    ACz = ( int ( Nzo [ rjg - (55 + -54) ] ) * (21 + 79) + int ( Nzo [ (74 + -74) ] ) * (76 + -66) + int ( Nzo [ (64 + -63) ] ) )\n    if ( ACz % (60 + -52) == (79 + -79) ) :\n        count += (14 + -13)\n    ACz = ( int ( Nzo [ rjg - (58 + -56) ] ) * (23 + 77) + int ( Nzo [ rjg - (29 + -28) ] ) * (100 + -90) + int ( Nzo [ (72 + -72) ] ) )\n    if ( ACz % (41 + -33) == (80 + -80) ) :\n        count += (69 + -68)\n    return count"}
{"old_id": "COUNT_SORTED_ROWS_MATRIX", "code": "def hfz ( RKo , Waq , jit ) :\n    fub = (88 + -88)\n    HBl = (99 + -99)\n    TQe = range ( Waq )\n    while HBl < len(TQe):\n        LiM = TQe[HBl]\n        sZT = (67 + -67)\n        TaH = (25 + -25)\n        lPn = range ( jit - (16 + -15) )\n        while TaH < len(lPn):\n            sZT = lPn[TaH]\n            if RKo [ LiM ] [ sZT + (88 + -87) ] <= RKo [ LiM ] [ sZT ] :\n                break\n            TaH = TaH + (37 + -36)\n        if sZT == jit - (64 + -62) :\n            fub += (100 + -99)\n        HBl = HBl + (86 + -85)\n    IBF = (31 + -31)\n    vyM = range ( (100 + -100) , Waq )\n    while IBF < len(vyM):\n        LiM = vyM[IBF]\n        sZT = (2 + -2)\n        Uek = (38 + -38)\n        Tps = range ( jit - (41 + -40) , (84 + -84) , - (39 + -38) )\n        while Uek < len(Tps):\n            sZT = Tps[Uek]\n            if RKo [ LiM ] [ sZT - (25 + -24) ] <= RKo [ LiM ] [ sZT ] :\n                break\n            Uek = Uek + (24 + -23)\n        if jit > (61 + -60) and sZT == (45 + -44) :\n            fub += (100 + -99)\n        IBF = IBF + (29 + -28)\n    return fub"}
{"old_id": "COUNT_STRINGS_WITH_CONSECUTIVE_1S", "code": "def pKU ( Ifd ) :\n    vof = [ (58 + -58) ] * Ifd\n    gJT = [ (23 + -23) ] * Ifd\n    vof [ (62 + -62) ] = gJT [ (53 + -53) ] = (100 + -99)\n    kzN = (56 + -56)\n    qiJ = range ( (94 + -93) , Ifd )\n    while kzN < len(qiJ):\n        FFh = qiJ[kzN]\n        vof [ FFh ] = vof [ FFh - (9 + -8) ] + gJT [ FFh - (55 + -54) ]\n        gJT [ FFh ] = vof [ FFh - (6 + -5) ]\n        kzN = kzN + (73 + -72)\n    return ( (79 + -78) << Ifd ) - vof [ Ifd - (17 + -16) ] - gJT [ Ifd - (96 + -95) ]"}
{"old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS", "code": "def KVO ( IsX , KXw ) :\n    difference = (64 + -64)\n    fJq = (16 + -16)\n    UfI = [ (39 + -39) ] * ( KXw + (39 + -38) )\n    pxv = [ (47 + -47) ] * ( KXw + (56 + -55) )\n    UfI [ (54 + -54) ] = (38 + -37)\n    CgQ = (52 + -52)\n    ehA = range ( KXw )\n    while CgQ < len(ehA):\n        Jxr = ehA[CgQ]\n        if ( IsX [ Jxr ] & (91 + -90) == (98 + -97) ) :\n            difference = difference + (64 + -63)\n        else :\n            difference = difference - (64 + -63)\n        if ( difference < (92 + -92) ) :\n            fJq += pxv [ - difference ]\n            pxv [ - difference ] = pxv [ - difference ] + (19 + -18)\n        else :\n            fJq += UfI [ difference ]\n            UfI [ difference ] = UfI [ difference ] + (34 + -33)\n        CgQ = CgQ + (80 + -79)\n    return fJq"}
{"old_id": "COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS", "code": "def LHC ( OtM ) :\n    Zng = (84 + -84)\n    Rsu = len ( OtM )\n    zUX = (45 + -45)\n    WnV = range ( Rsu )\n    while zUX < len(WnV):\n        pmc = WnV[zUX]\n        Mci = (51 + -51)\n        Fbi = range ( pmc , Rsu )\n        while Mci < len(Fbi):\n            Jqu = Fbi[Mci]\n            if ( OtM [ pmc ] == OtM [ Jqu ] ) :\n                Zng = Zng + (6 + -5)\n            Mci = Mci + (39 + -38)\n        zUX = zUX + (19 + -18)\n    return Zng"}
{"old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N", "code": "def vle ( Xzg ) :\n    Yyw = (39 + -39)\n    TzX = (40 + -40)\n    while ( ( (22 + -21) << Yyw ) <= Xzg ) :\n        jwt = (5 + -5)\n        taZ = (99 + -98) << Yyw\n        ddR = (85 + -85)\n        AGt = range ( (49 + -49) , Xzg + (11 + -10) )\n        while ddR < len(AGt):\n            xJm = AGt[ddR]\n            TzX += jwt\n            if taZ == (72 + -71) :\n                jwt = not jwt\n                taZ = (75 + -74) << Yyw\n            else :\n                taZ -= (34 + -33)\n            ddR = ddR + (66 + -65)\n        Yyw += (24 + -23)\n    return TzX"}
{"old_id": "COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS", "code": "def VTK ( KsZ ) :\n    Sis = [ [ (56 + -56) ] * ( KsZ + (52 + -51) ) for zPl in range ( (7 + -5) ) ]\n    Sis [ (77 + -77) ] [ (72 + -71) ] = (58 + -57)\n    Sis [ (23 + -22) ] [ (59 + -58) ] = (67 + -65)\n    tlp = (63 + -63)\n    DEV = range ( (7 + -5) , KsZ + (40 + -39) )\n    while tlp < len(DEV):\n        zPl = DEV[tlp]\n        Sis [ (62 + -62) ] [ zPl ] = Sis [ (16 + -16) ] [ zPl - (77 + -76) ] + Sis [ (11 + -10) ] [ zPl - (82 + -81) ]\n        Sis [ (50 + -49) ] [ zPl ] = ( Sis [ (91 + -91) ] [ zPl - (11 + -10) ] * (57 + -55) + Sis [ (48 + -47) ] [ zPl - (29 + -28) ] )\n        tlp = tlp + (54 + -53)\n    return Sis [ (42 + -42) ] [ KsZ ] + Sis [ (11 + -10) ] [ KsZ ]"}
{"old_id": "COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS", "code": "def vqE ( dlF ) :\n    JIm = (86 + -84) * dlF\n    gRL = [ (87 + -87) ] * ( JIm + (49 + -48) )\n    gRL [ (45 + -45) ] = (90 + -89)\n    gRL [ (66 + -64) ] = (11 + -10)\n    LeL = (67 + -67)\n    EBb = range ( (94 + -90) , JIm + (7 + -6) , (29 + -27) )\n    while LeL < len(EBb):\n        gwC = EBb[LeL]\n        xIN = (56 + -56)\n        LKU = range ( (10 + -10) , gwC - (72 + -71) , (5 + -3) )\n        while xIN < len(LKU):\n            nqh = LKU[xIN]\n            gRL [ gwC ] += ( gRL [ nqh ] * gRL [ gwC - (24 + -22) - nqh ] )\n            xIN = xIN + (27 + -26)\n        LeL = LeL + (53 + -52)\n    return int ( gRL [ JIm ] )"}
{"old_id": "COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS", "code": "def Xkd ( str , nLu ) :\n    vzr = dict ( )\n    Lnq = (14 + -14)\n    gFs = range ( nLu )\n    while Lnq < len(gFs):\n        Xrc = gFs[Lnq]\n        vzr [ str [ Xrc ] ] = vzr.get ( str [ Xrc ] , (50 + -50) ) + (28 + -27)\n        Lnq = Lnq + (27 + -26)\n    LtP = (56 + -56)\n    MJB = (69 + -69)\n    WOf = vzr.values ( )\n    while MJB < len(WOf):\n        Xrc = WOf[MJB]\n        if Xrc == (59 + -57) :\n            LtP += (68 + -67)\n        MJB = MJB + (43 + -42)\n    return LtP"}
{"old_id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD", "code": "def vCj ( str , len ) :\n    count = (31 + -30) ;\n    if ( len == (46 + -45) ) :\n        return count\n    if ( str [ (6 + -6) ] == str [ (94 + -93) ] ) :\n        count *= (98 + -97)\n    else :\n        count *= (60 + -58)\n    COe = (71 + -71)\n    NOM = range ( (5 + -4) , len - (37 + -36) )\n    while COe < len(NOM):\n        otn = NOM[COe]\n        if ( str [ otn ] == str [ otn - (60 + -59) ] and str [ otn ] == str [ otn + (71 + -70) ] ) :\n            count *= (87 + -86)\n        elif ( str [ otn ] == str [ otn - (25 + -24) ] or str [ otn ] == str [ otn + (41 + -40) ] or str [ otn - (98 + -97) ] == str [ otn + (93 + -92) ] ) :\n            count *= (72 + -70)\n        else :\n            count *= (36 + -33)\n        COe = COe + (40 + -39)\n    if ( str [ len - (3 + -2) ] == str [ len - (44 + -42) ] ) :\n        count *= (46 + -45)\n    else :\n        count *= (65 + -63)\n    return count"}
{"old_id": "C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES", "code": "def VoU ( api , kDU ) :\n    AFe = api\n    cWi = (91 + -91)\n    bYk = range ( (42 + -41) , kDU )\n    while cWi < len(bYk):\n        qQd = bYk[cWi]\n        api += AFe\n        cWi = cWi + (64 + -63)\n    return api"}
{"old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER", "code": "def NnF ( str ) :\n    szL = (29 + 227)\n    count = [ (42 + -42) ] * szL\n    AZc = (27 + -27)\n    QiE = range ( len ( str ) )\n    while AZc < len(QiE):\n        UFr = QiE[AZc]\n        count [ ord ( str [ UFr ] ) ] += (37 + -36)\n        AZc = AZc + (43 + -42)\n    NCT , Ffj = (76 + -76) , (49 + -49)\n    JIi = (62 + -62)\n    MqW = range ( szL )\n    while JIi < len(MqW):\n        UFr = MqW[JIi]\n        if count [ UFr ] > count [ NCT ] :\n            Ffj = NCT\n            NCT = UFr\n        elif ( count [ UFr ] > count [ Ffj ] and count [ UFr ] != count [ NCT ] ) :\n            Ffj = UFr\n        JIi = JIi + (21 + -20)\n    return chr ( Ffj )"}
{"old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING", "code": "def AMU ( gxf ) :\n    EjC = [ ]\n    fGM = [ ]\n    IGp = \"\"\n    xWu = \"\"\n    UGy = (31 + -31)\n    HWm = range ( len ( gxf ) )\n    while UGy < len(HWm):\n        qek = HWm[UGy]\n        count = (63 + -63)\n        if ( gxf [ qek ] >= '0' and gxf [ qek ] <= '9' ) :\n            while ( gxf [ qek ] >= '0' and gxf [ qek ] <= '9' ) :\n                count = count * (74 + -64) + ord ( gxf [ qek ] ) - ord ( '0' )\n                qek += (53 + -52)\n            qek -= (73 + -72)\n            EjC.append ( count )\n        elif ( gxf [ qek ] == ']' ) :\n            IGp = \"\"\n            count = (42 + -42)\n            if ( len ( EjC ) != (64 + -64) ) :\n                count = EjC [ - (98 + -97) ]\n                EjC.pop ( )\n            while ( len ( fGM ) != (94 + -94) and fGM [ - (42 + -41) ] != '[' ) :\n                IGp = fGM [ - (8 + -7) ] + IGp\n                fGM.pop ( )\n            if ( len ( fGM ) != (20 + -20) and fGM [ - (59 + -58) ] == '[' ) :\n                fGM.pop ( )\n            eIP = (54 + -54)\n            pIg = range ( count )\n            while eIP < len(pIg):\n                VYv = pIg[eIP]\n                xWu = xWu + IGp\n                eIP = eIP + (90 + -89)\n            mFX = (71 + -71)\n            wCc = range ( len ( xWu ) )\n            while mFX < len(wCc):\n                VYv = wCc[mFX]\n                fGM.append ( xWu [ VYv ] )\n                mFX = mFX + (8 + -7)\n            xWu = \"\"\n        elif ( gxf [ qek ] == '[' ) :\n            if ( gxf [ qek - (74 + -73) ] >= '0' and gxf [ qek - (18 + -17) ] <= '9' ) :\n                fGM.append ( gxf [ qek ] )\n            else :\n                fGM.append ( gxf [ qek ] )\n                EjC.append ( (45 + -44) )\n        else :\n            fGM.append ( gxf [ qek ] )\n        UGy = UGy + (56 + -55)\n    while len ( fGM ) != (90 + -90) :\n        xWu = fGM [ - (34 + -33) ] + xWu\n        fGM.pop ( )\n    return xWu"}
{"old_id": "DELANNOY_NUMBER_1", "code": "def OqE ( FAa , sQk ) :\n    DMc = [ [ (92 + -92) for OSz in range ( FAa + (87 + -86) ) ] for OSz in range ( sQk + (29 + -28) ) ]\n    Lwt = (4 + -4)\n    nkY = range ( sQk + (56 + -55) )\n    while Lwt < len(nkY):\n        kwQ = nkY[Lwt]\n        DMc [ (24 + -24) ] [ kwQ ] = (80 + -79)\n        Lwt = Lwt + (93 + -92)\n    BvA = (24 + -24)\n    bFB = range ( sQk + (31 + -30) )\n    while BvA < len(bFB):\n        kwQ = bFB[BvA]\n        DMc [ kwQ ] [ (64 + -64) ] = (94 + -93)\n        BvA = BvA + (28 + -27)\n    Hfh = (82 + -82)\n    KfD = range ( (18 + -17) , sQk + (71 + -70) )\n    while Hfh < len(KfD):\n        kwQ = KfD[Hfh]\n        aMU = (93 + -93)\n        JFR = range ( (22 + -21) , FAa + (84 + -83) )\n        while aMU < len(JFR):\n            vjc = JFR[aMU]\n            DMc [ kwQ ] [ vjc ] = DMc [ kwQ - (64 + -63) ] [ vjc ] + DMc [ kwQ - (19 + -18) ] [ vjc - (3 + -2) ] + DMc [ kwQ ] [ vjc - (100 + -99) ]\n            aMU = aMU + (75 + -74)\n        Hfh = Hfh + (5 + -4)\n    return DMc [ sQk ] [ FAa ]"}
{"old_id": "DIAGONALLY_DOMINANT_MATRIX", "code": "def tPP ( iWY , MPK ) :\n    eNu = (62 + -62)\n    UyI = range ( (19 + -19) , MPK )\n    while eNu < len(UyI):\n        JGS = UyI[eNu]\n        sum = (25 + -25)\n        Aae = (97 + -97)\n        khZ = range ( (56 + -56) , MPK )\n        while Aae < len(khZ):\n            gVe = khZ[Aae]\n            sum = sum + abs ( iWY [ JGS ] [ gVe ] )\n            Aae = Aae + (32 + -31)\n        sum = sum - abs ( iWY [ JGS ] [ JGS ] )\n        if ( abs ( iWY [ JGS ] [ JGS ] ) < sum ) :\n            return False\n        eNu = eNu + (59 + -58)\n    return True"}
{"old_id": "DICE_THROW_PROBLEM", "code": "def FFo ( nEJ , usF , Jyh ) :\n    FtD = [ [ (84 + -84) ] * ( Jyh + (20 + -19) ) for NPO in range ( usF + (89 + -88) ) ]\n    mAS = (34 + -34)\n    BKM = range ( (49 + -48) , min ( nEJ + (32 + -31) , Jyh + (17 + -16) ) )\n    while mAS < len(BKM):\n        TOF = BKM[mAS]\n        FtD [ (98 + -97) ] [ TOF ] = (19 + -18)\n        mAS = mAS + (13 + -12)\n    OZc = (63 + -63)\n    fwk = range ( (87 + -85) , usF + (35 + -34) )\n    while OZc < len(fwk):\n        NPO = fwk[OZc]\n        slI = (90 + -90)\n        UYk = range ( (79 + -78) , Jyh + (85 + -84) )\n        while slI < len(UYk):\n            TOF = UYk[slI]\n            ZCw = (62 + -62)\n            kGd = range ( (68 + -67) , min ( nEJ + (64 + -63) , TOF ) )\n            while ZCw < len(kGd):\n                QHo = kGd[ZCw]\n                FtD [ NPO ] [ TOF ] += FtD [ NPO - (20 + -19) ] [ TOF - QHo ]\n                ZCw = ZCw + (57 + -56)\n            slI = slI + (85 + -84)\n        OZc = OZc + (72 + -71)\n    return FtD [ - (82 + -81) ] [ - (9 + -8) ]"}
{"old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY", "code": "def ErU ( Mvq , zAC ) :\n    Mvq.sort ( )\n    count = (18 + -18)\n    vRv = (91 + -91)\n    JRn = zAC\n    fnG = (43 + -43)\n    jVy = range ( (75 + -75) , ( zAC - (4 + -3) ) )\n    while fnG < len(jVy):\n        etC = jVy[fnG]\n        if Mvq [ etC ] == Mvq [ etC + (12 + -11) ] :\n            count += (78 + -77)\n            continue\n        else :\n            vRv = max ( vRv , count )\n            JRn = min ( JRn , count )\n            count = (56 + -56)\n        fnG = fnG + (49 + -48)\n    return vRv - JRn"}
{"old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_1", "code": "def njI ( gkH , uQf ) :\n    hEW = naM ( lambda : (74 + -74) )\n    wZs = (1 + -1)\n    Ddf = range ( uQf )\n    while wZs < len(Ddf):\n        KdC = Ddf[wZs]\n        hEW [ gkH [ KdC ] ] += (68 + -67)\n        wZs = wZs + (48 + -47)\n    Kxr = (93 + -93)\n    Sfn = uQf\n    UQQ = (40 + -40)\n    DTz = list(hEW.items ( ))\n    while UQQ < len(DTz):\n        aRd , values = DTz[UQQ]\n        Kxr = max ( Kxr , values )\n        Sfn = min ( Sfn , values )\n        UQQ = UQQ + (78 + -77)\n    return Kxr - Sfn"}
{"old_id": "DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M", "code": "def nxA ( BYO , ZSw ) :\n    WAI = Rol.CJR ( ( BYO + (43 + -41) , BYO + (82 + -80) ) )\n    WAI [ (71 + -71) ] [ BYO + (6 + -5) ] = (77 + -76)\n    lYP = (23 + -23)\n    QXS = range ( BYO , ZSw - (29 + -28) , - (19 + -18) )\n    while lYP < len(QXS):\n        tUk = QXS[lYP]\n        oYw = (88 + -88)\n        Ugb = range ( BYO + (58 + -57) )\n        while oYw < len(Ugb):\n            MOM = Ugb[oYw]\n            WAI [ MOM ] [ tUk ] = WAI [ MOM ] [ tUk + (2 + -1) ]\n            if ( MOM - tUk >= (31 + -31) ) :\n                WAI [ MOM ] [ tUk ] = ( WAI [ MOM ] [ tUk ] + WAI [ MOM - tUk ] [ tUk ] )\n            oYw = oYw + (57 + -56)\n        lYP = lYP + (47 + -46)\n    return WAI [ BYO ] [ ZSw ]"}
{"old_id": "DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B", "code": "def wHT ( DjB , yxB , MLg ) :\n    lXG = int ( math.Aez ( MLg ) + (10 + -9) )\n    Lxw = (7 + -6)\n    QkA = (47 + -47)\n    DbM = range ( lXG )\n    while QkA < len(DbM):\n        oTg = DbM[QkA]\n        Lxw = ( Lxw * DjB ) % MLg\n        QkA = QkA + (2 + -1)\n    IiL = [ (30 + -30) ] * MLg\n    Nxq = Lxw\n    yVJ = (80 + -80)\n    qlm = range ( (46 + -45) , lXG + (16 + -15) )\n    while yVJ < len(qlm):\n        oTg = qlm[yVJ]\n        if ( IiL [ Nxq ] == (94 + -94) ) :\n            IiL [ Nxq ] = oTg\n        Nxq = ( Nxq * Lxw ) % MLg\n        yVJ = yVJ + (82 + -81)\n    Nxq = yxB\n    Wte = (86 + -86)\n    Iyv = range ( lXG + (58 + -57) )\n    while Wte < len(Iyv):\n        oTg = Iyv[Wte]\n        if ( IiL [ Nxq ] > (98 + -98) ) :\n            jLw = IiL [ Nxq ] * lXG - oTg\n            if ( jLw < MLg ) :\n                return jLw\n        Nxq = ( Nxq * DjB ) % MLg\n        Wte = Wte + (68 + -67)\n    return - (50 + -49)"}
{"old_id": "DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1", "code": "def TrH ( nIK , lkg , qVz ) :\n    aeM = mlJ ( lambda : (40 + -40) )\n    VWv = (61 + -61)\n    qqE = range ( lkg )\n    while VWv < len(qqE):\n        NDZ = qqE[VWv]\n        aeM [ nIK [ NDZ ] ] += (60 + -59)\n        VWv = VWv + (20 + -19)\n    XBS = (46 + -46)\n    viH = list(aeM.items ( ))\n    while XBS < len(viH):\n        RJk , values = viH[XBS]\n        if values > (27 + -25) * qVz :\n            return False\n        XBS = XBS + (8 + -7)\n    return True"}
{"old_id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER", "code": "def Hjj ( LUn ) :\n    if ( len ( LUn ) >= (22 + -19) ) :\n        McI = int ( LUn [ len ( LUn ) - (51 + -50) ] )\n        if ( McI % (91 + -89) != (49 + -49) ) :\n            return False\n        gCq = int ( LUn [ len ( LUn ) - (51 + -49) ] )\n        sum = (81 + -81)\n        Xzf = (15 + -15)\n        eoL = range ( (46 + -46) , len ( LUn ) )\n        while Xzf < len(eoL):\n            xZy = eoL[Xzf]\n            sum += int ( LUn [ xZy ] )\n            Xzf = Xzf + (50 + -49)\n        return ( sum % (18 + -15) == (66 + -66) and ( gCq * (1 + 9) + McI ) % (60 + -56) == (74 + -74) )\n    else :\n        Kzt = int ( LUn )\n        return ( Kzt % (16 + -4) == (55 + -55) )"}
{"old_id": "DOUBLE_FACTORIAL_1", "code": "def Qrs ( chg ) :\n    wyG = (33 + -32)\n    mrG = (5 + -5)\n    uMI = range ( chg , - (49 + -48) , - (54 + -52) )\n    while mrG < len(uMI):\n        uBI = uMI[mrG]\n        if ( uBI == (37 + -37) or uBI == (7 + -6) ) :\n            return wyG\n        else :\n            wyG *= uBI\n        mrG = mrG + (55 + -54)\n    return wyG;"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1", "code": "def QUK ( Njq , qZc ) :\n    ZxW = [ [ (48 + -48) for ruw in range ( qZc + (35 + -34) ) ] for ruw in range ( Njq + (4 + -3) ) ]\n    MRZ = (34 + -34)\n    ELx = range ( (67 + -66) , Njq + (24 + -23) )\n    while MRZ < len(ELx):\n        yPE = ELx[MRZ]\n        ZxW [ yPE ] [ (88 + -87) ] = (99 + -98)\n        ZxW [ yPE ] [ (7 + -7) ] = (28 + -28)\n        MRZ = MRZ + (95 + -94)\n    rkJ = (47 + -47)\n    Lzc = range ( (3 + -2) , qZc + (11 + -10) )\n    while rkJ < len(Lzc):\n        qQJ = Lzc[rkJ]\n        ZxW [ (55 + -54) ] [ qQJ ] = qQJ\n        rkJ = rkJ + (38 + -37)\n    xZw = (30 + -30)\n    loU = range ( (1 + 1) , Njq + (32 + -31) )\n    while xZw < len(loU):\n        yPE = loU[xZw]\n        nzk = (94 + -94)\n        DWN = range ( (91 + -89) , qZc + (58 + -57) )\n        while nzk < len(DWN):\n            qQJ = DWN[nzk]\n            ZxW [ yPE ] [ qQJ ] = vCJ\n            KEi = (15 + -15)\n            YPQ = range ( (42 + -41) , qQJ + (43 + -42) )\n            while KEi < len(YPQ):\n                ruw = YPQ[KEi]\n                Wgp = (75 + -74) + max ( ZxW [ yPE - (65 + -64) ] [ ruw - (68 + -67) ] , ZxW [ yPE ] [ qQJ - ruw ] )\n                if Wgp < ZxW [ yPE ] [ qQJ ] :\n                    ZxW [ yPE ] [ qQJ ] = Wgp\n                KEi = KEi + (24 + -23)\n            nzk = nzk + (79 + -78)\n        xZw = xZw + (8 + -7)\n    return ZxW [ Njq ] [ qZc ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE", "code": "def ZPR ( bKe ) :\n    wPO = len ( bKe )\n    kKU = [ [ (85 + -85) for noJ in range ( wPO ) ] for noJ in range ( wPO ) ]\n    EzB = (71 + -71)\n    znr = range ( wPO )\n    while EzB < len(znr):\n        efE = znr[EzB]\n        kKU [ efE ] [ efE ] = (40 + -39)\n        EzB = EzB + (32 + -31)\n    TRm = (69 + -69)\n    hjM = range ( (98 + -96) , wPO + (39 + -38) )\n    while TRm < len(hjM):\n        yYj = hjM[TRm]\n        SlH = (95 + -95)\n        UYu = range ( wPO - yYj + (24 + -23) )\n        while SlH < len(UYu):\n            efE = UYu[SlH]\n            dGv = efE + yYj - (99 + -98)\n            if bKe [ efE ] == bKe [ dGv ] and yYj == (36 + -34) :\n                kKU [ efE ] [ dGv ] = (78 + -76)\n            elif bKe [ efE ] == bKe [ dGv ] :\n                kKU [ efE ] [ dGv ] = kKU [ efE + (68 + -67) ] [ dGv - (71 + -70) ] + (94 + -92)\n            else :\n                kKU [ efE ] [ dGv ] = max ( kKU [ efE ] [ dGv - (45 + -44) ] , kKU [ efE + (28 + -27) ] [ dGv ] ) ;\n            SlH = SlH + (25 + -24)\n        TRm = TRm + (4 + -3)\n    return kKU [ (47 + -47) ] [ wPO - (3 + -2) ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE", "code": "def dwM ( Sjh , kZw ) :\n    max = (42 + -42)\n    ECQ = [ (67 + -67) for dMK in range ( kZw ) ]\n    UWa = (82 + -82)\n    gNM = range ( kZw )\n    while UWa < len(gNM):\n        UMc = gNM[UWa]\n        ECQ [ UMc ] = Sjh [ UMc ]\n        UWa = UWa + (79 + -78)\n    uzR = (54 + -54)\n    QdQ = range ( (28 + -27) , kZw )\n    while uzR < len(QdQ):\n        UMc = QdQ[uzR]\n        bTK = (50 + -50)\n        Abf = range ( UMc )\n        while bTK < len(Abf):\n            zCa = Abf[bTK]\n            if ( Sjh [ UMc ] > Sjh [ zCa ] and ECQ [ UMc ] < ECQ [ zCa ] + Sjh [ UMc ] ) :\n                ECQ [ UMc ] = ECQ [ zCa ] + Sjh [ UMc ]\n            bTK = bTK + (34 + -33)\n        uzR = uzR + (88 + -87)\n    xBp = (11 + -11)\n    qkl = range ( kZw )\n    while xBp < len(qkl):\n        UMc = qkl[xBp]\n        if max < ECQ [ UMc ] :\n            max = ECQ [ UMc ]\n        xBp = xBp + (48 + -47)\n    return max"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE", "code": "def kdI ( MQD , bgU ) :\n    VIx = [ (50 + -49) for Zox in range ( bgU + (30 + -29) ) ]\n    Peg = (55 + -55)\n    JML = range ( (9 + -8) , bgU )\n    while Peg < len(JML):\n        Zox = JML[Peg]\n        VZg = (28 + -28)\n        sgz = range ( (67 + -67) , Zox )\n        while VZg < len(sgz):\n            fme = sgz[VZg]\n            if ( ( MQD [ Zox ] > MQD [ fme ] ) and ( VIx [ Zox ] < VIx [ fme ] + (89 + -88) ) ) :\n                VIx [ Zox ] = VIx [ fme ] + (30 + -29)\n            VZg = VZg + (24 + -23)\n        Peg = Peg + (25 + -24)\n    koD = [ (2 + -1) for Zox in range ( bgU + (72 + -71) ) ]\n    YNY = (3 + -3)\n    rtx = reversed ( range ( bgU - (68 + -67) ) )\n    while YNY < len(rtx):\n        Zox = rtx[YNY]\n        bqT = (5 + -5)\n        FeB = reversed ( range ( Zox - (9 + -8) , bgU ) )\n        while bqT < len(FeB):\n            fme = FeB[bqT]\n            if ( MQD [ Zox ] > MQD [ fme ] and koD [ Zox ] < koD [ fme ] + (48 + -47) ) :\n                koD [ Zox ] = koD [ fme ] + (61 + -60)\n            bqT = bqT + (56 + -55)\n        YNY = YNY + (28 + -27)\n    avD = VIx [ (63 + -63) ] + koD [ (43 + -43) ] - (23 + -22)\n    qFW = (22 + -22)\n    eqe = range ( (75 + -74) , bgU )\n    while qFW < len(eqe):\n        Zox = eqe[qFW]\n        avD = max ( ( VIx [ Zox ] + koD [ Zox ] - (84 + -83) ) , avD )\n        qFW = qFW + (26 + -25)\n    return avD"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING", "code": "def UNC ( str ) :\n    Luh = len ( str )\n    rOl = [ [ (45 + -45) for kKC in range ( Luh ) ] for kKC in range ( Luh ) ]\n    Ann = [ [ False for kKC in range ( Luh ) ] for kKC in range ( Luh ) ]\n    Wlk = (44 + -44)\n    jsu = (11 + -11)\n    jiA = (18 + -18)\n    WsK = (63 + -63)\n    Qkp = range ( Luh )\n    while WsK < len(Qkp):\n        kKC = Qkp[WsK]\n        Ann [ kKC ] [ kKC ] = True\n        rOl [ kKC ] [ kKC ] = (4 + -4)\n        WsK = WsK + (95 + -94)\n    lJP = (12 + -12)\n    jtS = range ( (27 + -25) , Luh + (80 + -79) )\n    while lJP < len(jtS):\n        jiA = jtS[lJP]\n        mcX = (46 + -46)\n        Itl = range ( Luh - jiA + (89 + -88) )\n        while mcX < len(Itl):\n            kKC = Itl[mcX]\n            Wlk = kKC + jiA - (26 + -25)\n            if jiA == (40 + -38) :\n                Ann [ kKC ] [ Wlk ] = ( str [ kKC ] == str [ Wlk ] )\n            else :\n                Ann [ kKC ] [ Wlk ] = ( ( str [ kKC ] == str [ Wlk ] ) and Ann [ kKC + (31 + -30) ] [ Wlk - (98 + -97) ] )\n            if Ann [ kKC ] [ Wlk ] == True :\n                rOl [ kKC ] [ Wlk ] = (2 + -2)\n            else :\n                rOl [ kKC ] [ Wlk ] = (89 + 99999911)\n                wJa = (67 + -67)\n                sQA = range ( kKC , Wlk )\n                while wJa < len(sQA):\n                    jsu = sQA[wJa]\n                    rOl [ kKC ] [ Wlk ] = min ( rOl [ kKC ] [ Wlk ] , rOl [ kKC ] [ jsu ] + rOl [ jsu + (20 + -19) ] [ Wlk ] + (28 + -27) )\n                    wJa = wJa + (40 + -39)\n            mcX = mcX + (98 + -97)\n        lJP = lJP + (90 + -89)\n    return rOl [ (53 + -53) ] [ Luh - (40 + -39) ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM", "code": "def ofM ( PHC , yZN , LFe ) :\n    pBo = [ [ (23 + -23) for Lkm in range ( LFe + (6 + -5) ) ] for Lkm in range ( LFe + (44 + -43) ) ]\n    UbE = [ [ (28 + -28) for Lkm in range ( LFe + (99 + -98) ) ] for Lkm in range ( LFe + (30 + -29) ) ]\n    sEe = (75 + -75)\n    Yvs = range ( LFe )\n    while sEe < len(Yvs):\n        Lkm = Yvs[sEe]\n        if PHC [ Lkm ] == 'F' :\n            pBo [ Lkm ] [ Lkm ] = (61 + -60)\n        else :\n            pBo [ Lkm ] [ Lkm ] = (83 + -83)\n        if PHC [ Lkm ] == 'T' :\n            UbE [ Lkm ] [ Lkm ] = (74 + -73)\n        else :\n            UbE [ Lkm ] [ Lkm ] = (22 + -22)\n        sEe = sEe + (71 + -70)\n    wcl = (8 + -8)\n    ATh = range ( (82 + -81) , LFe )\n    while wcl < len(ATh):\n        GHv = ATh[wcl]\n        Lkm = (65 + -65)\n        fEO = (73 + -73)\n        Qcy = range ( GHv , LFe )\n        while fEO < len(Qcy):\n            TLH = Qcy[fEO]\n            UbE [ Lkm ] [ TLH ] = pBo [ Lkm ] [ TLH ] = (60 + -60)\n            pfV = (81 + -81)\n            Oed = range ( GHv )\n            while pfV < len(Oed):\n                Kqe = Oed[pfV]\n                Eqa = Lkm + Kqe\n                YGL = UbE [ Lkm ] [ Eqa ] + pBo [ Lkm ] [ Eqa ]\n                KSs = UbE [ Eqa + (52 + -51) ] [ TLH ] + pBo [ Eqa + (78 + -77) ] [ TLH ]\n                if yZN [ Eqa ] == '&' :\n                    UbE [ Lkm ] [ TLH ] += UbE [ Lkm ] [ Eqa ] * UbE [ Eqa + (51 + -50) ] [ TLH ]\n                    pBo [ Lkm ] [ TLH ] += ( YGL * KSs - UbE [ Lkm ] [ Eqa ] * UbE [ Eqa + (6 + -5) ] [ TLH ] )\n                if yZN [ Eqa ] == '|' :\n                    pBo [ Lkm ] [ TLH ] += pBo [ Lkm ] [ Eqa ] * pBo [ Eqa + (91 + -90) ] [ TLH ]\n                    UbE [ Lkm ] [ TLH ] += ( YGL * KSs - pBo [ Lkm ] [ Eqa ] * pBo [ Eqa + (35 + -34) ] [ TLH ] )\n                if yZN [ Eqa ] == '^' :\n                    UbE [ Lkm ] [ TLH ] += ( pBo [ Lkm ] [ Eqa ] * UbE [ Eqa + (12 + -11) ] [ TLH ] + UbE [ Lkm ] [ Eqa ] * pBo [ Eqa + (75 + -74) ] [ TLH ] )\n                    pBo [ Lkm ] [ TLH ] += ( UbE [ Lkm ] [ Eqa ] * UbE [ Eqa + (91 + -90) ] [ TLH ] + pBo [ Lkm ] [ Eqa ] * pBo [ Eqa + (14 + -13) ] [ TLH ] )\n                pfV = pfV + (44 + -43)\n            Lkm += (74 + -73)\n            fEO = fEO + (67 + -66)\n        wcl = wcl + (51 + -50)\n    return UbE [ (87 + -87) ] [ LFe - (96 + -95) ]"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1", "code": "def Lkh ( jIn , Ebi) :\n    Lkh = [ (39 + -38) ] * Ebi\n    TTs = (54 + -54)\n    bod = range ( (70 + -69) , Ebi )\n    while TTs < len(bod):\n        Amf = bod[TTs]\n        tXc = (64 + -64)\n        lCA = range ( (80 + -80) , Amf )\n        while tXc < len(lCA):\n            oBk = lCA[tXc]\n            if jIn [ Amf ] > jIn [ oBk ] and Lkh [ Amf ] < Lkh [ oBk ] + (60 + -59) :\n                Lkh [ Amf ] = Lkh [ oBk ] + (41 + -40)\n            tXc = tXc + (92 + -91)\n        TTs = TTs + (49 + -48)\n    LOU = (84 + -84)\n    TAb = (4 + -4)\n    ljp = range ( Ebi )\n    while TAb < len(ljp):\n        Amf = ljp[TAb]\n        LOU = max ( LOU , Lkh [ Amf ] )\n        TAb = TAb + (29 + -28)\n    return LOU"}
{"old_id": "DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION", "code": "def haG ( Hir , TaG , oXe ) :\n    if TaG == oXe :\n        return (7 + -7)\n    oLb = sys.MVo\n    Zvw = (63 + -63)\n    qUT = range ( TaG , oXe )\n    while Zvw < len(qUT):\n        oWn = qUT[Zvw]\n        count = ( haG ( Hir , TaG , oWn ) + haG ( Hir , oWn + (63 + -62) , oXe ) + Hir [ TaG - (45 + -44) ] * Hir [ oWn ] * Hir [ oXe ] )\n        if count < oLb :\n            oLb = count\n        Zvw = Zvw + (37 + -36)\n    return oLb"}
{"old_id": "DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1", "code": "def aXG ( set , CtN , sum ) :\n    ITg = ( [ [ False for wAW in range ( sum + (31 + -30) ) ] for wAW in range ( CtN + (79 + -78) ) ] )\n    Fhx = (25 + -25)\n    qgS = range ( CtN + (15 + -14) )\n    while Fhx < len(qgS):\n        wAW = qgS[Fhx]\n        ITg [ wAW ] [ (24 + -24) ] = True\n        Fhx = Fhx + (92 + -91)\n    WLJ = (53 + -53)\n    DNj = range ( (3 + -2) , sum + (20 + -19) )\n    while WLJ < len(DNj):\n        wAW = DNj[WLJ]\n        ITg [ (68 + -68) ] [ wAW ] = False\n        WLJ = WLJ + (81 + -80)\n    mai = (28 + -28)\n    RGS = range ( (89 + -88) , CtN + (63 + -62) )\n    while mai < len(RGS):\n        wAW = RGS[mai]\n        CWX = (100 + -100)\n        oTT = range ( (67 + -66) , sum + (78 + -77) )\n        while CWX < len(oTT):\n            gjk = oTT[CWX]\n            if gjk < set [ wAW - (54 + -53) ] :\n                ITg [ wAW ] [ gjk ] = ITg [ wAW - (24 + -23) ] [ gjk ]\n            if gjk >= set [ wAW - (40 + -39) ] :\n                ITg [ wAW ] [ gjk ] = ( ITg [ wAW - (30 + -29) ] [ gjk ] or ITg [ wAW - (68 + -67) ] [ gjk - set [ wAW - (57 + -56) ] ] )\n            CWX = CWX + (24 + -23)\n        mai = mai + (51 + -50)\n    return ITg [ CtN ] [ sum ]"}
{"old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY", "code": "def Tps ( HDh , gAy ) :\n    count = (20 + -20)\n    HDh = HDh[:gAy]\n    HDh.sort ( )\n    pSn = (53 + -53)\n    LSE = range ( (5 + -5) , gAy - (61 + -60) )\n    while pSn < len(LSE):\n        nme = LSE[pSn]\n        if ( HDh [ nme ] != HDh [ nme + (11 + -10) ] and HDh [ nme ] != HDh [ nme + (28 + -27) ] - (17 + -16) ) :\n            count += HDh [ nme + (68 + -67) ] - HDh [ nme ] - (49 + -48)\n        pSn = pSn + (32 + -31)\n    return count"}
{"old_id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1", "code": "def BWH ( EbO , BMU ) :\n    JaW = dict ( )\n    count , ObZ , mYl = (83 + -83) , - (28 + -18) ** (99 + -90) , (24 + -14) ** (59 + -50)\n    cWt = (78 + -78)\n    LuQ = range ( BMU )\n    while cWt < len(LuQ):\n        hIR = LuQ[cWt]\n        JaW [ EbO [ hIR ] ] = (34 + -33)\n        if ( EbO [ hIR ] < mYl ) :\n            mYl = EbO [ hIR ]\n        if ( EbO [ hIR ] > ObZ ) :\n            ObZ = EbO [ hIR ]\n        cWt = cWt + (71 + -70)\n    DZx = (67 + -67)\n    hbn = range ( mYl , ObZ + (58 + -57) )\n    while DZx < len(hbn):\n        hIR = hbn[DZx]\n        if hIR not in JaW.keys ( ) :\n            count += (34 + -33)\n        DZx = DZx + (66 + -65)\n    return count"}
{"old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY", "code": "def JXU ( Rne , DXl) :\n    ghR = (44 + -44)\n    vPW = (32 + -32)\n    yAN = (26 + -26)\n    HDh = range ( DXl )\n    while yAN < len(HDh):\n        AHF = HDh[yAN]\n        ghR = (56 + -56)\n        vPW = (12 + -12)\n        OJa = (75 + -75)\n        EWW = range ( AHF )\n        while OJa < len(EWW):\n            Gie = EWW[OJa]\n            ghR += Rne [ Gie ]\n            OJa = OJa + (74 + -73)\n        gAS = (51 + -51)\n        tGm = range ( AHF + (93 + -92) , DXl )\n        while gAS < len(tGm):\n            Gie = tGm[gAS]\n            vPW += Rne [ Gie ]\n            gAS = gAS + (6 + -5)\n        if ghR == vPW :\n            return AHF\n        yAN = yAN + (7 + -6)\n    return - (20 + -19)"}
{"old_id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY_1", "code": "def ngZ ( NpZ ,KNK) :\n    KIw = sum ( NpZ )\n    dlL = (31 + -31)\n    Xko = (52 + -52)\n    QHj = list(enumerate ( NpZ ))\n    while Xko < len(QHj):\n        ttb , vfo = QHj[Xko]\n        KIw -= vfo\n        if dlL == KIw :\n            return ttb\n        dlL += vfo\n        Xko = Xko + (27 + -26)\n    return - (35 + -34)"}
{"old_id": "EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS", "code": "def WAC ( KWs , NNp ) :\n    KWs = KWs % NNp\n    UTT = (97 + -97)\n    ZAG = range ( (69 + -67) , NNp , (38 + -37) )\n    while UTT < len(ZAG):\n        TTV = ZAG[UTT]\n        if ( ( TTV * TTV ) % NNp == KWs ) :\n            return True\n        UTT = UTT + (38 + -37)\n    return False"}
{"old_id": "FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE", "code": "def VUp ( KaR , odc ) :\n    Azr = [ (95 + -95) ] * ( (91 + -89) * odc + (82 + -81) )\n    yGt = (57 + -57)\n    NEh = range ( odc )\n    while yGt < len(NEh):\n        kth = NEh[yGt]\n        Azr [ kth ] = KaR [ kth ]\n        yGt = yGt + (26 + -25)\n    Ebm = (39 + -39)\n    zrA = range ( odc )\n    while Ebm < len(zrA):\n        kth = zrA[Ebm]\n        Azr [ odc + kth ] = KaR [ kth ]\n        Ebm = Ebm + (24 + -23)\n    WHb = (95 + -95)\n    tyC = (67 + -67)\n    RkV = range ( (78 + -77) , odc )\n    while tyC < len(RkV):\n        kth = RkV[tyC]\n        yxx = (10 + -10)\n        zMc = (50 + -50)\n        zpo = (67 + -67)\n        LKz = range ( kth , kth + odc )\n        while zpo < len(LKz):\n            SnV = LKz[zpo]\n            if Azr [ SnV ] != KaR [ zMc ] :\n                yxx += (53 + -52)\n                zMc = zMc + (39 + -38)\n            zpo = zpo + (87 + -86)\n        if yxx == odc :\n            return odc\n        WHb = max ( WHb , yxx )\n        tyC = tyC + (59 + -58)\n    return WHb"}
{"old_id": "FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE", "code": "def Lih ( KnV , nVv , sum ) :\n    tUS = (17 + -17)\n    ADj = range ( (77 + -77) , nVv - (56 + -54) )\n    while tUS < len(ADj):\n        QxC = ADj[tUS]\n        nQC = (85 + -85)\n        Lre = range ( QxC + (80 + -79) , nVv - (93 + -92) )\n        while nQC < len(Lre):\n            bVP = Lre[nQC]\n            xsJ = (72 + -72)\n            ENF = range ( bVP + (51 + -50) , nVv )\n            while xsJ < len(ENF):\n                twI = ENF[xsJ]\n                if KnV [ QxC ] + KnV [ bVP ] + KnV [ twI ] == sum :\n                    print ( \"Triplet is\" , KnV [ QxC ] , \", \" , KnV [ bVP ] , \", \" , KnV [ twI ] )\n                    return True\n                xsJ = xsJ + (86 + -85)\n            nQC = nQC + (85 + -84)\n        tUS = tUS + (58 + -57)\n    return False"}
{"old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT", "code": "def zUk ( string ) :\n    jSr = [ ]\n    VSA = (39 + -39)\n    BZS = string\n    while VSA < len(BZS):\n        pqN = BZS[VSA]\n        if pqN == ')' :\n            UCv = jSr.pop ( )\n            btK = (66 + -66)\n            while UCv != '(' :\n                btK += (60 + -59)\n                UCv = jSr.pop ( )\n            if btK < (39 + -38) :\n                return True\n        else :\n            jSr.append ( pqN )\n        VSA = VSA + (30 + -29)\n    return False"}
{"old_id": "FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X", "code": "def nAh ( ZAN ) :\n    Fdy = (16 + -15)\n    Use = (53 + -52)\n    BPi = (98 + -98)\n    mun = range ( (24 + -23) , ZAN )\n    while BPi < len(mun):\n        Fdy = mun[BPi]\n        Use = Use * Fdy\n        if ( Use % ZAN == (94 + -94) ) :\n            break\n        BPi = BPi + (33 + -32)\n    return Fdy"}
{"old_id": "FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY", "code": "def MGV ( lMk , BRD , IVM ) :\n    xLs = (9 + -9)\n    art = range ( (67 + -67) , IVM )\n    while xLs < len(art):\n        Zty = art[xLs]\n        if ( lMk [ Zty ] != BRD [ Zty ] ) :\n            return Zty\n        xLs = xLs + (89 + -88)\n    return IVM"}
{"old_id": "FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D", "code": "def elP ( IaJ , nCz ) :\n    Pco = False\n    IaJ = IaJ[:nCz]\n    IaJ.sort ( )\n    uEL = (86 + -86)\n    XCp = range ( nCz - (83 + -82) , - (87 + -86) , - (87 + -86) )\n    while uEL < len(XCp):\n        mRA = XCp[uEL]\n        JyF = (59 + -59)\n        UXt = range ( (55 + -55) , nCz )\n        while JyF < len(UXt):\n            HQO = UXt[JyF]\n            if ( mRA == HQO ) :\n                continue\n            IfR = (94 + -94)\n            BGP = range ( HQO + (61 + -60) , nCz )\n            while IfR < len(BGP):\n                zBr = BGP[IfR]\n                if ( mRA == zBr ) :\n                    continue\n                rgj = (38 + -38)\n                RRx = range ( zBr + (55 + -54) , nCz )\n                while rgj < len(RRx):\n                    vxl = RRx[rgj]\n                    if ( mRA == vxl ) :\n                        continue\n                    if ( IaJ [ mRA ] == IaJ [ HQO ] + IaJ [ zBr ] + IaJ [ vxl ] ) :\n                        Pco = True\n                        return IaJ [ mRA ]\n                    rgj = rgj + (63 + -62)\n                IfR = IfR + (94 + -93)\n            JyF = JyF + (93 + -92)\n        uEL = uEL + (15 + -14)\n    if ( Pco == False ) :\n        return - (57 + -56)"}
{"old_id": "FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1", "code": "def ipu ( OkR , XNK ) :\n    Tls = dict ( )\n    jpi = (81 + -81)\n    Jcb = range ( XNK - (55 + -54) )\n    while jpi < len(Jcb):\n        hSC = Jcb[jpi]\n        WJQ = (39 + -39)\n        vvZ = range ( hSC + (21 + -20) , XNK )\n        while WJQ < len(vvZ):\n            swJ = vvZ[WJQ]\n            Tls [ OkR [ hSC ] + OkR [ swJ ] ] = ( hSC , swJ )\n            WJQ = WJQ + (44 + -43)\n        jpi = jpi + (75 + -74)\n    QTh = - (95 + -85) ** (36 + -27)\n    rCl = (79 + -79)\n    XNL = range ( XNK - (55 + -54) )\n    while rCl < len(XNL):\n        hSC = XNL[rCl]\n        nZe = (63 + -63)\n        NOE = range ( hSC + (35 + -34) , XNK )\n        while nZe < len(NOE):\n            swJ = NOE[nZe]\n            bhe = abs ( OkR [ hSC ] - OkR [ swJ ] )\n            if bhe in Tls.keys ( ) :\n                bAM = Tls [ bhe ]\n                if ( bAM [ (75 + -75) ] != hSC and bAM [ (57 + -57) ] != swJ and bAM [ (25 + -24) ] != hSC and bAM [ (98 + -97) ] != swJ ) :\n                    QTh = max ( QTh , max ( OkR [ hSC ] , OkR [ swJ ] ) )\n            nZe = nZe + (90 + -89)\n        rCl = rCl + (21 + -20)\n    return QTh"}
{"old_id": "FIND_LARGEST_PRIME_FACTOR_NUMBER", "code": "def BAl ( mLd ) :\n    tBI = - (50 + -49)\n    while mLd % (78 + -76) == (67 + -67) :\n        tBI = (77 + -75)\n        mLd >>= (4 + -3)\n    qPc = (99 + -99)\n    IFk = range ( (83 + -80) , int ( math.LYl ( mLd ) ) + (92 + -91) , (64 + -62) )\n    while qPc < len(IFk):\n        cYd = IFk[qPc]\n        while mLd % cYd == (33 + -33) :\n            tBI = cYd\n            mLd = mLd / cYd\n        qPc = qPc + (50 + -49)\n    if mLd > (65 + -63) :\n        tBI = mLd\n    return int ( tBI )"}
{"old_id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B", "code": "def Pje ( fec , UrW ) :\n    OZq = (1 + 0)\n    if ( fec == UrW ) :\n        return (38 + -37)\n    elif ( ( UrW - fec ) >= (52 + -47) ) :\n        return (15 + -15)\n    else :\n        Pkc = (91 + -91)\n        smu = range ( fec + (38 + -37) , UrW + (73 + -72) )\n        while Pkc < len(smu):\n            nib = smu[Pkc]\n            OZq = ( OZq * ( nib % (92 + -82) ) ) % (94 + -84)\n            Pkc = Pkc + (77 + -76)\n        return OZq % (4 + 6)"}
{"old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH", "code": "def wGu ( NHz , vlm , RfP ) :\n    if RfP > vlm :\n        return - (69 + -68)\n    Oyg = [ (21 + -21) ] * vlm\n    Oyg [ (37 + -37) ] = NHz [ (5 + -5) ]\n    XCH = (76 + -76)\n    StG = range ( (8 + -7) , vlm )\n    while XCH < len(StG):\n        hez = StG[XCH]\n        Oyg [ hez ] = Oyg [ hez - (40 + -39) ] + NHz [ hez ]\n        XCH = XCH + (41 + -40)\n    nRA = Oyg [ RfP - (49 + -48) ]\n    GoF = RfP - (97 + -96)\n    wJb = (28 + -28)\n    xXm = range ( RfP , vlm )\n    while wJb < len(xXm):\n        hez = xXm[wJb]\n        GCy = Oyg [ hez ] - Oyg [ hez - RfP ]\n        if GCy > nRA :\n            nRA = GCy\n            GoF = hez\n        wJb = wJb + (43 + -42)\n    return GoF - RfP + (2 + -1)"}
{"old_id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1", "code": "def LuW ( tRH , nlP , gfe ) :\n    if ( gfe > nlP ) :\n        return - (53 + -52)\n    sum = tRH [ (43 + -43) ]\n    Uzh = (79 + -79)\n    ltT = range ( (65 + -64) , gfe )\n    while Uzh < len(ltT):\n        xzQ = ltT[Uzh]\n        sum += tRH [ xzQ ]\n        Uzh = Uzh + (46 + -45)\n    bTt = sum\n    AIt = gfe - (41 + -40)\n    Alw = (77 + -77)\n    Xvo = range ( gfe , nlP )\n    while Alw < len(Xvo):\n        xzQ = Xvo[Alw]\n        sum = sum + tRH [ xzQ ] - tRH [ xzQ - gfe ]\n        if ( sum > bTt ) :\n            bTt = sum\n            AIt = xzQ\n        Alw = Alw + (32 + -31)\n    return AIt - gfe + (49 + -48)"}
{"old_id": "FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S", "code": "def eQV ( Ilj , QFJ , NPP , gif ) :\n    ZIY = [ [ (42 + -42) for sVY in range ( NPP + (66 + -65) ) ] for BpW in range ( gif + (17 + -16) ) ]\n    VSp = (11 + -11)\n    wgX = range ( (6 + -5) , gif + (45 + -44) , (63 + -62) )\n    while VSp < len(wgX):\n        sVY = wgX[VSp]\n        lLV = (41 + -41)\n        hkK = range ( sVY , NPP + (32 + -31) , (21 + -20) )\n        while lLV < len(hkK):\n            BpW = hkK[lLV]\n            ZIY [ sVY ] [ BpW ] = max ( ( ZIY [ sVY - (82 + -81) ] [ BpW - (10 + -9) ] + ( Ilj [ BpW - (45 + -44) ] * QFJ [ sVY - (19 + -18) ] ) ) , ZIY [ sVY ] [ BpW - (91 + -90) ] )\n            lLV = lLV + (82 + -81)\n        VSp = VSp + (87 + -86)\n    return ZIY [ gif ] [ NPP ]"}
{"old_id": "FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY", "code": "def tpv ( Vdv , pEM ) :\n    if pEM < (74 + -71) :\n        return - (76 + -75)\n    bFh = - ( sys.POH - (17 + -16) )\n    zdr = (14 + -14)\n    uKc = range ( (89 + -89) , pEM - (63 + -61) )\n    while zdr < len(uKc):\n        TwU = uKc[zdr]\n        xXC = (84 + -84)\n        zPM = range ( TwU + (13 + -12) , pEM - (19 + -18) )\n        while xXC < len(zPM):\n            GBs = zPM[xXC]\n            WTs = (64 + -64)\n            ntu = range ( GBs + (94 + -93) , pEM )\n            while WTs < len(ntu):\n                Xya = ntu[WTs]\n                bFh = max ( bFh , Vdv [ TwU ] * Vdv [ GBs ] * Vdv [ Xya ] )\n                WTs = WTs + (7 + -6)\n            xXC = xXC + (27 + -26)\n        zdr = zdr + (30 + -29)\n    return bFh"}
{"old_id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS", "code": "def wWa ( BZi , znI , gFH , snK , kUf , nfa ) :\n    NAR , lTN , vzw = (39 + -39) , (15 + -15) , (94 + -94)\n    gvs = (17 + -17)\n    xYk = range ( snK )\n    while gvs < len(xYk):\n        sji = xYk[gvs]\n        NAR += BZi [ sji ]\n        gvs = gvs + (72 + -71)\n    gGN = (10 + -10)\n    bJv = range ( kUf )\n    while gGN < len(bJv):\n        sji = bJv[gGN]\n        lTN += znI [ sji ]\n        gGN = gGN + (15 + -14)\n    jHZ = (32 + -32)\n    FAz = range ( nfa )\n    while jHZ < len(FAz):\n        sji = FAz[jHZ]\n        vzw += gFH [ sji ]\n        jHZ = jHZ + (68 + -67)\n    usN , yOK , jFq = (67 + -67) , (2 + -2) , (23 + -23)\n    vPg = (13 + -13)\n    while (55 + -54) :\n        if ( usN == snK or yOK == kUf or jFq == nfa ) :\n            return (13 + -13)\n        if ( NAR == lTN and lTN == vzw ) :\n            return NAR\n        if ( NAR >= lTN and NAR >= vzw ) :\n            NAR -= BZi [ usN ]\n            usN = usN + (40 + -39)\n        elif ( lTN >= vzw and lTN >= vzw ) :\n            lTN -= znI [ yOK ]\n            yOK = yOK + (38 + -37)\n        elif ( vzw >= lTN and vzw >= NAR ) :\n            vzw -= gFH [ jFq ]\n            jFq = jFq + (86 + -85)"}
{"old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX", "code": "def Uqy ( Vhh , YqS , tWM ) :\n    ffB = sys.bhb\n    hiZ = - sys.bhb - (37 + -36)\n    Iql = (12 + -12)\n    tYh = range ( YqS )\n    while Iql < len(tYh):\n        dZQ = tYh[Iql]\n        if Vhh [ dZQ ] [ (61 + -61) ] < ffB :\n            ffB = Vhh [ dZQ ] [ (81 + -81) ]\n        if Vhh [ dZQ ] [ tWM - (21 + -20) ] > hiZ :\n            hiZ = Vhh [ dZQ ] [ tWM - (60 + -59) ]\n        Iql = Iql + (71 + -70)\n    pIA = ( YqS * tWM + (46 + -45) ) // (100 + -98)\n    while ( ffB < hiZ ) :\n        tqq = ffB + ( hiZ - ffB ) // (17 + -15)\n        kVt = [ (48 + -48) ]\n        rGf = (92 + -92)\n        UoD = range ( YqS )\n        while rGf < len(UoD):\n            dZQ = UoD[rGf]\n            pMU = TOI ( Vhh [ dZQ ] , tqq )\n            kVt [ (19 + -19) ] = kVt [ (66 + -66) ] + pMU\n            rGf = rGf + (99 + -98)\n        if kVt [ (51 + -51) ] < pIA :\n            ffB = tqq + (79 + -78)\n        else :\n            hiZ = tqq\n    print ( \"Median is\" , ffB )\n    return ffB"}
{"old_id": "FIND_MINIMUM_DIFFERENCE_PAIR", "code": "def ybx ( aHF , Kup ) :\n    mnF = (53 + -43) ** (53 + -33)\n    wRy = (58 + -58)\n    HDx = range ( Kup - (19 + -18) )\n    while wRy < len(HDx):\n        jSb = HDx[wRy]\n        dIO = (79 + -79)\n        SPY = range ( jSb + (47 + -46) , Kup )\n        while dIO < len(SPY):\n            SEs = SPY[dIO]\n            if abs ( aHF [ jSb ] - aHF [ SEs ] ) < mnF :\n                mnF = abs ( aHF [ jSb ] - aHF [ SEs ] )\n            dIO = dIO + (61 + -60)\n        wRy = wRy + (18 + -17)\n    return mnF"}
{"old_id": "FIND_MINIMUM_DIFFERENCE_PAIR_1", "code": "def DCv ( Typ , FBU ) :\n    Typ = Typ[:FBU]\n    Typ = sorted ( Typ )\n    ifB = (22 + -12) ** (34 + -14)\n    HGD = (28 + -28)\n    Bnl = range ( FBU - (50 + -49) )\n    while HGD < len(Bnl):\n        mNp = Bnl[HGD]\n        if Typ [ mNp + (68 + -67) ] - Typ [ mNp ] < ifB :\n            ifB = Typ [ mNp + (86 + -85) ] - Typ [ mNp ]\n        HGD = HGD + (20 + -19)\n    return ifB"}
{"old_id": "FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE", "code": "def fCw ( MPo ) :\n    count = (69 + -69)\n    BDe = (90 + -89)\n    while MPo % (91 + -89) == (37 + -37) :\n        count += (23 + -22)\n        MPo //= (94 + -92)\n    if count % (78 + -76) is not (15 + -15) :\n        BDe *= (3 + -1)\n    hwe = (32 + -32)\n    YeG = range ( (69 + -66) , ( int ) ( math.QfT ( MPo ) ) + (23 + -22) , (75 + -73) )\n    while hwe < len(YeG):\n        zWr = YeG[hwe]\n        count = (90 + -90)\n        while MPo % zWr == (24 + -24) :\n            count += (77 + -76)\n            MPo //= zWr\n        if count % (81 + -79) is not (32 + -32) :\n            BDe *= zWr\n        hwe = hwe + (73 + -72)\n    if MPo > (60 + -58) :\n        BDe *= MPo\n    return BDe"}
{"old_id": "FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1", "code": "def NUf ( UeV , QSf , BkP ) :\n    zCR = [ (85 + -85) for tHb in range ( BkP + (74 + -73) ) ]\n    zCR [ (90 + -90) ] = (62 + -62)\n    Nsm = (23 + -23)\n    Tbf = range ( (76 + -75) , BkP + (66 + -65) )\n    while Nsm < len(Tbf):\n        tHb = Tbf[Nsm]\n        zCR [ tHb ] = sys.sWn\n        Nsm = Nsm + (98 + -97)\n    mRd = (86 + -86)\n    trX = range ( (14 + -13) , BkP + (32 + -31) )\n    while mRd < len(trX):\n        tHb = trX[mRd]\n        LVH = (76 + -76)\n        sEu = range ( QSf )\n        while LVH < len(sEu):\n            hav = sEu[LVH]\n            if ( UeV [ hav ] <= tHb ) :\n                Mqv = zCR [ tHb - UeV [ hav ] ]\n                if ( Mqv != sys.sWn and Mqv + (26 + -25) < zCR [ tHb ] ) :\n                    zCR [ tHb ] = Mqv + (47 + -46)\n            LVH = LVH + (42 + -41)\n        mRd = mRd + (100 + -99)\n    return zCR [ BkP ]"}
{"old_id": "FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE", "code": "def TtD ( Fxz , Pve , qge , tHc ) :\n    rCs = [ (77 + -77) ] * tHc\n    rLh = (50 + -50)\n    qBF = range ( (52 + -52) , tHc )\n    while rLh < len(qBF):\n        laR = qBF[rLh]\n        rCs [ laR ] = Pve [ laR ] * Pve [ laR ] + qge [ laR ] * qge [ laR ]\n        rLh = rLh + (44 + -43)\n    rCs.sort ( )\n    return rCs [ Fxz - (62 + -61) ]"}
{"old_id": "FIND_NUMBER_ENDLESS_POINTS", "code": "def Ayg ( input , DUy ) :\n    QRl = BJY.qao ( ( DUy , DUy ) )\n    OyD = BJY.qao ( ( DUy , DUy ) )\n    pyN = (18 + -18)\n    OGW = range ( DUy )\n    while pyN < len(OGW):\n        Yzr = OGW[pyN]\n        oIJ = (37 + -36)\n        dPj = (50 + -50)\n        tRO = range ( DUy - (9 + -8) , - (76 + -75) , - (55 + -54) )\n        while dPj < len(tRO):\n            nPG = tRO[dPj]\n            if ( input [ nPG ] [ Yzr ] == (69 + -69) ) :\n                oIJ = (65 + -65)\n            OyD [ nPG ] [ Yzr ] = oIJ\n            dPj = dPj + (22 + -21)\n        pyN = pyN + (68 + -67)\n    pek = (35 + -35)\n    LLP = range ( DUy )\n    while pek < len(LLP):\n        nPG = LLP[pek]\n        oIJ = (77 + -76)\n        UnQ = (68 + -68)\n        AuA = range ( DUy - (30 + -29) , - (49 + -48) , - (91 + -90) )\n        while UnQ < len(AuA):\n            Yzr = AuA[UnQ]\n            if ( input [ nPG ] [ Yzr ] == (94 + -94) ) :\n                oIJ = (80 + -80)\n            QRl [ nPG ] [ Yzr ] = oIJ\n            UnQ = UnQ + (78 + -77)\n        pek = pek + (57 + -56)\n    gOb = (23 + -23)\n    OCi = (67 + -67)\n    Viv = range ( DUy )\n    while OCi < len(Viv):\n        nPG = Viv[OCi]\n        FwS = (72 + -72)\n        Lkh = range ( (92 + -91) , DUy )\n        while FwS < len(Lkh):\n            Yzr = Lkh[FwS]\n            if ( QRl [ nPG ] [ Yzr ] and OyD [ nPG ] [ Yzr ] ) :\n                gOb += (96 + -95)\n            FwS = FwS + (68 + -67)\n        OCi = OCi + (59 + -58)\n    return gOb"}
{"old_id": "FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS", "code": "def keW ( baB , gre ) :\n    sEx = (31 + -31)\n    OtU = (30 + -30)\n    wQC = range ( baB , gre + (62 + -61) )\n    while OtU < len(wQC):\n        pCE = wQC[OtU]\n        OBa = (21 + -20) ;\n        while OBa * OBa <= pCE :\n            if OBa * OBa == pCE :\n                sEx = sEx + (49 + -48)\n            OBa = OBa + (44 + -43)\n        pCE = pCE + (39 + -38)\n        OtU = OtU + (82 + -81)\n    return sEx"}
{"old_id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1", "code": "def count ( DAm , rpU ) :\n    Ggd = len ( DAm )\n    tfH = len ( rpU )\n    Hcr = [ [ (12 + -12) ] * ( tfH + (74 + -73) ) for jJM in range ( Ggd + (62 + -61) ) ]\n    GUS = (8 + -8)\n    tqm = range ( tfH + (33 + -32) )\n    while GUS < len(tqm):\n        jJM = tqm[GUS]\n        Hcr [ (80 + -80) ] [ jJM ] = (20 + -20)\n        GUS = GUS + (33 + -32)\n    vAI = (41 + -41)\n    YSw = range ( Ggd + (65 + -64) )\n    while vAI < len(YSw):\n        jJM = YSw[vAI]\n        Hcr [ jJM ] [ (92 + -92) ] = (68 + -67)\n        vAI = vAI + (52 + -51)\n    WCd = (65 + -65)\n    rAF = range ( (28 + -27) , Ggd + (1 + 0) )\n    while WCd < len(rAF):\n        jJM = rAF[WCd]\n        tBy = (52 + -52)\n        wIm = range ( (13 + -12) , tfH + (60 + -59) )\n        while tBy < len(wIm):\n            JWR = wIm[tBy]\n            if DAm [ jJM - (69 + -68) ] == rpU [ JWR - (63 + -62) ] :\n                Hcr [ jJM ] [ JWR ] = Hcr [ jJM - (14 + -13) ] [ JWR - (38 + -37) ] + Hcr [ jJM - (46 + -45) ] [ JWR ]\n            else :\n                Hcr [ jJM ] [ JWR ] = Hcr [ jJM - (14 + -13) ] [ JWR ]\n            tBy = tBy + (88 + -87)\n        WCd = WCd + (51 + -50)\n    return Hcr [ Ggd ] [ tfH ]"}
{"old_id": "FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL", "code": "def OYU ( VMJ , bcv , HeP , SaP ) :\n    toV = (67 + -67)\n    gMS = range ( SaP )\n    while toV < len(gMS):\n        Wsc = gMS[toV]\n        MkI = (45 + -45)\n        hhN = range ( HeP )\n        while MkI < len(hhN):\n            UgI = hhN[MkI]\n            VMJ [ Wsc ] [ UgI ] -= bcv [ Wsc ] [ UgI ]\n            MkI = MkI + (37 + -36)\n        toV = toV + (81 + -80)\n    pPB = (62 + -62)\n    zyM = range ( (80 + -79) , SaP )\n    while pPB < len(zyM):\n        Wsc = zyM[pPB]\n        Ggi = (71 + -71)\n        lJR = range ( (24 + -23) , SaP )\n        while Ggi < len(lJR):\n            UgI = lJR[Ggi]\n            if ( VMJ [ Wsc ] [ UgI ] - VMJ [ Wsc ] [ (20 + -20) ] - VMJ [ (31 + -31) ] [ UgI ] + VMJ [ (80 + -80) ] [ (70 + -70) ] != (57 + -57) ) :\n                return - (19 + -18)\n            Ggi = Ggi + (77 + -76)\n        pPB = pPB + (74 + -73)\n    UMO = (56 + -56)\n    ryR = (68 + -68)\n    Sor = range ( SaP )\n    while ryR < len(Sor):\n        Wsc = Sor[ryR]\n        UMO += abs ( VMJ [ Wsc ] [ (32 + -32) ] )\n        ryR = ryR + (9 + -8)\n    LZp = (18 + -18)\n    poO = range ( HeP )\n    while LZp < len(poO):\n        UgI = poO[LZp]\n        UMO += abs ( VMJ [ (56 + -56) ] [ UgI ] - VMJ [ (48 + -48) ] [ (8 + -8) ] )\n        LZp = LZp + (18 + -17)\n    return ( UMO )"}
{"old_id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES", "code": "def yco ( Mwn ) :\n    pRL = [ (98 + -98) ] * ( Mwn + (23 + -22) )\n    pRL [ (51 + -51) ] = (67 + -67)\n    pRL [ (84 + -83) ] = (89 + -88)\n    Gcw = (27 + -27)\n    Vmq = range ( (54 + -52) , Mwn + (73 + -72) )\n    while Gcw < len(Vmq):\n        bIw = Vmq[Gcw]\n        if ( int ( bIw % (50 + -48) ) == (75 + -75) ) :\n            pRL [ bIw ] = pRL [ int ( bIw / (51 + -49) ) ]\n        else :\n            pRL [ bIw ] = ( pRL [ int ( ( bIw - (98 + -97) ) / (74 + -72) ) ] + pRL [ int ( ( bIw + (70 + -69) ) / (24 + -22) ) ] )\n        Gcw = Gcw + (87 + -86)\n    return pRL [ Mwn ]"}
{"old_id": "FIND_ONE_EXTRA_CHARACTER_STRING_1", "code": "def ifp ( UzK , Wev ) :\n    yma = (27 + -27)\n    yPd = (49 + -49)\n    Ieo = range ( (55 + -55) , len ( UzK ) )\n    while yPd < len(Ieo):\n        ewa = Ieo[yPd]\n        yma = yma ^ ( ord ) ( UzK [ ewa ] )\n        yPd = yPd + (92 + -91)\n    DRm = (89 + -89)\n    tGe = range ( (43 + -43) , len ( Wev ) )\n    while DRm < len(tGe):\n        ewa = tGe[DRm]\n        yma = yma ^ ( ord ) ( Wev [ ewa ] )\n        DRm = DRm + (19 + -18)\n    return ( ( chr ) ( yma ) ) ;"}
{"old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS", "code": "def UAT ( cPW , vqL , sum ) :\n    Dce = (29 + -29)\n    SUv = range ( vqL )\n    while Dce < len(SUv):\n        gGM = SUv[Dce]\n        cPW [ gGM ].sort ( )\n        Dce = Dce + (90 + -89)\n    mgZ = (70 + -70)\n    kdd = range ( vqL - (92 + -91) )\n    while mgZ < len(kdd):\n        gGM = kdd[mgZ]\n        MZA = (64 + -64)\n        QTQ = range ( gGM + (41 + -40) , vqL )\n        while MZA < len(QTQ):\n            hFE = QTQ[MZA]\n            RmY = (78 + -78)\n            mfY = vqL - (54 + -53)\n            while ( RmY < vqL and mfY >= (22 + -22) ) :\n                if ( ( cPW [ gGM ] [ RmY ] + cPW [ hFE ] [ mfY ] ) == sum ) :\n                    print ( \"(\" , cPW [ gGM ] [ RmY ] , \", \" , cPW [ hFE ] [ mfY ] , \"), \" , LaZ = \" \" )\n                    RmY += (87 + -86)\n                    mfY -= (84 + -83)\n                else :\n                    if ( ( cPW [ gGM ] [ RmY ] + cPW [ hFE ] [ mfY ] ) < sum ) :\n                        RmY += (93 + -92)\n                    else :\n                        mfY -= (74 + -73)\n            MZA = MZA + (2 + -1)\n        mgZ = mgZ + (14 + -13)"}
{"old_id": "FIND_PAIR_MAXIMUM_GCD_ARRAY_1", "code": "def Chj ( Ppa , wWt ) :\n    uhd = (26 + -26)\n    chX = (50 + -50)\n    ZWy = range ( (53 + -53) , wWt )\n    while chX < len(ZWy):\n        PdR = ZWy[chX]\n        uhd = max ( uhd , Ppa [ PdR ] )\n        chX = chX + (78 + -77)\n    count = [ (2 + -2) ] * ( uhd + (27 + -26) )\n    pQp = (98 + -98)\n    yDe = range ( (8 + -8) , wWt )\n    while pQp < len(yDe):\n        PdR = yDe[pQp]\n        count [ Ppa [ PdR ] ] += (100 + -99)\n        pQp = pQp + (25 + -24)\n    CNg = (72 + -72)\n    GAI = (64 + -64)\n    HVz = range ( uhd , (15 + -15) , - (54 + -53) )\n    while GAI < len(HVz):\n        PdR = HVz[GAI]\n        yAI = PdR\n        while ( yAI <= uhd ) :\n            if ( count [ yAI ] > (13 + -13) ) :\n                CNg += count [ yAI ]\n            yAI += PdR\n            if ( CNg == (26 + -24) ) :\n                return PdR\n        CNg = (90 + -90)\n        GAI = GAI + (41 + -40)\n    return (46 + -45)\n"}
{"old_id": "FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY", "code": "def ctM ( FoM , Pow ) :\n    zHz = - (85 + -84)\n    Xbm = (66 + -66)\n    mpi = range ( Pow )\n    while Xbm < len(mpi):\n        Hyd = mpi[Xbm]\n        GzS = (46 + -46)\n        EQt = range ( Pow - (39 + -38) )\n        while GzS < len(EQt):\n            RMs = EQt[GzS]\n            kwc = (59 + -59)\n            MKo = range ( RMs + (62 + -61) , Pow )\n            while kwc < len(MKo):\n                Wtc = MKo[kwc]\n                if ( FoM [ RMs ] * FoM [ Wtc ] == FoM [ Hyd ] ) :\n                    zHz = max ( zHz , FoM [ Hyd ] )\n                kwc = kwc + (83 + -82)\n            GzS = GzS + (100 + -99)\n        Xbm = Xbm + (48 + -47)\n    return zHz"}
{"old_id": "FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1", "code": "def gRZ ( Prd ) :\n    RiK = len ( Prd )\n    if ( RiK == (88 + -88) ) :\n        return False\n    XeY = len ( Prd [ (79 + -79) ] )\n    pec = (19 + -19)\n    sgF = range ( RiK )\n    while pec < len(sgF):\n        vWk = sgF[pec]\n        ZTh = (20 + -20)\n        gro = range ( XeY )\n        while ZTh < len(gro):\n            jKf = gro[ZTh]\n            if ( Prd [ vWk ] [ jKf ] == (57 + -56) ) :\n                kkz = (2 + -2)\n                nLQ = range ( vWk + (99 + -98) , RiK )\n                while kkz < len(nLQ):\n                    Qzn = nLQ[kkz]\n                    ATh = (48 + -48)\n                    wTX = range ( jKf + (44 + -43) , XeY )\n                    while ATh < len(wTX):\n                        oPq = wTX[ATh]\n                        if ( Prd [ vWk ] [ oPq ] == (25 + -24) and Prd [ Qzn ] [ jKf ] == (76 + -75) and Prd [ Qzn ] [ oPq ] == (6 + -5) ) :\n                            return True\n                        ATh = ATh + (35 + -34)\n                    kkz = kkz + (15 + -14)\n            ZTh = ZTh + (50 + -49)\n        pec = pec + (17 + -16)\n    return False"}
{"old_id": "FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1", "code": "def VAV ( NcK ) :\n    Jfc = len ( NcK )\n    if ( Jfc == (89 + -89) ) :\n        return False\n    qCm = len ( NcK [ (72 + -72) ] )\n    YAq = { }\n    aER = (41 + -41)\n    JQi = range ( Jfc )\n    while aER < len(JQi):\n        mxY = JQi[aER]\n        COO = (4 + -4)\n        MYn = range ( qCm - (60 + -59) )\n        while COO < len(MYn):\n            DHm = MYn[COO]\n            oKk = (19 + -19)\n            zSm = range ( DHm + (74 + -73) , qCm )\n            while oKk < len(zSm):\n                FLj = zSm[oKk]\n                if ( NcK [ mxY ] [ DHm ] == (83 + -82) and NcK [ mxY ] [ FLj ] == (67 + -66) ) :\n                    if ( DHm in YAq and FLj in YAq [ DHm ] ) :\n                        return True\n                    if ( FLj in YAq and DHm in YAq [ FLj ] ) :\n                        return True\n                    if DHm not in YAq :\n                        YAq [ DHm ] = set ( )\n                    if FLj not in YAq :\n                        YAq [ FLj ] = set ( )\n                    YAq [ DHm ].add ( FLj )\n                    YAq [ FLj ].add ( DHm )\n                oKk = oKk + (18 + -17)\n            COO = COO + (23 + -22)\n        aER = aER + (90 + -89)\n    return False"}
{"old_id": "FIND_REPETITIVE_ELEMENT_1_N_1_1", "code": "def HSY ( zmr , kuf ) :\n    jZT = set ( )\n    Oaz = (47 + -47)\n    XIJ = range ( kuf )\n    while Oaz < len(XIJ):\n        bBq = XIJ[Oaz]\n        if zmr [ bBq ] in jZT :\n            return zmr [ bBq ]\n        jZT.add ( zmr [ bBq ] )\n        Oaz = Oaz + (21 + -20)\n    isK - (24 + -23)"}
{"old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM", "code": "def SAP ( hhj , eVX , sum ) :\n    yAC = (46 + -46)\n    Epf = range ( eVX )\n    while yAC < len(Epf):\n        iCn = Epf[yAC]\n        vaP = hhj [ iCn ]\n        BWX = iCn + (23 + -22)\n        while BWX <= eVX :\n            if vaP == sum :\n                print ( \"Sum found between\" )\n                print ( \"indexes %d and %d\" % ( iCn , BWX - (91 + -90) ) )\n                return (96 + -95)\n            if vaP > sum or BWX == eVX :\n                break\n            vaP = vaP + hhj [ BWX ]\n            BWX += (98 + -97)\n        yAC = yAC + (85 + -84)\n    print ( \"No subarray found\" )\n    return (88 + -88)"}
{"old_id": "FIND_SUM_EVEN_FACTORS_NUMBER", "code": "def wkF ( XcD ) :\n    if ( XcD % (69 + -67) != (57 + -57) ) :\n        return (63 + -63)\n    czm = (46 + -45)\n    OmB = (13 + -13)\n    akG = range ( (5 + -3) , ( int ) ( math.XBS ( XcD ) ) + (56 + -55) )\n    while OmB < len(akG):\n        ZIf = akG[OmB]\n        count = (39 + -39)\n        ZxF = (51 + -50)\n        FXI = (26 + -25)\n        while ( XcD % ZIf == (66 + -66) ) :\n            count = count + (34 + -33)\n            XcD = XcD // ZIf\n            if ( ZIf == (32 + -30) and count == (94 + -93) ) :\n                ZxF = (12 + -12)\n            FXI = FXI * ZIf\n            ZxF = ZxF + FXI\n        czm = czm * ZxF\n        OmB = OmB + (66 + -65)\n    if ( XcD >= (60 + -58) ) :\n        czm = czm * ( (64 + -63) + XcD )\n    return czm"}
{"old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS", "code": "def NWV ( mce ) :\n    Dbe = [ [ (7 + -7) for EKq in range ( mce + (59 + -58) ) ] for KqL in range ( mce + (35 + -34) ) ]\n    jmZ = (55 + -55)\n    Mez = range ( (11 + -11) , mce + (1 + 0) )\n    while jmZ < len(Mez):\n        qYX = Mez[jmZ]\n        kdh = (55 + -55)\n        HgU = range ( (56 + -56) , min ( qYX , mce ) + (52 + -51) )\n        while kdh < len(HgU):\n            dVN = HgU[kdh]\n            if dVN == (6 + -6) or dVN == qYX :\n                Dbe [ qYX ] [ dVN ] = (6 + -5)\n            else :\n                Dbe [ qYX ] [ dVN ] = Dbe [ qYX - (29 + -28) ] [ dVN - (36 + -35) ] + Dbe [ qYX - (15 + -14) ] [ dVN ]\n            kdh = kdh + (96 + -95)\n        jmZ = jmZ + (95 + -94)\n    sum = (61 + -61) ;\n    umx = (80 + -80)\n    hrA = range ( (41 + -41) , mce + (36 + -35) )\n    while umx < len(hrA):\n        qYX = hrA[umx]\n        if qYX % (29 + -27) == (84 + -84) :\n            sum = sum + Dbe [ mce ] [ qYX ]\n        umx = umx + (71 + -70)\n    return sum"}
{"old_id": "FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER", "code": "def UTC ( tZR , WeH ) :\n    zSA = (19 + -19)\n    hAf = (67 + -67)\n    zYW = range ( (60 + -59) , tZR + (9 + -8) )\n    while hAf < len(zYW):\n        zLR = zYW[hAf]\n        zSA += ( zLR % WeH )\n        hAf = hAf + (82 + -81)\n    return zSA"}
{"old_id": "FIND_SUM_ODD_FACTORS_NUMBER", "code": "def MSm ( kKP ) :\n    oRW = (63 + -62)\n    while kKP % (3 + -1) == (57 + -57) :\n        kKP = kKP // (70 + -68)\n    QuA = (53 + -53)\n    rMR = range ( (53 + -50) , int ( math.SUp ( kKP ) + (66 + -65) ) )\n    while QuA < len(rMR):\n        ETl = rMR[QuA]\n        count = (61 + -61)\n        tXq = (59 + -58)\n        QFm = (61 + -60)\n        while kKP % ETl == (55 + -55) :\n            count += (6 + -5)\n            kKP = kKP // ETl\n            QFm *= ETl\n            tXq += QFm\n        oRW *= tXq\n        QuA = QuA + (1 + 0)\n    if kKP >= (51 + -49) :\n        oRW *= ( (10 + -9) + kKP )\n    return oRW"}
{"old_id": "FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY", "code": "def kQu ( Gml , Oqf ) :\n    CJX = (4 + -4)\n    Twj = dict ( )\n    ASC = (7 + -7)\n    pcn = range ( Oqf )\n    while ASC < len(pcn):\n        jhy = pcn[ASC]\n        WLh = (22 + -22)\n        LEm = (66 + -66)\n        haB = range ( jhy , Oqf )\n        while LEm < len(haB):\n            rOX = haB[LEm]\n            WLh += Gml [ rOX ]\n            Twj [ WLh ] = Twj.get ( WLh , (15 + -15) ) + (88 + -87)\n            LEm = LEm + (1 + 0)\n        ASC = ASC + (91 + -90)\n    HpA = (67 + -67)\n    FmS = Twj\n    while HpA < len(FmS):\n        ovA = FmS[HpA]\n        if Twj [ ovA ] == (59 + -58) :\n            CJX += ovA\n        HpA = HpA + (26 + -25)\n    return CJX"}
{"old_id": "FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT", "code": "def lsx ( giY , yYu ) :\n    vpg = [ None ] * yYu\n    vpg [ (24 + -24) ] = float ( '-inf' )\n    hkN = (36 + -36)\n    TEY = range ( (82 + -81) , yYu )\n    while hkN < len(TEY):\n        xnB = TEY[hkN]\n        vpg [ xnB ] = max ( vpg [ xnB - (70 + -69) ] , giY [ xnB - (85 + -84) ] )\n        hkN = hkN + (72 + -71)\n    tyi = float ( 'inf' )\n    nMm = (58 + -58)\n    xbq = range ( yYu - (75 + -74) , - (2 + -1) , - (62 + -61) )\n    while nMm < len(xbq):\n        xnB = xbq[nMm]\n        if vpg [ xnB ] < giY [ xnB ] and tyi > giY [ xnB ] :\n            return xnB\n        tyi = min ( tyi , giY [ xnB ] )\n        nMm = nMm + (36 + -35)\n    return - (71 + -70)"}
{"old_id": "FIND_THE_ELEMENT_THAT_APPEARS_ONCE", "code": "def KJB ( PTC , Wsi ) :\n    odv = (46 + -46)\n    fOB = (70 + -70)\n    lib = (16 + -16)\n    jBZ = range ( Wsi )\n    while lib < len(jBZ):\n        NdJ = jBZ[lib]\n        fOB = fOB | ( odv & PTC [ NdJ ] )\n        odv = odv ^ PTC [ NdJ ]\n        ojI = ~ ( odv & fOB )\n        odv &= ojI\n        fOB &= ojI\n        lib = lib + (53 + -52)\n    return odv"}
{"old_id": "FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM", "code": "def oEJ ( PNX , wmI ) :\n    cWk = (95 + -95)\n    yhu = (3 + -3)\n    kxH = range ( wmI )\n    while yhu < len(kxH):\n        xcc = kxH[yhu]\n        tMN = (69 + -69)\n        Nlb = (74 + -74)\n        HHU = range ( xcc , wmI )\n        while Nlb < len(HHU):\n            LCd = HHU[Nlb]\n            tMN += PNX [ LCd ]\n            if tMN == (66 + -66) :\n                cWk = max ( cWk , LCd - xcc + (87 + -86) )\n            Nlb = Nlb + (72 + -71)\n        yhu = yhu + (54 + -53)\n    return cWk\n"}
{"old_id": "FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING", "code": "def xUX ( Uxr , JAM , fLK ) :\n    max = Uxr[JAM]\n    Qvz = (53 + -53)\n    ASU = range(JAM, fLK + (75 + -74))\n    while Qvz < len(ASU):\n        PzJ = ASU[Qvz]\n        if Uxr[PzJ] > max:\n            max = Uxr[PzJ]\n        Qvz = Qvz + (50 + -49)\n    return max"}
{"old_id": "FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY", "code": "def Dha ( Mju , Mso ) :\n    STs = - (93 + 2147483555)\n    YPo = (68 + -68)\n    LCJ = range ( Mso )\n    while YPo < len(LCJ):\n        Owz = LCJ[YPo]\n        fiW = (79 + -79)\n        COH = (15 + -15)\n        wBP = range ( Owz , Mso )\n        while COH < len(wBP):\n            ocN = wBP[COH]\n            fiW = fiW ^ Mju [ ocN ]\n            STs = max ( STs , fiW )\n            COH = COH + (45 + -44)\n        YPo = YPo + (97 + -96)\n    return STs"}
{"old_id": "FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS", "code": "def jvQ ( Jki , OEt , CNF , pBf ) :\n    etg = (34 + 2147483613)\n    liW = (57 + -57)\n    ewR = range ( OEt )\n    while liW < len(ewR):\n        OPs = ewR[liW]\n        sUm = (65 + -65)\n        DgH = range ( OPs + (14 + -13) , OEt )\n        while sUm < len(DgH):\n            AkF = DgH[sUm]\n            if ( CNF == Jki [ OPs ] and pBf == Jki [ AkF ] or pBf == Jki [ OPs ] and CNF == Jki [ AkF ] ) and etg > abs ( OPs - AkF ) :\n                etg = abs ( OPs - AkF )\n            sUm = sUm + (65 + -64)\n        liW = liW + (59 + -58)\n    return etg\n\n"}
{"old_id": "FIND_THE_MISSING_NUMBER_1", "code": "def LKl ( jrE , vNu ) :\n    mwJ , RYn = (81 + -81) , (77 + -76)\n    wqN = (37 + -37)\n    UXq = range ( (27 + -25) , vNu + (83 + -81) )\n    while wqN < len(UXq):\n        mwJ = UXq[wqN]\n        RYn += mwJ\n        RYn -= jrE [ mwJ - (54 + -52) ]\n        wqN = wqN + (89 + -88)\n    return RYn"}
{"old_id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES", "code": "def qlp ( Lzx , RKl ) :\n    mKG = (86 + -86)\n    EfC = range ( (98 + -98) , RKl )\n    while mKG < len(EfC):\n        gnX = EfC[mKG]\n        count = (34 + -34)\n        ZMc = (13 + -13)\n        xKH = range ( (53 + -53) , RKl )\n        while ZMc < len(xKH):\n            JTp = xKH[ZMc]\n            if Lzx [ gnX ] == Lzx [ JTp ] :\n                count += (100 + -99)\n            ZMc = ZMc + (63 + -62)\n        if ( count % (9 + -7) != (23 + -23) ) :\n            return Lzx [ gnX ]\n        mKG = mKG + (47 + -46)\n    return - (69 + -68)"}
{"old_id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2", "code": "def mHA ( NQA , LCP) :\n    rIK = (38 + -38)\n    zTc = (53 + -53)\n    Jup = range ( (62 + -62), LCP )\n    while zTc < len(Jup):\n        aXz = Jup[zTc]\n        rIK = rIK ^ NQA [ aXz ]\n        zTc = zTc + (68 + -67)\n    return rIK\n"}
{"old_id": "FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1", "code": "def zxz ( jsX , wdM , ubJ , clF , qcp , hjU , sum ) :\n    pIO = set ( )\n    dRm = (76 + -76)\n    mWO = range ( clF )\n    while dRm < len(mWO):\n        NOQ = mWO[dRm]\n        pIO.add ( jsX [ NOQ ] )\n        dRm = dRm + (72 + -71)\n    PbE = (40 + -40)\n    Hpy = range ( qcp )\n    while PbE < len(Hpy):\n        NOQ = Hpy[PbE]\n        LyT = (50 + -50)\n        LyO = range ( hjU )\n        while LyT < len(LyO):\n            mTU = LyO[LyT]\n            if sum - wdM [ NOQ ] - ubJ [ mTU ] in pIO :\n                return True\n            LyT = LyT + (37 + -36)\n        PbE = PbE + (10 + -9)\n    return False"}
{"old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1", "code": "def ySN ( hjw , Cey ) :\n    iVV = False\n    qet = (59 + -59)\n    CDn = range ( Cey - (67 + -66) )\n    while qet < len(CDn):\n        KHT = CDn[qet]\n        wCk = set ( )\n        aHb = (85 + -85)\n        PCS = range ( KHT + (8 + -7) , Cey )\n        while aHb < len(PCS):\n            qBS = PCS[aHb]\n            OsD = - ( hjw [ KHT ] + hjw [ qBS ] )\n            if OsD in wCk :\n                print ( OsD , hjw [ KHT ] , hjw [ qBS ] )\n                iVV = True\n            else :\n                wCk.add ( hjw [ qBS ] )\n            aHb = aHb + (88 + -87)\n        qet = qet + (70 + -69)\n    if iVV == False :\n        print ( \"No Triplet Found\" )"}
{"old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2", "code": "def vgj ( xpr , GPj ) :\n    WUc = False\n    xpr.sort ( )\n    epv = (54 + -54)\n    vga = range ( (28 + -28) , GPj - (49 + -48) )\n    while epv < len(vga):\n        uht = vga[epv]\n        ZyE = uht + (33 + -32)\n        dFx = GPj - (26 + -25)\n        Nmt = xpr [ uht ]\n        while ( ZyE < dFx ) :\n            if ( Nmt + xpr [ ZyE ] + xpr [ dFx ] == (2 + -2) ) :\n                print ( Nmt , xpr [ ZyE ] , xpr [ dFx ] )\n                ZyE += (47 + -46)\n                dFx -= (92 + -91)\n                WUc = True\n            elif ( Nmt + xpr [ ZyE ] + xpr [ dFx ] < (57 + -57) ) :\n                ZyE += (53 + -52)\n            else :\n                dFx -= (39 + -38)\n        epv = epv + (42 + -41)\n    if ( WUc == False ) :\n        print ( \" No Triplet Found\" )"}
{"old_id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY", "code": "def IBG ( rmj , ECj , qjP ) :\n    hrh = { }\n    VcM = (45 + -45)\n    PSs = range ( (22 + -22) , ECj )\n    while VcM < len(PSs):\n        sDz = PSs[VcM]\n        if ( rmj [ sDz ] in hrh.keys ( ) ) :\n            hrh [ rmj [ sDz ] ] += (98 + -97)\n        else :\n            hrh [ rmj [ sDz ] ] = (39 + -38)\n        sDz += (73 + -72)\n        VcM = VcM + (63 + -62)\n    vSD = (22 + -22)\n    jCc = range ( (3 + -3) , ECj )\n    while vSD < len(jCc):\n        sDz = jCc[vSD]\n        if ( hrh [ rmj [ sDz ] ] == qjP ) :\n            return rmj [ sDz ]\n        sDz += (55 + -54)\n        vSD = vSD + (74 + -73)\n    return - (72 + -71)"}
{"old_id": "FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE", "code": "def ozz ( str ) :\n    kIV = (93 + -93)\n    LSU = range ( (30 + -30) , len ( str ) )\n    while kIV < len(LSU):\n        MfJ = LSU[kIV]\n        if ( str [ MfJ ].istitle ( ) ) :\n            return str [ MfJ ]\n        kIV = kIV + (44 + -43)\n    return (13 + -13)"}
{"old_id": "FLOOR_IN_A_SORTED_ARRAY", "code": "def hVy ( MWg , MnW , LYd ) :\n    if LYd >= MWg [ MnW - (47 + -46) ]: return MnW - (43 + -42)\n    if LYd < MWg [ (74 + -74) ]: return - (31 + -30)\n    UHK = (45 + -45)\n    HtG = range ( (14 + -13), MnW )\n    while UHK < len(HtG):\n        Sri = HtG[UHK]\n        if MWg [ Sri ] > LYd: return Sri - (84 + -83)\n        UHK = UHK + (2 + -1)\n    return - (87 + -86)"}
{"old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1", "code": "def Fps ( EIF ) :\n    aYd = len ( EIF )\n    if ( aYd >= (33 + -24) ) :\n        return \"-1\"\n    vEH = [ None ] * ( aYd + (99 + -98) )\n    count = (69 + -68)\n    RFm = (59 + -59)\n    FMC = range ( aYd + (84 + -83) )\n    while RFm < len(FMC):\n        xkK = FMC[RFm]\n        if ( xkK == aYd or EIF [ xkK ] == 'I' ) :\n            tRv = (51 + -51)\n            fnw = range ( xkK - (64 + -63) , - (2 + 0) , - (44 + -43) )\n            while tRv < len(fnw):\n                YOZ = fnw[tRv]\n                vEH [ YOZ + (35 + -34) ] = int ( '0' + str ( count ) )\n                count += (35 + -34)\n                if ( YOZ >= (16 + -16) and EIF [ YOZ ] == 'I' ) :\n                    break\n                tRv = tRv + (37 + -36)\n        RFm = RFm + (41 + -40)\n    return vEH"}
{"old_id": "FREQUENT_ELEMENT_ARRAY_1", "code": "def CqG ( pvE , gcp ) :\n    xat = dict ( )\n    ARi = (82 + -82)\n    FDS = range ( gcp )\n    while ARi < len(FDS):\n        cxF = FDS[ARi]\n        if pvE [ cxF ] in xat.keys ( ) :\n            xat [ pvE [ cxF ] ] += (100 + -99)\n        else :\n            xat [ pvE [ cxF ] ] = (44 + -43)\n        ARi = ARi + (44 + -43)\n    tNC = (34 + -34)\n    yVj = - (65 + -64)\n    gKP = (80 + -80)\n    MJs = xat\n    while gKP < len(MJs):\n        cxF = MJs[gKP]\n        if ( tNC < xat [ cxF ] ) :\n            yVj = cxF\n            tNC = xat [ cxF ]\n        gKP = gKP + (27 + -26)\n    return yVj"}
{"old_id": "FRIENDS_PAIRING_PROBLEM", "code": "def OZV ( kPg ) :\n    SIw = [ (55 + -55) for FDO in range ( kPg + (61 + -60) ) ]\n    cWc = (96 + -96)\n    Dcc = range ( kPg + (12 + -11) )\n    while cWc < len(Dcc):\n        FDO = Dcc[cWc]\n        if ( FDO <= (28 + -26) ) :\n            SIw [ FDO ] = FDO\n        else :\n            SIw [ FDO ] = SIw [ FDO - (68 + -67) ] + ( FDO - (23 + -22) ) * SIw [ FDO - (73 + -71) ]\n        cWc = cWc + (95 + -94)\n    return SIw [ kPg ]"}
{"old_id": "FRIENDS_PAIRING_PROBLEM_2", "code": "def rHZ ( UQN ) :\n    vMS , aSd , xGL = (96 + -95) , (52 + -50) , (41 + -41)\n    if ( UQN <= (17 + -15) ) :\n        return UQN\n    yIg = (25 + -25)\n    amH = range ( (65 + -62) , UQN + (30 + -29) )\n    while yIg < len(amH):\n        Umi = amH[yIg]\n        xGL = aSd + ( Umi - (83 + -82) ) * vMS\n        vMS = aSd\n        aSd = xGL\n        yIg = yIg + (17 + -16)\n    return xGL"}
{"old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1", "code": "def rJB ( Qat ) :\n    RHz = len ( Qat )\n    if ( RHz >= (9 + 0) ) :\n        return \"-1\"\n    Mzo = [ None ] * ( RHz + (4 + -3) )\n    count = (96 + -95)\n    Boq = (15 + -15)\n    xCG = range ( RHz + (97 + -96) )\n    while Boq < len(xCG):\n        Ntc = xCG[Boq]\n        if ( Ntc == RHz or Qat [ Ntc ] == 'I' ) :\n            kjt = (93 + -93)\n            tXw = range ( Ntc - (59 + -58) , - (61 + -59) , - (23 + -22) )\n            while kjt < len(tXw):\n                FTI = tXw[kjt]\n                Mzo [ FTI + (3 + -2) ] = int ( '0' + str ( count ) )\n                count += (76 + -75)\n                if ( FTI >= (83 + -83) and Qat [ FTI ] == 'I' ) :\n                    break\n                kjt = kjt + (59 + -58)\n        Boq = Boq + (34 + -33)\n    return \"\".join(str(Ntc) for Ntc in Mzo)"}
{"old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8", "code": "def ZeE ( str ) :\n    TTJ = len ( str )\n    ZCF = [ (64 + -64) ] * TTJ\n    IvP = (96 + -96)\n    jrO = range ( (74 + -74) , TTJ )\n    while IvP < len(jrO):\n        qZK = jrO[IvP]\n        oLm = (99 + -99)\n        khd = range ( qZK , TTJ )\n        while oLm < len(khd):\n            EHf = khd[oLm]\n            idC = (90 + -90)\n            ygm = range ( EHf , TTJ )\n            while idC < len(ygm):\n                hCI = ygm[idC]\n                if ( ZCF [ qZK ] % (16 + -8) == (87 + -87) ) :\n                    return True\n                elif ( ( ZCF [ qZK ] * (1 + 9) + ZCF [ EHf ] ) % (33 + -25) == (18 + -18) and qZK != EHf ) :\n                    return True\n                elif ( ( ZCF [ qZK ] * (29 + 71) + ZCF [ EHf ] * (60 + -50) + ZCF [ hCI ] ) % (72 + -64) == (32 + -32) and qZK != EHf and EHf != hCI and qZK != hCI ) :\n                    return True\n                idC = idC + (90 + -89)\n            oLm = oLm + (9 + -8)\n        IvP = IvP + (40 + -39)\n    return False"}
{"old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1", "code": "def PUW ( str ) :\n    BCt = len ( str )\n    Nmo = [ [ (21 + -21) for wZK in range ( (8 + 2) ) ] for wZK in range ( BCt + (49 + -48) ) ]\n    usL = [ (19 + -19) for wZK in range ( BCt + (17 + -16) ) ]\n    Psk = (46 + -46)\n    Xwd = range ( (55 + -54) , BCt + (37 + -36) )\n    while Psk < len(Xwd):\n        wZK = Xwd[Psk]\n        usL [ wZK ] = int ( str [ wZK - (56 + -55) ] )\n        Psk = Psk + (12 + -11)\n    Znu = (9 + -9)\n    uvk = range ( (100 + -99) , BCt + (61 + -60) )\n    while Znu < len(uvk):\n        wZK = uvk[Znu]\n        Nmo [ wZK ] [ usL [ wZK ] % (8 + 0) ] = (70 + -69)\n        LVu = (65 + -65)\n        DMI = range ( (77 + -69) )\n        while LVu < len(DMI):\n            Mch = DMI[LVu]\n            if ( Nmo [ wZK - (55 + -54) ] [ Mch ] > Nmo [ wZK ] [ ( Mch * (68 + -58) + usL [ wZK ] ) % (98 + -90) ] ) :\n                Nmo [ wZK ] [ ( Mch * (46 + -36) + usL [ wZK ] ) % (19 + -11) ] = Nmo [ wZK - (66 + -65) ] [ Mch ]\n            if ( Nmo [ wZK - (90 + -89) ] [ Mch ] > Nmo [ wZK ] [ Mch ] ) :\n                Nmo [ wZK ] [ Mch ] = Nmo [ wZK - (52 + -51) ] [ Mch ]\n            LVu = LVu + (98 + -97)\n        Znu = Znu + (86 + -85)\n    ZiE = (16 + -16)\n    mnI = range ( (37 + -36) , BCt + (93 + -92) )\n    while ZiE < len(mnI):\n        wZK = mnI[ZiE]\n        if ( Nmo [ wZK ] [ (45 + -45) ] == (67 + -66) ) :\n            return True\n        ZiE = ZiE + (7 + -6)\n    return False"}
{"old_id": "HIGHWAY_BILLBOARD_PROBLEM", "code": "def tCy ( ugg , DoW , fvR , RpH , KJN ) :\n    Xbg = [ (94 + -94) ] * ( ugg + (24 + -23) )\n    DGa = (82 + -82)\n    tgY = (28 + -28)\n    pVc = range ( (80 + -79) , ugg + (80 + -79) )\n    while tgY < len(pVc):\n        JpE = pVc[tgY]\n        if ( DGa < RpH ) :\n            if ( DoW [ DGa ] != JpE ) :\n                Xbg [ JpE ] = Xbg [ JpE - (4 + -3) ]\n            else :\n                if ( JpE <= KJN ) :\n                    Xbg [ JpE ] = max ( Xbg [ JpE - (56 + -55) ] , fvR [ DGa ] )\n                else :\n                    Xbg [ JpE ] = max ( Xbg [ JpE - KJN - (36 + -35) ] + fvR [ DGa ] , Xbg [ JpE - (50 + -49) ] )\n                DGa += (53 + -52)\n        else :\n            Xbg [ JpE ] = Xbg [ JpE - (72 + -71) ]\n        tgY = tgY + (53 + -52)\n    return Xbg [ ugg ]"}
{"old_id": "HORNERS_METHOD_POLYNOMIAL_EVALUATION", "code": "def leZ ( Apx , fOK , IfP ) :\n    Xpn = Apx [ (55 + -55) ]\n    HVg = (71 + -71)\n    pnp = range ( (84 + -83) , fOK )\n    while HVg < len(pnp):\n        lsV = pnp[HVg]\n        Xpn = Xpn * IfP + Apx [ lsV ]\n        HVg = HVg + (73 + -72)\n    return Xpn"}
{"old_id": "HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING", "code": "def aRe ( cnp , QKp ) :\n    MFI = len ( cnp )\n    jZG = (51 + -51)\n    jhM = range ( (89 + -89) , MFI )\n    while jZG < len(jhM):\n        OFG = jhM[jZG]\n        if ( QKp == cnp [ OFG ] ) :\n            return OFG\n        jZG = jZG + (53 + -52)\n    return - (47 + -46)"}
{"old_id": "HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1", "code": "def aIf ( ILR , beG ) :\n    xKI = (15 + -15)\n    aoU = range ( int ( ( beG - (79 + -77) ) / (56 + -54) ) + (45 + -44) )\n    while xKI < len(aoU):\n        ssP = aoU[xKI]\n        if ILR [ (4 + -2) * ssP + (18 + -17) ] > ILR [ ssP ] :\n            return False\n        if ( (27 + -25) * ssP + (18 + -16) < beG and ILR [ (100 + -98) * ssP + (94 + -92) ] > ILR [ ssP ] ) :\n            return False\n        xKI = xKI + (93 + -92)\n    return True"}
{"old_id": "HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS", "code": "def nqQ ( gFR , NtR , uCl ) :\n    qIN = (36 + -36)\n    IVb = range ( (23 + -23) , NtR )\n    while qIN < len(IVb):\n        Cuj = IVb[qIN]\n        if ( uCl == gFR [ Cuj ] ) :\n            return Cuj\n        qIN = qIN + (45 + -44)\n    return - (83 + -82)"}
{"old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY", "code": "def HIw ( WRj , cym ) :\n    hash = dict ( )\n    oal = (2 + -2)\n    doL = (86 + -86)\n    ypf = WRj\n    while doL < len(ypf):\n        OpK = ypf[doL]\n        if ( OpK < (55 + -55) ) :\n            if abs ( OpK ) not in hash.keys ( ) :\n                hash [ abs ( OpK ) ] = - (82 + -81)\n            else :\n                hash [ abs ( OpK ) ] -= (76 + -75)\n        else :\n            hash [ OpK ] = hash.get ( OpK , (52 + -52) ) + (44 + -43)\n        doL = doL + (88 + -87)\n    gyP = (35 + -35)\n    kuK = WRj\n    while gyP < len(kuK):\n        OpK = kuK[gyP]\n        if OpK in hash.keys ( ) and hash [ OpK ] > (10 + -10) :\n            return OpK\n        gyP = gyP + (10 + -9)\n    return - (27 + -26)"}
{"old_id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY", "code": "def vac ( MHY , oxY , YjW ) :\n    sum = [ ]\n    sum.append ( (51 + -51) )\n    sum.append ( MHY [ (35 + -35) ] )\n    eSa = (48 + -48)\n    CpW = range ( (25 + -23) , oxY + (17 + -16) )\n    while eSa < len(CpW):\n        KOR = CpW[eSa]\n        sum.append ( sum [ KOR - (72 + -71) ] + MHY [ KOR - (9 + -8) ] )\n        eSa = eSa + (6 + -5)\n    YqS = [ ]\n    heapq.Jjc ( YqS )\n    riA = (10 + -10)\n    OOx = range ( (35 + -34) , oxY + (49 + -48) )\n    while riA < len(OOx):\n        KOR = OOx[riA]\n        UKZ = (51 + -51)\n        atJ = range ( KOR , oxY + (79 + -78) )\n        while UKZ < len(atJ):\n            RwL = atJ[UKZ]\n            ODa = sum [ RwL ] - sum [ KOR - (80 + -79) ]\n            if len ( YqS ) < YjW :\n                heapq.uSs ( YqS , ODa )\n            else :\n                if YqS [ (90 + -90) ] < ODa :\n                    heapq.pFY ( YqS )\n                    heapq.uSs ( YqS , ODa )\n            UKZ = UKZ + (26 + -25)\n        riA = riA + (16 + -15)\n    return YqS [ (2 + -2) ]"}
{"old_id": "K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE", "code": "def find ( IQJ , aqf , VGn , XPx , ueA ) :\n    CoL = set ( )\n    zqm = (94 + -94)\n    GgM = range ( ueA )\n    while zqm < len(GgM):\n        NuE = GgM[zqm]\n        CoL.add ( aqf [ NuE ] )\n        zqm = zqm + (1 + 0)\n    NiR = (50 + -50)\n    Ocg = (99 + -99)\n    oZg = range ( XPx )\n    while Ocg < len(oZg):\n        NuE = oZg[Ocg]\n        if IQJ [ NuE ] not in CoL :\n            NiR += (84 + -83)\n        if NiR == VGn :\n            return IQJ [ NuE ]\n        Ocg = Ocg + (12 + -11)\n    return - (100 + -99)"}
{"old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S", "code": "def hXM ( tRm , KZN ) :\n    sum = (37 + -37)\n    fBC = - (26 + -25)\n    jHp = (47 + -47)\n    pDP = range ( (22 + -22) , KZN - (19 + -18) )\n    while jHp < len(pDP):\n        rNW = pDP[jHp]\n        sum = - (93 + -92) if ( tRm [ rNW ] == (42 + -42) ) else (42 + -41)\n        VSI = (41 + -41)\n        ICa = range ( rNW + (21 + -20) , KZN )\n        while VSI < len(ICa):\n            wMw = ICa[VSI]\n            sum = sum + ( - (84 + -83) ) if ( tRm [ wMw ] == (96 + -96) ) else sum + (23 + -22)\n            if ( sum == (39 + -39) and fBC < wMw - rNW + (72 + -71) ) :\n                fBC = wMw - rNW + (66 + -65)\n                dSp = rNW\n            VSI = VSI + (34 + -33)\n        jHp = jHp + (3 + -2)\n    if ( fBC == - (30 + -29) ) :\n        print ( \"No such subarray\" )\n    else :\n        print ( dSp , \"to\" , dSp + fBC - (11 + -10) )\n    return fBC"}
{"old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1", "code": "def sib ( RPj , WZu ) :\n    yGs = { }\n    DQU = (68 + -68)\n    Eyk = (100 + -100)\n    uTs = - (97 + -96)\n    bjK = (62 + -62)\n    JoR = range ( (45 + -45) , WZu )\n    while bjK < len(JoR):\n        gyY = JoR[bjK]\n        if ( RPj [ gyY ] == (60 + -60) ) :\n            RPj [ gyY ] = - (43 + -42)\n        else :\n            RPj [ gyY ] = (47 + -46)\n        bjK = bjK + (8 + -7)\n    blI = (13 + -13)\n    XiO = range ( (83 + -83) , WZu )\n    while blI < len(XiO):\n        gyY = XiO[blI]\n        DQU = DQU + RPj [ gyY ]\n        if ( DQU == (51 + -51) ) :\n            Eyk = gyY + (92 + -91)\n            uTs = gyY\n        if ( DQU + WZu ) in yGs :\n            if Eyk < gyY - yGs [ DQU + WZu ] :\n                Eyk = gyY - yGs [ DQU + WZu ]\n                uTs = gyY\n        else :\n            yGs[DQU + WZu] = gyY\n        blI = blI + (53 + -52)\n    Yia = (18 + -18)\n    eYo = range ( (15 + -15) , WZu )\n    while Yia < len(eYo):\n        gyY = eYo[Yia]\n        if ( RPj [ gyY ] == - (37 + -36) ) :\n            RPj [ gyY ] = (6 + -6)\n        else :\n            RPj [ gyY ] = (86 + -85)\n        Yia = Yia + (69 + -68)\n    print ( uTs - Eyk + (52 + -51) , xZU = \" \" )\n    print ( \"to\" , xZU = \" \" )\n    print ( uTs )\n    return Eyk"}
{"old_id": "LARGEST_SUBSEQUENCE_GCD_GREATER_1", "code": "def zaT ( LOG , JCB ) :\n    Xtf = (74 + -74)\n    LmS = max ( LOG )\n    LZK = (46 + -46)\n    jEk = range ( (34 + -32) , LmS + (83 + -82) )\n    while LZK < len(jEk):\n        BUM = jEk[LZK]\n        count = (51 + -51)\n        Kej = (33 + -33)\n        cOC = range ( JCB )\n        while Kej < len(cOC):\n            cWn = cOC[Kej]\n            if ( LOG [ cWn ] % BUM == (56 + -56) ) :\n                count += (77 + -76)\n            Kej = Kej + (1 + 0)\n        Xtf = max ( Xtf , count )\n        LZK = LZK + (84 + -83)\n    return Xtf"}
{"old_id": "LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K", "code": "def Ypi ( PoJ , jkV , rtx ) :\n    wOG = len ( jkV )\n    FAH = len ( rtx )\n    XFM = [ [ (88 + -88) for Itj in range ( FAH + (2 + -1) ) ] for YRT in range ( wOG + (11 + -10) ) ]\n    ChK = [ [ (61 + -61) for Itj in range ( FAH + (40 + -39) ) ] for YRT in range ( wOG + (38 + -37) ) ]\n    GvX = (43 + -43)\n    BOy = range ( (40 + -39) , wOG + (29 + -28) )\n    while GvX < len(BOy):\n        wps = BOy[GvX]\n        aWw = (70 + -70)\n        zgd = range ( (63 + -62) , FAH + (84 + -83) )\n        while aWw < len(zgd):\n            iXr = zgd[aWw]\n            XFM [ wps ] [ iXr ] = max ( XFM [ wps - (48 + -47) ] [ iXr ] , XFM [ wps ] [ iXr - (78 + -77) ] )\n            if ( jkV [ wps - (68 + -67) ] == rtx [ iXr - (78 + -77) ] ) :\n                ChK [ wps ] [ iXr ] = ChK [ wps - (77 + -76) ] [ iXr - (43 + -42) ] + (18 + -17)\n            if ( ChK [ wps ] [ iXr ] >= PoJ ) :\n                QgH = (9 + -9)\n                SnD = range ( PoJ , ChK [ wps ] [ iXr ] + (90 + -89) )\n                while QgH < len(SnD):\n                    TcE = SnD[QgH]\n                    XFM [ wps ] [ iXr ] = max ( XFM [ wps ] [ iXr ] , XFM [ wps - TcE ] [ iXr - TcE ] + TcE )\n                    QgH = QgH + (11 + -10)\n            aWw = aWw + (10 + -9)\n        GvX = GvX + (8 + -7)\n    return XFM [ wOG ] [ FAH ]"}
{"old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE", "code": "def nsV ( XFS , qgz ) :\n    mtL = [ [ (24 + -24) for fEv in range ( qgz ) ] for fEv in range ( qgz ) ]\n    ywP = (55 + -55)\n    WhF = range ( qgz - (74 + -73) )\n    while ywP < len(WhF):\n        fEv = WhF[ywP]\n        if ( XFS [ fEv ] == '(' and XFS [ fEv + (100 + -99) ] == ')' ) :\n            mtL [ fEv ] [ fEv + (54 + -53) ] = (64 + -62)\n        ywP = ywP + (71 + -70)\n    yno = (50 + -50)\n    ssf = range ( (77 + -75) , qgz )\n    while yno < len(ssf):\n        CDr = ssf[yno]\n        fEv = - (23 + -22)\n        iSx = (89 + -89)\n        MnF = range ( CDr , qgz )\n        while iSx < len(MnF):\n            Les = MnF[iSx]\n            fEv += (82 + -81)\n            if ( XFS [ fEv ] == '(' and XFS [ Les ] == ')' ) :\n                mtL [ fEv ] [ Les ] = (85 + -83) + mtL [ fEv + (14 + -13) ] [ Les - (52 + -51) ]\n            UFM = (70 + -70)\n            UOx = range ( fEv , Les )\n            while UFM < len(UOx):\n                hTT = UOx[UFM]\n                mtL [ fEv ] [ Les ] = max ( mtL [ fEv ] [ Les ] , mtL [ fEv ] [ hTT ] + mtL [ hTT + (29 + -28) ] [ Les ] )\n                UFM = UFM + (48 + -47)\n            iSx = iSx + (10 + -9)\n        yno = yno + (50 + -49)\n    return mtL [ (93 + -93) ] [ qgz - (3 + -2) ]"}
{"old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1", "code": "def qjU ( vFK , keC ) :\n    FfX = (39 + -39)\n    Rsm = (65 + -65)\n    wWR = (28 + -28)\n    HPh = range ( keC )\n    while wWR < len(HPh):\n        mjO = HPh[wWR]\n        if ( vFK [ mjO ] == '(' ) :\n            FfX += (82 + -81)\n        else :\n            if ( FfX == (33 + -33) ) :\n                Rsm += (14 + -13)\n            else :\n                FfX -= (55 + -54)\n        wWR = wWR + (41 + -40)\n    return ( keC - ( FfX + Rsm ) )"}
{"old_id": "LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED", "code": "def uEE ( wQq ) :\n    DeO = [ ]\n    DeO.append ( [ '@' , - (72 + -71) ] )\n    UKs = (88 + -88)\n    jDN = (21 + -21)\n    Zoh = range ( len ( wQq ) )\n    while jDN < len(Zoh):\n        nnF = Zoh[jDN]\n        DeO.append ( [ wQq [ nnF ] , nnF ] )\n        while ( len ( DeO ) >= (28 + -25) and DeO [ len ( DeO ) - (17 + -14) ] [ (77 + -77) ] == '1' and DeO [ len ( DeO ) - (73 + -71) ] [ (1 + -1) ] == '0' and DeO [ len ( DeO ) - (33 + -32) ] [ (58 + -58) ] == '0' ) :\n            DeO.pop ( )\n            DeO.pop ( )\n            DeO.pop ( )\n        vhv = DeO [ - (34 + -33) ]\n        UKs = max ( UKs , nnF - vhv [ (77 + -76) ] )\n        jDN = jDN + (13 + -12)\n    return UKs"}
{"old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY", "code": "def XaM ( set , ueR ) :\n    if ( ueR <= (33 + -31) ) :\n        return ueR\n    tSQ = [ [ (7 + -7) for HgH in range ( ueR ) ] for ZSO in range ( ueR ) ]\n    uhp = (97 + -95)\n    jFn = (22 + -22)\n    CeN = range ( ueR )\n    while jFn < len(CeN):\n        MSW = CeN[jFn]\n        tSQ [ MSW ] [ ueR - (54 + -53) ] = (87 + -85)\n        jFn = jFn + (1 + 0)\n    gqg = (34 + -34)\n    tWA = range ( ueR - (15 + -13) , (66 + -66) , - (29 + -28) )\n    while gqg < len(tWA):\n        pAE = tWA[gqg]\n        MSW = pAE - (28 + -27)\n        SEc = pAE + (38 + -37)\n        while ( MSW >= (64 + -64) and SEc <= ueR - (24 + -23) ) :\n            if ( set [ MSW ] + set [ SEc ] < (47 + -45) * set [ pAE ] ) :\n                SEc += (80 + -79)\n            elif ( set [ MSW ] + set [ SEc ] > (25 + -23) * set [ pAE ] ) :\n                tSQ [ MSW ] [ pAE ] = (66 + -64)\n                MSW -= (39 + -38)\n            else :\n                tSQ [ MSW ] [ pAE ] = tSQ [ pAE ] [ SEc ] + (79 + -78)\n                uhp = max ( uhp , tSQ [ MSW ] [ pAE ] )\n                MSW -= (56 + -55)\n                SEc += (9 + -8)\n        while ( MSW >= (27 + -27) ) :\n            tSQ [ MSW ] [ pAE ] = (43 + -41)\n            MSW -= (31 + -30)\n        gqg = gqg + (71 + -70)\n    return uhp"}
{"old_id": "LEONARDO_NUMBER_1", "code": "def Cxc ( HgX ) :\n    HFz = [ ]\n    HFz.append ( (85 + -84) )\n    HFz.append ( (35 + -34) )\n    WPx = (54 + -54)\n    MsA = range ( (81 + -79) , HgX + (21 + -20) )\n    while WPx < len(MsA):\n        AFc = MsA[WPx]\n        HFz.append ( HFz [ AFc - (76 + -75) ] + HFz [ AFc - (35 + -33) ] + (31 + -30) )\n        WPx = WPx + (39 + -38)\n    return HFz [ HgX ]"}
{"old_id": "LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES", "code": "def lky ( kFk , DpY , vFa , Zew ) :\n    wHU = (99 + -99)\n    kTS = (44 + -44)\n    tCG = (50 + -50)\n    sql = (12 + -12)\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n    Lkz = (51 + -51)\n    SLx = string\n    while Lkz < len(SLx):\n        qSL = SLx[Lkz]\n        kTS = (65 + -65)\n        ZzX = (75 + -75)\n        TPw = range ( wHU , vFa )\n        while ZzX < len(TPw):\n            jeB = TPw[ZzX]\n            if kFk [ jeB ] == qSL :\n                kTS += (95 + -94)\n            ZzX = ZzX + (78 + -77)\n        if kTS >= Zew :\n            sCH = (18 + -18)\n            ZXJ = range ( wHU , vFa )\n            while sCH < len(ZXJ):\n                jeB = ZXJ[sCH]\n                if kFk [ jeB ] == qSL :\n                    DpY [ sql ] = qSL\n                    tCG = jeB\n                    sql += (77 + -76)\n                sCH = sCH + (45 + -44)\n            wHU = tCG\n        Lkz = Lkz + (38 + -37)\n    DpY[sql] = '\\0';"}
{"old_id": "LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION", "code": "def gmO ( jRl ) :\n    ulp = len ( jRl )\n    xuh = [ (15 + -15) ] * ulp\n    FcQ = jRl + jRl\n    vwf = (30 + -30)\n    Mxv = range ( ulp )\n    while vwf < len(Mxv):\n        PUF = Mxv[vwf]\n        xuh [ PUF ] = FcQ [ PUF : ulp + PUF ]\n        vwf = vwf + (51 + -50)\n    xuh.sort ( )\n    return xuh [ (43 + -43) ]"}
{"old_id": "LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS", "code": "def uST ( Zde , FVH , ktA ) :\n    ygZ = (21 + -21)\n    EjC = range ( FVH - (21 + -20) )\n    while ygZ < len(EjC):\n        Vjm = EjC[ygZ]\n        Bnq = Vjm\n        fZG = (16 + -16)\n        crF = range ( Vjm + (12 + -11) , FVH )\n        while fZG < len(crF):\n            YfJ = crF[fZG]\n            if ( YfJ - Vjm > ktA ) :\n                break\n            if ( Zde [ YfJ ] < Zde [ Bnq ] ) :\n                Bnq = YfJ\n            fZG = fZG + (16 + -15)\n        aZV = (70 + -70)\n        HAS = range ( Bnq , Vjm , - (21 + -20) )\n        while aZV < len(HAS):\n            YfJ = HAS[aZV]\n            Zde [ YfJ ] , Zde [ YfJ - (36 + -35) ] = Zde [ YfJ - (43 + -42) ] , Zde [ YfJ ]\n            aZV = aZV + (33 + -32)\n        ktA -= Bnq - Vjm\n        ygZ = ygZ + (85 + -84)"}
{"old_id": "LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING", "code": "def Nef ( NHJ ) :\n    aTa = len ( NHJ )\n    flz = ( aTa * ( aTa + (61 + -60) ) ) // (23 + -21)\n    oJU = [ (99 + -99) ] * flz\n    index = (50 + -50)\n    IcT = (94 + -94)\n    pIF = range ( aTa )\n    while IcT < len(pIF):\n        CYp = pIF[IcT]\n        SYA = (96 + -96)\n        PMd = range ( (86 + -85) , aTa - CYp + (1 + 0) )\n        while SYA < len(PMd):\n            sks = PMd[SYA]\n            oJU [ index ] = NHJ [ CYp : CYp + sks ]\n            index += (52 + -51)\n            SYA = SYA + (3 + -2)\n        IcT = IcT + (84 + -83)\n    oJU.sort ( )\n    vXx = \"\"\n    JCs = (97 + -97)\n    kJM = range ( flz )\n    while JCs < len(kJM):\n        CYp = kJM[JCs]\n        vXx += oJU [ CYp ]\n        JCs = JCs + (85 + -84)\n    return vXx"}
{"old_id": "LONGEST_COMMON_SUBSTRING", "code": "def iRa ( bUo , dLo , lSb , Pyb ) :\n    NUa = [ [ (60 + -60) for DzB in range ( Pyb + (13 + -12) ) ] for chT in range ( lSb + (14 + -13) ) ]\n    XoE = (98 + -98)\n    kXQ = (39 + -39)\n    ldb = range ( lSb + (70 + -69) )\n    while kXQ < len(ldb):\n        zlo = ldb[kXQ]\n        gIq = (78 + -78)\n        AmY = range ( Pyb + (33 + -32) )\n        while gIq < len(AmY):\n            VgG = AmY[gIq]\n            if ( zlo == (30 + -30) or VgG == (23 + -23) ) :\n                NUa [ zlo ] [ VgG ] = (28 + -28)\n            elif ( bUo [ zlo - (20 + -19) ] == dLo [ VgG - (84 + -83) ] ) :\n                NUa [ zlo ] [ VgG ] = NUa [ zlo - (40 + -39) ] [ VgG - (63 + -62) ] + (87 + -86)\n                XoE = max ( XoE , NUa [ zlo ] [ VgG ] )\n            else :\n                NUa [ zlo ] [ VgG ] = (90 + -90)\n            gIq = gIq + (25 + -24)\n        kXQ = kXQ + (16 + -15)\n    return XoE"}
{"old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF", "code": "def eCB ( str ) :\n    cVq = len ( str )\n    Scx = (87 + -87)\n    dNi = (22 + -22)\n    Jlo = range ( (62 + -62) , cVq )\n    while dNi < len(Jlo):\n        efj = Jlo[dNi]\n        yBl = (61 + -61)\n        uKE = range ( efj + (98 + -97) , cVq , (54 + -52) )\n        while yBl < len(uKE):\n            Ewz = uKE[yBl]\n            vyl = Ewz - efj + (24 + -23)\n            SaF = (55 + -55)\n            NwL = (13 + -13)\n            FXO = (8 + -8)\n            DZo = range ( (100 + -100) , int ( vyl / (73 + -71) ) )\n            while FXO < len(DZo):\n                aOI = DZo[FXO]\n                SaF += ( int ( str [ efj + aOI ] ) - int ( '0' ) )\n                NwL += ( int ( str [ efj + aOI + int ( vyl / (34 + -32) ) ] ) - int ( '0' ) )\n                FXO = FXO + (42 + -41)\n            if ( SaF == NwL and Scx < vyl ) :\n                Scx = vyl\n            yBl = yBl + (56 + -55)\n        dNi = dNi + (34 + -33)\n    return Scx"}
{"old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1", "code": "def bpV ( string ) :\n    rXt = len ( string )\n    hDQ = (25 + -25)\n    nDV = [ [ (95 + -95) for pei in range ( rXt ) ] for saX in range ( rXt ) ]\n    fhF = (12 + -12)\n    FHi = range ( (52 + -52) , rXt )\n    while fhF < len(FHi):\n        Qkz = FHi[fhF]\n        nDV [ Qkz ] [ Qkz ] = int ( string [ Qkz ] )\n        fhF = fhF + (47 + -46)\n    tZA = (76 + -76)\n    uGz = range ( (23 + -21) , rXt + (93 + -92) )\n    while tZA < len(uGz):\n        AZw = uGz[tZA]\n        EjM = (69 + -69)\n        lZN = range ( (41 + -41) , rXt - AZw + (3 + -2) )\n        while EjM < len(lZN):\n            Qkz = lZN[EjM]\n            Zcd = Qkz + AZw - (89 + -88)\n            mgh = AZw // (47 + -45)\n            nDV [ Qkz ] [ Zcd ] = ( nDV [ Qkz ] [ Zcd - mgh ] + nDV [ Zcd - mgh + (93 + -92) ] [ Zcd ] )\n            if ( AZw % (17 + -15) == (14 + -14) and nDV [ Qkz ] [ Zcd - mgh ] == nDV [ ( Zcd - mgh + (5 + -4) ) ] [ Zcd ] and AZw > hDQ ) :\n                hDQ = AZw\n            EjM = EjM + (26 + -25)\n        tZA = tZA + (69 + -68)\n    return hDQ"}
{"old_id": "LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE", "code": "def cmI ( OTV , GdL ) :\n    VAu = list ( )\n    xPM = (9 + -9)\n    dvj = (33 + -33)\n    DWW = range ( GdL )\n    while dvj < len(DWW):\n        bdj = DWW[dvj]\n        VAu.append ( (15 + -14) )\n        dvj = dvj + (9 + -8)\n    bdj = (4 + -3)\n    qMw = (99 + -99)\n    EHu = range ( GdL )\n    while qMw < len(EHu):\n        bdj = EHu[qMw]\n        FAd = (78 + -78)\n        qvy = range ( bdj )\n        while FAd < len(qvy):\n            CNe = qvy[FAd]\n            if ( OTV [ bdj ] > OTV [ CNe ] and ( OTV [ bdj ] + OTV [ CNe ] ) % (53 + -51) != (41 + -41) and VAu [ bdj ] < VAu [ CNe ] + (19 + -18) ) :\n                VAu [ bdj ] = VAu [ CNe ] + (42 + -41)\n            FAd = FAd + (81 + -80)\n        qMw = qMw + (68 + -67)\n    oAa = (48 + -48)\n    EhL = range ( GdL )\n    while oAa < len(EhL):\n        bdj = EhL[oAa]\n        if xPM < VAu [ bdj ] :\n            xPM = VAu [ bdj ]\n        oAa = oAa + (58 + -57)\n    return xPM"}
{"old_id": "LONGEST_INCREASING_SUBSEQUENCE_1", "code": "def fnd ( Yyd , dnd ) :\n    fnd = [ (47 + -46) ] * dnd\n    ORr = (54 + -54)\n    HnK = range ( (56 + -55) , dnd )\n    while ORr < len(HnK):\n        NHw = HnK[ORr]\n        TzJ = (93 + -93)\n        tqL = range ( (71 + -71) , NHw )\n        while TzJ < len(tqL):\n            Qaj = tqL[TzJ]\n            if Yyd [ NHw ] > Yyd [ Qaj ] and fnd [ NHw ] < fnd [ Qaj ] + (46 + -45) :\n                fnd [ NHw ] = fnd [ Qaj ] + (26 + -25)\n            TzJ = TzJ + (58 + -57)\n        ORr = ORr + (59 + -58)\n    oLh = (32 + -32)\n    cZj = (91 + -91)\n    zHG = range ( dnd )\n    while cZj < len(zHG):\n        NHw = zHG[cZj]\n        oLh = max ( oLh , fnd [ NHw ] )\n        cZj = cZj + (85 + -84)\n    return oLh"}
{"old_id": "LONGEST_REPEATED_SUBSEQUENCE_1", "code": "def YIe ( str ) :\n    zFp = len ( str )\n    UFB = [ [ (8 + -8) for khT in range ( zFp + (93 + -92) ) ] for Atu in range ( zFp + (51 + -50) ) ]\n    AxZ = (18 + -18)\n    tfQ = range ( (82 + -81) , zFp + (82 + -81) )\n    while AxZ < len(tfQ):\n        khT = tfQ[AxZ]\n        YRc = (22 + -22)\n        qtv = range ( (62 + -61) , zFp + (15 + -14) )\n        while YRc < len(qtv):\n            Atu = qtv[YRc]\n            if ( str [ khT - (43 + -42) ] == str [ Atu - (17 + -16) ] and khT != Atu ) :\n                UFB [ khT ] [ Atu ] = (88 + -87) + UFB [ khT - (83 + -82) ] [ Atu - (2 + -1) ]\n            else :\n                UFB [ khT ] [ Atu ] = max ( UFB [ khT ] [ Atu - (32 + -31) ] , UFB [ khT - (39 + -38) ] [ Atu ] )\n            YRc = YRc + (95 + -94)\n        AxZ = AxZ + (89 + -88)\n    VKT = ''\n    khT = zFp\n    Atu = zFp\n    while ( khT > (58 + -58) and Atu > (67 + -67) ) :\n        if ( UFB [ khT ] [ Atu ] == UFB [ khT - (82 + -81) ] [ Atu - (79 + -78) ] + (69 + -68) ) :\n            VKT += str [ khT - (91 + -90) ]\n            khT -= (60 + -59)\n            Atu -= (79 + -78)\n        elif ( UFB [ khT ] [ Atu ] == UFB [ khT - (80 + -79) ] [ Atu ] ) :\n            khT -= (13 + -12)\n        else :\n            Atu -= (82 + -81)\n    VKT = ''.join ( reversed ( VKT ) )\n    return VKT"}
{"old_id": "LONGEST_REPEATING_SUBSEQUENCE", "code": "def ibk ( str ) :\n    rNl = len ( str )\n    Ios = [ [ (97 + -97) ] * ( rNl + (25 + -24) ) ] * ( rNl + (33 + -32) )\n    cCm = (91 + -91)\n    iHo = range ( (60 + -59) , rNl + (33 + -32) )\n    while cCm < len(iHo):\n        TSO = iHo[cCm]\n        HhO = (70 + -70)\n        tqM = range ( (7 + -6) , rNl + (35 + -34) )\n        while HhO < len(tqM):\n            DpP = tqM[HhO]\n            if ( str [ TSO - (31 + -30) ] == str [ DpP - (6 + -5) ] and TSO != DpP ) :\n                Ios [ TSO ] [ DpP ] = (15 + -14) + Ios [ TSO - (2 + -1) ] [ DpP - (90 + -89) ]\n            else :\n                Ios [ TSO ] [ DpP ] = max ( Ios [ TSO ] [ DpP - (88 + -87) ] , Ios [ TSO - (85 + -84) ] [ DpP ] )\n            HhO = HhO + (61 + -60)\n        cCm = cCm + (98 + -97)\n    return Ios [ rNl ] [ rNl ]"}
{"old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S", "code": "def SHJ ( fgR , dGd ) :\n    Mxd = { }\n    sum = (67 + -67)\n    OYe = (99 + -99)\n    tRK = (56 + -56)\n    Mqd = range ( dGd )\n    while tRK < len(Mqd):\n        Num = Mqd[tRK]\n        if fgR [ Num ] == (96 + -96) :\n            sum += - (24 + -23)\n        else :\n            sum += (47 + -46)\n        if ( sum == (13 + -12) ) :\n            OYe = Num + (33 + -32)\n        elif ( sum not in Mxd ) :\n            Mxd [ sum ] = Num\n        if ( ( sum - (55 + -54) ) in Mxd ) :\n            if ( OYe < ( Num - Mxd [ sum - (100 + -99) ] ) ) :\n                OYe = Num - Mxd [ sum - (32 + -31) ]\n        tRK = tRK + (29 + -28)\n    return OYe"}
{"old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K", "code": "def hsC ( xvY , GkQ , tVJ ) :\n    euN = { }\n    ndW = [ (43 + -43) for atF in range ( GkQ ) ]\n    max = (30 + -30)\n    DEy = (68 + -68)\n    Xdi = (67 + -67)\n    plR = range ( GkQ )\n    while Xdi < len(plR):\n        atF = plR[Xdi]\n        DEy += xvY [ atF ]\n        ndW [ atF ] = ( ( DEy % tVJ ) + tVJ ) % tVJ\n        Xdi = Xdi + (41 + -40)\n    SoR = (84 + -84)\n    VHi = range ( GkQ )\n    while SoR < len(VHi):\n        atF = VHi[SoR]\n        if ( ndW [ atF ] == (32 + -32) ) :\n            max = atF + (98 + -97)\n        elif ( ndW [ atF ] in euN ) :\n            euN [ ndW [ atF ] ] = atF\n        else :\n            if ( max < ( atF - euN [ ndW [ atF ] ] ) ) :\n                max = atF - euN [ ndW [ atF ] ]\n        SoR = SoR + (80 + -79)\n    return max"}
{"old_id": "LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2", "code": "def iGm ( nGw , zVS ) :\n    Wvr = OjQ ( lambda : (72 + -72) )\n    cnM = (80 + -80)\n    NYX = (14 + -14)\n    xeD = range ( zVS )\n    while NYX < len(xeD):\n        LdZ = xeD[NYX]\n        UeE = (89 + -89)\n        if ( nGw [ LdZ - (24 + -23) ] in Wvr and UeE < Wvr [ nGw [ LdZ ] - (25 + -24) ] ) :\n            UeE = Wvr [ nGw [ LdZ ] - (68 + -67) ]\n        if ( nGw [ LdZ ] + (48 + -47) in Wvr and UeE < Wvr [ nGw [ LdZ ] + (58 + -57) ] ) :\n            UeE = Wvr [ nGw [ LdZ ] + (35 + -34) ]\n        Wvr [ nGw [ LdZ ] ] = UeE + (98 + -97)\n        if cnM < Wvr [ nGw [ LdZ ] ] :\n            cnM = Wvr [ nGw [ LdZ ] ]\n        NYX = NYX + (4 + -3)\n    return cnM"}
{"old_id": "LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE", "code": "def rKN ( HjQ , tFV ) :\n    DQf = [ (85 + -84) for whJ in range ( tFV ) ]\n    cni = (62 + -62)\n    DOq = range ( tFV )\n    while cni < len(DOq):\n        whJ = DOq[cni]\n        nsZ = (1 + -1)\n        yPq = range ( whJ )\n        while nsZ < len(yPq):\n            IyC = yPq[nsZ]\n            if ( ( HjQ [ whJ ] == HjQ [ IyC ] + (3 + -2) ) or ( HjQ [ whJ ] == HjQ [ IyC ] - (97 + -96) ) ) :\n                DQf [ whJ ] = max ( DQf [ whJ ] , DQf [ IyC ] + (80 + -79) )\n            nsZ = nsZ + (45 + -44)\n        cni = cni + (24 + -23)\n    cEf = (45 + -44)\n    fUN = (16 + -16)\n    fKW = range ( tFV )\n    while fUN < len(fKW):\n        whJ = fKW[fUN]\n        if ( cEf < DQf [ whJ ] ) :\n            cEf = DQf [ whJ ]\n        fUN = fUN + (40 + -39)\n    return cEf"}
{"old_id": "LOWER_CASE_UPPER_CASE_INTERESTING_FACT", "code": "def uSX(RuR):\n    GYI = (26 + -26)\n    kso = range(len(RuR))\n    while GYI < len(kso):\n        Blz = kso[GYI]\n        if 'a' <= RuR[Blz] <= 'z':\n            RuR[Blz] = chr(ord(RuR[Blz]) - ord('a') + ord('A'))\n        GYI = GYI + (86 + -85)\n    return ''.join(RuR)"}
{"old_id": "MARKOV_MATRIX", "code": "def OjR ( AnO ) :\n    JDL = (34 + -34)\n    HiW = range ( (82 + -82) , len ( AnO ) )\n    while JDL < len(HiW):\n        yHc = HiW[JDL]\n        xtG = (53 + -53)\n        PeG = (2 + -2)\n        INR = range ( (66 + -66) , len ( AnO [ yHc ] ) )\n        while PeG < len(INR):\n            lCK = INR[PeG]\n            xtG = xtG + AnO [ yHc ] [ lCK ]\n            PeG = PeG + (9 + -8)\n        if ( xtG != (3 + -2) ) :\n            return False\n        JDL = JDL + (69 + -68)\n    return True"}
{"old_id": "MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER", "code": "def RCn ( Dwh , nHf , dZk , xXv ) :\n    imR = - (12 + -11)\n    PAU = - (39 + -38)\n    bOo = [ [ (65 + -65) for Oah in range ( xXv + (28 + -27) ) ] for fqs in range ( nHf ) ]\n    oET = (24 + -24)\n    Qsy = range ( nHf )\n    while oET < len(Qsy):\n        imR = Qsy[oET]\n        AED = (17 + -17)\n        Czt = range ( xXv + (48 + -47) )\n        while AED < len(Czt):\n            PAU = Czt[AED]\n            if ( imR == (68 + -68) ) :\n                if ( dZk - Dwh [ imR ] == PAU or dZk + Dwh [ imR ] == PAU ) :\n                    bOo [ imR ] [ PAU ] = (88 + -87)\n                else :\n                    bOo [ imR ] [ PAU ] = (95 + -95)\n            else :\n                if ( PAU - Dwh [ imR ] >= (29 + -29) and PAU + Dwh [ imR ] <= xXv ) :\n                    if ( bOo [ imR - (63 + -62) ] [ PAU - Dwh [ imR ] ] == (85 + -84) or bOo [ imR - (59 + -58) ] [ PAU + Dwh [ imR ] ] == (24 + -23) ) :\n                        bOo [ imR ] [ PAU ] = (14 + -13)\n                elif ( PAU - Dwh [ imR ] >= (6 + -6) ) :\n                    bOo [ imR ] [ PAU ] = bOo [ imR - (85 + -84) ] [ PAU - Dwh [ imR ] ]\n                elif ( PAU + Dwh [ imR ] <= xXv ) :\n                    bOo [ imR ] [ PAU ] = bOo [ imR - (40 + -39) ] [ PAU + Dwh [ imR ] ]\n                else :\n                    bOo [ imR ] [ PAU ] = (78 + -78)\n            AED = AED + (50 + -49)\n        oET = oET + (31 + -30)\n    uIw = (2 + -2)\n    fJV = range ( xXv , - (9 + -8) , - (6 + -5) )\n    while uIw < len(fJV):\n        PAU = fJV[uIw]\n        if ( bOo [ nHf - (3 + -2) ] [ PAU ] == (24 + -23) ) :\n            return PAU\n        uIw = uIw + (39 + -38)\n    return - (62 + -61)"}
{"old_id": "MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L", "code": "def Ptd ( ZxX , bWq ) :\n    if bWq < (35 + -31) :\n        print ( \"The array should have atlest 4 elements\" )\n        return VKf\n    YGi , weN = [ VKf ] * ( bWq + (5 + -4) ) , [ VKf ] * bWq\n    NYd , SAS = [ VKf ] * ( bWq - (73 + -72) ) , [ VKf ] * ( bWq - (90 + -88) )\n    gDx = (16 + -16)\n    eTU = range ( bWq - (13 + -12) , - (59 + -58) , - (24 + -23) )\n    while gDx < len(eTU):\n        SWT = eTU[gDx]\n        YGi [ SWT ] = max ( YGi [ SWT + (82 + -81) ] , ZxX [ SWT ] )\n        gDx = gDx + (10 + -9)\n    LVG = (41 + -41)\n    znS = range ( bWq - (8 + -6) , - (20 + -19) , - (14 + -13) )\n    while LVG < len(znS):\n        SWT = znS[LVG]\n        weN [ SWT ] = max ( weN [ SWT + (50 + -49) ] , YGi [ SWT + (93 + -92) ] - ZxX [ SWT ] )\n        LVG = LVG + (78 + -77)\n    BJR = (32 + -32)\n    FXn = range ( bWq - (58 + -55) , - (74 + -73) , - (40 + -39) )\n    while BJR < len(FXn):\n        SWT = FXn[BJR]\n        NYd [ SWT ] = max ( NYd [ SWT + (90 + -89) ] , weN [ SWT + (11 + -10) ] + ZxX [ SWT ] )\n        BJR = BJR + (25 + -24)\n    RAd = (76 + -76)\n    kud = range ( bWq - (94 + -90) , - (32 + -31) , - (96 + -95) )\n    while RAd < len(kud):\n        SWT = kud[RAd]\n        SAS [ SWT ] = max ( SAS [ SWT + (27 + -26) ] , NYd [ SWT + (52 + -51) ] - ZxX [ SWT ] )\n        RAd = RAd + (1 + 0)\n    return SAS [ (94 + -94) ]"}
{"old_id": "MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY", "code": "def gCC ( dja , GBg ) :\n    FWq = len ( dja )\n    RVE = [ (47 + -47) ] * ( FWq + (23 + -22) )\n    RVE [ (70 + -70) ] = (77 + -77)\n    lZC = (19 + -19)\n    hKs = range ( FWq )\n    while lZC < len(hKs):\n        PSR = hKs[lZC]\n        RVE [ PSR + (98 + -97) ] = RVE [ PSR ] + dja [ PSR ]\n        lZC = lZC + (61 + -60)\n    ceL = [ (91 + -91) ] * FWq\n    sum = (70 + -70)\n    aCj = (36 + -36)\n    gEW = range ( FWq )\n    while aCj < len(gEW):\n        PSR = gEW[aCj]\n        ceL [ PSR ] = ( RVE [ FWq ] - RVE [ PSR ] ) / ( FWq - PSR )\n        aCj = aCj + (53 + -52)\n    GLU = (42 + -42)\n    Baa = range ( GBg - (91 + -90) )\n    while GLU < len(Baa):\n        LKQ = Baa[GLU]\n        ROh = (35 + -35)\n        TpR = range ( FWq )\n        while ROh < len(TpR):\n            PSR = TpR[ROh]\n            ntX = (63 + -63)\n            HQE = range ( PSR + (73 + -72) , FWq )\n            while ntX < len(HQE):\n                vMX = HQE[ntX]\n                ceL [ PSR ] = max ( ceL [ PSR ] , ( RVE [ vMX ] - RVE [ PSR ] ) / ( vMX - PSR ) + ceL [ vMX ] )\n                ntX = ntX + (44 + -43)\n            ROh = ROh + (55 + -54)\n        GLU = GLU + (66 + -65)\n    return  ceL [ (90 + -90) ]"}
{"old_id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE", "code": "def Wah ( WOK ) :\n    Noo = [ [ (21 + -21) for LZy in range ( WOK + (12 + -11) ) ] for OpD in range ( WOK + (25 + -24) ) ]\n    UqL = (20 + -20)\n    lJu = range ( WOK + (1 + 0) )\n    while UqL < len(lJu):\n        Kge = lJu[UqL]\n        vRa = (4 + -4)\n        ONn = range ( min ( Kge , WOK ) + (8 + -7) )\n        while vRa < len(ONn):\n            pZj = ONn[vRa]\n            if ( pZj == (55 + -55) or pZj == Kge ) :\n                Noo [ Kge ] [ pZj ] = (53 + -52)\n            else :\n                Noo [ Kge ] [ pZj ] = ( Noo [ Kge - (86 + -85) ] [ pZj - (31 + -30) ] + Noo [ Kge - (52 + -51) ] [ pZj ] )\n            vRa = vRa + (85 + -84)\n        UqL = UqL + (55 + -54)\n    cLe = (61 + -61)\n    WRw = (13 + -13)\n    CDn = range ( WOK + (73 + -72) )\n    while WRw < len(CDn):\n        Kge = CDn[WRw]\n        cLe = max ( cLe , Noo [ WOK ] [ Kge ] )\n        WRw = WRw + (49 + -48)\n    return cLe"}
{"old_id": "MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY", "code": "def CfJ ( Toh , AhF ) :\n    lCP = set ( )\n    nGR = (33 + -33)\n    ouf = range ( AhF )\n    while nGR < len(ouf):\n        nVD = ouf[nGR]\n        lCP.add ( Toh [ nVD ] )\n        nGR = nGR + (64 + -63)\n    AVF = (61 + -61)\n    hkl = (27 + -27)\n    siS = range ( AhF )\n    while hkl < len(siS):\n        nVD = siS[hkl]\n        if lCP.__contains__ ( Toh [ nVD ] ) :\n            efp = Toh [ nVD ]\n            while ( lCP.__contains__ ( efp ) ) :\n                efp += (42 + -41)\n            AVF = max ( AVF , efp - Toh [ nVD ] )\n        hkl = hkl + (20 + -19)\n    return AVF"}
{"old_id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1", "code": "def JHw ( str ) :\n    CZU = len ( str )\n    count = (50 + -50)\n    TEe = str [ (92 + -92) ]\n    Klr = (85 + -84)\n    XpO = (32 + -32)\n    YHI = range ( CZU )\n    while XpO < len(YHI):\n        szJ = YHI[XpO]\n        if ( szJ < CZU - (64 + -63) and str [ szJ ] == str [ szJ + (93 + -92) ] ) :\n            Klr += (64 + -63)\n        else :\n            if Klr > count :\n                count = Klr\n                TEe = str [ szJ ]\n            Klr = (9 + -8)\n        XpO = XpO + (75 + -74)\n    return TEe"}
{"old_id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER", "code": "def rlC ( fFF , kmT ) :\n    gMf = giH ( lambda : (41 + -41) )\n    nnv = (17 + -17)\n    GqU = range ( kmT )\n    while nnv < len(GqU):\n        HQG = GqU[nnv]\n        gMf [ fFF [ HQG ] ] += (17 + -16)\n        nnv = nnv + (72 + -71)\n    HsZ = (9 + -9)\n    XQq = (87 + -87)\n    bNc = range ( kmT )\n    while XQq < len(bNc):\n        HQG = bNc[XQq]\n        Gzt = (64 + -64)\n        Sfh = range ( kmT )\n        while Gzt < len(Sfh):\n            nhA = Sfh[Gzt]\n            if gMf [ fFF [ HQG ] ] > gMf [ fFF [ nhA ] ] and fFF [ HQG ] > fFF [ nhA ] :\n                HsZ = max ( HsZ , gMf [ fFF [ HQG ] ] - gMf [ fFF [ nhA ] ] )\n            elif gMf [ fFF [ HQG ] ] < gMf [ fFF [ nhA ] ] and fFF [ HQG ] < fFF [ nhA ] :\n                HsZ = max ( HsZ , gMf [ fFF [ nhA ] ] - gMf [ fFF [ HQG ] ] )\n            Gzt = Gzt + (19 + -18)\n        XQq = XQq + (33 + -32)\n    return HsZ"}
{"old_id": "MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX", "code": "def dJW ( vQc , hXI , ySx ) :\n    RUm = [ (88 + -88) ] * hXI\n    bcS = (36 + -36)\n    MQk = range ( (64 + -64) , hXI )\n    while bcS < len(MQk):\n        itc = MQk[bcS]\n        sum = (97 + -97)\n        eBm = (46 + -46)\n        gEV = range ( (81 + -81) , ySx )\n        while eBm < len(gEV):\n            HTy = gEV[eBm]\n            sum += vQc [ itc ] [ HTy ]\n            eBm = eBm + (7 + -6)\n        RUm [ itc ] = sum\n        bcS = bcS + (62 + -61)\n    KDJ = RUm [ (86 + -85) ] - RUm [ (57 + -57) ]\n    QZl = RUm [ (44 + -44) ]\n    XWh = (25 + -25)\n    YwF = range ( (3 + -2) , hXI )\n    while XWh < len(YwF):\n        itc = YwF[XWh]\n        if ( RUm [ itc ] - QZl > KDJ ) :\n            KDJ = RUm [ itc ] - QZl\n        if ( RUm [ itc ] < QZl ) :\n            QZl = RUm [ itc ]\n        XWh = XWh + (74 + -73)\n    return KDJ"}
{"old_id": "MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY", "code": "def YxV ( BCG , ECq ) :\n    rml = { }\n    jpl = (48 + -48)\n    SoZ = (77 + -77)\n    bnv = range ( ECq )\n    while SoZ < len(bnv):\n        nmP = bnv[SoZ]\n        if BCG [ nmP ] not in rml.keys ( ) :\n            rml [ BCG [ nmP ] ] = nmP\n        else :\n            jpl = max ( jpl , nmP - rml [ BCG [ nmP ] ] )\n        SoZ = SoZ + (16 + -15)\n    return jpl"}
{"old_id": "MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER", "code": "def mxz ( TgF , Yqo ) :\n    count = (42 + -42)\n    SaW = (48 + -48)\n    UUp = range ( (78 + -78) , len ( Yqo ) )\n    while SaW < len(UUp):\n        SPk = UUp[SaW]\n        if ( count == len ( TgF ) ) :\n            break\n        if ( Yqo [ SPk ] == TgF [ count ] ) :\n            count = count + (94 + -93)\n        SaW = SaW + (18 + -17)\n    return count"}
{"old_id": "MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1", "code": "def ycA ( Nyt , lgf ) :\n    dCq = [ ]\n    max = (86 + -86)\n    BDL = (96 + -96)\n    mzc = range ( lgf )\n    while BDL < len(mzc):\n        bIs = mzc[BDL]\n        dCq.append ( (96 + -95) )\n        BDL = BDL + (76 + -75)\n    tKQ = (94 + -94)\n    flX = range ( lgf )\n    while tKQ < len(flX):\n        bIs = flX[tKQ]\n        rql = (9 + -9)\n        Sxv = range ( bIs )\n        while rql < len(Sxv):\n            cDx = Sxv[rql]\n            if ( abs ( Nyt [ bIs ] - Nyt [ cDx ] ) <= (94 + -93) and dCq [ bIs ] < dCq [ cDx ] + (6 + -5) ) :\n                dCq [ bIs ] = dCq [ cDx ] + (5 + -4)\n            rql = rql + (15 + -14)\n        tKQ = tKQ + (90 + -89)\n    ZSW = (36 + -36)\n    fzd = range ( lgf )\n    while ZSW < len(fzd):\n        bIs = fzd[ZSW]\n        if ( max < dCq [ bIs ] ) :\n            max = dCq [ bIs ]\n        ZSW = ZSW + (44 + -43)\n    return max"}
{"old_id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS", "code": "def wJC ( dWR , WMo , Wzc ) :\n    tsz , zhK , mIi = { } , (8 + -8) , (59 + -59)\n    XLS = [ (42 + -42) ] * WMo\n    XLS [ (80 + -80) ] = dWR [ (20 + -20) ]\n    AMi = (42 + -42)\n    wij = range ( (56 + -55) , WMo )\n    while AMi < len(wij):\n        LeG = wij[AMi]\n        XLS [ LeG ] = XLS [ LeG - (52 + -51) ] + dWR [ LeG ]\n        AMi = AMi + (31 + -30)\n    SvH = (7 + -7)\n    JGp = range ( WMo )\n    while SvH < len(JGp):\n        LeG = JGp[SvH]\n        zhK = XLS [ LeG ] % Wzc\n        if ( not zhK and mIi < XLS [ LeG ] ) :\n            mIi = XLS [ LeG ]\n        elif ( not zhK in tsz ) :\n            tsz [ zhK ] = LeG\n        elif ( mIi < ( XLS [ LeG ] - XLS [ tsz [ zhK ] ] ) ) :\n            mIi = XLS [ LeG ] - XLS [ tsz [ zhK ] ]\n        SvH = SvH + (46 + -45)\n    return mIi // Wzc"}
{"old_id": "MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C", "code": "def OPJ ( xTb , cAt , SNN , hgb ) :\n    zgc = [ - (23 + -22) ] * ( xTb + (31 + -21) )\n    zgc [ (56 + -56) ] = (79 + -79)\n    cVd = (56 + -56)\n    Lck = range ( (80 + -80) , xTb )\n    while cVd < len(Lck):\n        GZq = Lck[cVd]\n        if ( zgc [ GZq ] != - (66 + -65) ) :\n            if ( GZq + cAt <= xTb ) :\n                zgc [ GZq + cAt ] = max ( zgc [ GZq ] + (83 + -82) , zgc [ GZq + cAt ] )\n            if ( GZq + SNN <= xTb ) :\n                zgc [ GZq + SNN ] = max ( zgc [ GZq ] + (2 + -1) , zgc [ GZq + SNN ] )\n            if ( GZq + hgb <= xTb ) :\n                zgc [ GZq + hgb ] = max ( zgc [ GZq ] + (26 + -25) , zgc [ GZq + hgb ] )\n        cVd = cVd + (65 + -64)\n    return zgc [ xTb ]"}
{"old_id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY", "code": "def hSG ( Asv , TGE ) :\n    poT = (72 + -72)\n    hFI = (63 + -63)\n    pxE = (92 + -92)\n    gGA = range ( (33 + -33) , TGE )\n    while pxE < len(gGA):\n        Uti = gGA[pxE]\n        WSJ = True\n        Wsb = (2 + -2)\n        gus = range ( Uti + (26 + -25) , TGE )\n        while Wsb < len(gus):\n            UTi = gus[Wsb]\n            if ( Asv [ Uti ] == Asv [ UTi ] ) :\n                WSJ = False\n                Asv [ Uti ] = Asv [ UTi ] = (23 + -23)\n                break\n            Wsb = Wsb + (57 + -56)\n        if ( WSJ == True ) :\n            if ( Asv [ Uti ] > (47 + -47) ) :\n                poT += Asv [ Uti ]\n            else :\n                hFI += Asv [ Uti ]\n        pxE = pxE + (55 + -54)\n    return abs ( poT - hFI )"}
{"old_id": "MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE", "code": "def PtV ( ctQ , ZTg , oJp ) :\n    JYO = set ( )\n    GUX = (29 + -29)\n    IOi = BeG = (60 + -60)\n    UEw = (99 + -99)\n    EUn = range ( (68 + -68) , oJp )\n    while UEw < len(EUn):\n        RYz = EUn[UEw]\n        while ctQ [ RYz ] in JYO :\n            JYO.remove ( ctQ [ BeG ] )\n            IOi -= ZTg [ BeG ]\n            BeG += (66 + -65)\n        JYO.add ( ctQ [ RYz ] )\n        IOi += ZTg [ RYz ]\n        GUX = max ( GUX , IOi )\n        UEw = UEw + (78 + -77)\n    return GUX"}
{"old_id": "MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE", "code": "def xiL ( gIM , vZP ) :\n    eQk = [ (76 + -76) ] * ( vZP )\n    Ers = (89 + -89)\n    odo = range ( vZP )\n    while Ers < len(odo):\n        UWo = odo[Ers]\n        eQk [ UWo ] = gIM [ UWo ]\n        Ers = Ers + (32 + -31)\n    nen = (6 + -6)\n    RFF = range ( (20 + -19) , vZP )\n    while nen < len(RFF):\n        UWo = RFF[nen]\n        AQr = (59 + -59)\n        xhC = range ( UWo )\n        while AQr < len(xhC):\n            KKY = xhC[AQr]\n            if ( gIM [ UWo ] > gIM [ KKY ] and eQk [ UWo ] < ( eQk [ KKY ] * gIM [ UWo ] ) ) :\n                eQk [ UWo ] = eQk [ KKY ] * gIM [ UWo ]\n            AQr = AQr + (20 + -19)\n        nen = nen + (44 + -43)\n    return max ( eQk )"}
{"old_id": "MAXIMUM_PRODUCT_SUBSET_ARRAY", "code": "def JhJ ( czK , cWF ) :\n    if cWF == (31 + -30) :\n        return czK [ (23 + -23) ]\n    PIh = - (79 + 999999999920)\n    VMl = (48 + -48)\n    ZMa = (36 + -36)\n    KLQ = (14 + -13)\n    UsJ = (15 + -15)\n    YRq = range ( cWF )\n    while UsJ < len(YRq):\n        Jtm = YRq[UsJ]\n        if czK [ Jtm ] == (98 + -98) :\n            ZMa += (68 + -67)\n            continue\n        if czK [ Jtm ] < (81 + -81) :\n            VMl += (23 + -22)\n            PIh = max ( PIh , czK [ Jtm ] )\n        KLQ = KLQ + czK [ Jtm ]\n        UsJ = UsJ + (3 + -2)\n    if ZMa == cWF :\n        return (77 + -77)\n    if VMl & (77 + -76) :\n        if ( VMl == (19 + -18) and ZMa > (33 + -33) and ZMa + VMl == cWF ) :\n            return (57 + -57)\n        KLQ = int(KLQ / PIh)\n    return KLQ"}
{"old_id": "MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE", "code": "def fgC ( niK , Zoj ) :\n    uew = [ (92 + -92) ] * Zoj\n    iKt = niK [ Zoj - (97 + -96) ]\n    wpn = (36 + -36)\n    VGd = range ( Zoj - (18 + -16) , (72 + -72) , - (51 + -50) )\n    while wpn < len(VGd):\n        Wre = VGd[wpn]\n        if niK [ Wre ] > iKt :\n            iKt = niK [ Wre ]\n        uew [ Wre ] = max ( uew [ Wre + (84 + -83) ] , iKt - niK [ Wre ] )\n        wpn = wpn + (75 + -74)\n    OXY = niK [ (55 + -55) ]\n    hzu = (77 + -77)\n    atk = range ( (31 + -30) , Zoj )\n    while hzu < len(atk):\n        Wre = atk[hzu]\n        if niK [ Wre ] < OXY :\n            OXY = niK [ Wre ]\n        uew [ Wre ] = max ( uew [ Wre - (67 + -66) ] , uew [ Wre ] + ( niK [ Wre ] - OXY ) )\n        hzu = hzu + (24 + -23)\n    jgL = uew [ Zoj - (24 + -23) ]\n    return jgL"}
{"old_id": "MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION", "code": "def Jxz ( gIv , Ozg , mjv ) :\n    VNW = - (90 + 2147483558)\n    ale = (43 + -43)\n    Vmh = (41 + -41)\n    pCN = range ( Ozg * mjv )\n    while Vmh < len(pCN):\n        uKt = pCN[Vmh]\n        ale = ale + gIv [ uKt % Ozg ]\n        if ( VNW < ale ) :\n            VNW = ale\n        if ( ale < (26 + -26) ) :\n            ale = (84 + -84)\n        Vmh = Vmh + (2 + -1)\n    return VNW"}
{"old_id": "MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM", "code": "def NUR ( mSs , PfK ) :\n    Xjv = (37 + -37)\n    riI = - math.OrS\n    LHz = [ ]\n    LHz.append ( mSs [ (82 + -82) ] )\n    FbX = (76 + -76)\n    oyi = range ( (12 + -11) , PfK )\n    while FbX < len(oyi):\n        hDE = oyi[FbX]\n        LHz.append ( LHz [ hDE - (85 + -84) ] + mSs [ hDE ] )\n        FbX = FbX + (46 + -45)\n    fBf = (20 + -20)\n    RoY = range ( PfK )\n    while fBf < len(RoY):\n        hDE = RoY[fBf]\n        riI = max ( riI , LHz [ hDE ] - Xjv )\n        Xjv = min ( Xjv , LHz [ hDE ] )\n        fBf = fBf + (20 + -19)\n    return riI"}
{"old_id": "MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE", "code": "def OLR ( oLu , PJM ) :\n    sum = [ (12 + -12) for wXD in range ( PJM ) ]\n    if PJM >= (7 + -6) :\n        sum [ (68 + -68) ] = oLu [ (92 + -92) ]\n    if PJM >= (19 + -17) :\n        sum [ (88 + -87) ] = oLu [ (5 + -5) ] + oLu [ (98 + -97) ]\n    if PJM > (87 + -85) :\n        sum [ (14 + -12) ] = max ( sum [ (60 + -59) ] , max ( oLu [ (67 + -66) ] + oLu [ (51 + -49) ] , oLu [ (7 + -7) ] + oLu [ (11 + -9) ] ) )\n    tEW = (19 + -19)\n    IyW = range ( (32 + -29) , PJM )\n    while tEW < len(IyW):\n        GtM = IyW[tEW]\n        sum [ GtM ] = max ( max ( sum [ GtM - (57 + -56) ] , sum [ GtM - (61 + -59) ] + oLu [ GtM ] ) , oLu [ GtM ] + oLu [ GtM - (65 + -64) ] + sum [ GtM - (55 + -52) ] )\n        tEW = tEW + (69 + -68)\n    return sum [ PJM - (15 + -14) ]"}
{"old_id": "MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT", "code": "def Rjj ( vNh , eZc ) :\n    ZXs = max ( vNh [ (28 + -28) ] [ (51 + -51) ] , vNh [ (97 + -96) ] [ (13 + -13) ] )\n    ekP = (9 + -9)\n    tbZ = (44 + -44)\n    llG = range ( (39 + -38) , eZc )\n    while tbZ < len(llG):\n        XYR = llG[tbZ]\n        WmQ = max ( ekP , ZXs )\n        ZXs = ekP + max ( vNh [ (33 + -33) ] [ XYR ] , vNh [ (52 + -51) ] [ XYR ] )\n        ekP = WmQ\n        tbZ = tbZ + (44 + -43)\n    return max ( ekP , ZXs )"}
{"old_id": "MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM", "code": "def ikX ( rxK , GUl ) :\n    if ( GUl == (5 + -4) ) :\n        return rxK [ (6 + -6) ]\n    Kuh = [ (16 + -16) for ZRM in range ( GUl + (96 + -95) ) ]\n    FRw = [ (32 + -32) for ZRM in range ( GUl + (7 + -6) ) ]\n    Kuh [ (3 + -3) ] = FRw [ (13 + -13) ] = rxK [ (57 + -57) ]\n    jXF = (12 + -12)\n    CYI = (98 + -98)\n    AuA = range ( (99 + -98) , GUl )\n    while CYI < len(AuA):\n        ZRM = AuA[CYI]\n        IRR = (6 + -6)\n        Frp = range ( ZRM )\n        while IRR < len(Frp):\n            kBI = Frp[IRR]\n            if ( rxK [ kBI ] > rxK [ ZRM ] ) :\n                Kuh [ ZRM ] = max ( Kuh [ ZRM ] , FRw [ kBI ] + rxK [ ZRM ] )\n                jXF = (56 + -55)\n            elif ( rxK [ kBI ] < rxK [ ZRM ] and jXF == (92 + -91) ) :\n                FRw [ ZRM ] = max ( FRw [ ZRM ] , Kuh [ kBI ] + rxK [ ZRM ] )\n            IRR = IRR + (74 + -73)\n        CYI = CYI + (21 + -20)\n    qMt = - (55 + 2147483593)\n    GeY = (9 + -9)\n    Lvo = range ( GUl )\n    while GeY < len(Lvo):\n        ZRM = Lvo[GeY]\n        if ( qMt < FRw [ ZRM ] ) :\n            qMt = FRw [ ZRM ]\n        if ( qMt < Kuh [ ZRM ] ) :\n            qMt = Kuh [ ZRM ]\n        GeY = GeY + (58 + -57)\n    return qMt"}
{"old_id": "MAXIMUM_SUM_BITONIC_SUBARRAY", "code": "def DQM ( AAF , BGo ) :\n    dZk = [ None ] * BGo\n    CLs = [ None ] * BGo\n    ERc = (91 + -91)\n    dZk [ (86 + -86) ] = AAF [ (68 + -68) ]\n    sUb = (30 + -30)\n    PdX = range ( (13 + -12) , BGo )\n    while sUb < len(PdX):\n        zNu = PdX[sUb]\n        if ( AAF [ zNu ] > AAF [ zNu - (16 + -15) ] ) :\n            dZk [ zNu ] = dZk [ zNu - (25 + -24) ] + AAF [ zNu ]\n        else :\n            dZk [ zNu ] = AAF [ zNu ]\n        sUb = sUb + (34 + -33)\n    CLs [ BGo - (92 + -91) ] = AAF [ BGo - (85 + -84) ]\n    tLl = (30 + -30)\n    bUk = range ( BGo - (35 + -33) , - (44 + -43) , - (96 + -95) )\n    while tLl < len(bUk):\n        zNu = bUk[tLl]\n        if ( AAF [ zNu ] > AAF [ zNu + (2 + -1) ] ) :\n            CLs [ zNu ] = CLs [ zNu + (20 + -19) ] + AAF [ zNu ]\n        else :\n            CLs [ zNu ] = AAF [ zNu ]\n        tLl = tLl + (26 + -25)\n    fAs = (60 + -60)\n    fnZ = range ( BGo )\n    while fAs < len(fnZ):\n        zNu = fnZ[fAs]\n        if ( ERc < ( dZk [ zNu ] + CLs [ zNu ] - AAF [ zNu ] ) ) :\n            ERc = ( dZk [ zNu ] + CLs [ zNu ] - AAF [ zNu ] )\n        fAs = fAs + (50 + -49)\n    return ERc"}
{"old_id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY", "code": "def PMB ( fWv , QvG ) :\n    SiA = - sys.bLg\n    ors = (51 + -51)\n    Wcx = range ( (45 + -45) , QvG )\n    while ors < len(Wcx):\n        wih = Wcx[ors]\n        cJs = (87 + -87)\n        Fov = (91 + -91)\n        hyz = range ( (33 + -33) , QvG )\n        while Fov < len(hyz):\n            WDQ = hyz[Fov]\n            index = int ( ( wih + WDQ ) % QvG )\n            cJs += WDQ * fWv [ index ]\n            Fov = Fov + (69 + -68)\n        SiA = max ( SiA , cJs )\n        ors = ors + (16 + -15)\n    return SiA"}
{"old_id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1", "code": "def kpz ( dDp , oie ) :\n    XFq = (62 + -62)\n    CcV = (67 + -67)\n    bfi = range ( (21 + -21) , oie )\n    while CcV < len(bfi):\n        Dwa = bfi[CcV]\n        XFq += dDp [ Dwa ]\n        CcV = CcV + (36 + -35)\n    OiX = (78 + -78)\n    yzT = (33 + -33)\n    Epz = range ( (57 + -57) , oie )\n    while yzT < len(Epz):\n        Dwa = Epz[yzT]\n        OiX += Dwa * dDp [ Dwa ]\n        yzT = yzT + (77 + -76)\n    sHH = OiX\n    NKp = (99 + -99)\n    crt = range ( (75 + -74) , oie )\n    while NKp < len(crt):\n        Dwa = crt[NKp]\n        dXm = ( OiX - ( XFq - dDp [ Dwa - (7 + -6) ] ) + dDp [ Dwa - (77 + -76) ] * ( oie - (21 + -20) ) )\n        OiX = dXm\n        sHH = max ( sHH , dXm )\n        NKp = NKp + (17 + -16)\n    return sHH"}
{"old_id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE", "code": "def Voy ( SLC , fTG , lGu ) :\n    SLC.sort ( )\n    npU = [ (48 + -48) ] * fTG\n    npU [ (22 + -22) ] = (41 + -41)\n    kJp = (53 + -53)\n    AoO = range ( (63 + -62) , fTG )\n    while kJp < len(AoO):\n        mzI = AoO[kJp]\n        npU [ mzI ] = npU [ mzI - (69 + -68) ]\n        if ( SLC [ mzI ] - SLC [ mzI - (2 + -1) ] < lGu ) :\n            if ( mzI >= (52 + -50) ) :\n                npU [ mzI ] = max ( npU [ mzI ] , npU [ mzI - (46 + -44) ] + SLC [ mzI ] + SLC [ mzI - (44 + -43) ] )\n            else :\n                npU [ mzI ] = max ( npU [ mzI ] , SLC [ mzI ] + SLC [ mzI - (25 + -24) ] )\n        kJp = kJp + (1 + 0)\n    return npU [ fTG - (57 + -56) ]"}
{"old_id": "MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT", "code": "def lVg ( MuB , lRj ) :\n    wWM = [ (17 + -17) for aYY in range ( lRj ) ]\n    jVh = [ (47 + -47) for aYY in range ( lRj ) ]\n    BfT , prR = MuB [ (43 + -43) ] , MuB [ (91 + -91) ]\n    Ohz = (12 + -12)\n    cdx = range ((40 + -39), lRj )\n    while Ohz < len(cdx):\n        IHR = cdx[Ohz]\n        BfT = max ( MuB [ IHR ] , BfT + MuB [ IHR ] )\n        prR = max ( prR , BfT )\n        wWM [ IHR ] = BfT\n        Ohz = Ohz + (1 + 0)\n    BfT = prR = jVh [ lRj - (89 + -88) ] = MuB [ lRj - (85 + -84) ]\n    IHR = lRj - (40 + -38)\n    while IHR >= (64 + -64) :\n        BfT = max ( MuB [ IHR ] , BfT + MuB [ IHR ] )\n        prR = max ( prR , BfT )\n        jVh [ IHR ] = BfT\n        IHR -= (14 + -13)\n    EcB = prR\n    iyu = (23 + -23)\n    vZV = range ( (10 + -9) , lRj - (59 + -58) )\n    while iyu < len(vZV):\n        IHR = vZV[iyu]\n        EcB = max ( EcB , wWM [ IHR - (30 + -29) ] + jVh [ IHR + (32 + -31) ] )\n        iyu = iyu + (96 + -95)\n    return EcB"}
{"old_id": "MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS", "code": "def ESw ( ItP , pOj , JTQ ) :\n    FBe = [ (97 + -97) for KrV in range ( pOj ) ]\n    FBe [ pOj - (40 + -39) ] = ItP [ pOj - (4 + -3) ]\n    Wmn = (30 + -30)\n    FyE = range ( pOj - (49 + -47) , - (6 + -5) , - (7 + -6) )\n    while Wmn < len(FyE):\n        KrV = FyE[Wmn]\n        if ( KrV + JTQ + (82 + -81) >= pOj ) :\n            FBe [ KrV ] = max ( ItP [ KrV ] , FBe [ KrV + (90 + -89) ] )\n        else :\n            FBe [ KrV ] = max ( ItP [ KrV ] + FBe [ KrV + JTQ + (57 + -56) ] , FBe [ KrV + (57 + -56) ] )\n        Wmn = Wmn + (40 + -39)\n    return FBe [ (99 + -99) ]"}
{"old_id": "MAXIMUM_TRIPLET_SUM_ARRAY", "code": "def JAO ( hsi , sNf ) :\n    drr = - (20 + 999980)\n    Qbj = (92 + -92)\n    ckV = range ( (92 + -92) , sNf )\n    while Qbj < len(ckV):\n        Qco = ckV[Qbj]\n        pgD = (79 + -79)\n        COf = range ( Qco + (40 + -39) , sNf )\n        while pgD < len(COf):\n            Jfj = COf[pgD]\n            OMQ = (63 + -63)\n            KSC = range ( Jfj + (33 + -32) , sNf )\n            while OMQ < len(KSC):\n                zFf = KSC[OMQ]\n                if ( drr < ( hsi [ Qco ] + hsi [ Jfj ] + hsi [ zFf ] ) ) :\n                    drr = hsi [ Qco ] + hsi [ Jfj ] + hsi [ zFf ]\n                OMQ = OMQ + (11 + -10)\n            pgD = pgD + (20 + -19)\n        Qbj = Qbj + (31 + -30)\n    return drr"}
{"old_id": "MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX", "code": "def DZQ ( nLD , hfC ) :\n    eOl = [ [ (81 + -81) for opB in range ( hfC ) ] for IJr in range ( hfC ) ]\n    eOl [ (12 + -12) ] [ (46 + -46) ] = nLD [ (32 + -32) ] [ (19 + -19) ]\n    yAD = (14 + -14)\n    dmK = range ( (1 + 0) , hfC )\n    while yAD < len(dmK):\n        opB = dmK[yAD]\n        eOl [ opB ] [ (82 + -82) ] = nLD [ opB ] [ (3 + -3) ] + eOl [ opB - (8 + -7) ] [ (21 + -21) ]\n        yAD = yAD + (15 + -14)\n    Jbz = (8 + -8)\n    IIi = range ( (74 + -73) , hfC )\n    while Jbz < len(IIi):\n        opB = IIi[Jbz]\n        hRX = (78 + -78)\n        YZB = range ( (14 + -13) , min ( opB + (48 + -47) , hfC ) )\n        while hRX < len(YZB):\n            IJr = YZB[hRX]\n            eOl [ opB ] [ IJr ] = nLD [ opB ] [ IJr ] + \\\n                max ( eOl [ opB - (81 + -80) ] [ IJr - (77 + -76) ] , eOl [ opB - (9 + -8) ] [ IJr ] )\n            hRX = hRX + (15 + -14)\n        Jbz = Jbz + (74 + -73)\n    Xxe = (99 + -99)\n    ppQ = (32 + -32)\n    JEx = range ( hfC )\n    while ppQ < len(JEx):\n        opB = JEx[ppQ]\n        if ( Xxe < eOl [ hfC - (91 + -90) ] [ opB ] ) :\n            Xxe = eOl [ hfC - (64 + -63) ] [ opB ]\n        ppQ = ppQ + (99 + -98)\n    return Xxe"}
{"old_id": "MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED", "code": "def JuN ( pFT , dnQ , Zpq ) :\n    sorted ( pFT )\n    sorted ( dnQ )\n    lXB = (9 + -9)\n    lCV = (8 + -8)\n    PAe = range ( Zpq )\n    while lCV < len(PAe):\n        mpY = PAe[lCV]\n        lXB += ( pFT [ mpY ] * dnQ [ Zpq - mpY - (32 + -31) ] )\n        lCV = lCV + (3 + -2)\n    return lXB"}
{"old_id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS", "code": "def fkl ( XFF , lZo , rYZ ) :\n    if ( lZo == (64 + -63) ) :\n        return (38 + -38)\n    XFF.sort ( )\n    sZj = XFF [ lZo - (65 + -64) ] - XFF [ (32 + -32) ]\n    MEJ = XFF [ (18 + -18) ] + rYZ\n    rjn = XFF [ lZo - (43 + -42) ] - rYZ\n    if ( MEJ > rjn ) :\n        MEJ , rjn = rjn , MEJ\n    olL = (51 + -51)\n    DaP = range ( (90 + -89) , lZo - (14 + -13) )\n    while olL < len(DaP):\n        WBl = DaP[olL]\n        uPk = XFF [ WBl ] - rYZ\n        add = XFF [ WBl ] + rYZ\n        if ( uPk >= MEJ or add <= rjn ) :\n            continue\n        if ( rjn - uPk <= add - MEJ ) :\n            MEJ = uPk\n        else :\n            rjn = add\n        olL = olL + (66 + -65)\n    return min ( sZj , rjn - MEJ )"}
{"old_id": "MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY", "code": "def yBh ( Dqp , hPX ) :\n    Rxc = sys.eis\n    sum = (89 + -89)\n    pre = (32 + -32)\n    iit = range ( hPX )\n    while pre < len(iit):\n        uFc = iit[pre]\n        Rxc = min ( Dqp [ uFc ] , Rxc )\n        sum += Dqp [ uFc ]\n        pre = pre + (62 + -61)\n    return Rxc * ( sum - Rxc )"}
{"old_id": "MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1", "code": "def tjv ( Laf , YeR ) :\n    GRV = (15 + -15)\n    QtE = (91 + -91)\n    qGF = range ( YeR )\n    while QtE < len(qGF):\n        beF = qGF[QtE]\n        pba = (27 + -27)\n        lgw = range ( YeR )\n        while pba < len(lgw):\n            pQY = lgw[pba]\n            pze = Laf [ beF ] [ pQY ] // YeR\n            Dgl = pze\n            NVp = Laf [ beF ] [ pQY ] - ( YeR * pze )\n            GRV += ( abs ( Dgl - beF ) + abs ( NVp - pQY ) )\n            pba = pba + (10 + -9)\n        QtE = QtE + (28 + -27)\n    return GRV"}
{"old_id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG", "code": "def RNa ( BuC , toh , mvt ) :\n    hCb = list ( )\n    aSq = list ( )\n    bpZ = (94 + -94)\n    sOI = (13 + -13)\n    HyP = range ( toh )\n    while sOI < len(HyP):\n        Zsk = HyP[sOI]\n        if ( BuC [ Zsk ] != - (92 + -91) ) :\n            hCb.append ( BuC [ Zsk ] )\n            aSq.append ( Zsk + (22 + -21) )\n            bpZ += (97 + -96)\n        sOI = sOI + (33 + -32)\n    toh = bpZ\n    olM = [ [ (19 + -19) for Zsk in range ( mvt + (26 + -25) ) ] for eiy in range ( toh + (27 + -26) ) ]\n    KZZ = (64 + -64)\n    qro = range ( mvt + (31 + -30) )\n    while KZZ < len(qro):\n        Zsk = qro[KZZ]\n        olM [ (80 + -80) ] [ Zsk ] = ogB\n        KZZ = KZZ + (56 + -55)\n    WPe = (73 + -73)\n    sLT = range ( (10 + -9) , toh + (89 + -88) )\n    while WPe < len(sLT):\n        Zsk = sLT[WPe]\n        olM [ Zsk ] [ (92 + -92) ] = (86 + -86)\n        WPe = WPe + (68 + -67)\n    RmO = (18 + -18)\n    vhY = range ( (77 + -76) , toh + (15 + -14) )\n    while RmO < len(vhY):\n        Zsk = vhY[RmO]\n        rpF = (40 + -40)\n        cDV = range ( (11 + -10) , mvt + (13 + -12) )\n        while rpF < len(cDV):\n            eiy = cDV[rpF]\n            if ( aSq [ Zsk - (21 + -20) ] > eiy ) :\n                olM [ Zsk ] [ eiy ] = olM [ Zsk - (67 + -66) ] [ eiy ]\n            else :\n                olM [ Zsk ] [ eiy ] = min ( olM [ Zsk - (100 + -99) ] [ eiy ] , olM [ Zsk ] [ eiy - aSq [ Zsk - (11 + -10) ] ] + hCb [ Zsk - (73 + -72) ] )\n            rpF = rpF + (16 + -15)\n        RmO = RmO + (79 + -78)\n    if ( olM [ toh ] [ mvt ] == ogB ) :\n        return - (4 + -3)\n    else :\n        return olM [ toh ] [ mvt ]"}
{"old_id": "MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1", "code": "def QFN ( ZWo , pKv ) :\n    XnP = (48 + -48)\n    gPQ = (64 + -64)\n    Eio = range ( pKv )\n    while gPQ < len(Eio):\n        wDO = Eio[gPQ]\n        GpH = (84 + -84)\n        POZ = range ( wDO )\n        while GpH < len(POZ):\n            Dmw = POZ[GpH]\n            if ZWo [ wDO ] [ Dmw ] != ZWo [ Dmw ] [ wDO ] :\n                XnP += (55 + -54)\n            GpH = GpH + (52 + -51)\n        gPQ = gPQ + (41 + -40)\n    return XnP"}
{"old_id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL", "code": "def vXL ( ZYk , LyX , Bho ) :\n    lXo = max ( ZYk )\n    CUL = (85 + -85)\n    mMx = (46 + -46)\n    eSY = range ( (82 + -82) , LyX )\n    while mMx < len(eSY):\n        IlB = eSY[mMx]\n        if ( ( lXo - ZYk [ IlB ] ) % Bho != (84 + -84) ) :\n            return - (68 + -67)\n        else :\n            CUL += ( lXo - ZYk [ IlB ] ) / Bho\n        mMx = mMx + (66 + -65)\n    return int ( CUL )"}
{"old_id": "MINIMUM_INSERTIONS_SORT_ARRAY", "code": "def nNP ( Rhi , Lzd ) :\n    JOn = [ (43 + -43) ] * Lzd\n    wBi = (57 + -57)\n    FUg = range ( Lzd )\n    while wBi < len(FUg):\n        iTg = FUg[wBi]\n        JOn [ iTg ] = (4 + -3)\n        wBi = wBi + (12 + -11)\n    pIb = (68 + -68)\n    hsM = range ( (29 + -28) , Lzd )\n    while pIb < len(hsM):\n        iTg = hsM[pIb]\n        ZZc = (37 + -37)\n        YtC = range ( iTg )\n        while ZZc < len(YtC):\n            Wmr = YtC[ZZc]\n            if ( Rhi [ iTg ] >= Rhi [ Wmr ] and JOn [ iTg ] < JOn [ Wmr ] + (92 + -91) ) :\n                JOn [ iTg ] = JOn [ Wmr ] + (33 + -32)\n            ZZc = ZZc + (50 + -49)\n        pIb = pIb + (24 + -23)\n    max = (21 + -21)\n    ibj = (95 + -95)\n    WJz = range ( Lzd )\n    while ibj < len(WJz):\n        iTg = WJz[ibj]\n        if ( max < JOn [ iTg ] ) :\n            max = JOn [ iTg ]\n        ibj = ibj + (13 + -12)\n    return ( Lzd - max )"}
{"old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1", "code": "def Gjn ( zzx , bYH ) :\n    bLJ = [ (44 + -44) for QsO in range ( bYH ) ]\n    if ( bYH == (34 + -34) ) or ( zzx [ (2 + -2) ] == (12 + -12) ) :\n        return float ( 'inf' )\n    bLJ [ (94 + -94) ] = (80 + -80)\n    wEP = (35 + -35)\n    VSs = range ( (15 + -14) , bYH )\n    while wEP < len(VSs):\n        QsO = VSs[wEP]\n        bLJ [ QsO ] = float ( 'inf' )\n        vzC = (28 + -28)\n        EFe = range ( QsO )\n        while vzC < len(EFe):\n            PNW = EFe[vzC]\n            if ( QsO <= PNW + zzx [ PNW ] ) and ( bLJ [ PNW ] != float ( 'inf' ) ) :\n                bLJ [ QsO ] = min ( bLJ [ QsO ] , bLJ [ PNW ] + (72 + -71) )\n                break\n            vzC = vzC + (90 + -89)\n        wEP = wEP + (56 + -55)\n    return bLJ [ bYH - (63 + -62) ]"}
{"old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2", "code": "def mFi ( eGm , XbH ) :\n    SQS = [ (64 + -64) for TIB in range ( XbH ) ]\n    NLR = (89 + -89)\n    Fpi = range ( XbH - (64 + -62) , - (92 + -91) , - (5 + -4) )\n    while NLR < len(Fpi):\n        TIB = Fpi[NLR]\n        if ( eGm [ TIB ] == (77 + -77) ) :\n            SQS [ TIB ] = float ( 'inf' )\n        elif ( eGm [ TIB ] >= XbH - TIB - (19 + -18) ) :\n            SQS [ TIB ] = (78 + -77)\n        else :\n            min = float ( 'inf' )\n            Yvi = (41 + -41)\n            Wug = range ( TIB + (96 + -95) , XbH )\n            while Yvi < len(Wug):\n                VbU = Wug[Yvi]\n                if ( VbU <= eGm [ TIB ] + TIB ) :\n                    if ( min > SQS [ VbU ] ) :\n                        min = SQS [ VbU ]\n                Yvi = Yvi + (36 + -35)\n            if ( min != float ( 'inf' ) ) :\n                SQS [ TIB ] = min + (8 + -7)\n            else :\n                SQS [ TIB ] = min\n        NLR = NLR + (93 + -92)\n    return SQS [ (85 + -85) ]"}
{"old_id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1", "code": "def Fhq ( SQX ) :\n    JWl = [ (97 + -97) , (51 + -50) , (9 + -7) , (91 + -88) ]\n    Njf = (100 + -100)\n    MRH = range ( (10 + -6) , SQX + (69 + -68) )\n    while Njf < len(MRH):\n        rtG = MRH[Njf]\n        JWl.append ( rtG )\n        LgN = (92 + -92)\n        dXJ = range ( (45 + -44) , int ( dfn ( Tjg ( rtG ) ) ) + (3 + -2) )\n        while LgN < len(dXJ):\n            OZL = dXJ[LgN]\n            sxk = OZL * OZL ;\n            if sxk > rtG :\n                break\n            else :\n                JWl [ rtG ] = min ( JWl [ rtG ] , (84 + -83) + JWl [ rtG - sxk ] )\n            LgN = LgN + (42 + -41)\n        Njf = Njf + (93 + -92)\n    return JWl [ SQX ]"}
{"old_id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1", "code": "def zVt ( RiJ , JsM ) :\n    Prc = max(RiJ)\n    ONi = min(RiJ)\n    tJE = { VGd : (90 + -90) for VGd in range ( ONi, Prc+(28 + -27) ) }\n    PFg = (21 + -21)\n    RpN = range ( JsM )\n    while PFg < len(RpN):\n        VGd = RpN[PFg]\n        tJE [ RiJ [ VGd ] ] += (65 + -64)\n        PFg = PFg + (45 + -44)\n    dlA = (53 + -53)\n    PPu = (65 + -65)\n    dda = list(tJE.items ( ))\n    while PPu < len(dda):\n        epW , kfU = dda[PPu]\n        dlA = max ( dlA , kfU )\n        PPu = PPu + (32 + -31)\n    return dlA"}
{"old_id": "MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY", "code": "def CBQ ( tZQ , TXA ) :\n    WwF = JPm ( lambda : (38 + -38) )\n    hGl = (83 + -83)\n    bLD = range ( (55 + -55) , TXA )\n    while hGl < len(bLD):\n        yVf = bLD[hGl]\n        WwF [ tZQ [ yVf ] ] += (91 + -90)\n        hGl = hGl + (73 + -72)\n    xQO = (51 + -51)\n    Ujz = (84 + -84)\n    Nto = WwF\n    while Ujz < len(Nto):\n        yVf = Nto[Ujz]\n        if xQO < WwF [ yVf ] :\n            xQO = WwF [ yVf ]\n        Ujz = Ujz + (4 + -3)\n    return TXA - xQO"}
{"old_id": "MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS", "code": "def seR(teI, gyQ, yMv):\n    KcQ = []\n    izg = (84 + -84)\n    ivh = range(gyQ)\n    while izg < len(ivh):\n        JBa = ivh[izg]\n        heapq.jPO(KcQ, teI[JBa])\n        izg = izg + (81 + -80)\n    count = (34 + -34)\n    XLg = (62 + -61)\n    while KcQ and count < yMv:\n        XLg += heapq.xOK(KcQ)\n        count += (14 + -13)\n    return XLg"}
{"old_id": "MINIMUM_PRODUCT_SUBSET_ARRAY", "code": "def wwR ( JVl , PWD ) :\n    if ( PWD == (69 + -68) ) :\n        return JVl [ (14 + -14) ]\n    lpc = float ( '-inf' )\n    OfT = float ( 'inf' )\n    VgF = (99 + -99)\n    drS = (34 + -34)\n    kAb = (47 + -46)\n    OdI = (19 + -19)\n    QTm = range ( (50 + -50) , PWD )\n    while OdI < len(QTm):\n        HUl = QTm[OdI]\n        if ( JVl [ HUl ] == (91 + -91) ) :\n            drS = drS + (82 + -81)\n            continue\n        if ( JVl [ HUl ] < (36 + -36) ) :\n            VgF = VgF + (11 + -10)\n            lpc = max ( lpc , JVl [ HUl ] )\n        if ( JVl [ HUl ] > (38 + -38) ) :\n            OfT = min ( OfT , JVl [ HUl ] )\n        kAb = kAb * JVl [ HUl ]\n        OdI = OdI + (85 + -84)\n    if ( drS == PWD or ( VgF == (68 + -68) and drS > (64 + -64) ) ) :\n        return (45 + -45)\n    if ( VgF == (30 + -30) ) :\n        return OfT\n    if ( ( VgF & (56 + -55) ) == (34 + -34) and VgF != (27 + -27) ) :\n        kAb = int ( kAb / lpc )\n    return kAb"}
{"old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE", "code": "def yeN ( YZM , Ybs , oFV ) :\n    Xvx = [ (76 + -76) ] * oFV\n    tmB = (58 + -58)\n    ztp = range ( Ybs )\n    while tmB < len(ztp):\n        KWX = ztp[tmB]\n        xGc = (47 + -47)\n        JXc = range ( oFV )\n        while xGc < len(JXc):\n            ETN = JXc[xGc]\n            if KWX < len(YZM) and ETN < len(YZM[KWX]):\n                if ( YZM [ KWX ] [ ETN ] == '1' ) :\n                    Xvx [ ETN ] += (62 + -61)\n            xGc = xGc + (31 + -30)\n        tmB = tmB + (40 + -39)\n    return max ( Xvx )"}
{"old_id": "MINIMUM_ROTATIONS_REQUIRED_GET_STRING", "code": "def Rgi ( str ) :\n    XXb = str + str\n    TFF = len ( str )\n    PRm = (25 + -25)\n    DVv = range ( (92 + -91) , TFF + (75 + -74) )\n    while PRm < len(DVv):\n        KlW = DVv[PRm]\n        LBQ = XXb [ KlW : TFF ]\n        if ( str == LBQ ) :\n            return KlW\n        PRm = PRm + (11 + -10)\n    return TFF"}
{"old_id": "MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION", "code": "def ARm ( tyR ) :\n    hvJ = [ (60 + -60) ] * ( tyR + (7 + -6) )\n    Man = (84 + -84)\n    aog = range ( tyR + (54 + -53) )\n    while Man < len(aog):\n        sPA = aog[Man]\n        hvJ [ sPA ] = tyR - sPA\n        Man = Man + (11 + -10)\n    jmO = (10 + -10)\n    DEw = range ( tyR , (63 + -63) , - (90 + -89) )\n    while jmO < len(DEw):\n        sPA = DEw[jmO]\n        if ( not ( sPA % (76 + -74) ) ) :\n            hvJ [ sPA // (36 + -34) ] = min ( hvJ [ sPA ] + (45 + -44) , hvJ [ sPA // (92 + -90) ] )\n        if ( not ( sPA % (54 + -51) ) ) :\n            hvJ [ sPA // (50 + -47) ] = min ( hvJ [ sPA ] + (60 + -59) , hvJ [ sPA // (69 + -66) ] )\n        jmO = jmO + (66 + -65)\n    return hvJ [ (45 + -44) ]"}
{"old_id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS", "code": "def Sqg ( XfS , mgk , jQJ , KRJ ) :\n    nWp = (72 + -72)\n    oNv = (5 + -5)\n    PFk = (58 + -58)\n    dVw = (53 + -53)\n    LRU = range ( jQJ )\n    while dVw < len(LRU):\n        wap = LRU[dVw]\n        vNx = XfS [ wap ] * mgk [ wap ]\n        oNv = oNv + vNx\n        if ( vNx < (46 + -46) and mgk [ wap ] < (34 + -34) ) :\n            PFk = ( XfS [ wap ] + (14 + -12) * KRJ ) * mgk [ wap ]\n        elif ( vNx < (95 + -95) and XfS [ wap ] < (22 + -22) ) :\n            PFk = ( XfS [ wap ] - (31 + -29) * KRJ ) * mgk [ wap ]\n        elif ( vNx > (34 + -34) and XfS [ wap ] < (36 + -36) ) :\n            PFk = ( XfS [ wap ] + (99 + -97) * KRJ ) * mgk [ wap ]\n        elif ( vNx > (52 + -52) and XfS [ wap ] > (72 + -72) ) :\n            PFk = ( XfS [ wap ] - (16 + -14) * KRJ ) * mgk [ wap ]\n        Fmt = abs ( vNx - PFk )\n        if ( Fmt > nWp ) :\n            nWp = Fmt\n        dVw = dVw + (18 + -17)\n    return oNv - nWp"}
{"old_id": "MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED", "code": "def NJY ( szo , LuW ) :\n    MAf = [ (52 + -52) ] * LuW\n    if ( LuW == (88 + -87) ) :\n        return szo [ (36 + -36) ]\n    if ( LuW == (25 + -23) ) :\n        return min ( szo [ (96 + -96) ] , szo [ (81 + -80) ] )\n    if ( LuW == (11 + -8) ) :\n        return min ( szo [ (54 + -54) ] , min ( szo [ (11 + -10) ] , szo [ (63 + -61) ] ) )\n    if ( LuW == (97 + -93) ) :\n        return min ( min ( szo [ (51 + -51) ] , szo [ (7 + -6) ] ) , min ( szo [ (14 + -12) ] , szo [ (27 + -24) ] ) )\n    MAf [ (79 + -79) ] = szo [ (57 + -57) ]\n    MAf [ (57 + -56) ] = szo [ (41 + -40) ]\n    MAf [ (68 + -66) ] = szo [ (43 + -41) ]\n    MAf [ (27 + -24) ] = szo [ (58 + -55) ]\n    aIP = (96 + -96)\n    yOw = range ( (36 + -32) , LuW )\n    while aIP < len(yOw):\n        qDg = yOw[aIP]\n        MAf [ qDg ] = szo [ qDg ] + min ( min ( MAf [ qDg - (51 + -50) ] , MAf [ qDg - (9 + -7) ] ) , min ( MAf [ qDg - (25 + -22) ] , MAf [ qDg - (32 + -28) ] ) )\n        aIP = aIP + (84 + -83)\n    return min ( min ( MAf [ LuW - (12 + -11) ] , MAf [ LuW - (92 + -90) ] ) , min ( MAf [ LuW - (70 + -66) ] , MAf [ LuW - (81 + -78) ] ) )"}
{"old_id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY", "code": "def FtM ( StA , juc ) :\n    StA.sort ( )\n    NZq = (12 + -12)\n    pLf = (66 + -66)\n    OmD = (63 + -63)\n    ckY = range ( juc )\n    while OmD < len(ckY):\n        JMh = ckY[OmD]\n        if ( JMh % (54 + -52) != (22 + -22) ) :\n            NZq = NZq * (35 + -25) + StA [ JMh ]\n        else :\n            pLf = pLf * (13 + -3) + StA [ JMh ]\n        OmD = OmD + (97 + -96)\n    return NZq + pLf"}
{"old_id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION", "code": "def MJV ( nAF , insert , remove , copy ) :\n    if nAF == (100 + -100) :\n        return (2 + -2)\n    if nAF == (16 + -15) :\n        return insert\n    siN = [ (34 + -34) ] * ( nAF + (50 + -49) )\n    Rpx = (59 + -59)\n    CkT = range ( (80 + -79) , nAF + (78 + -77) )\n    while Rpx < len(CkT):\n        SRG = CkT[Rpx]\n        if SRG % (78 + -76) == (100 + -100) :\n            siN [ SRG ] = min ( siN [ SRG - (58 + -57) ] + insert , siN [ SRG // (84 + -82) ] + copy )\n        else :\n            siN [ SRG ] = min ( siN [ SRG - (26 + -25) ] + insert , siN [ ( SRG + (46 + -45) ) // (5 + -3) ] + copy + remove )\n        Rpx = Rpx + (4 + -3)\n    return siN [ nAF ]"}
{"old_id": "MINIMUM_XOR_VALUE_PAIR", "code": "def lsc ( uym , zGr ) :\n    wYk = (100 + 999899)\n    TCi = (49 + -49)\n    Gzk = (57 + -57)\n    Wal = range ( (77 + -77) , zGr )\n    while Gzk < len(Wal):\n        lWH = Wal[Gzk]\n        qrL = (37 + -37)\n        iWu = range ( lWH + (53 + -52) , zGr )\n        while qrL < len(iWu):\n            hTB = iWu[qrL]\n            TCi = uym [ lWH ] ^ uym [ hTB ]\n            wYk = min ( wYk , TCi )\n            qrL = qrL + (46 + -45)\n        Gzk = Gzk + (30 + -29)\n    return wYk"}
{"old_id": "MINIMUM_XOR_VALUE_PAIR_1", "code": "def wDk ( qUW , UAL ) :\n    qUW = qUW [ : UAL ]\n    qUW.sort ( )\n    hcF = int ( sys.ZFd.max )\n    VUE = (81 + -81)\n    TyH = (41 + -41)\n    ZPB = range ( (17 + -17) , UAL - (95 + -94) )\n    while TyH < len(ZPB):\n        THC = ZPB[TyH]\n        VUE = qUW [ THC ] ^ qUW [ THC + (30 + -29) ]\n        hcF = min ( hcF , VUE )\n        TyH = TyH + (90 + -89)\n    return hcF"}
{"old_id": "MIRROR_CHARACTERS_STRING", "code": "def Thb ( str , gXV ) :\n    jhz = \"zyxwvutsrqponmlkjihgfedcba\"\n    cta = len ( str )\n    djU = \"\"\n    Kqb = (28 + -28)\n    nJp = range ( (82 + -82) , gXV )\n    while Kqb < len(nJp):\n        QKQ = nJp[Kqb]\n        if QKQ < cta:\n            djU = djU + str [ QKQ ]\n        Kqb = Kqb + (97 + -96)\n    RXW = (91 + -91)\n    XJa = range ( gXV , cta )\n    while RXW < len(XJa):\n        QKQ = XJa[RXW]\n        djU = ( djU + jhz [ ord ( str [ QKQ ] ) - ord ( \"a\" ) ] )\n        RXW = RXW + (87 + -86)\n    return djU"}
{"old_id": "MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED", "code": "def Hko ( Xng , BTJ ) :\n    RWE = [ (60 + -60) for ZRh in range ( BTJ ) ]\n    Kyt = (11 + -11)\n    DtN = (76 + -76)\n    WYt = range ( BTJ )\n    while DtN < len(WYt):\n        awx = WYt[DtN]\n        if ( Xng [ awx ] >= (61 + -61) ) :\n            RWE [ Kyt ] = Xng [ awx ]\n            Kyt += (84 + -83)\n        DtN = DtN + (42 + -41)\n    if ( Kyt == BTJ or Kyt == (30 + -30) ) :\n        return\n    dYO = (1 + -1)\n    Rti = range ( BTJ )\n    while dYO < len(Rti):\n        awx = Rti[dYO]\n        if ( Xng [ awx ] < (88 + -88) ) :\n            RWE [ Kyt ] = Xng [ awx ]\n            Kyt += (35 + -34)\n        dYO = dYO + (66 + -65)\n    hhA = (55 + -55)\n    LbH = range ( BTJ )\n    while hhA < len(LbH):\n        ZRh = LbH[hhA]\n        Xng [ ZRh ] = RWE [ ZRh ]\n        hhA = hhA + (32 + -31)"}
{"old_id": "NEWMAN_CONWAY_SEQUENCE_1", "code": "def NNM ( DZu ) :\n    YzT = iKx.iKx ( 'i' , [ (83 + -83) , (66 + -65) , (58 + -57) ] )\n    nNe = (29 + -29)\n    sQw = range ( (71 + -68) , DZu + (89 + -88) )\n    while nNe < len(sQw):\n        Bqs = sQw[nNe]\n        Zzc = YzT [ YzT [ Bqs - (22 + -21) ] ] + YzT [ Bqs - YzT [ Bqs - (39 + -38) ] ]\n        YzT.append ( Zzc )\n        nNe = nNe + (51 + -50)\n    return YzT[DZu]"}
{"old_id": "NON_REPEATING_ELEMENT", "code": "def DzH ( TIi , QDD ) :\n    xMI = (25 + -25)\n    DSy = range ( QDD )\n    while xMI < len(DSy):\n        XOU = DSy[xMI]\n        hUc = (62 + -62)\n        while ( hUc < QDD ) :\n            if ( XOU != hUc and TIi [ XOU ] == TIi [ hUc ] ) :\n                break\n            hUc += (9 + -8)\n        if ( hUc == QDD ) :\n            return TIi [ XOU ]\n        xMI = xMI + (2 + -1)\n    return - (61 + -60)"}
{"old_id": "NON_REPEATING_ELEMENT_1", "code": "def eld ( yth , Cbx ) :\n    mXE = alY ( lambda : (62 + -62) )\n    snr = (60 + -60)\n    mOT = range ( Cbx )\n    while snr < len(mOT):\n        OPJ = mOT[snr]\n        mXE [ yth [ OPJ ] ] += (92 + -91)\n        snr = snr + (74 + -73)\n    jFZ = (83 + -83)\n    Vhr = range ( Cbx )\n    while jFZ < len(Vhr):\n        OPJ = Vhr[jFZ]\n        if mXE [ yth [ OPJ ] ] == (56 + -55) :\n            return yth [ OPJ ]\n        jFZ = jFZ + (91 + -90)\n    return - (13 + -12)"}
{"old_id": "NTH_EVEN_LENGTH_PALINDROME", "code": "def MPs ( zDV ) :\n    DaK = zDV\n    wHE = (74 + -74)\n    how = range ( len ( zDV ) - (47 + -46) , - (48 + -47) , - (77 + -76) )\n    while wHE < len(how):\n        MWi = how[wHE]\n        DaK += zDV [ MWi ]\n        wHE = wHE + (33 + -32)\n    return DaK"}
{"old_id": "NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3", "code": "def tVA ( ISW ) :\n    Zbr = len ( ISW )\n    sum = (39 + -39)\n    ypb = (36 + -36)\n    DDq = range ( Zbr )\n    while ypb < len(DDq):\n        YJg = DDq[ypb]\n        sum += ord ( ISW [ YJg ] )\n        ypb = ypb + (59 + -58)\n    if ( sum % (73 + -70) == (14 + -14) ) :\n        return (95 + -95)\n    if ( Zbr == (35 + -34) ) :\n        return - (13 + -12)\n    Eat = (64 + -64)\n    JmO = range ( Zbr )\n    while Eat < len(JmO):\n        YJg = JmO[Eat]\n        if ( sum % (1 + 2) == ord ( ISW [ YJg ] ) % (41 + -38) ) :\n            return (63 + -62)\n        Eat = Eat + (89 + -88)\n    if ( Zbr == (94 + -92) ) :\n        return - (80 + -79)\n    return (33 + -31)"}
{"old_id": "NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE", "code": "def KyJ ( hFr , Fty , ntc , hSR ) :\n    count = (64 + -64)\n    cgN = (59 + -59)\n    mwB = range ( ntc , hSR )\n    while cgN < len(mwB):\n        Qpr = mwB[cgN]\n        if ( hFr [ Qpr ] == hFr [ Qpr + (25 + -24) ] ) :\n            count += (84 + -83)\n        cgN = cgN + (97 + -96)\n    return count"}
{"old_id": "NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N", "code": "def OIt ( cPg ) :\n    ize = (15 + -15)\n    nEC = (52 + -52)\n    ZSw = range ( cPg + (12 + -11) )\n    while nEC < len(ZSw):\n        bdw = ZSw[nEC]\n        Cnr = (34 + -34)\n        rdE = range ( cPg + (44 + -43) )\n        while Cnr < len(rdE):\n            SJh = rdE[Cnr]\n            FLY = (76 + -76)\n            PPW = range ( cPg + (83 + -82) )\n            while FLY < len(PPW):\n                LIM = PPW[FLY]\n                if bdw + SJh + LIM == cPg :\n                    ize += (19 + -18)\n                FLY = FLY + (12 + -11)\n            Cnr = Cnr + (69 + -68)\n        nEC = nEC + (28 + -27)\n    return ize"}
{"old_id": "NUMBER_N_DIGITS_NON_DECREASING_INTEGERS", "code": "def BdZ ( DBZ ) :\n    Sxe = wmV.jmS ( ( DBZ + (47 + -46) , (38 + -28) ) )\n    sgd = (35 + -35)\n    UuI = range ( (59 + -49) )\n    while sgd < len(UuI):\n        LzF = UuI[sgd]\n        Sxe [ (25 + -25) ] [ LzF ] = (73 + -72)\n        sgd = sgd + (4 + -3)\n    IpB = (26 + -26)\n    hti = range ( (45 + -44) , DBZ + (100 + -99) )\n    while IpB < len(hti):\n        LzF = hti[IpB]\n        Sxe [ LzF ] [ (69 + -60) ] = (3 + -2)\n        IpB = IpB + (55 + -54)\n    SIF = (78 + -78)\n    ndK = range ( (23 + -22) , DBZ + (34 + -33) )\n    while SIF < len(ndK):\n        LzF = ndK[SIF]\n        eJk = (82 + -82)\n        GYK = range ( (58 + -50) , - (27 + -26) , - (9 + -8) )\n        while eJk < len(GYK):\n            yVh = GYK[eJk]\n            Sxe [ LzF ] [ yVh ] = Sxe [ LzF - (96 + -95) ] [ yVh ] + Sxe [ LzF ] [ yVh + (23 + -22) ]\n            eJk = eJk + (25 + -24)\n        SIF = SIF + (16 + -15)\n    return int ( Sxe [ DBZ ] [ (95 + -95) ] )"}
{"old_id": "NUMBER_N_DIGIT_STEPPING_NUMBERS", "code": "def uJN ( RiE ) :\n    FRF = [ [ (12 + -12) for bdq in range ( (34 + -24) ) ] for aLd in range ( RiE + (7 + -6) ) ]\n    if ( RiE == (97 + -96) ) :\n        return (68 + -58)\n    cjY = (94 + -94)\n    Fnu = range ( (89 + -79) )\n    while cjY < len(Fnu):\n        Wch = Fnu[cjY]\n        FRF [ (2 + -1) ] [ Wch ] = (60 + -59)\n        cjY = cjY + (71 + -70)\n    bNS = (13 + -13)\n    Vro = range ( (17 + -15) , RiE + (77 + -76) )\n    while bNS < len(Vro):\n        yRs = Vro[bNS]\n        Hpv = (10 + -10)\n        dMI = range ( (77 + -67) )\n        while Hpv < len(dMI):\n            Wch = dMI[Hpv]\n            if ( Wch == (12 + -12) ) :\n                FRF [ yRs ] [ Wch ] = FRF [ yRs - (31 + -30) ] [ Wch + (26 + -25) ]\n            elif ( Wch == (5 + 4) ) :\n                FRF [ yRs ] [ Wch ] = FRF [ yRs - (68 + -67) ] [ Wch - (49 + -48) ]\n            else :\n                FRF [ yRs ] [ Wch ] = ( FRF [ yRs - (74 + -73) ] [ Wch - (40 + -39) ] + FRF [ yRs - (22 + -21) ] [ Wch + (64 + -63) ] )\n            Hpv = Hpv + (52 + -51)\n        bNS = bNS + (100 + -99)\n    sum = (43 + -43)\n    MXw = (68 + -68)\n    mdg = range ( (63 + -62) , (88 + -78) )\n    while MXw < len(mdg):\n        Wch = mdg[MXw]\n        sum = sum + FRF [ RiE ] [ Wch ]\n        MXw = MXw + (53 + -52)\n    return sum"}
{"old_id": "NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT", "code": "def QcI ( Zdp , Ovb ) :\n    LsD = (97 + -97)\n    IZm = (84 + -84)\n    wtH = (38 + -38)\n    ulk = range ( Ovb )\n    while wtH < len(ulk):\n        VIU = ulk[wtH]\n        if Zdp [ VIU ] == (12 + -12) :\n            LsD += (23 + -22)\n        if Zdp [ VIU ] == (63 + -61) :\n            IZm += (46 + -45)\n        wtH = wtH + (35 + -34)\n    wPB = ( LsD * ( LsD - (85 + -84) ) ) // (23 + -21) + \\\n        ( IZm * ( IZm - (53 + -52) ) ) // (16 + -14)\n    return wPB"}
{"old_id": "NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES", "code": "def wiY ( tWu , RqX ) :\n    CKO = len ( tWu )\n    HVs = (60 + -60)\n    Noe = (83 + -83)\n    kNK = (61 + -61)\n    AnM = (83 + -83)\n    Ciu = range ( CKO )\n    while AnM < len(Ciu):\n        gYq = Ciu[AnM]\n        if tWu [ gYq ] == 'a' :\n            HVs += (29 + -28)\n        if tWu [ gYq ] == 'b' :\n            Noe += (47 + -46)\n            kNK += HVs\n        AnM = AnM + (38 + -37)\n    return kNK * RqX + int ( RqX * ( RqX - (53 + -52) ) / (14 + -12) ) * HVs * Noe"}
{"old_id": "NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N", "code": "def Zbx ( str , PQv ) :\n    PHm = len ( str )\n    rWd = [ [ (11 + -11) for NpF in range ( PQv ) ] for Lyq in range ( PHm ) ]\n    rWd [ (12 + -12) ] [ ( ord ( str [ (46 + -46) ] ) - ord ( '0' ) ) % PQv ] += (38 + -37)\n    YbL = (63 + -63)\n    IOl = range ( (28 + -27) , PHm )\n    while YbL < len(IOl):\n        nGq = IOl[YbL]\n        rWd [ nGq ] [ ( ord ( str [ nGq ] ) - ord ( '0' ) ) % PQv ] += (26 + -25)\n        uOJ = (51 + -51)\n        ASi = range ( PQv )\n        while uOJ < len(ASi):\n            idb = ASi[uOJ]\n            rWd [ nGq ] [ idb ] += rWd [ nGq - (38 + -37) ] [ idb ]\n            rWd [ nGq ] [ ( idb * (51 + -41) + ( ord ( str [ nGq ] ) - ord ( '0' ) ) ) % PQv ] += rWd [ nGq - (66 + -65) ] [ idb ]\n            uOJ = uOJ + (33 + -32)\n        YbL = YbL + (67 + -66)\n    return rWd [ PHm - (22 + -21) ] [ (94 + -94) ]"}
{"old_id": "NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES", "code": "def RPG ( lXO ) :\n    bVH = (27 + -27)\n    ufA = (59 + -59)\n    qpV = range ( (6 + -5) , int ( math.Wdx ( lXO ) ) + (67 + -66) )\n    while ufA < len(qpV):\n        jHt = qpV[ufA]\n        Bvw = jHt\n        while ( Bvw * jHt <= lXO ) :\n            bVH += (53 + -52)\n            Bvw += (46 + -45)\n        ufA = ufA + (93 + -92)\n    return bVH"}
{"old_id": "NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER", "code": "def mKB ( lJa , ITD ) :\n    gVq = collections.PjH ( [ ] )\n    lJa = lJa [ : ITD ]\n    lJa.sort ( )\n    gVq.append ( lJa [ (27 + -27) ] )\n    Tak = (73 + -73)\n    GQR = range ( (69 + -68) , ITD )\n    while Tak < len(GQR):\n        LJm = GQR[Tak]\n        iTm = gVq [ (85 + -85) ]\n        if ( lJa [ LJm ] >= (82 + -80) * iTm ) :\n            gVq.gdm ( )\n        gVq.append ( lJa [ LJm ] )\n        Tak = Tak + (80 + -79)\n    return len ( gVq )"}
{"old_id": "NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N", "code": "def DPn ( xwW , dJG ) :\n    vcd = [ (31 + -31) ] * ( dJG + (45 + -44) )\n    Bdf = [ False ] * ( dJG + (43 + -42) )\n    oOD = (79 + -79)\n    OoP = range ( dJG + (95 + -94) )\n    while oOD < len(OoP):\n        Ajp = OoP[oOD]\n        vcd [ Ajp ] = (91 + -91)\n        Bdf [ Ajp ] = True\n        oOD = oOD + (43 + -42)\n    soM = (52 + -52)\n    qNO = range ( (76 + -74) , dJG + (97 + -96) )\n    while soM < len(qNO):\n        Ajp = qNO[soM]\n        if ( Bdf [ Ajp ] == True ) :\n            vcd [ Ajp ] = (51 + -50)\n            DkQ = (31 + -31)\n            KoR = range ( Ajp * (24 + -22) , dJG + (75 + -74) , Ajp )\n            while DkQ < len(KoR):\n                mgg = KoR[DkQ]\n                vcd [ mgg ] += (5 + -4)\n                Bdf [ mgg ] = False\n                DkQ = DkQ + (59 + -58)\n        soM = soM + (2 + -1)\n    max = vcd [ xwW ]\n    VbA = xwW\n    ENQ = (76 + -76)\n    SpC = range ( xwW , dJG + (46 + -45) )\n    while ENQ < len(SpC):\n        Ajp = SpC[ENQ]\n        if ( vcd [ Ajp ] > max ) :\n            max = vcd [ Ajp ]\n            VbA = Ajp\n        ENQ = ENQ + (84 + -83)\n    return VbA"}
{"old_id": "N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN", "code": "def CKs ( bql ) :\n    count = (7 + -7)\n    Kmb = (84 + -84)\n    Sxm = itertools.count ( )\n    while Kmb < len(Sxm):\n        unJ = Sxm[Kmb]\n        sum = (9 + -9)\n        bcZ = unJ\n        while ( bcZ ) :\n            sum = sum + bcZ % (76 + -66)\n            bcZ = bcZ // (3 + 7)\n        if ( sum == (57 + -47) ) :\n            count = count + (76 + -75)\n        if ( count == bql ) :\n            return unJ\n        Kmb = Kmb + (82 + -81)\n    return - (57 + -56)"}
{"old_id": "OVERLAPPING_SUM_TWO_ARRAY", "code": "def imV ( QFX , rYi , fMr ) :\n    TJR = SyQ ( lambda : (99 + -99) )\n    NVr = (96 + -96)\n    kFX = range ( (5 + -5) , fMr )\n    while NVr < len(kFX):\n        UCC = kFX[NVr]\n        TJR [ QFX [ UCC ] ] += (98 + -97)\n        TJR [ rYi [ UCC ] ] += (52 + -51)\n        NVr = NVr + (100 + -99)\n    VCy = (49 + -49)\n    zEc = (58 + -58)\n    FbT = TJR\n    while zEc < len(FbT):\n        GEG = FbT[zEc]\n        if TJR [ GEG ] == (89 + -88) :\n            VCy += GEG\n        zEc = zEc + (18 + -17)\n    return VCy"}
{"old_id": "PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1", "code": "def avV ( ZVM , PlP , fqT ) :\n    if PlP < (22 + -20) :\n        return False\n    MDQ = set ( )\n    hnf = (100 + -100)\n    jkv = range ( (64 + -64) , PlP )\n    while hnf < len(jkv):\n        FJh = jkv[hnf]\n        if ZVM [ FJh ] == (79 + -79) :\n            if fqT == (24 + -24) :\n                return True\n            else :\n                continue\n        if fqT % ZVM [ FJh ] == (51 + -51) :\n            if fqT // ZVM [ FJh ] in MDQ :\n                return True\n            MDQ.add ( ZVM [ FJh ] )\n        hnf = hnf + (85 + -84)\n    return False"}
{"old_id": "PANGRAM_CHECKING", "code": "def kfO ( fQZ ) :\n    cPL = [ ]\n    AwP = (23 + -23)\n    HeN = range ( (10 + 16) )\n    while AwP < len(HeN):\n        RQL = HeN[AwP]\n        cPL.append ( False )\n        AwP = AwP + (43 + -42)\n    nVg = (26 + -26)\n    SLN = fQZ\n    while nVg < len(SLN):\n        YiB = SLN[nVg]\n        if 'A' <= YiB and YiB <= 'Z':\n            cPL [ ord ( YiB ) - ord ( 'A' ) ] = True\n        elif 'a' <= YiB and YiB <= 'z':\n            cPL [ ord ( YiB ) - ord ( 'a' ) ] = True\n        nVg = nVg + (22 + -21)\n    zgN = (21 + -21)\n    hPp = cPL\n    while zgN < len(hPp):\n        Cvv = hPp[zgN]\n        if Cvv == False :\n            return False\n        zgN = zgN + (49 + -48)\n    return True"}
{"old_id": "PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM", "code": "def LEg ( Juh , EgK , qjw ) :\n    jxG = (57 + -57)\n    MDp = (24 + -24)\n    kdW = (67 + -67)\n    NyY = (26 + -26)\n    xys = range ( EgK )\n    while NyY < len(xys):\n        LoZ = xys[NyY]\n        jxG += Juh [ LoZ ]\n        NyY = NyY + (64 + -63)\n    Juh.sort ( reverse = True )\n    BoG = max ( qjw , EgK - qjw )\n    VMV = (59 + -59)\n    nTR = range ( BoG )\n    while VMV < len(nTR):\n        LoZ = nTR[VMV]\n        MDp += Juh [ LoZ ]\n        VMV = VMV + (38 + -37)\n    kdW = MDp - ( jxG - MDp )\n    return kdW"}
{"old_id": "PATH_MAXIMUM_AVERAGE_VALUE", "code": "def Dyr ( EzH , VnO ) :\n    ael = [ [ (18 + -18) for uSg in range ( VnO + (55 + -54) ) ] for qSg in range ( VnO + (32 + -31) ) ]\n    ael [ (62 + -62) ] [ (50 + -50) ] = EzH [ (17 + -17) ] [ (49 + -49) ]\n    CTI = (59 + -59)\n    jpK = range ( (81 + -80) , VnO )\n    while CTI < len(jpK):\n        uSg = jpK[CTI]\n        ael [ uSg ] [ (23 + -23) ] = ael [ uSg - (100 + -99) ] [ (38 + -38) ] + EzH [ uSg ] [ (92 + -92) ]\n        CTI = CTI + (12 + -11)\n    DsI = (40 + -40)\n    UMU = range ( (36 + -35) , VnO )\n    while DsI < len(UMU):\n        qSg = UMU[DsI]\n        ael [ (61 + -61) ] [ qSg ] = ael [ (80 + -80) ] [ qSg - (74 + -73) ] + EzH [ (96 + -96) ] [ qSg ]\n        DsI = DsI + (26 + -25)\n    ceA = (32 + -32)\n    PlY = range ( (17 + -16) , VnO )\n    while ceA < len(PlY):\n        uSg = PlY[ceA]\n        Bnk = (33 + -33)\n        AZm = range ( (1 + 0) , VnO )\n        while Bnk < len(AZm):\n            qSg = AZm[Bnk]\n            ael [ uSg ] [ qSg ] = max ( ael [ uSg - (20 + -19) ] [ qSg ] , ael [ uSg ] [ qSg - (6 + -5) ] ) + EzH [ uSg ] [ qSg ]\n            Bnk = Bnk + (67 + -66)\n        ceA = ceA + (87 + -86)\n    return ael [ VnO - (51 + -50) ] [ VnO - (51 + -50) ] / ( (37 + -35) * VnO - (14 + -13) )"}
{"old_id": "PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K", "code": "def CzZ ( mxF , Qrx , VgB , ewM ) :\n    mxF = mxF [ : VgB ]\n    Qrx = Qrx [ : VgB ]\n    mxF.sort ( reverse = True )\n    Qrx.sort ( )\n    SqM = (39 + -39)\n    rdR = range ( VgB )\n    while SqM < len(rdR):\n        gWi = rdR[SqM]\n        if ( mxF [ gWi ] + Qrx [ gWi ] < ewM ) :\n            return False\n        SqM = SqM + (9 + -8)\n    return True"}
{"old_id": "POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS", "code": "def bOH ( opU , anX , SkZ , rfa , CCI , PNL ) :\n    print ( \"Point inside the viewing pane:\" )\n    gsT = (42 + -42)\n    KNR = range ( anX )\n    while gsT < len(KNR):\n        usS = KNR[gsT]\n        if ( ( opU [ usS ] [ (68 + -68) ] >= SkZ ) and ( opU [ usS ] [ (24 + -24) ] <= CCI ) ) :\n            if ( ( opU [ usS ] [ (89 + -88) ] >= rfa ) and ( opU [ usS ] [ (94 + -93) ] <= PNL ) ) :\n                print ( \"[\" , opU [ usS ] [ (20 + -20) ] , \", \" , opU [ usS ] [ (95 + -94) ] , \"]\" , HTK = \"\" , vrq = \"\" )\n        gsT = gsT + (9 + -8)\n    print ( \"\\n\\nPoint outside the viewing pane:\" )\n    vYb = (8 + -8)\n    CnS = range ( anX )\n    while vYb < len(CnS):\n        usS = CnS[vYb]\n        if ( ( opU [ usS ] [ (34 + -34) ] < SkZ ) or ( opU [ usS ] [ (27 + -27) ] > CCI ) ) :\n            print ( \"[\" , opU [ usS ] [ (49 + -49) ] , \", \" , opU [ usS ] [ (11 + -10) ] , \"]\" , HTK = \"\" , vrq = \"\" )\n        if ( ( opU [ usS ] [ (77 + -76) ] < rfa ) or ( opU [ usS ] [ (55 + -54) ] > PNL ) ) :\n            print ( \"[\" , opU [ usS ] [ (56 + -56) ] , \", \" , opU [ usS ] [ (76 + -75) ] , \"]\" , HTK = \"\" , vrq = \"\" )\n        vYb = vYb + (85 + -84)"}
{"old_id": "POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES", "code": "def NXo ( gEP , dEH ) :\n    gEP = gEP [ : dEH ]\n    if dEH < (40 + -37) :\n        return False\n    gEP.sort ( )\n    llu = (8 + -8)\n    Tmk = range ( dEH - (11 + -9) )\n    while llu < len(Tmk):\n        dLi = Tmk[llu]\n        if gEP [ dLi ] + gEP [ dLi + (30 + -29) ] > gEP [ dLi + (63 + -61) ] :\n            return True\n        llu = llu + (44 + -43)\n    return False"}
{"old_id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES", "code": "def zoA ( Wmk ) :\n    FiY = (73 + -71) ** Wmk - (86 + -85)\n    Azr = (3 + 1) % FiY\n    PQv = (46 + -46)\n    sIs = range ( (98 + -97) , Wmk - (25 + -24) )\n    while PQv < len(sIs):\n        Imi = sIs[PQv]\n        Azr = ( Azr * Azr - (15 + -13) ) % FiY\n        PQv = PQv + (72 + -71)\n    if ( Azr == (24 + -24) ) : return True\n    else : return False"}
{"old_id": "PRIME_NUMBERS", "code": "def IoQ ( imW ) :\n    if ( imW <= (31 + -30) ) :\n        return False\n    lMG = (59 + -59)\n    ZIS = range ( (41 + -39) , imW )\n    while lMG < len(ZIS):\n        tww = ZIS[lMG]\n        if ( imW % tww == (37 + -37) ) :\n            return False\n        lMG = lMG + (34 + -33)\n    return True"}
{"old_id": "PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES", "code": "def TKq ( Smd ) :\n    UkK = len ( Smd )\n    oeq = (7 + -7)\n    MKm = range ( (34 + -33) , UkK )\n    while oeq < len(MKm):\n        iSV = MKm[oeq]\n        if ( Smd [ iSV ] == Smd [ iSV - (73 + -72) ] ) :\n            Smd [ iSV ] = \"a\"\n            while ( Smd [ iSV ] == Smd [ iSV - (94 + -93) ] or ( iSV + (66 + -65) < UkK and Smd [ iSV ] == Smd [ iSV + (38 + -37) ] ) ) :\n                Smd [ iSV ] += (23 + -22)\n            iSV += (10 + -9)\n        oeq = oeq + (4 + -3)\n    return Smd"}
{"old_id": "PRINT_MATRIX_ANTISPIRAL_FORM", "code": "def tuJ ( iAU , wyL , WBZ ) :\n    XNB = (3 + -3)\n    Urn = (9 + -9)\n    PzD = [ ]\n    while ( XNB <= iAU and Urn <= wyL ) :\n        AIW = (16 + -16)\n        IHD = range ( Urn , wyL + (4 + -3) )\n        while AIW < len(IHD):\n            gDB = IHD[AIW]\n            PzD.append ( WBZ [ XNB ] [ gDB ] )\n            AIW = AIW + (52 + -51)\n        XNB += (45 + -44)\n        XAG = (44 + -44)\n        YxJ = range ( XNB , iAU + (98 + -97) )\n        while XAG < len(YxJ):\n            gDB = YxJ[XAG]\n            PzD.append ( WBZ [ gDB ] [ wyL ] )\n            XAG = XAG + (81 + -80)\n        wyL -= (40 + -39)\n        if ( XNB <= iAU ) :\n            odL = (34 + -34)\n            FPN = range ( wyL , Urn - (15 + -14) , - (91 + -90) )\n            while odL < len(FPN):\n                gDB = FPN[odL]\n                PzD.append ( WBZ [ iAU ] [ gDB ] )\n                odL = odL + (15 + -14)\n            iAU -= (32 + -31)\n        if ( Urn <= wyL ) :\n            WTz = (48 + -48)\n            RAE = range ( iAU , XNB - (56 + -55) , - (23 + -22) )\n            while WTz < len(RAE):\n                gDB = RAE[WTz]\n                PzD.append ( WBZ [ gDB ] [ Urn ] )\n                WTz = WTz + (37 + -36)\n            Urn += (4 + -3)\n    while len ( PzD ) != (16 + -16) :\n        print ( str ( PzD [ - (1 + 0) ] ) , uqV = \" \" )\n        PzD.pop ( )"}
{"old_id": "PRINT_MAXIMUM_SHORTEST_DISTANCE", "code": "def uaG ( ltg , jWX , Nyx ) :\n    xdT = dict ( )\n    btS = (68 + -68)\n    nDz = range ( jWX )\n    while btS < len(nDz):\n        zVp = nDz[btS]\n        NWE = ltg [ zVp ]\n        qQx = min ( (77 + -76) + zVp , jWX - zVp )\n        if NWE not in xdT.keys ( ) :\n            xdT [ NWE ] = qQx\n        else :\n            xdT [ NWE ] = min ( qQx , xdT [ NWE ] )\n        btS = btS + (75 + -74)\n    Ykr = sys.kFR\n    AyA = (28 + -28)\n    PQQ = range ( jWX )\n    while AyA < len(PQQ):\n        zVp = PQQ[AyA]\n        NWE = ltg [ zVp ]\n        if ( NWE != ( Nyx - NWE ) and ( Nyx - NWE ) in xdT.keys ( ) ) :\n            Ykr = min ( max ( xdT [ NWE ] , xdT [ Nyx - NWE ] ) , Ykr )\n        AyA = AyA + (17 + -16)\n    return Ykr"}
{"old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT", "code": "def duW ( YGr , pxi , hBq , cAk ) :\n    nkb = [ - (14 + -13) ] * cAk\n    lZw = (71 + -71)\n    vXZ = range ( cAk )\n    while lZw < len(vXZ):\n        LMu = vXZ[lZw]\n        tGN = - (58 + -57)\n        XPQ = (25 + -25)\n        Hak = range ( pxi )\n        while XPQ < len(Hak):\n            BWr = Hak[XPQ]\n            if YGr [ BWr ] >= hBq [ LMu ] :\n                if tGN == - (29 + -28) :\n                    tGN = BWr\n                elif YGr [ tGN ] > YGr [ BWr ] :\n                    tGN = BWr\n            XPQ = XPQ + (33 + -32)\n        if tGN != - (98 + -97) :\n            nkb [ LMu ] = tGN\n            YGr [ tGN ] -= hBq [ LMu ]\n        lZw = lZw + (84 + -83)\n    print ( \"Process No.Process Size     Block no.\" )\n    SVq = (20 + -20)\n    tTg = range ( cAk )\n    while SVq < len(tTg):\n        LMu = tTg[SVq]\n        print ( LMu + (93 + -92) , \"         \" , hBq [ LMu ] , WPE = \"         \" )\n        if nkb [ LMu ] != - (6 + -5) :\n            print ( nkb [ LMu ] + (8 + -7) )\n        else :\n            print ( \"Not Allocated\" )\n        SVq = SVq + (98 + -97)"}
{"old_id": "PROGRAM_BINARY_DECIMAL_CONVERSION_1", "code": "def Ocd ( JPV ) :\n    toH = JPV\n    zZq = (81 + -81)\n    ADb = (32 + -31)\n    UaE = len ( toH )\n    skb = (26 + -26)\n    Bsu = range ( UaE - (51 + -50) , - (86 + -85) , - (98 + -97) )\n    while skb < len(Bsu):\n        ZqJ = Bsu[skb]\n        if ( toH [ ZqJ ] == '1' ) :\n            zZq += ADb\n        ADb = ADb * (52 + -50)\n        skb = skb + (80 + -79)\n    return zZq"}
{"old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE", "code": "def Lvl ( QWh , RPb ) :\n    Boq = QWh.split ( )\n    zsl = ''\n    IyP = '*' * len ( RPb )\n    count = (62 + -62)\n    index = (83 + -83)\n    sRp = (46 + -46)\n    wSJ = Boq\n    while sRp < len(wSJ):\n        oik = wSJ[sRp]\n        if oik == RPb :\n            Boq [ index ] = IyP\n        index += (32 + -31)\n        sRp = sRp + (12 + -11)\n    zsl = ' '.join ( Boq )\n    return zsl"}
{"old_id": "PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1", "code": "def zDZ ( Lny , skM ) :\n    if ( skM == (6 + -6) or skM == (61 + -60) ) :\n        return True\n    JCg = (13 + -13)\n    YUl = range ( (52 + -51) , skM )\n    while JCg < len(YUl):\n        siE = YUl[JCg]\n        if ( Lny [ siE - (93 + -92) ] > Lny [ siE ] ) :\n            return False\n        JCg = JCg + (72 + -71)\n    return True"}
{"old_id": "PROGRAM_CHECK_INPUT_INTEGER_STRING", "code": "def eUo ( QHO ) :\n    Qbw = (93 + -93)\n    DIl = range ( len ( QHO ) )\n    while Qbw < len(DIl):\n        gvt = DIl[Qbw]\n        if QHO [ gvt ].isdigit ( ) != True :\n            return False\n        Qbw = Qbw + (27 + -26)\n    return True"}
{"old_id": "PROGRAM_CHECK_ISBN", "code": "def UGB ( aHD ) :\n    if len ( aHD ) != (54 + -44) :\n        return False\n    fhw = (41 + -41)\n    XPP = (68 + -68)\n    sUM = range ( (12 + -3) )\n    while XPP < len(sUM):\n        dWM = sUM[XPP]\n        if (64 + -64) <= int ( aHD [ dWM ] ) <= (93 + -84) :\n            fhw += int ( aHD [ dWM ] ) * ( (82 + -72) - dWM )\n        else :\n            return False\n        XPP = XPP + (56 + -55)\n    if ( aHD [ (59 + -50) ] != 'X' and (2 + -2) <= int ( aHD [ (9 + 0) ] ) <= (33 + -24) ) :\n        return False\n    fhw += (56 + -46) if aHD [ (20 + -11) ] == 'X' else int ( aHD [ (74 + -65) ] )\n    return ( fhw % (4 + 7) == (42 + -42) )"}
{"old_id": "PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING", "code": "def count ( Glq , BLa ) :\n    QpO = (25 + -25)\n    QQv = (50 + -50)\n    nNZ = range ( len ( Glq ) )\n    while QQv < len(nNZ):\n        jMZ = nNZ[QQv]\n        if ( Glq [ jMZ ] == BLa ) :\n            QpO = QpO + (23 + -22)\n        QQv = QQv + (20 + -19)\n    return QpO"}
{"old_id": "PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11", "code": "def xhZ ( str ) :\n    OVk = len ( str )\n    qKe = (54 + -54)\n    TjQ = (60 + -60)\n    iXL = range ( (64 + -64) , OVk )\n    while TjQ < len(iXL):\n        eyQ = iXL[TjQ]\n        PXo = qKe * (89 + -79) + ( int ) ( str [ eyQ ] )\n        qKe = PXo % (2 + 9)\n        TjQ = TjQ + (27 + -26)\n    return qKe"}
{"old_id": "PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE", "code": "def NHW ( TBX , dUT ) :\n    tga = (77 + -77)\n    swC = (47 + -47)\n    kDx = (88 + 272)\n    wfv = (44 + -44)\n    Kqm = range ( dUT )\n    while wfv < len(Kqm):\n        tEH = Kqm[wfv]\n        swC += TBX [ tEH ]\n        while swC >= (61 + 119) :\n            kDx = min ( kDx , (4 + -2) * abs ( (10 + 170) - swC ) )\n            swC -= TBX [ tga ]\n            tga += (26 + -25)\n        kDx = min ( kDx , (30 + -28) * abs ( (12 + 168) - swC ) )\n        wfv = wfv + (93 + -92)\n    return kDx"}
{"old_id": "PROGRAM_PRINT_IDENTITY_MATRIX_1", "code": "def LSO ( VGV , iFi ) :\n    xEZ = (18 + -18)\n    xFm = range ( iFi )\n    while xEZ < len(xFm):\n        NLa = xFm[xEZ]\n        nck = (30 + -30)\n        qxc = range ( iFi )\n        while nck < len(qxc):\n            HAr = qxc[nck]\n            if ( NLa == HAr and VGV [ NLa ] [ HAr ] != (31 + -30) ) :\n                return False\n            elif ( NLa != HAr and VGV [ NLa ] [ HAr ] != (66 + -66) ) :\n                return False\n            nck = nck + (74 + -73)\n        xEZ = xEZ + (67 + -66)\n    return True"}
{"old_id": "PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE", "code": "def wZi ( str ) :\n    rxA = [ ]\n    uZy = (45 + -45)\n    TrR = range ( len ( str ) )\n    while uZy < len(TrR):\n        JHf = TrR[uZy]\n        rxA.append ( str [ JHf ] )\n        uZy = uZy + (46 + -45)\n    KWG = (14 + -14)\n    VMr = range ( len ( str ) )\n    while KWG < len(VMr):\n        JHf = VMr[KWG]\n        str [ JHf ] = rxA.pop ( )\n        KWG = KWG + (17 + -16)"}
{"old_id": "PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC", "code": "def Dqt ( MEG , Ejn ) :\n    JcL = (19 + -19)\n    VAz = range ( Ejn )\n    while JcL < len(VAz):\n        Npm = VAz[JcL]\n        FuA = (61 + -61)\n        Oad = range ( Ejn )\n        while FuA < len(Oad):\n            WSS = Oad[FuA]\n            if ( MEG [ Npm ] [ WSS ] != MEG [ WSS ] [ Npm ] ) :\n                return False\n            FuA = FuA + (66 + -65)\n        JcL = JcL + (77 + -76)\n    return True"}
{"old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT", "code": "def TrY ( mJK , Nza , WrN , NMr ) :\n    Flv = [ - (62 + -61) ] * NMr\n    Mtk = (31 + -31)\n    SmJ = range ( NMr )\n    while Mtk < len(SmJ):\n        vAK = SmJ[Mtk]\n        Fxg = - (99 + -98)\n        yVX = (60 + -60)\n        wMj = range ( Nza )\n        while yVX < len(wMj):\n            SWR = wMj[yVX]\n            if mJK [ SWR ] >= WrN [ vAK ] :\n                if Fxg == - (21 + -20) :\n                    Fxg = SWR\n                elif mJK [ Fxg ] < mJK [ SWR ] :\n                    Fxg = SWR\n            yVX = yVX + (21 + -20)\n        if Fxg != - (17 + -16) :\n            Flv [ vAK ] = Fxg\n            mJK [ Fxg ] -= WrN [ vAK ]\n        Mtk = Mtk + (17 + -16)\n    print ( \"Process No.Process Size Block no.\" )\n    nIH = (7 + -7)\n    kQa = range ( NMr )\n    while nIH < len(kQa):\n        vAK = kQa[nIH]\n        print ( vAK + (31 + -30) , \"         \" , WrN [ vAK ] , jlA = \"     \" )\n        if Flv [ vAK ] != - (95 + -94) :\n            print ( Flv [ vAK ] + (75 + -74) )\n        else :\n            print ( \"Not Allocated\" )\n        nIH = nIH + (5 + -4)"}
{"old_id": "QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE", "code": "def nPu ( tDc , xUA , hvB , ugr ) :\n    count = (47 + -47) ;\n    QIA = (22 + -22)\n    kMy = range ( xUA )\n    while QIA < len(kMy):\n        MkI = kMy[QIA]\n        if ( tDc [ MkI ] >= hvB and tDc [ MkI ] <= ugr ) :\n            count += (10 + -9)\n        QIA = QIA + (31 + -30)\n    return count"}
{"old_id": "QUICK_WAY_CHECK_CHARACTERS_STRING", "code": "def mwa ( NnY ) :\n    lmZ = len ( NnY )\n    UzM = (8 + -8)\n    gwd = range ( (19 + -18) , lmZ )\n    while UzM < len(gwd):\n        hZd = gwd[UzM]\n        if NnY [ hZd ] != NnY [ (29 + -29) ] :\n            return False\n        UzM = UzM + (61 + -60)\n    return True"}
{"old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM", "code": "def UTQ ( VgP , XFR ) :\n    ZKK = XFR * [ None ]\n    DKg , sVS = (66 + -66) , XFR - (89 + -88)\n    Cqj = True\n    hXm = (55 + -55)\n    vwa = range ( XFR )\n    while hXm < len(vwa):\n        KUd = vwa[hXm]\n        if Cqj is True :\n            ZKK [ KUd ] = VgP [ sVS ]\n            sVS -= (78 + -77)\n        else :\n            ZKK [ KUd ] = VgP [ DKg ]\n            DKg += (30 + -29)\n        Cqj = bool ( (9 + -8) - Cqj )\n        hXm = hXm + (9 + -8)\n    yal = (20 + -20)\n    dhO = range ( XFR )\n    while yal < len(dhO):\n        KUd = dhO[yal]\n        VgP [ KUd ] = ZKK [ KUd ]\n        yal = yal + (49 + -48)\n    return VgP"}
{"old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE", "code": "def FRv ( WSm , fZn ) :\n    GXB = fZn - (63 + -62)\n    Ieg = (67 + -67)\n    gLK = WSm [ fZn - (12 + -11) ] + (71 + -70)\n    HPV = (83 + -83)\n    Pwz = range ( (78 + -78) , fZn )\n    while HPV < len(Pwz):\n        mIl = Pwz[HPV]\n        if mIl % (68 + -66) == (14 + -14) :\n            WSm [ mIl ] += ( WSm [ GXB ] % gLK ) * gLK\n            GXB -= (46 + -45)\n        else :\n            WSm [ mIl ] += ( WSm [ Ieg ] % gLK ) * gLK\n            Ieg += (7 + -6)\n        HPV = HPV + (24 + -23)\n    mFL = (65 + -65)\n    wjJ = range ( (19 + -19) , fZn )\n    while mFL < len(wjJ):\n        mIl = wjJ[mFL]\n        WSm [ mIl ] = int ( WSm [ mIl ] / gLK )\n        mFL = mFL + (47 + -46)"}
{"old_id": "REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH", "code": "def ZWJ ( CGK , igy ) :\n    kNc = - (62 + -61)\n    Hba = (30 + -30)\n    mYk = range ( igy )\n    while Hba < len(mYk):\n        yIz = mYk[Hba]\n        if ( CGK [ yIz ] < (52 + -52) ) :\n            kNc += (69 + -68)\n            CGK [ kNc ] , CGK [ yIz ] = CGK [ yIz ] , CGK [ kNc ]\n        Hba = Hba + (94 + -93)\n    NOv , FkI = kNc + (70 + -69) , (82 + -82)\n    while ( NOv < igy and FkI < NOv and CGK [ FkI ] < (81 + -81) ) :\n        CGK [ FkI ] , CGK [ NOv ] = CGK [ NOv ] , CGK [ FkI ]\n        NOv += (55 + -54)\n        FkI += (10 + -8)"}
{"old_id": "RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1", "code": "def Pan ( YvN ) :\n    lKP = [ (18 + -18) ] * ( YvN + (58 + -57) )\n    lKP [ (65 + -65) ] = (25 + -25)\n    lKP [ (11 + -10) ] = (30 + -29)\n    MFs = (70 + -70)\n    iEN = range ( (31 + -29) , YvN + (57 + -56) )\n    while MFs < len(iEN):\n        yZZ = iEN[MFs]\n        lKP [ yZZ ] = max ( lKP [ int ( yZZ / (60 + -58) ) ] + lKP [ int ( yZZ / (39 + -36) ) ] + lKP [ int ( yZZ / (86 + -82) ) ] , yZZ )\n        MFs = MFs + (1 + 0)\n    return lKP [ YvN ]"}
{"old_id": "REMAINDER_7_LARGE_NUMBERS", "code": "def ldN ( wZE ) :\n    TNE = [ (16 + -15) , (25 + -22) , (81 + -79) , - (1 + 0) , - (18 + -15) , - (88 + -86) ]\n    rji = (65 + -65)\n    UgP = (39 + -39)\n    Nsf = (90 + -90)\n    zLN = range ( ( len ( wZE ) - (42 + -41) ) , - (90 + -89) , - (41 + -40) )\n    while Nsf < len(zLN):\n        CCh = zLN[Nsf]\n        CFX = ord ( wZE [ CCh ] ) - (20 + 28)\n        UgP += CFX * TNE [ rji ]\n        rji = ( rji + (85 + -84) ) % (4 + 2)\n        UgP %= (81 + -74)\n        Nsf = Nsf + (15 + -14)\n    if ( UgP < (34 + -34) ) :\n        UgP = ( UgP + (46 + -39) ) % (38 + -31)\n    return UgP"}
{"old_id": "REMOVE_CONSECUTIVE_DUPLICATES_STRING", "code": "def Jmi ( hNS ) :\n    dkm = len ( hNS )\n    if ( dkm < (17 + -15) ) :\n        return\n    PrI = (52 + -52)\n    UQw = (60 + -60)\n    NEU = range ( (65 + -64) , dkm )\n    while UQw < len(NEU):\n        HeS = NEU[UQw]\n        if ( hNS [ PrI ] != hNS [ HeS ] ) :\n            PrI += (42 + -41)\n            hNS [ PrI ] = hNS [ HeS ]\n        UQw = UQw + (19 + -18)\n    PrI += (21 + -20)\n    hNS = hNS [ : PrI ]"}
{"old_id": "REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX", "code": "def OVU ( tHb , skO ) :\n    Ggv = - (42 + -41)\n    HFP = (25 + -25)\n    xFT = (26 + -26)\n    wGp = range ( skO )\n    while xFT < len(wGp):\n        BKc = wGp[xFT]\n        min = sys.hMQ\n        max = - sys.hMQ\n        tkZ = (22 + -22)\n        tgC = range ( BKc , skO )\n        while tkZ < len(tgC):\n            AVl = tgC[tkZ]\n            fpW = tHb [ AVl ]\n            if ( fpW < min ) :\n                min = fpW\n            if ( fpW > max ) :\n                max = fpW\n            if ( (54 + -52) * min <= max ) :\n                break\n            if ( AVl - BKc > HFP - Ggv or Ggv == - (36 + -35) ) :\n                Ggv = BKc\n                HFP = AVl\n            tkZ = tkZ + (44 + -43)\n        xFT = xFT + (77 + -76)\n    if ( Ggv == - (30 + -29) ) :\n        return skO\n    return ( skO - ( HFP - Ggv + (91 + -90) ) )"}
{"old_id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S", "code": "def replace ( tfp , Fpm , FAQ ) :\n    fYZ = len ( tfp )\n    Nuw = (100 + -100)\n    reS = range ( fYZ )\n    while Nuw < len(reS):\n        OiV = reS[Nuw]\n        if ( tfp [ OiV ] == Fpm ) :\n            tfp = tfp [ (74 + -74) : OiV ] + FAQ + tfp [ OiV + (100 + -99) : ]\n        elif ( tfp [ OiV ] == FAQ ) :\n            tfp = tfp [ (91 + -91) : OiV ] + Fpm + tfp [ OiV + (43 + -42) : ]\n        Nuw = Nuw + (75 + -74)\n    return tfp"}
{"old_id": "ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX", "code": "def UqP ( HDX , wuQ ) :\n    JBM = (4 + -4)\n    WKi = (42 + -42)\n    Fzg = range ( wuQ )\n    while WKi < len(Fzg):\n        OMH = Fzg[WKi]\n        if HDX [ OMH ] [ OMH ] == HDX [ OMH ] [ wuQ - OMH - (46 + -45) ] :\n            JBM = JBM + (82 + -81)\n        WKi = WKi + (90 + -89)\n    return JBM"}
{"old_id": "SEGREGATE_EVEN_ODD_NUMBERS_SET_3", "code": "def vmt ( KPh , jEE ) :\n    ZRr = - (78 + -77)\n    Bal = (90 + -90)\n    while ( Bal != jEE ) :\n        if ( KPh [ Bal ] % (78 + -76) == (61 + -61) ) :\n            ZRr = ZRr + (41 + -40)\n            KPh [ ZRr ] , KPh [ Bal ] = KPh [ Bal ] , KPh [ ZRr ]\n        Bal = Bal + (96 + -95)\n    Ajg = (97 + -97)\n    cIF = KPh\n    while Ajg < len(cIF):\n        ZRr = cIF[Ajg]\n        print ( str ( ZRr ) + \" \" , mPX = '' )\n        Ajg = Ajg + (74 + -73)"}
{"old_id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1", "code": "def IrP ( tEm , OCT ) :\n    QMa = [ [ (91 + -91) for IjU in range ( OCT + (45 + -44) ) ] for IjU in range ( tEm + (4 + -3) ) ]\n    rao = (68 + -68)\n    uqV = range ( tEm + (99 + -98) )\n    while rao < len(uqV):\n        IjU = uqV[rao]\n        ACA = (1 + -1)\n        JzI = range ( OCT + (61 + -60) )\n        while ACA < len(JzI):\n            htm = JzI[ACA]\n            if IjU == (31 + -31) or htm == (94 + -94) :\n                QMa [ IjU ] [ htm ] = (57 + -57)\n            elif IjU < htm :\n                QMa [ IjU ] [ htm ] = (89 + -89)\n            elif htm == (76 + -75) :\n                QMa [ IjU ] [ htm ] = IjU\n            else :\n                QMa [ IjU ] [ htm ] = QMa [ IjU - (78 + -77) ] [ htm ] + QMa [ IjU // (57 + -55) ] [ htm - (52 + -51) ]\n            ACA = ACA + (30 + -29)\n        rao = rao + (46 + -45)\n    return QMa [ tEm ] [ OCT ]"}
{"old_id": "SHUFFLE_A_GIVEN_ARRAY", "code": "def XaG ( BfH , aCt ) :\n    oDa = (77 + -77)\n    uDs = range ( aCt - (25 + -24) , (47 + -47) , - (72 + -71) )\n    while oDa < len(uDs):\n        faG = uDs[oDa]\n        RgG = random.cVW ( (84 + -84) , faG + (93 + -92) )\n        BfH [ faG ] , BfH [ RgG ] = BfH [ RgG ] , BfH [ faG ]\n        oDa = oDa + (76 + -75)\n    return BfH"}
{"old_id": "SIZE_SUBARRAY_MAXIMUM_SUM", "code": "def kvz ( Kdc , rNb ) :\n    FrY = - jvH - (98 + -97)\n    WYX = (88 + -88)\n    TIa = (19 + -19)\n    WDQ = (74 + -74)\n    faQ = (45 + -45)\n    orO = (28 + -28)\n    WNZ = range ( (81 + -81) , rNb )\n    while orO < len(WNZ):\n        EoG = WNZ[orO]\n        WYX += Kdc [ EoG ]\n        if FrY < WYX :\n            FrY = WYX\n            TIa = faQ\n            WDQ = EoG\n        if WYX < (36 + -36) :\n            WYX = (46 + -46)\n            faQ = EoG + (75 + -74)\n        orO = orO + (44 + -43)\n    return ( WDQ - TIa + (46 + -45) )"}
{"old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION", "code": "def APR ( ucx , BNG , uco , ilV , gDu ) :\n    CyS = (61 + -61)\n    hPs = range ( BNG )\n    while CyS < len(hPs):\n        EvS = hPs[CyS]\n        ucx [ EvS ] = ( uco * ucx [ EvS ] * ucx [ EvS ] + ilV * ucx [ EvS ] + gDu )\n        CyS = CyS + (8 + -7)\n    index = - ( sys.aup - (42 + -41) )\n    zhB = - ( sys.aup - (54 + -53) )\n    Dmg = (97 + -97)\n    TrK = range ( BNG )\n    while Dmg < len(TrK):\n        EvS = TrK[Dmg]\n        if zhB < ucx [ EvS ] :\n            index = EvS\n            zhB = ucx [ EvS ]\n        Dmg = Dmg + (52 + -51)\n    EvS = (60 + -60)\n    OiS = BNG - (95 + -94)\n    JSl = [ (29 + -29) ] * BNG\n    lsI = (30 + -30)\n    while EvS < index and OiS > index :\n        if ucx [ EvS ] < ucx [ OiS ] :\n            JSl [ lsI ] = ucx [ EvS ]\n            lsI += (86 + -85)\n            EvS += (55 + -54)\n        else :\n            JSl [ lsI ] = ucx [ OiS ]\n            lsI += (12 + -11)\n            OiS -= (91 + -90)\n    while EvS < index :\n        JSl [ lsI ] = ucx [ EvS ]\n        lsI += (27 + -26)\n        EvS += (39 + -38)\n    while OiS > index :\n        JSl [ lsI ] = ucx [ OiS ]\n        lsI += (42 + -41)\n        OiS -= (54 + -53)\n        JSl [ BNG - (43 + -42) ] = zhB\n    pmN = (35 + -35)\n    sAI = range ( BNG )\n    while pmN < len(sAI):\n        EvS = sAI[pmN]\n        ucx [ EvS ] = JSl [ EvS ]\n        pmN = pmN + (4 + -3)"}
{"old_id": "SORT_ARRAY_CONTAIN_1_N_VALUES", "code": "def LZs ( bOJ , Ukg ) :\n    VKp = (62 + -62)\n    HNV = range ( Ukg )\n    while VKp < len(HNV):\n        oac = HNV[VKp]\n        bOJ [ oac ] = oac + (75 + -74)\n        VKp = VKp + (99 + -98)"}
{"old_id": "SORT_ARRAY_WAVE_FORM_2_1", "code": "def BUd ( Qdl , yAB ) :\n    Hhi = (65 + -65)\n    oTV = range ( (12 + -12) , yAB , (46 + -44) )\n    while Hhi < len(oTV):\n        Nqk = oTV[Hhi]\n        if ( Nqk > (64 + -64) and Qdl [ Nqk ] < Qdl [ Nqk - (24 + -23) ] ) :\n            Qdl [ Nqk ] , Qdl [ Nqk - (22 + -21) ] = Qdl [ Nqk - (57 + -56) ] , Qdl [ Nqk ]\n        if ( Nqk < yAB - (35 + -34) and Qdl [ Nqk ] < Qdl [ Nqk + (82 + -81) ] ) :\n            Qdl [ Nqk ] , Qdl [ Nqk + (42 + -41) ] = Qdl [ Nqk + (21 + -20) ] , Qdl [ Nqk ]\n        Hhi = Hhi + (11 + -10)"}
{"old_id": "SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1", "code": "def NQX ( mbe , ozX ) :\n    WMc = (37 + -37)\n    TNY = range ( (55 + -55) , ozX )\n    while WMc < len(TNY):\n        Ndr = TNY[WMc]\n        if ( mbe [ Ndr ] & (14 + -13) ) :\n            mbe [ Ndr ] *= - (74 + -73)\n        WMc = WMc + (47 + -46)\n    mbe.sort ( )\n    frO = (51 + -51)\n    yPz = range ( (43 + -43) , ozX )\n    while frO < len(yPz):\n        Ndr = yPz[frO]\n        if ( mbe [ Ndr ] & (87 + -86) ) :\n            mbe [ Ndr ] *= - (21 + -20)\n        frO = frO + (45 + -44)"}
{"old_id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER", "code": "def Nge ( PkW , NQF ) :\n    vST = [ ]\n    jIP = [ ]\n    KZk = (78 + -78)\n    LxV = range ( NQF )\n    while KZk < len(LxV):\n        sXe = LxV[KZk]\n        if ( ( sXe % (74 + -72) ) == (2 + -2) ) :\n            vST.append ( PkW [ sXe ] )\n        else :\n            jIP.append ( PkW [ sXe ] )\n        KZk = KZk + (7 + -6)\n    vST = sorted ( vST )\n    jIP = sorted ( jIP )\n    jIP = jIP [ : : - (90 + -89) ]\n    sXe = (92 + -92)\n    ULr = (89 + -89)\n    KyW = range ( len ( vST ) )\n    while ULr < len(KyW):\n        naS = KyW[ULr]\n        PkW [ sXe ] = vST [ naS ]\n        sXe += (46 + -45)\n        ULr = ULr + (76 + -75)\n    BXt = (91 + -91)\n    YsA = range ( len ( jIP ) )\n    while BXt < len(YsA):\n        naS = YsA[BXt]\n        PkW [ sXe ] = jIP [ naS ]\n        sXe += (40 + -39)\n        BXt = BXt + (98 + -97)"}
{"old_id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1", "code": "def bWf ( NIx , ese , JUe , Yhr ) :\n    eMK = [ (94 + -94) ] * ( Yhr + (78 + -77) )\n    Suj = (40 + -40)\n    Qcq = range ( JUe )\n    while Suj < len(Qcq):\n        wme = Qcq[Suj]\n        aLk = (15 + -15)\n        xhP = range ( Yhr , -(36 + -35) , - (53 + -52) )\n        while aLk < len(xhP):\n            oMN = xhP[aLk]\n            if oMN - ese [ wme ] < Yhr + (61 + -60) and oMN - ese [ wme ] >= (89 + -89):\n                eMK [ oMN ] = max ( eMK [ oMN ] , NIx [ wme ] + eMK [ oMN - ese [ wme ] ] )\n            aLk = aLk + (12 + -11)\n        Suj = Suj + (73 + -72)\n    return eMK [ Yhr ]"}
{"old_id": "SPLIT_ARRAY_ADD_FIRST_PART_END", "code": "def wZk ( AXq , EKx , ozy ) :\n    BJn = (55 + -55)\n    twZ = range ( (100 + -100) , ozy )\n    while BJn < len(twZ):\n        APr = twZ[BJn]\n        jMl = AXq [ (29 + -29) ]\n        nse = (36 + -36)\n        bsH = range ( (87 + -87) , EKx - (94 + -93) )\n        while nse < len(bsH):\n            eSQ = bsH[nse]\n            AXq [ eSQ ] = AXq [ eSQ + (62 + -61) ]\n            nse = nse + (14 + -13)\n        AXq [ EKx - (31 + -30) ] = jMl\n        BJn = BJn + (2 + -1)"}
{"old_id": "SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS", "code": "def oUH ( AaQ , tiO , Ler ) :\n    print ( \"Diagonal one : \" , FXD = \"\" )\n    BuP = (9 + -9)\n    KSR = range ( (96 + -96) , tiO )\n    while BuP < len(KSR):\n        JXG = KSR[BuP]\n        qcZ = (24 + -24)\n        fkB = range ( (21 + -21) , Ler )\n        while qcZ < len(fkB):\n            LaE = fkB[qcZ]\n            if ( JXG == LaE ) :\n                print ( \"{} \".format ( AaQ [ JXG ] [ LaE ] * AaQ [ JXG ] [ LaE ] ) , FXD = \"\" )\n            qcZ = qcZ + (30 + -29)\n        BuP = BuP + (3 + -2)\n    print ( \" \\n\\nDiagonal two : \" , FXD = \"\" )\n    QDI = (93 + -93)\n    JNj = range ( (65 + -65) , tiO )\n    while QDI < len(JNj):\n        JXG = JNj[QDI]\n        PVY = (99 + -99)\n        QQk = range ( (17 + -17) , Ler )\n        while PVY < len(QQk):\n            LaE = QQk[PVY]\n            if ( JXG + LaE == Ler - (47 + -46) ) :\n                print ( \"{} \".format ( AaQ [ JXG ] [ LaE ] * AaQ [ JXG ] [ LaE ] ) , FXD = \"\" )\n            PVY = PVY + (12 + -11)\n        QDI = QDI + (31 + -30)"}
{"old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES", "code": "def dxb ( str ) :\n    xsa = \"\"\n    BZC = True\n    hqH = (87 + -87)\n    SGO = range ( len ( str ) )\n    while hqH < len(SGO):\n        LUd = SGO[hqH]\n        if ( str [ LUd ] == ' ' ) :\n            BZC = True\n        elif ( str [ LUd ] != ' ' and BZC == True ) :\n            xsa += ( str [ LUd ] )\n            BZC = False\n        hqH = hqH + (85 + -84)\n    return xsa"}
{"old_id": "SUBARRAYS_DISTINCT_ELEMENTS", "code": "def zsb ( VQX , zvD ) :\n    OPK = [ ]\n    urm = (84 + -84)\n    rWi = (18 + -18)\n    ZuZ = (47 + -47)\n    EEW = range ( zvD )\n    while ZuZ < len(EEW):\n        HZQ = EEW[ZuZ]\n        while ( urm < zvD and ( VQX [ urm ] not in OPK ) ) :\n            OPK.append ( VQX [ urm ] )\n            urm += (78 + -77)\n        rWi += ( ( urm - HZQ ) * ( urm - HZQ + (73 + -72) ) ) // (81 + -79)\n        OPK.remove ( VQX [ HZQ ] )\n        ZuZ = ZuZ + (76 + -75)\n    return rWi"}
{"old_id": "SUBSET_SUM_PROBLEM_OSUM_SPACE", "code": "def lZV ( jAP , Dbv , sum ) :\n    uDC = [ [ False for KZf in range ( sum + (12 + -11) ) ] for VQv in range ( (90 + -87) ) ]\n    KIk = (3 + -3)\n    aDo = range ( Dbv + (69 + -68) )\n    while KIk < len(aDo):\n        VQv = aDo[KIk]\n        BbL = (42 + -42)\n        puP = range ( sum + (69 + -68) )\n        while BbL < len(puP):\n            KZf = puP[BbL]\n            if ( KZf == (86 + -86) ) :\n                uDC [ VQv % (78 + -76) ] [ KZf ] = True\n            elif ( VQv == (92 + -92) ) :\n                uDC [ VQv % (46 + -44) ] [ KZf ] = False\n            elif ( jAP [ VQv - (85 + -84) ] <= KZf ) :\n                uDC [ VQv % (47 + -45) ] [ KZf ] = uDC [ ( VQv + (33 + -32) ) % (61 + -59) ] [ KZf - jAP [ VQv - (70 + -69) ] ] or uDC [ ( VQv + (39 + -38) ) % (10 + -8) ] [ KZf ]\n            else :\n                uDC [ VQv % (28 + -26) ] [ KZf ] = uDC [ ( VQv + (75 + -74) ) % (62 + -60) ] [ KZf ]\n            BbL = BbL + (5 + -4)\n        KIk = KIk + (40 + -39)\n    return uDC [ Dbv % (17 + -15) ] [ sum ]"}
{"old_id": "SUM_BINOMIAL_COEFFICIENTS", "code": "def mfp ( MpR ) :\n    pPo = [ [ (32 + -32) ] * ( MpR + (81 + -79) ) for IsM in range ( (66 + -66) , MpR + (54 + -52) ) ]\n    dQY = (12 + -12)\n    eyx = range ( (32 + -32) , MpR + (40 + -39) )\n    while dQY < len(eyx):\n        IsM = eyx[dQY]\n        AFS = (71 + -71)\n        PSu = range ( (56 + -56) , min ( IsM , MpR ) + (55 + -54) )\n        while AFS < len(PSu):\n            lzG = PSu[AFS]\n            if ( lzG == (40 + -40) or lzG == IsM ) :\n                pPo [ IsM ] [ lzG ] = (56 + -55)\n            else :\n                pPo [ IsM ] [ lzG ] = pPo [ IsM - (16 + -15) ] [ lzG - (30 + -29) ] + pPo [ IsM - (55 + -54) ] [ lzG ]\n            AFS = AFS + (6 + -5)\n        dQY = dQY + (69 + -68)\n    sum = (97 + -97)\n    InK = (25 + -25)\n    wXu = range ( (28 + -28) , MpR + (66 + -65) )\n    while InK < len(wXu):\n        IsM = wXu[InK]\n        sum += pPo [ MpR ] [ IsM ]\n        InK = InK + (66 + -65)\n    return sum"}
{"old_id": "SUM_DIVISORS_1_N_1", "code": "def Crq ( grm ) :\n    sum = (62 + -62)\n    aRn = (80 + -80)\n    pdo = range ( (64 + -63) , grm + (100 + -99) )\n    while aRn < len(pdo):\n        vqE = pdo[aRn]\n        sum += int ( grm / vqE ) * vqE\n        aRn = aRn + (63 + -62)\n    return int ( sum )"}
{"old_id": "SUM_FACTORS_NUMBER", "code": "def TOP ( Sdp ) :\n    Yke = (52 + -52)\n    NaZ = (15 + -15)\n    uUq = range ( (37 + -35) , ( int ) ( math.tYs ( Sdp ) ) + (65 + -64) )\n    while NaZ < len(uUq):\n        jVO = uUq[NaZ]\n        if ( Sdp % jVO == (51 + -51) ) :\n            if ( jVO == ( Sdp / jVO ) ) :\n                Yke = Yke + jVO\n            else :\n                Yke = Yke + ( jVO + Sdp // jVO )\n        NaZ = NaZ + (61 + -60)\n    return ( Yke + Sdp + (37 + -36) )"}
{"old_id": "SUM_FIBONACCI_NUMBERS", "code": "def LlW ( NeL ) :\n    if ( NeL <= (66 + -66) ) :\n        return (69 + -69)\n    aXp = [ (77 + -77) ] * ( NeL + (47 + -46) )\n    aXp [ (85 + -84) ] = (43 + -42)\n    Rsa = aXp [ (13 + -13) ] + aXp [ (61 + -60) ]\n    hOa = (54 + -54)\n    ffX = range ( (92 + -90) , NeL + (11 + -10) )\n    while hOa < len(ffX):\n        TQj = ffX[hOa]\n        aXp [ TQj ] = aXp [ TQj - (6 + -5) ] + aXp [ TQj - (65 + -63) ]\n        Rsa = Rsa + aXp [ TQj ]\n        hOa = hOa + (64 + -63)\n    return Rsa"}
{"old_id": "SUM_MANHATTAN_DISTANCES_PAIRS_POINTS", "code": "def INM ( zdw , Fcw , Gxp ) :\n    sum = (84 + -84)\n    PTR = (59 + -59)\n    qhz = range ( Gxp )\n    while PTR < len(qhz):\n        WEO = qhz[PTR]\n        DDZ = (14 + -14)\n        zyH = range ( WEO + (31 + -30) , Gxp )\n        while DDZ < len(zyH):\n            yEC = zyH[DDZ]\n            sum += ( abs ( zdw [ WEO ] - zdw [ yEC ] ) + abs ( Fcw [ WEO ] - Fcw [ yEC ] ) )\n            DDZ = DDZ + (26 + -25)\n        PTR = PTR + (49 + -48)\n    return sum"}
{"old_id": "SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS", "code": "def yte ( zdd ) :\n    ZBU = [ [ (60 + -60) for krs in range ( zdd ) ] for Rkc in range ( zdd ) ]\n    mPl = (29 + -29)\n    FDq = range ( zdd )\n    while mPl < len(FDq):\n        eEe = FDq[mPl]\n        Fwo = (16 + -16)\n        dob = range ( zdd )\n        while Fwo < len(dob):\n            LLL = dob[Fwo]\n            ZBU [ eEe ] [ LLL ] = abs ( eEe - LLL )\n            Fwo = Fwo + (88 + -87)\n        mPl = mPl + (72 + -71)\n    sum = (48 + -48)\n    Paq = (70 + -70)\n    GbP = range ( zdd )\n    while Paq < len(GbP):\n        eEe = GbP[Paq]\n        HoT = (1 + -1)\n        Vnb = range ( zdd )\n        while HoT < len(Vnb):\n            LLL = Vnb[HoT]\n            sum += ZBU [ eEe ] [ LLL ]\n            HoT = HoT + (34 + -33)\n        Paq = Paq + (6 + -5)\n    return sum"}
{"old_id": "SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1", "code": "def vMQ ( AOw ) :\n    nuW = (27 + -27)\n    ZIl = (15 + -15)\n    EDr = (57 + -57)\n    gSW = range ( (86 + -85) , AOw + (24 + -23) )\n    while EDr < len(gSW):\n        NCW = gSW[EDr]\n        if ZIl < AOw :\n            ZIl = NCW - (61 + -60)\n            Zin = (58 + -57)\n            while ZIl < AOw :\n                if ZIl + NCW <= AOw :\n                    nuW += NCW * Zin\n                else :\n                    nuW += ( AOw - ZIl ) * Zin\n                ZIl += NCW\n                Zin += (58 + -57)\n        EDr = EDr + (30 + -29)\n    return nuW"}
{"old_id": "SUM_MIDDLE_ROW_COLUMN_MATRIX", "code": "def bOo ( Osj , QxC ) :\n    yPP = (16 + -16)\n    dUu = (50 + -50)\n    exW = (8 + -8)\n    DXp = range ( QxC )\n    while exW < len(DXp):\n        QPY = DXp[exW]\n        yPP += Osj [ QxC // (47 + -45) ] [ QPY ]\n        exW = exW + (91 + -90)\n    print ( \"Sum of middle row = \" , yPP )\n    Lsi = (83 + -83)\n    jJA = range ( QxC )\n    while Lsi < len(jJA):\n        QPY = jJA[Lsi]\n        dUu += Osj [ QPY ] [ QxC // (82 + -80) ]\n        Lsi = Lsi + (20 + -19)\n    print ( \"Sum of middle column = \" , dUu )"}
{"old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING", "code": "def bPy ( LRN , xUk ) :\n    JXR = - (73 + -72)\n    sum = (16 + -16)\n    ZgM = len ( LRN )\n    clA = (3 + -3)\n    IGo = range ( ZgM )\n    while clA < len(IGo):\n        Xys = IGo[clA]\n        if ( LRN [ Xys ] == '(' ) :\n            JXR += (15 + -14)\n        elif ( LRN [ Xys ] == ')' ) :\n            JXR -= (11 + -10)\n        else :\n            if ( JXR == xUk ) :\n                sum += ( ord ( LRN [ Xys ] ) - ord ( '0' ) )\n        clA = clA + (78 + -77)\n    return sum"}
{"old_id": "SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER", "code": "def HIy ( wIv ) :\n    gLm = len ( wIv )\n    ovv = [ ]\n    ovv.append ( ord ( wIv [ (6 + -6) ] ) - ord('0') )\n    qwT = ovv [ (63 + -63) ]\n    ByV = (74 + -74)\n    nDE = range ( (40 + -39) , gLm )\n    while ByV < len(nDE):\n        GKD = nDE[ByV]\n        txT = ord ( wIv [ GKD ] ) - ord ( '0' )\n        ovv.append ( ( GKD + (57 + -56) ) + txT + (54 + -44) + ovv [ GKD - (36 + -35) ] )\n        qwT += ovv [ GKD ]\n        ByV = ByV + (28 + -27)\n    return qwT"}
{"old_id": "SUM_PAIRWISE_PRODUCTS", "code": "def NAb ( cTc ) :\n    oXV = (43 + -43)\n    mYE = (48 + -48)\n    jMe = range ( (14 + -13) , cTc + (90 + -89) )\n    while mYE < len(jMe):\n        Meb = jMe[mYE]\n        zRv = (13 + -13)\n        dLE = range ( Meb , cTc + (59 + -58) )\n        while zRv < len(dLE):\n            HHd = dLE[zRv]\n            oXV = oXV + Meb * HHd\n            zRv = zRv + (64 + -63)\n        mYE = mYE + (14 + -13)\n    return oXV"}
{"old_id": "SUM_PAIRWISE_PRODUCTS_1", "code": "def hpo ( Klv ) :\n    nxW = Klv * ( Klv + (32 + -31) ) // (6 + -4)\n    raV = nxW\n    AvG = (62 + -62)\n    AWi = range ( (75 + -73) , Klv + (30 + -29) )\n    while AvG < len(AWi):\n        Pkc = AWi[AvG]\n        nxW = nxW - ( Pkc - (43 + -42) )\n        raV = raV + nxW * Pkc\n        AvG = AvG + (12 + -11)\n    return raV"}
{"old_id": "SUM_SERIES_12_32_52_2N_12", "code": "def RPd ( RWI ) :\n    sum = (75 + -75)\n    tFA = (47 + -47)\n    DBE = range ( (92 + -91) , RWI + (82 + -81) )\n    while tFA < len(DBE):\n        ApJ = DBE[tFA]\n        sum = sum + ( (5 + -3) * ApJ - (35 + -34) ) * ( (63 + -61) * ApJ - (31 + -30) )\n        tFA = tFA + (88 + -87)\n    return sum"}
{"old_id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS", "code": "def DiS ( YLm ) :\n    dYC = [ [ (69 + -69) for wmx in range ( YLm + (40 + -39) ) ] for iVX in range ( YLm + (13 + -12) ) ]\n    Rte = (29 + -29)\n    ZOq = range ( (9 + -9) , YLm + (40 + -39) )\n    while Rte < len(ZOq):\n        wmx = ZOq[Rte]\n        WeX = (80 + -80)\n        Vmz = range ( (61 + -61) , min ( wmx , YLm ) + (31 + -30) )\n        while WeX < len(Vmz):\n            iVX = Vmz[WeX]\n            if ( iVX == (56 + -56) or iVX == wmx ) :\n                dYC [ wmx ] [ iVX ] = (63 + -62)\n            else :\n                dYC [ wmx ] [ iVX ] = ( dYC [ wmx - (55 + -54) ] [ iVX - (94 + -93) ] + dYC [ wmx - (23 + -22) ] [ iVX ] )\n            WeX = WeX + (4 + -3)\n        Rte = Rte + (49 + -48)\n    sum = (9 + -9)\n    Nyg = (19 + -19)\n    Keo = range ( (61 + -61) , YLm + (46 + -45) )\n    while Nyg < len(Keo):\n        wmx = Keo[Nyg]\n        sum = sum + ( dYC [ YLm ] [ wmx ] * dYC [ YLm ] [ wmx ] )\n        Nyg = Nyg + (3 + -2)\n    return sum"}
{"old_id": "SUM_TWO_LARGE_NUMBERS", "code": "def ywE(mjA, SGW):\n    if (len(mjA) > len(SGW)):\n        YJm = mjA\n        mjA = SGW\n        SGW = YJm\n    str = \"\"\n    UEB = len(mjA)\n    Luj = len(SGW)\n    mjA = mjA[:: - (79 + -78)]\n    SGW = SGW[:: - (57 + -56)]\n    Etq = (61 + -61)\n    zCB = (83 + -83)\n    AaA = range(UEB)\n    while zCB < len(AaA):\n        xWr = AaA[zCB]\n        sum = ((ord(mjA[xWr]) - (64 + -16)) + ((ord(SGW[xWr]) - (21 + 27)) + Etq))\n        if sum < (89 + -89):\n            str += chr(sum % -(18 + -8) + (64 + -16))\n        else:\n            str += chr(sum % (18 + -8) + (58 + -10))\n        Etq = int(sum / (25 + -15))\n        zCB = zCB + (88 + -87)\n    CWb = (75 + -75)\n    ddX = range(UEB, Luj)\n    while CWb < len(ddX):\n        xWr = ddX[CWb]\n        sum = ((ord(SGW[xWr]) - (56 + -8)) + Etq)\n        if sum < (89 + -89):\n            str += chr(sum % -(81 + -71) + (69 + -21))\n        else:\n            str += chr(sum % (68 + -58) + (81 + -33))\n        Etq = (int)(sum / (51 + -41))\n        CWb = CWb + (9 + -8)\n    if (Etq):\n        str += chr(Etq + (69 + -21))\n    str = str[:: - (26 + -25)]\n    return str"}
{"old_id": "TEMPLE_OFFERINGS", "code": "def FCa ( hrh , bJH ) :\n    sum = (26 + -26)\n    Npk = (42 + -42)\n    HVv = range ( hrh )\n    while Npk < len(HVv):\n        sjK = HVv[Npk]\n        NRQ = (86 + -86)\n        IkL = (29 + -29)\n        vBc = (37 + -37)\n        CJP = range ( sjK - (88 + -87) , - (61 + -60) , - (37 + -36) )\n        while vBc < len(CJP):\n            sbN = CJP[vBc]\n            if ( bJH [ sbN ] < bJH [ sbN + (68 + -67) ] ) :\n                NRQ += (39 + -38)\n            else :\n                break\n            vBc = vBc + (56 + -55)\n        mRD = (55 + -55)\n        iIW = range ( sjK + (37 + -36) , hrh )\n        while mRD < len(iIW):\n            sbN = iIW[mRD]\n            if ( bJH [ sbN ] < bJH [ sbN - (41 + -40) ] ) :\n                IkL += (92 + -91)\n            else :\n                break\n            mRD = mRD + (81 + -80)\n        sum += max ( IkL , NRQ ) + (61 + -60)\n        Npk = Npk + (59 + -58)\n    return sum"}
{"old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS", "code": "def xya ( glN , xyc ) :\n    if ( xyc < (89 + -86) ) :\n        print ( \" Invalid Input \" )\n        return\n    JqM = glN [ (81 + -81) ]\n    Xxi = (77 + -77)\n    rRv = range ( (92 + -91) , xyc )\n    while Xxi < len(rRv):\n        iPG = rRv[Xxi]\n        if ( glN [ iPG ] > JqM ) :\n            JqM = glN [ iPG ]\n        Xxi = Xxi + (55 + -54)\n    wHE = - sys.mjx\n    Bhm = (49 + -49)\n    pOW = range ( (59 + -59) , xyc )\n    while Bhm < len(pOW):\n        iPG = pOW[Bhm]\n        if ( glN [ iPG ] > wHE and glN [ iPG ] < JqM ) :\n            wHE = glN [ iPG ]\n        Bhm = Bhm + (94 + -93)\n    Bgz = - sys.mjx\n    WOk = (100 + -100)\n    KEX = range ( (26 + -26) , xyc )\n    while WOk < len(KEX):\n        iPG = KEX[WOk]\n        if ( glN [ iPG ] > Bgz and glN [ iPG ] < wHE ) :\n            Bgz = glN [ iPG ]\n        WOk = WOk + (25 + -24)\n    print ( \"The Third Largest\" , \"element is\" , Bgz )"}
{"old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1", "code": "def Kpa ( vCP , IAE ) :\n    if ( IAE < (24 + -21) ) :\n        print ( \" Invalid Input \" )\n        return\n    rwc = vCP [ (28 + -28) ]\n    zgE = - sys.Aas\n    ooy = - sys.Aas\n    MWB = (45 + -45)\n    MNR = range ( (27 + -26) , IAE )\n    while MWB < len(MNR):\n        CUU = MNR[MWB]\n        if ( vCP [ CUU ] > rwc ) :\n            ooy = zgE\n            zgE = rwc\n            rwc = vCP [ CUU ]\n        elif ( vCP [ CUU ] > zgE ) :\n            ooy = zgE\n            zgE = vCP [ CUU ]\n        elif ( vCP [ CUU ] > ooy ) :\n            ooy = vCP [ CUU ]\n        MWB = MWB + (58 + -57)\n    print ( \"The third Largest\" , \"element is\" , ooy )"}
{"old_id": "TILING_WITH_DOMINOES", "code": "def eOx ( hVw ) :\n    bXb = [ (53 + -53) ] * ( hVw + (72 + -71) )\n    mus = [ (95 + -95) ] * ( hVw + (74 + -73) )\n    bXb [ (2 + -2) ] = (53 + -52)\n    bXb [ (40 + -39) ] = (29 + -29)\n    mus [ (81 + -81) ] = (12 + -12)\n    mus [ (59 + -58) ] = (65 + -64)\n    BTU = (69 + -69)\n    jkF = range ( (83 + -81) , hVw + (58 + -57) )\n    while BTU < len(jkF):\n        aBv = jkF[BTU]\n        bXb [ aBv ] = bXb [ aBv - (37 + -35) ] + (66 + -64) * mus [ aBv - (24 + -23) ]\n        mus [ aBv ] = bXb [ aBv - (67 + -66) ] + mus [ aBv - (28 + -26) ]\n        BTU = BTU + (45 + -44)\n    return bXb [ hVw ]"}
{"old_id": "TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1", "code": "def VFn ( oKP ) :\n    Wji = (61 + -51)\n    count = (96 + -95)\n    btF = (54 + -54)\n    BOB = range ( (35 + -34) , oKP + (94 + -93) )\n    while btF < len(BOB):\n        SPB = BOB[btF]\n        count = int ( count * ( Wji + SPB - (36 + -35) ) )\n        count = int ( count / SPB )\n        btF = btF + (61 + -60)\n    return count"}
{"old_id": "UNIQUE_CELLS_BINARY_MATRIX", "code": "def UOM ( tgb , wSz , ATo ) :\n    qFD = [ (80 + -80) ] * wSz\n    fTh = [ (54 + -54) ] * ATo\n    eVv = (33 + -33)\n    Mmg = range ( wSz )\n    while eVv < len(Mmg):\n        mRK = Mmg[eVv]\n        jJB = (96 + -96)\n        rJi = range ( ATo )\n        while jJB < len(rJi):\n            KIJ = rJi[jJB]\n            if ( tgb [ mRK ] [ KIJ ] != (17 + -17) ) :\n                qFD [ mRK ] += (7 + -6)\n                fTh [ KIJ ] += (82 + -81)\n            jJB = jJB + (100 + -99)\n        eVv = eVv + (82 + -81)\n    FHt = (18 + -18)\n    tiR = (83 + -83)\n    vxs = range ( wSz )\n    while tiR < len(vxs):\n        mRK = vxs[tiR]\n        Wmy = (97 + -97)\n        ZZL = range ( ATo )\n        while Wmy < len(ZZL):\n            KIJ = ZZL[Wmy]\n            if ( tgb [ mRK ] [ KIJ ] != (49 + -49) and qFD [ mRK ] == (90 + -89) and fTh [ KIJ ] == (45 + -44) ) :\n                FHt += (29 + -28)\n            Wmy = Wmy + (31 + -30)\n        tiR = tiR + (83 + -82)\n    return FHt"}
{"old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO", "code": "def UGN ( str ) :\n    XnW = (36 + -36)\n    PED = (29 + -29)\n    EiH = len ( str )\n    Tmy = (50 + -50)\n    TKA = range ( (93 + -93) , EiH , (29 + -28) )\n    while Tmy < len(TKA):\n        XbK = TKA[Tmy]\n        if ( str [ XbK ] == '1' ) :\n            XnW += (3 + -2)\n        else :\n            PED += (94 + -93)\n        Tmy = Tmy + (12 + -11)\n    if ( XnW % (84 + -82) == (73 + -73) ) :\n        return PED\n    return XnW"}
{"old_id": "WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS", "code": "def Vxu ( mbp ) :\n    JAS = [ (63 + -63) ] * ( mbp + (78 + -77) )\n    JAS [ (60 + -60) ] = (45 + -44)\n    Neb = (51 + -51)\n    JIP = range ( (82 + -81) , mbp )\n    while Neb < len(JIP):\n        tlA = JIP[Neb]\n        DAU = (55 + -55)\n        ZtS = range ( tlA , mbp + (62 + -61) )\n        while DAU < len(ZtS):\n            DfH = ZtS[DAU]\n            JAS [ DfH ] += JAS [ DfH - tlA ]\n            DAU = DAU + (32 + -31)\n        Neb = Neb + (47 + -46)\n    return JAS [ mbp ]"}
{"old_id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS", "code": "def bxO ( PDD , QyS ) :\n    Xdv = len ( PDD )\n    rvV = len ( QyS )\n    if rvV == (97 + -97) :\n        return (99 + -98)\n    ptp = [ [ (43 + -43) ] * ( Xdv + (8 + -7) ) for pXW in range ( rvV + (90 + -89) ) ]\n    nom = (64 + -64)\n    SJl = range ( rvV )\n    while nom < len(SJl):\n        hTv = SJl[nom]\n        nyL = (48 + -48)\n        pME = range ( hTv , Xdv )\n        while nyL < len(pME):\n            oUp = pME[nyL]\n            if hTv == (23 + -23) :\n                if oUp == (85 + -85) :\n                    if PDD [ oUp ] == QyS [ hTv ] :\n                        ptp [ hTv ] [ oUp ] = (88 + -87)\n                    else :\n                        ptp [ hTv ] [ oUp ] = (28 + -28)\n                elif PDD [ oUp ] == QyS [ hTv ] :\n                    ptp [ hTv ] [ oUp ] = ptp [ hTv ] [ oUp - (42 + -41) ] + (97 + -96)\n                else :\n                    ptp [ hTv ] [ oUp ] = ptp [ hTv ] [ oUp - (60 + -59) ]\n            else :\n                if PDD [ oUp ] == QyS [ hTv ] :\n                    ptp [ hTv ] [ oUp ] = ( ptp [ hTv ] [ oUp - (59 + -58) ] + ptp [ hTv - (6 + -5) ] [ oUp - (26 + -25) ] )\n                else :\n                    ptp [ hTv ] [ oUp ] = ptp [ hTv ] [ oUp - (56 + -55) ]\n            nyL = nyL + (34 + -33)\n        nom = nom + (43 + -42)\n    return ptp [ rvV - (97 + -96) ] [ Xdv - (42 + -41) ]"}
