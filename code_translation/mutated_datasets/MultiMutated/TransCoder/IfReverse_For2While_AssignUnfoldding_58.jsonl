{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ); res = res - 48\n    idx_wvsa = 0\n    list_sxnl = range ( 1 , len ( str ) )\n    while idx_wvsa < len(list_sxnl):\n        i = list_sxnl[idx_wvsa]\n        if not ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ):\n            res += ord ( str [ i ] ) - 48\n        else:\n            res += ord ( str [ i ] ) - 48\n        idx_wvsa = idx_wvsa + 1\n    return res", "id": "AssignUnfoldding_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_0", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if not ( length % 3 == 1 ):\n        if ( length % 3 == 2 ) :\n            num = str ( num ); num = num + \"0\"\n            length += 1\n    else:\n        num = str ( num ); num = num + \"00\"\n        length += 2\n    sum = 0\n    p = 1\n    idx_snxi = 0\n    list_ykbz = range ( length - 1 , - 1 , - 3 )\n    while idx_snxi < len(list_ykbz):\n        i = list_ykbz[idx_snxi]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n        idx_snxi = idx_snxi + 1\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "AssignUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_1", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if not ( n % 3 == 1 ):\n        if ( n % 3 == 2 ) :\n            num = str ( num ); num = num + \"0\"\n            n += 1\n    else:\n        num = str ( num ); num = num + \"00\"\n        n += 2\n    GSum = 0\n    p = 1\n    idx_vhe4 = 0\n    list_591l = range ( n - 1 , - 1 , - 1 )\n    while idx_vhe4 < len(list_591l):\n        i = list_591l[idx_vhe4]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n        idx_vhe4 = idx_vhe4 + 1\n    return ( GSum % 7 == 0 )", "id": "AssignUnfoldding_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_2", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    idx_tzly = 0\n    list_v9zj = range ( 2 , n + 1 )\n    while idx_tzly < len(list_v9zj):\n        i = list_v9zj[idx_tzly]\n        idx_v5d8 = 0\n        list_s1rn = range ( k + 1 )\n        while idx_v5d8 < len(list_s1rn):\n            j = list_s1rn[idx_v5d8]\n            if not j >= i:\n                dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ]; dp [ i ] [ j ] [ 0 ] = dp [ i ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ]\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n            else:\n                break\n            idx_v5d8 = idx_v5d8 + 1\n        idx_tzly = idx_tzly + 1\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_3", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def findSubsequenceCount ( S , T ) :\n    m = len ( T )\n    n = len ( S )\n    if m > n :\n        return 0\n    mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ]\n    idx_l2ue = 0\n    list_a69g = range ( 1 , m + 1 )\n    while idx_l2ue < len(list_a69g):\n        i = list_a69g[idx_l2ue]\n        mat [ i ] [ 0 ] = 0\n        idx_l2ue = idx_l2ue + 1\n    idx_fanv = 0\n    list_j3lr = range ( n + 1 )\n    while idx_fanv < len(list_j3lr):\n        j = list_j3lr[idx_fanv]\n        mat [ 0 ] [ j ] = 1\n        idx_fanv = idx_fanv + 1\n    idx_ajri = 0\n    list_kiv4 = range ( 1 , m + 1 )\n    while idx_ajri < len(list_kiv4):\n        i = list_kiv4[idx_ajri]\n        idx_vjh6 = 0\n        list_flhc = range ( 1 , n + 1 )\n        while idx_vjh6 < len(list_flhc):\n            j = list_flhc[idx_vjh6]\n            if not T [ i - 1 ] != S [ j - 1 ]:\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]; mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ i - 1 ] [ j - 1 ]\n            else:\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]\n            idx_vjh6 = idx_vjh6 + 1\n        idx_ajri = idx_ajri + 1\n    return mat [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE_to_4", "old_id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE"}
{"code": "def countP ( n , k ) :\n    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]\n    idx_s3o6 = 0\n    list_b0ey = range ( n + 1 )\n    while idx_s3o6 < len(list_b0ey):\n        i = list_b0ey[idx_s3o6]\n        dp [ i ] [ 0 ] = 0\n        idx_s3o6 = idx_s3o6 + 1\n    idx_cr3p = 0\n    list_1ahn = range ( k + 1 )\n    while idx_cr3p < len(list_1ahn):\n        i = list_1ahn[idx_cr3p]\n        dp [ 0 ] [ k ] = 0\n        idx_cr3p = idx_cr3p + 1\n    idx_cau8 = 0\n    list_rbsa = range ( 1 , n + 1 )\n    while idx_cau8 < len(list_rbsa):\n        i = list_rbsa[idx_cau8]\n        idx_9o02 = 0\n        list_bapf = range ( 1 , k + 1 )\n        while idx_9o02 < len(list_bapf):\n            j = list_bapf[idx_9o02]\n            if not ( j == 1 or i == j ):\n                dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            else:\n                dp [ i ] [ j ] = 1\n            idx_9o02 = idx_9o02 + 1\n        idx_cau8 = idx_cau8 + 1\n    return dp [ n ] [ k ]", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1_to_5", "old_id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1"}
{"code": "def countWays ( n , m ) :\n    count = [ ]\n    idx_ts1x = 0\n    list_gzm6 = range ( n + 2 )\n    while idx_ts1x < len(list_gzm6):\n        i = list_gzm6[idx_ts1x]\n        count.append ( 0 )\n        idx_ts1x = idx_ts1x + 1\n    count [ 0 ] = 0\n    idx_usiv = 0\n    list_dmwt = range ( 1 , n + 1 )\n    while idx_usiv < len(list_dmwt):\n        i = list_dmwt[idx_usiv]\n        if not ( i > m ):\n            if ( i < m ) :\n                count [ i ] = 1\n            else :\n                count [ i ] = 2\n        else:\n            count [ i ] = count [ i - 1 ]; count [ i ] = count [ i ] + count [ i - m ]\n        idx_usiv = idx_usiv + 1\n    return count [ n ]", "id": "AssignUnfoldding_sample_from_COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES_to_6", "old_id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ); ans = ans // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    idx_6b9a = 0\n    list_1hp6 = range ( n )\n    while idx_6b9a < len(list_1hp6):\n        i = list_1hp6[idx_6b9a]\n        if not ( str [ i ] == 'a' ):\n            if ( str [ i ] == 'b' ) :\n                b_index = i; b_index = b_index + 1\n                ans -= min ( a_index , c_index )\n            else :\n                c_index = i; c_index = c_index + 1\n                ans -= min ( a_index , b_index )\n        else:\n            a_index = i; a_index = a_index + 1\n            ans -= min ( b_index , c_index )\n        idx_6b9a = idx_6b9a + 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_7", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def CountPS ( str , n ) :\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    idx_oht5 = 0\n    list_mz7f = range ( n )\n    while idx_oht5 < len(list_mz7f):\n        i = list_mz7f[idx_oht5]\n        P [ i ] [ i ] = True\n        idx_oht5 = idx_oht5 + 1\n    idx_ky63 = 0\n    list_9udh = range ( n - 1 )\n    while idx_ky63 < len(list_9udh):\n        i = list_9udh[idx_ky63]\n        if ( str [ i ] == str [ i + 1 ] ) :\n            P [ i ] [ i + 1 ] = True\n            dp [ i ] [ i + 1 ] = 1\n        idx_ky63 = idx_ky63 + 1\n    idx_34il = 0\n    list_5yjg = range ( 2 , n )\n    while idx_34il < len(list_5yjg):\n        gap = list_5yjg[idx_34il]\n        idx_ft7m = 0\n        list_65gj = range ( n - gap )\n        while idx_ft7m < len(list_65gj):\n            i = list_65gj[idx_ft7m]\n            j = gap; j = j + i\n            if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) :\n                P [ i ] [ j ] = True\n            if not ( P [ i ] [ j ] == True ):\n                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ]; dp [ i ] [ j ] = dp [ i ] [ j ] - dp [ i + 1 ] [ j - 1 ]\n            else:\n                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1; dp [ i ] [ j ] = dp [ i ] [ j ] - dp [ i + 1 ] [ j - 1 ]\n            idx_ft7m = idx_ft7m + 1\n        idx_34il = idx_34il + 1\n    return dp [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_COUNT_PALINDROME_SUB_STRINGS_STRING_to_8", "old_id": "COUNT_PALINDROME_SUB_STRINGS_STRING"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ]; hash_positive = hash_positive * ( n + 1 )\n    hash_negative = [ 0 ]; hash_negative = hash_negative * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    idx_l14k = 0\n    list_6rmo = range ( n )\n    while idx_l14k < len(list_6rmo):\n        i = list_6rmo[idx_l14k]\n        if not ( arr [ i ] & 1 == 1 ):\n            difference = difference - 1\n        else:\n            difference = difference + 1\n        if not ( difference < 0 ):\n            ans += hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ]; hash_positive [ difference ] = hash_positive [ difference ] + 1\n        else:\n            ans += hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ]; hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n        idx_l14k = idx_l14k + 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_9", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1; change = change << i\n        idx_urqc = 0\n        list_se5i = range ( 0 , n + 1 )\n        while idx_urqc < len(list_se5i):\n            j = list_se5i[idx_urqc]\n            ans += k\n            if not change == 1:\n                change -= 1\n            else:\n                k = not k\n                change = 1; change = change << i\n            idx_urqc = idx_urqc + 1\n        i += 1\n    return ans", "id": "AssignUnfoldding_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_10", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ]; count = count * NO_OF_CHARS\n    idx_gioe = 0\n    list_0mfo = range ( len ( str ) )\n    while idx_gioe < len(list_0mfo):\n        i = list_0mfo[idx_gioe]\n        count [ ord ( str [ i ] ) ] += 1\n        idx_gioe = idx_gioe + 1\n    first , second = 0 , 0\n    idx_9g8t = 0\n    list_5fd3 = range ( NO_OF_CHARS )\n    while idx_9g8t < len(list_5fd3):\n        i = list_5fd3[idx_9g8t]\n        if not count [ i ] > count [ first ]:\n            if ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n                second = i\n        else:\n            second = first\n            first = i\n        idx_9g8t = idx_9g8t + 1\n    return chr ( second )", "id": "AssignUnfoldding_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_11", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    idx_lt2p = 0\n    list_o1gm = range ( len ( Str ) )\n    while idx_lt2p < len(list_o1gm):\n        i = list_o1gm[idx_lt2p]\n        count = 0\n        if not ( Str [ i ] >= '0' and Str [ i ] <= '9' ):\n            if ( Str [ i ] == ']' ) :\n                temp = \"\"\n                count = 0\n                if ( len ( integerstack ) != 0 ) :\n                    count = integerstack [ - 1 ]\n                    integerstack.pop ( )\n                while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                    temp = stringstack [ - 1 ] + temp\n                    stringstack.pop ( )\n                if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                    stringstack.pop ( )\n                idx_q5ws = 0\n                list_hrkz = range ( count )\n                while idx_q5ws < len(list_hrkz):\n                    j = list_hrkz[idx_q5ws]\n                    result = result + temp\n                    idx_q5ws = idx_q5ws + 1\n                idx_wa9k = 0\n                list_n69z = range ( len ( result ) )\n                while idx_wa9k < len(list_n69z):\n                    j = list_n69z[idx_wa9k]\n                    stringstack.append ( result [ j ] )\n                    idx_wa9k = idx_wa9k + 1\n                result = \"\"\n            elif ( Str [ i ] == '[' ) :\n                if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                    stringstack.append ( Str [ i ] )\n                else :\n                    stringstack.append ( Str [ i ] )\n                    integerstack.append ( 1 )\n            else :\n                stringstack.append ( Str [ i ] )\n        else:\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ); count = count - ord ( '0' )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n        idx_lt2p = idx_lt2p + 1\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "AssignUnfoldding_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_12", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def lps ( seq ) :\n    n = len ( seq )\n    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]\n    idx_k8zw = 0\n    list_8qfb = range ( n )\n    while idx_k8zw < len(list_8qfb):\n        i = list_8qfb[idx_k8zw]\n        L [ i ] [ i ] = 1\n        idx_k8zw = idx_k8zw + 1\n    idx_r0li = 0\n    list_0lfd = range ( 2 , n + 1 )\n    while idx_r0li < len(list_0lfd):\n        cl = list_0lfd[idx_r0li]\n        idx_uamx = 0\n        list_jqb9 = range ( n - cl + 1 )\n        while idx_uamx < len(list_jqb9):\n            i = list_jqb9[idx_uamx]\n            j = i + cl; j = j - 1\n            if not seq [ i ] == seq [ j ] and cl == 2:\n                if seq [ i ] == seq [ j ] :\n                    L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ]; L [ i ] [ j ] = L [ i ] [ j ] + 2\n                else :\n                    L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;\n            else:\n                L [ i ] [ j ] = 2\n            idx_uamx = idx_uamx + 1\n        idx_r0li = idx_r0li + 1\n    return L [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE_to_13", "old_id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE"}
{"code": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = 0\n    k = 0\n    L = 0\n    idx_u059 = 0\n    list_l5gm = range ( n )\n    while idx_u059 < len(list_l5gm):\n        i = list_l5gm[idx_u059]\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = 0\n        idx_u059 = idx_u059 + 1\n    idx_zksd = 0\n    list_lkp6 = range ( 2 , n + 1 )\n    while idx_zksd < len(list_lkp6):\n        L = list_lkp6[idx_zksd]\n        idx_e9cr = 0\n        list_ep5l = range ( n - L + 1 )\n        while idx_e9cr < len(list_ep5l):\n            i = list_ep5l[idx_e9cr]\n            j = i + L; j = j - 1\n            if not L == 2:\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )\n            else:\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            if not P [ i ] [ j ] == True:\n                C [ i ] [ j ] = 100000000\n                idx_nhqo = 0\n                list_sl85 = range ( i , j )\n                while idx_nhqo < len(list_sl85):\n                    k = list_sl85[idx_nhqo]\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n                    idx_nhqo = idx_nhqo + 1\n            else:\n                C [ i ] [ j ] = 0\n            idx_e9cr = idx_e9cr + 1\n        idx_zksd = idx_zksd + 1\n    return C [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_to_14", "old_id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    idx_zb1f = 0\n    list_lr4d = range ( n )\n    while idx_zb1f < len(list_lr4d):\n        i = list_lr4d[idx_zb1f]\n        if not symb [ i ] == 'F':\n            F [ i ] [ i ] = 0\n        else:\n            F [ i ] [ i ] = 1\n        if not symb [ i ] == 'T':\n            T [ i ] [ i ] = 0\n        else:\n            T [ i ] [ i ] = 1\n        idx_zb1f = idx_zb1f + 1\n    idx_g6ro = 0\n    list_ep50 = range ( 1 , n )\n    while idx_g6ro < len(list_ep50):\n        gap = list_ep50[idx_g6ro]\n        i = 0\n        idx_7xhz = 0\n        list_h36e = range ( gap , n )\n        while idx_7xhz < len(list_h36e):\n            j = list_h36e[idx_7xhz]\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            idx_ayd1 = 0\n            list_b3ch = range ( gap )\n            while idx_ayd1 < len(list_b3ch):\n                g = list_b3ch[idx_ayd1]\n                k = i; k = k + g\n                tik = T [ i ] [ k ]; tik = tik + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ]; tkj = tkj + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                idx_ayd1 = idx_ayd1 + 1\n            i += 1\n            idx_7xhz = idx_7xhz + 1\n        idx_g6ro = idx_g6ro + 1\n    return T [ 0 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_15", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def computeLastDigit ( A , B ) :\n    variable = 1\n    if not ( A == B ):\n        if ( ( B - A ) >= 5 ) :\n            return 0\n        else :\n            idx_av15 = 0\n            list_eqdp = range ( A + 1 , B + 1 )\n            while idx_av15 < len(list_eqdp):\n                i = list_eqdp[idx_av15]\n                variable = ( variable * ( i % 10 ) ); variable = variable % 10\n                idx_av15 = idx_av15 + 1\n            return variable % 10\n    else:\n        return 1", "id": "AssignUnfoldding_sample_from_FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B_to_16", "old_id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize; mx = mx - 1\n    idx_r2iw = 0\n    list_3cn7 = range ( r )\n    while idx_r2iw < len(list_3cn7):\n        i = list_3cn7[idx_r2iw]\n        if m [ i ] [ 0 ] < mi :\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx :\n            mx = m [ i ] [ c - 1 ]\n        idx_r2iw = idx_r2iw + 1\n    desired = ( r * c + 1 ); desired = desired // 2\n    while ( mi < mx ) :\n        mid = mi; mid = mid + ( mx - mi ) // 2\n        place = [ 0 ]\n        idx_p4a7 = 0\n        list_hawk = range ( r )\n        while idx_p4a7 < len(list_hawk):\n            i = list_hawk[idx_p4a7]\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ]; place [ 0 ] = place [ 0 ] + j\n            idx_p4a7 = idx_p4a7 + 1\n        if not place [ 0 ] < desired:\n            mx = mid\n        else:\n            mi = mid; mi = mi + 1\n    print ( \"Median is\" , mi )\n    return mi", "id": "AssignUnfoldding_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_17", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def count ( a , b ) :\n    m = len ( a )\n    n = len ( b )\n    lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]\n    idx_k9el = 0\n    list_bknv = range ( n + 1 )\n    while idx_k9el < len(list_bknv):\n        i = list_bknv[idx_k9el]\n        lookup [ 0 ] [ i ] = 0\n        idx_k9el = idx_k9el + 1\n    idx_q4op = 0\n    list_r01f = range ( m + 1 )\n    while idx_q4op < len(list_r01f):\n        i = list_r01f[idx_q4op]\n        lookup [ i ] [ 0 ] = 1\n        idx_q4op = idx_q4op + 1\n    idx_e7zy = 0\n    list_oglc = range ( 1 , m + 1 )\n    while idx_e7zy < len(list_oglc):\n        i = list_oglc[idx_e7zy]\n        idx_8voj = 0\n        list_1twg = range ( 1 , n + 1 )\n        while idx_8voj < len(list_1twg):\n            j = list_1twg[idx_8voj]\n            if not a [ i - 1 ] == b [ j - 1 ]:\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]\n            else:\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ]; lookup [ i ] [ j ] = lookup [ i ] [ j ] + lookup [ i - 1 ] [ j ]\n            idx_8voj = idx_8voj + 1\n        idx_e7zy = idx_e7zy + 1\n    return lookup [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1_to_18", "old_id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1"}
{"code": "def findSDSFunc ( n ) :\n    DP = [ 0 ]; DP = DP * ( n + 1 )\n    DP [ 0 ] = 0\n    DP [ 1 ] = 1\n    idx_wvsy = 0\n    list_fcm2 = range ( 2 , n + 1 )\n    while idx_wvsy < len(list_fcm2):\n        i = list_fcm2[idx_wvsy]\n        if not ( int ( i % 2 ) == 0 ):\n            DP [ i ] = DP [ int ( ( i - 1 ) / 2 ) ]; DP [ i ] = DP [ i ] + DP [ int ( ( i + 1 ) / 2 ) ]\n        else:\n            DP [ i ] = DP [ int ( i / 2 ) ]\n        idx_wvsy = idx_wvsy + 1\n    return DP [ n ]", "id": "AssignUnfoldding_sample_from_FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES_to_19", "old_id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES"}
{"code": "def pairSum ( mat , n , sum ) :\n    idx_u9k5 = 0\n    list_dor7 = range ( n )\n    while idx_u9k5 < len(list_dor7):\n        i = list_dor7[idx_u9k5]\n        mat [ i ].sort ( )\n        idx_u9k5 = idx_u9k5 + 1\n    idx_m7zy = 0\n    list_yn3e = range ( n - 1 )\n    while idx_m7zy < len(list_yn3e):\n        i = list_yn3e[idx_m7zy]\n        idx_x1rz = 0\n        list_xviu = range ( i + 1 , n )\n        while idx_x1rz < len(list_xviu):\n            j = list_xviu[idx_x1rz]\n            left = 0\n            right = n; right = right - 1\n            while ( left < n and right >= 0 ) :\n                if not ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ):\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1\n                else:\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left += 1\n                    right -= 1\n            idx_x1rz = idx_x1rz + 1\n        idx_m7zy = idx_m7zy + 1", "id": "AssignUnfoldding_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_20", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def evenSum ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    idx_qep6 = 0\n    list_8mh6 = range ( 0 , n + 1 )\n    while idx_qep6 < len(list_8mh6):\n        i = list_8mh6[idx_qep6]\n        idx_txb7 = 0\n        list_xlr3 = range ( 0 , min ( i , n ) + 1 )\n        while idx_txb7 < len(list_xlr3):\n            j = list_xlr3[idx_txb7]\n            if not j == 0 or j == i:\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            else:\n                C [ i ] [ j ] = 1\n            idx_txb7 = idx_txb7 + 1\n        idx_qep6 = idx_qep6 + 1\n    sum = 0 ;\n    idx_l9s6 = 0\n    list_9avh = range ( 0 , n + 1 )\n    while idx_l9s6 < len(list_9avh):\n        i = list_9avh[idx_l9s6]\n        if i % 2 == 0 :\n            sum = sum + C [ n ] [ i ]\n        idx_l9s6 = idx_l9s6 + 1\n    return sum", "id": "AssignUnfoldding_sample_from_FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_to_21", "old_id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    idx_rbos = 0\n    list_2iug = range ( 0 , n - 1 )\n    while idx_rbos < len(list_2iug):\n        i = list_2iug[idx_rbos]\n        l = i; l = l + 1\n        r = n; r = r - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if not ( x + arr [ l ] + arr [ r ] == 0 ):\n                if ( x + arr [ l ] + arr [ r ] < 0 ) :\n                    l += 1\n                else :\n                    r -= 1\n            else:\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n        idx_rbos = idx_rbos + 1\n    if ( found == False ) :\n        print ( \" No Triplet Found\" )", "id": "AssignUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_22", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def countFriendsPairings ( n ) :\n    dp = [ 0 for i in range ( n + 1 ) ]\n    idx_14k0 = 0\n    list_d3zn = range ( n + 1 )\n    while idx_14k0 < len(list_d3zn):\n        i = list_d3zn[idx_14k0]\n        if not ( i <= 2 ):\n            dp [ i ] = dp [ i - 1 ]; dp [ i ] = dp [ i ] + ( i - 1 ) * dp [ i - 2 ]\n        else:\n            dp [ i ] = i\n        idx_14k0 = idx_14k0 + 1\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_FRIENDS_PAIRING_PROBLEM_to_23", "old_id": "FRIENDS_PAIRING_PROBLEM"}
{"code": "def isSubSeqDivisible ( str ) :\n    l = len ( str )\n    arr = [ 0 ]; arr = arr * l\n    idx_jy7c = 0\n    list_md63 = range ( 0 , l )\n    while idx_jy7c < len(list_md63):\n        i = list_md63[idx_jy7c]\n        idx_j97t = 0\n        list_4lg6 = range ( i , l )\n        while idx_j97t < len(list_4lg6):\n            j = list_4lg6[idx_j97t]\n            idx_xtru = 0\n            list_fwkc = range ( j , l )\n            while idx_xtru < len(list_fwkc):\n                k = list_fwkc[idx_xtru]\n                if not ( arr [ i ] % 8 == 0 ):\n                    if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :\n                        return True\n                    elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :\n                        return True\n                else:\n                    return True\n                idx_xtru = idx_xtru + 1\n            idx_j97t = idx_j97t + 1\n        idx_jy7c = idx_jy7c + 1\n    return False", "id": "AssignUnfoldding_sample_from_GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_to_24", "old_id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ]; maxRev = maxRev * ( m + 1 )\n    nxtbb = 0\n    idx_vpa3 = 0\n    list_d14x = range ( 1 , m + 1 )\n    while idx_vpa3 < len(list_d14x):\n        i = list_d14x[idx_vpa3]\n        if not ( nxtbb < n ):\n            maxRev [ i ] = maxRev [ i - 1 ]\n        else:\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb += 1\n        idx_vpa3 = idx_vpa3 + 1\n    return maxRev [ m ]", "id": "AssignUnfoldding_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_25", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    idx_ypc1 = 0\n    list_osy7 = arr\n    while idx_ypc1 < len(list_osy7):\n        i = list_osy7[idx_ypc1]\n        if not ( i < 0 ):\n            hash [ i ] = hash.get ( i , 0 ); hash [ i ] = hash [ i ] + 1\n        else:\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] -= 1\n        idx_ypc1 = idx_ypc1 + 1\n    idx_ano0 = 0\n    list_qp0u = arr\n    while idx_ano0 < len(list_qp0u):\n        i = list_qp0u[idx_ano0]\n        if i in hash.keys ( ) and hash [ i ] > 0 :\n            return i\n        idx_ano0 = idx_ano0 + 1\n    return - 1", "id": "AssignUnfoldding_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_26", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def kthLargestSum ( arr , n , k ) :\n    sum = [ ]\n    sum.append ( 0 )\n    sum.append ( arr [ 0 ] )\n    idx_g0sv = 0\n    list_re5m = range ( 2 , n + 1 )\n    while idx_g0sv < len(list_re5m):\n        i = list_re5m[idx_g0sv]\n        sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )\n        idx_g0sv = idx_g0sv + 1\n    Q = [ ]\n    heapq.heapify ( Q )\n    idx_bt4z = 0\n    list_vfn5 = range ( 1 , n + 1 )\n    while idx_bt4z < len(list_vfn5):\n        i = list_vfn5[idx_bt4z]\n        idx_hzc6 = 0\n        list_q3je = range ( i , n + 1 )\n        while idx_hzc6 < len(list_q3je):\n            j = list_q3je[idx_hzc6]\n            x = sum [ j ]; x = x - sum [ i - 1 ]\n            if not len ( Q ) < k:\n                if Q [ 0 ] < x :\n                    heapq.heappop ( Q )\n                    heapq.heappush ( Q , x )\n            else:\n                heapq.heappush ( Q , x )\n            idx_hzc6 = idx_hzc6 + 1\n        idx_bt4z = idx_bt4z + 1\n    return Q [ 0 ]", "id": "AssignUnfoldding_sample_from_K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY_to_27", "old_id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY"}
{"code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    idx_sajq = 0\n    list_0762 = range ( 0 , n - 1 )\n    while idx_sajq < len(list_0762):\n        i = list_0762[idx_sajq]\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        idx_ibpz = 0\n        list_0so2 = range ( i + 1 , n )\n        while idx_ibpz < len(list_0so2):\n            j = list_0so2[idx_ibpz]\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) :\n                maxsize = j - i; maxsize = maxsize + 1\n                startindex = i\n            idx_ibpz = idx_ibpz + 1\n        idx_sajq = idx_sajq + 1\n    if not ( maxsize == - 1 ):\n        print ( startindex , \"to\" , startindex + maxsize - 1 )\n    else:\n        print ( \"No such subarray\" )\n    return maxsize", "id": "AssignUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_28", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    idx_hsqp = 0\n    list_1ybx = range ( 0 , n )\n    while idx_hsqp < len(list_1ybx):\n        i = list_1ybx[idx_hsqp]\n        if not ( arr [ i ] == 0 ):\n            arr [ i ] = 1\n        else:\n            arr [ i ] = - 1\n        idx_hsqp = idx_hsqp + 1\n    idx_s40m = 0\n    list_ji89 = range ( 0 , n )\n    while idx_s40m < len(list_ji89):\n        i = list_ji89[idx_s40m]\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) :\n            max_len = i; max_len = max_len + 1\n            ending_index = i\n        if not ( curr_sum + n ) in hash_map:\n            hash_map[curr_sum + n] = i\n        else:\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i; max_len = max_len - hash_map [ curr_sum + n ]\n                ending_index = i\n        idx_s40m = idx_s40m + 1\n    idx_9na0 = 0\n    list_vpzl = range ( 0 , n )\n    while idx_9na0 < len(list_vpzl):\n        i = list_vpzl[idx_9na0]\n        if not ( arr [ i ] == - 1 ):\n            arr [ i ] = 1\n        else:\n            arr [ i ] = 0\n        idx_9na0 = idx_9na0 + 1\n    print ( ending_index - max_len + 1 , end = \" \" )\n    print ( \"to\" , end = \" \" )\n    print ( ending_index )\n    return max_len", "id": "AssignUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_29", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    idx_h7zc = 0\n    list_4apr = range ( n )\n    while idx_h7zc < len(list_4apr):\n        i = list_4apr[idx_h7zc]\n        L [ i ] [ n - 1 ] = 2\n        idx_h7zc = idx_h7zc + 1\n    idx_7zqp = 0\n    list_2jfl = range ( n - 2 , 0 , - 1 )\n    while idx_7zqp < len(list_2jfl):\n        j = list_2jfl[idx_7zqp]\n        i = j; i = i - 1\n        k = j; k = k + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if not ( set [ i ] + set [ k ] < 2 * set [ j ] ):\n                if ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                    L [ i ] [ j ] = 2\n                    i -= 1\n                else :\n                    L [ i ] [ j ] = L [ j ] [ k ]; L [ i ] [ j ] = L [ i ] [ j ] + 1\n                    llap = max ( llap , L [ i ] [ j ] )\n                    i -= 1\n                    k += 1\n            else:\n                k += 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i -= 1\n        idx_7zqp = idx_7zqp + 1\n    return llap", "id": "AssignUnfoldding_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_30", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def LCSubStr ( X , Y , m , n ) :\n    LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ]\n    result = 0\n    idx_9obm = 0\n    list_vocq = range ( m + 1 )\n    while idx_9obm < len(list_vocq):\n        i = list_vocq[idx_9obm]\n        idx_jatc = 0\n        list_1wo8 = range ( n + 1 )\n        while idx_jatc < len(list_1wo8):\n            j = list_1wo8[idx_jatc]\n            if not ( i == 0 or j == 0 ):\n                if ( X [ i - 1 ] == Y [ j - 1 ] ) :\n                    LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ]; LCSuff [ i ] [ j ] = LCSuff [ i ] [ j ] + 1\n                    result = max ( result , LCSuff [ i ] [ j ] )\n                else :\n                    LCSuff [ i ] [ j ] = 0\n            else:\n                LCSuff [ i ] [ j ] = 0\n            idx_jatc = idx_jatc + 1\n        idx_9obm = idx_9obm + 1\n    return result", "id": "AssignUnfoldding_sample_from_LONGEST_COMMON_SUBSTRING_to_31", "old_id": "LONGEST_COMMON_SUBSTRING"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_6vyz = 0\n    list_yij1 = range ( 1 , n + 1 )\n    while idx_6vyz < len(list_yij1):\n        i = list_yij1[idx_6vyz]\n        idx_nyh1 = 0\n        list_10ho = range ( 1 , n + 1 )\n        while idx_nyh1 < len(list_10ho):\n            j = list_10ho[idx_nyh1]\n            if not ( str [ i - 1 ] == str [ j - 1 ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            else:\n                dp [ i ] [ j ] = 1; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            idx_nyh1 = idx_nyh1 + 1\n        idx_6vyz = idx_6vyz + 1\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if not ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ):\n            if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n                i -= 1\n            else :\n                j -= 1\n        else:\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "AssignUnfoldding_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_32", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def findLongestRepeatingSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 ] * ( n + 1 ) ]; dp = dp * ( n + 1 )\n    idx_vuht = 0\n    list_d53p = range ( 1 , n + 1 )\n    while idx_vuht < len(list_d53p):\n        i = list_d53p[idx_vuht]\n        idx_gfac = 0\n        list_d3rh = range ( 1 , n + 1 )\n        while idx_gfac < len(list_d3rh):\n            j = list_d3rh[idx_gfac]\n            if not ( str [ i - 1 ] == str [ j - 1 ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            else:\n                dp [ i ] [ j ] = 1; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n            idx_gfac = idx_gfac + 1\n        idx_vuht = idx_vuht + 1\n    return dp [ n ] [ n ]", "id": "AssignUnfoldding_sample_from_LONGEST_REPEATING_SUBSEQUENCE_to_33", "old_id": "LONGEST_REPEATING_SUBSEQUENCE"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    idx_3n1p = 0\n    list_iz84 = range ( n )\n    while idx_3n1p < len(list_iz84):\n        i = list_iz84[idx_3n1p]\n        if not arr [ i ] == 0:\n            sum += 1\n        else:\n            sum += - 1\n        if not ( sum == 1 ):\n            if ( sum not in um ) :\n                um [ sum ] = i\n        else:\n            maxLen = i; maxLen = maxLen + 1\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i; maxLen = maxLen - um [ sum - 1 ]\n        idx_3n1p = idx_3n1p + 1\n    return maxLen", "id": "AssignUnfoldding_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_34", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    idx_pqms = 0\n    list_sgnf = range ( n )\n    while idx_pqms < len(list_sgnf):\n        i = list_sgnf[idx_pqms]\n        curr_sum += arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ); mod_arr [ i ] = mod_arr [ i ] % k\n        idx_pqms = idx_pqms + 1\n    idx_uil0 = 0\n    list_zpdl = range ( n )\n    while idx_uil0 < len(list_zpdl):\n        i = list_zpdl[idx_uil0]\n        if not ( mod_arr [ i ] == 0 ):\n            if ( mod_arr [ i ] in um ) :\n                um [ mod_arr [ i ] ] = i\n            else :\n                if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                    max = i; max = max - um [ mod_arr [ i ] ]\n        else:\n            max = i; max = max + 1\n        idx_uil0 = idx_uil0 + 1\n    return max", "id": "AssignUnfoldding_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_35", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def maxcoefficientvalue ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    idx_5i71 = 0\n    list_lj1i = range ( n + 1 )\n    while idx_5i71 < len(list_lj1i):\n        i = list_lj1i[idx_5i71]\n        idx_7rev = 0\n        list_hfwk = range ( min ( i , n ) + 1 )\n        while idx_7rev < len(list_hfwk):\n            j = list_hfwk[idx_7rev]\n            if not ( j == 0 or j == i ):\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            else:\n                C [ i ] [ j ] = 1\n            idx_7rev = idx_7rev + 1\n        idx_5i71 = idx_5i71 + 1\n    maxvalue = 0\n    idx_tzyl = 0\n    list_62qu = range ( n + 1 )\n    while idx_tzyl < len(list_62qu):\n        i = list_62qu[idx_tzyl]\n        maxvalue = max ( maxvalue , C [ n ] [ i ] )\n        idx_tzyl = idx_tzyl + 1\n    return maxvalue", "id": "AssignUnfoldding_sample_from_MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE_to_36", "old_id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE"}
{"code": "def maxNumOfChocolates ( arr , n , k ) :\n    um , curr_rem , maxSum = { } , 0 , 0\n    sm = [ 0 ]; sm = sm * n\n    sm [ 0 ] = arr [ 0 ]\n    idx_kdh1 = 0\n    list_3lhz = range ( 1 , n )\n    while idx_kdh1 < len(list_3lhz):\n        i = list_3lhz[idx_kdh1]\n        sm [ i ] = sm [ i - 1 ]; sm [ i ] = sm [ i ] + arr [ i ]\n        idx_kdh1 = idx_kdh1 + 1\n    idx_umhx = 0\n    list_r3gy = range ( n )\n    while idx_umhx < len(list_r3gy):\n        i = list_r3gy[idx_umhx]\n        curr_rem = sm [ i ]; curr_rem = curr_rem % k\n        if not ( not curr_rem and maxSum < sm [ i ] ):\n            if ( not curr_rem in um ) :\n                um [ curr_rem ] = i\n            elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :\n                maxSum = sm [ i ]; maxSum = maxSum - sm [ um [ curr_rem ] ]\n        else:\n            maxSum = sm [ i ]\n        idx_umhx = idx_umhx + 1\n    return maxSum // k", "id": "AssignUnfoldding_sample_from_MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS_to_37", "old_id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS"}
{"code": "def maxSumBitonicSubArr ( arr , n ) :\n    msis = [ None ]; msis = msis * n\n    msds = [ None ]; msds = msds * n\n    max_sum = 0\n    msis [ 0 ] = arr [ 0 ]\n    idx_q390 = 0\n    list_x7yd = range ( 1 , n )\n    while idx_q390 < len(list_x7yd):\n        i = list_x7yd[idx_q390]\n        if not ( arr [ i ] > arr [ i - 1 ] ):\n            msis [ i ] = arr [ i ]\n        else:\n            msis [ i ] = msis [ i - 1 ]; msis [ i ] = msis [ i ] + arr [ i ]\n        idx_q390 = idx_q390 + 1\n    msds [ n - 1 ] = arr [ n - 1 ]\n    idx_f3sk = 0\n    list_14t6 = range ( n - 2 , - 1 , - 1 )\n    while idx_f3sk < len(list_14t6):\n        i = list_14t6[idx_f3sk]\n        if not ( arr [ i ] > arr [ i + 1 ] ):\n            msds [ i ] = arr [ i ]\n        else:\n            msds [ i ] = msds [ i + 1 ]; msds [ i ] = msds [ i ] + arr [ i ]\n        idx_f3sk = idx_f3sk + 1\n    idx_0uzo = 0\n    list_bi46 = range ( n )\n    while idx_0uzo < len(list_bi46):\n        i = list_bi46[idx_0uzo]\n        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :\n            max_sum = msis [ i ] + msds [ i ]; max_sum = max_sum - arr [ i ]\n        idx_0uzo = idx_0uzo + 1\n    return max_sum", "id": "AssignUnfoldding_sample_from_MAXIMUM_SUM_BITONIC_SUBARRAY_to_38", "old_id": "MAXIMUM_SUM_BITONIC_SUBARRAY"}
{"code": "def getMinDiff ( arr , n , k ) :\n    if ( n == 1 ) :\n        return 0\n    arr.sort ( )\n    ans = arr [ n - 1 ]; ans = ans - arr [ 0 ]\n    small = arr [ 0 ]; small = small + k\n    big = arr [ n - 1 ]; big = big - k\n    if ( small > big ) :\n        small , big = big , small\n    idx_c7d0 = 0\n    list_jy4u = range ( 1 , n - 1 )\n    while idx_c7d0 < len(list_jy4u):\n        i = list_jy4u[idx_c7d0]\n        subtract = arr [ i ]; subtract = subtract - k\n        add = arr [ i ]; add = add + k\n        if ( subtract >= small or add <= big ) :\n            continue\n        if not ( big - subtract <= add - small ):\n            big = add\n        else:\n            small = subtract\n        idx_c7d0 = idx_c7d0 + 1\n    return min ( ans , big - small )", "id": "AssignUnfoldding_sample_from_MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS_to_39", "old_id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    idx_rv14 = 0\n    list_dxhw = range ( n - 2 , - 1 , - 1 )\n    while idx_rv14 < len(list_dxhw):\n        i = list_dxhw[idx_rv14]\n        if not ( arr [ i ] == 0 ):\n            if ( arr [ i ] >= n - i - 1 ) :\n                jumps [ i ] = 1\n            else :\n                min = float ( 'inf' )\n                idx_hrvb = 0\n                list_6e5j = range ( i + 1 , n )\n                while idx_hrvb < len(list_6e5j):\n                    j = list_6e5j[idx_hrvb]\n                    if ( j <= arr [ i ] + i ) :\n                        if ( min > jumps [ j ] ) :\n                            min = jumps [ j ]\n                    idx_hrvb = idx_hrvb + 1\n                if ( min != float ( 'inf' ) ) :\n                    jumps [ i ] = min; jumps [ i ] = jumps [ i ] + 1\n                else :\n                    jumps [ i ] = min\n        else:\n            jumps [ i ] = float ( 'inf' )\n        idx_rv14 = idx_rv14 + 1\n    return jumps [ 0 ]", "id": "AssignUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_40", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def getMinSquares ( n ) :\n    dp = [ 0 , 1 , 2 , 3 ]\n    idx_9h7o = 0\n    list_9atv = range ( 4 , n + 1 )\n    while idx_9h7o < len(list_9atv):\n        i = list_9atv[idx_9h7o]\n        dp.append ( i )\n        idx_aoej = 0\n        list_gi2h = range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 )\n        while idx_aoej < len(list_gi2h):\n            x = list_gi2h[idx_aoej]\n            temp = x; temp = temp * x\n            if not temp > i:\n                dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )\n            else:\n                break\n            idx_aoej = idx_aoej + 1\n        idx_9h7o = idx_9h7o + 1\n    return dp [ n ]", "id": "AssignUnfoldding_sample_from_MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1_to_41", "old_id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1"}
{"code": "def minproduct ( a , b , n , k ) :\n    diff = 0\n    res = 0\n    temp = 0\n    idx_d1o6 = 0\n    list_e289 = range ( n )\n    while idx_d1o6 < len(list_e289):\n        i = list_e289[idx_d1o6]\n        pro = a [ i ]; pro = pro * b [ i ]\n        res = res + pro\n        if not ( pro < 0 and b [ i ] < 0 ):\n            if ( pro < 0 and a [ i ] < 0 ) :\n                temp = ( a [ i ] - 2 * k ); temp = temp * b [ i ]\n            elif ( pro > 0 and a [ i ] < 0 ) :\n                temp = ( a [ i ] + 2 * k ); temp = temp * b [ i ]\n            elif ( pro > 0 and a [ i ] > 0 ) :\n                temp = ( a [ i ] - 2 * k ); temp = temp * b [ i ]\n        else:\n            temp = ( a [ i ] + 2 * k ); temp = temp * b [ i ]\n        d = abs ( pro - temp )\n        if ( d > diff ) :\n            diff = d\n        idx_d1o6 = idx_d1o6 + 1\n    return res - diff", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_PRODUCT_TWO_ARRAYS_to_42", "old_id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS"}
{"code": "def solve ( arr , n ) :\n    arr.sort ( )\n    a = 0\n    b = 0\n    idx_6fld = 0\n    list_et69 = range ( n )\n    while idx_6fld < len(list_et69):\n        i = list_et69[idx_6fld]\n        if not ( i % 2 != 0 ):\n            b = b * 10; b = b + arr [ i ]\n        else:\n            a = a * 10; a = a + arr [ i ]\n        idx_6fld = idx_6fld + 1\n    return a + b", "id": "AssignUnfoldding_sample_from_MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_to_43", "old_id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY"}
{"code": "def minTimeForWritingChars ( N , insert , remove , copy ) :\n    if N == 0 :\n        return 0\n    if N == 1 :\n        return insert\n    dp = [ 0 ]; dp = dp * ( N + 1 )\n    idx_amhx = 0\n    list_ho8k = range ( 1 , N + 1 )\n    while idx_amhx < len(list_ho8k):\n        i = list_ho8k[idx_amhx]\n        if not i % 2 == 0:\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove )\n        else:\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy )\n        idx_amhx = idx_amhx + 1\n    return dp [ N ]", "id": "AssignUnfoldding_sample_from_MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION_to_44", "old_id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION"}
{"code": "def answer ( n ) :\n    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ]\n    if ( n == 1 ) :\n        return 10\n    idx_f8wx = 0\n    list_kg4u = range ( 10 )\n    while idx_f8wx < len(list_kg4u):\n        j = list_kg4u[idx_f8wx]\n        dp [ 1 ] [ j ] = 1\n        idx_f8wx = idx_f8wx + 1\n    idx_qli7 = 0\n    list_fe4v = range ( 2 , n + 1 )\n    while idx_qli7 < len(list_fe4v):\n        i = list_fe4v[idx_qli7]\n        idx_g6bv = 0\n        list_7q69 = range ( 10 )\n        while idx_g6bv < len(list_7q69):\n            j = list_7q69[idx_g6bv]\n            if not ( j == 0 ):\n                if ( j == 9 ) :\n                    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]\n                else :\n                    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j + 1 ]\n            else:\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]\n            idx_g6bv = idx_g6bv + 1\n        idx_qli7 = idx_qli7 + 1\n    sum = 0\n    idx_laxi = 0\n    list_0v6q = range ( 1 , 10 )\n    while idx_laxi < len(list_0v6q):\n        j = list_0v6q[idx_laxi]\n        sum = sum + dp [ n ] [ j ]\n        idx_laxi = idx_laxi + 1\n    return sum", "id": "AssignUnfoldding_sample_from_NUMBER_N_DIGIT_STEPPING_NUMBERS_to_45", "old_id": "NUMBER_N_DIGIT_STEPPING_NUMBERS"}
{"code": "def isPrime ( p ) :\n    checkNumber = 2 ** p; checkNumber = checkNumber - 1\n    nextval = 4; nextval = nextval % checkNumber\n    idx_csm3 = 0\n    list_6ol1 = range ( 1 , p - 1 )\n    while idx_csm3 < len(list_6ol1):\n        i = list_6ol1[idx_csm3]\n        nextval = ( nextval * nextval - 2 ); nextval = nextval % checkNumber\n        idx_csm3 = idx_csm3 + 1\n    if not ( nextval == 0 ): return False\n    else: return True", "id": "AssignUnfoldding_sample_from_PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES_to_46", "old_id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ]; allocation = allocation * n\n    idx_052x = 0\n    list_hygs = range ( n )\n    while idx_052x < len(list_hygs):\n        i = list_hygs[idx_052x]\n        bestIdx = - 1\n        idx_9be5 = 0\n        list_qle3 = range ( m )\n        while idx_9be5 < len(list_qle3):\n            j = list_qle3[idx_9be5]\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n            idx_9be5 = idx_9be5 + 1\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n        idx_052x = idx_052x + 1\n    print ( \"Process No.Process Size     Block no.\" )\n    idx_ovq3 = 0\n    list_9z7k = range ( n )\n    while idx_ovq3 < len(list_9z7k):\n        i = list_9z7k[idx_ovq3]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if not allocation [ i ] != - 1:\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + 1 )\n        idx_ovq3 = idx_ovq3 + 1", "id": "AssignUnfoldding_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_47", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ]; allocation = allocation * n\n    idx_n8ab = 0\n    list_a8xt = range ( n )\n    while idx_n8ab < len(list_a8xt):\n        i = list_a8xt[idx_n8ab]\n        wstIdx = - 1\n        idx_sx2l = 0\n        list_nziu = range ( m )\n        while idx_sx2l < len(list_nziu):\n            j = list_nziu[idx_sx2l]\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n            idx_sx2l = idx_sx2l + 1\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n        idx_n8ab = idx_n8ab + 1\n    print ( \"Process No.Process Size Block no.\" )\n    idx_mylp = 0\n    list_x8cl = range ( n )\n    while idx_mylp < len(list_x8cl):\n        i = list_x8cl[idx_mylp]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if not allocation [ i ] != - 1:\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + 1 )\n        idx_mylp = idx_mylp + 1", "id": "AssignUnfoldding_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_48", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def rearrange ( arr , n ) :\n    temp = n; temp = temp * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    idx_9r2b = 0\n    list_eb5i = range ( n )\n    while idx_9r2b < len(list_eb5i):\n        i = list_eb5i[idx_9r2b]\n        if not flag is True:\n            temp [ i ] = arr [ small ]\n            small += 1\n        else:\n            temp [ i ] = arr [ large ]\n            large -= 1\n        flag = bool ( 1 - flag )\n        idx_9r2b = idx_9r2b + 1\n    idx_b06h = 0\n    list_197i = range ( n )\n    while idx_b06h < len(list_197i):\n        i = list_197i[idx_b06h]\n        arr [ i ] = temp [ i ]\n        idx_b06h = idx_b06h + 1\n    return arr", "id": "AssignUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_49", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n; max_idx = max_idx - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ]; max_elem = max_elem + 1\n    idx_17u0 = 0\n    list_o7p8 = range ( 0 , n )\n    while idx_17u0 < len(list_o7p8):\n        i = list_o7p8[idx_17u0]\n        if not i % 2 == 0:\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n        else:\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        idx_17u0 = idx_17u0 + 1\n    idx_v5pf = 0\n    list_3v05 = range ( 0 , n )\n    while idx_v5pf < len(list_3v05):\n        i = list_3v05[idx_v5pf]\n        arr [ i ] = int ( arr [ i ] / max_elem )\n        idx_v5pf = idx_v5pf + 1", "id": "AssignUnfoldding_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_50", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def replace ( s , c1 , c2 ) :\n    l = len ( s )\n    idx_v5o4 = 0\n    list_81bh = range ( l )\n    while idx_v5o4 < len(list_81bh):\n        i = list_81bh[idx_v5o4]\n        if not ( s [ i ] == c1 ):\n            if ( s [ i ] == c2 ) :\n                s = s [ 0 : i ] + c1; s = s + s [ i + 1 : ]\n        else:\n            s = s [ 0 : i ] + c2; s = s + s [ i + 1 : ]\n        idx_v5o4 = idx_v5o4 + 1\n    return s", "id": "AssignUnfoldding_sample_from_REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S_to_51", "old_id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S"}
{"code": "def getTotalNumberOfSequences ( m , n ) :\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ]\n    idx_hp05 = 0\n    list_0vh8 = range ( m + 1 )\n    while idx_hp05 < len(list_0vh8):\n        i = list_0vh8[idx_hp05]\n        idx_lmn6 = 0\n        list_6u8y = range ( n + 1 )\n        while idx_lmn6 < len(list_6u8y):\n            j = list_6u8y[idx_lmn6]\n            if not i == 0 or j == 0:\n                if i < j :\n                    T [ i ] [ j ] = 0\n                elif j == 1 :\n                    T [ i ] [ j ] = i\n                else :\n                    T [ i ] [ j ] = T [ i - 1 ] [ j ]; T [ i ] [ j ] = T [ i ] [ j ] + T [ i // 2 ] [ j - 1 ]\n            else:\n                T [ i ] [ j ] = 0\n            idx_lmn6 = idx_lmn6 + 1\n        idx_hp05 = idx_hp05 + 1\n    return T [ m ] [ n ]", "id": "AssignUnfoldding_sample_from_SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1_to_52", "old_id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    idx_0qzt = 0\n    list_zxma = range ( n )\n    while idx_0qzt < len(list_zxma):\n        i = list_zxma[idx_0qzt]\n        arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ]; arr [ i ] = arr [ i ] + C\n        idx_0qzt = idx_0qzt + 1\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    idx_8gvn = 0\n    list_qh9b = range ( n )\n    while idx_8gvn < len(list_qh9b):\n        i = list_qh9b[idx_8gvn]\n        if maximum < arr [ i ] :\n            index = i\n            maximum = arr [ i ]\n        idx_8gvn = idx_8gvn + 1\n    i = 0\n    j = n; j = j - 1\n    new_arr = [ 0 ]; new_arr = new_arr * n\n    k = 0\n    while i < index and j > index :\n        if not arr [ i ] < arr [ j ]:\n            new_arr [ k ] = arr [ j ]\n            k += 1\n            j -= 1\n        else:\n            new_arr [ k ] = arr [ i ]\n            k += 1\n            i += 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k += 1\n        i += 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k += 1\n        j -= 1\n        new_arr [ n - 1 ] = maximum\n    idx_trnc = 0\n    list_nmue = range ( n )\n    while idx_trnc < len(list_nmue):\n        i = list_nmue[idx_trnc]\n        arr [ i ] = new_arr [ i ]\n        idx_trnc = idx_trnc + 1", "id": "AssignUnfoldding_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_53", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    idx_2niu = 0\n    list_8jew = range ( 0 , n + 1 )\n    while idx_2niu < len(list_8jew):\n        i = list_8jew[idx_2niu]\n        idx_5jwm = 0\n        list_dext = range ( 0 , min ( i , n ) + 1 )\n        while idx_5jwm < len(list_dext):\n            j = list_dext[idx_5jwm]\n            if not ( j == 0 or j == i ):\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            else:\n                C [ i ] [ j ] = 1\n            idx_5jwm = idx_5jwm + 1\n        idx_2niu = idx_2niu + 1\n    sum = 0\n    idx_km4j = 0\n    list_4tsb = range ( 0 , n + 1 )\n    while idx_km4j < len(list_4tsb):\n        i = list_4tsb[idx_km4j]\n        sum += C [ n ] [ i ]\n        idx_km4j = idx_km4j + 1\n    return sum", "id": "AssignUnfoldding_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_54", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def sumofsquare ( n ) :\n    C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_1jvz = 0\n    list_mhk5 = range ( 0 , n + 1 )\n    while idx_1jvz < len(list_mhk5):\n        i = list_mhk5[idx_1jvz]\n        idx_7vr3 = 0\n        list_m4fg = range ( 0 , min ( i , n ) + 1 )\n        while idx_7vr3 < len(list_m4fg):\n            j = list_m4fg[idx_7vr3]\n            if not ( j == 0 or j == i ):\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ]; C [ i ] [ j ] = C [ i ] [ j ] + C [ i - 1 ] [ j ]\n            else:\n                C [ i ] [ j ] = 1\n            idx_7vr3 = idx_7vr3 + 1\n        idx_1jvz = idx_1jvz + 1\n    sum = 0\n    idx_tzjp = 0\n    list_gj0e = range ( 0 , n + 1 )\n    while idx_tzjp < len(list_gj0e):\n        i = list_gj0e[idx_tzjp]\n        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )\n        idx_tzjp = idx_tzjp + 1\n    return sum", "id": "AssignUnfoldding_sample_from_SUM_SQUARES_BINOMIAL_COEFFICIENTS_to_55", "old_id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    idx_v6pi = 0\n    list_eiop = range(n1)\n    while idx_v6pi < len(list_eiop):\n        i = list_eiop[idx_v6pi]\n        sum = (ord(str1[i]) - 48); sum = sum + ((ord(str2[i]) - 48) + carry)\n        if not sum < 0:\n            str += chr(sum % 10 + 48)\n        else:\n            str += chr(sum % -10 + 48)\n        carry = int(sum / 10)\n        idx_v6pi = idx_v6pi + 1\n    idx_xc9d = 0\n    list_6m93 = range(n1, n2)\n    while idx_xc9d < len(list_6m93):\n        i = list_6m93[idx_xc9d]\n        sum = (ord(str2[i]) - 48); sum = sum + carry\n        if not sum < 0:\n            str += chr(sum % 10 + 48)\n        else:\n            str += chr(sum % -10 + 48)\n        carry = (int)(sum / 10)\n        idx_xc9d = idx_xc9d + 1\n    if (carry):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "AssignUnfoldding_sample_from_SUM_TWO_LARGE_NUMBERS_to_56", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def countTransformation ( a , b ) :\n    n = len ( a )\n    m = len ( b )\n    if m == 0 :\n        return 1\n    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]\n    idx_3vi1 = 0\n    list_61bi = range ( m )\n    while idx_3vi1 < len(list_61bi):\n        i = list_61bi[idx_3vi1]\n        idx_e1og = 0\n        list_yd4b = range ( i , n )\n        while idx_e1og < len(list_yd4b):\n            j = list_yd4b[idx_e1og]\n            if not i == 0:\n                if a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n            else:\n                if j == 0 :\n                    if a [ j ] == b [ i ] :\n                        dp [ i ] [ j ] = 1\n                    else :\n                        dp [ i ] [ j ] = 0\n                elif a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]; dp [ i ] [ j ] = dp [ i ] [ j ] + 1\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n            idx_e1og = idx_e1og + 1\n        idx_3vi1 = idx_3vi1 + 1\n    return dp [ m - 1 ] [ n - 1 ]", "id": "AssignUnfoldding_sample_from_WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS_to_57", "old_id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS"}
