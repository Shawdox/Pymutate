{"code": "def encrypt ( text , s ) :\n    result = (\"\" + \"\")\n    idx_i9gq = 0\n    list_elnd = range ( len ( text ) )\n    while idx_i9gq < len(list_elnd):\n        i = list_elnd[idx_i9gq]\n        char = text [ i ]\n        if not ( char.isupper ( ) ):\n            result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n        else:\n            result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        idx_i9gq = idx_i9gq + 1\n    return result", "id": "StringUnfoldding_sample_from_CAESAR_CIPHER_to_0", "old_id": "CAESAR_CIPHER"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    idx_8orb = 0\n    list_pi35 = range ( 1 , len ( str ) )\n    while idx_8orb < len(list_pi35):\n        i = list_pi35[idx_8orb]\n        if not ( str [ i ] == ('' + '0') or str [ i ] == ('1' + '') or res < 2 ):\n            res += ord ( str [ i ] ) - 48\n        else:\n            res += ord ( str [ i ] ) - 48\n        idx_8orb = idx_8orb + 1\n    return res", "id": "StringUnfoldding_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_1", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = (\"\" + \"0\")\n    Sum = 0\n    idx_xviq = 0\n    list_rxs8 = str\n    while idx_xviq < len(list_rxs8):\n        ch = list_rxs8[idx_xviq]\n        if not ( ch.isdigit ( ) ):\n            Sum += int ( temp )\n            temp = (\"\" + \"0\")\n        else:\n            temp += ch\n        idx_xviq = idx_xviq + 1\n    return Sum + int ( temp )", "id": "StringUnfoldding_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_2", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def canMakeAllSame ( str ) :\n    zeros = 0\n    ones = 0\n    idx_c1ga = 0\n    list_lfx3 = range ( 0 , len ( str ) )\n    while idx_c1ga < len(list_lfx3):\n        i = list_lfx3[idx_c1ga]\n        ch = str [ i ]\n        if not ( ch == ('0' + '') ):\n            ones = ones + 1\n        else:\n            zeros = zeros + 1\n        idx_c1ga = idx_c1ga + 1\n    return ( zeros == 1 or ones == 1 )", "id": "StringUnfoldding_sample_from_CHANGE_BITS_CAN_MADE_ONE_FLIP_to_3", "old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == ('0' + '') ) :\n        return True\n    if not ( length % 3 == 1 ):\n        if ( length % 3 == 2 ) :\n            num = str ( num ) + (\"\" + \"0\")\n            length += 1\n    else:\n        num = str ( num ) + (\"0\" + \"0\")\n        length += 2\n    sum = 0\n    p = 1\n    idx_40kv = 0\n    list_pr6o = range ( length - 1 , - 1 , - 3 )\n    while idx_40kv < len(list_pr6o):\n        i = list_pr6o[idx_40kv]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( ('0' + '') )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('0' + '') ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('0' + '') ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n        idx_40kv = idx_40kv + 1\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "StringUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_4", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if not ( n % 3 == 1 ):\n        if ( n % 3 == 2 ) :\n            num = str ( num ) + (\"\" + \"0\")\n            n += 1\n    else:\n        num = str ( num ) + (\"\" + \"00\")\n        n += 2\n    GSum = 0\n    p = 1\n    idx_70ma = 0\n    list_1l3g = range ( n - 1 , - 1 , - 1 )\n    while idx_70ma < len(list_1l3g):\n        i = list_1l3g[idx_70ma]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( ('' + '0') )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('0' + '') ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('' + '0') ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n        idx_70ma = idx_70ma + 1\n    return ( GSum % 7 == 0 )", "id": "StringUnfoldding_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_5", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    idx_kohb = 0\n    list_kodw = range ( n )\n    while idx_kohb < len(list_kodw):\n        i = list_kodw[idx_kohb]\n        if not ( str [ i ] == ('' + 'a') ):\n            if ( str [ i ] == ('' + 'b') ) :\n                b_index = i + 1\n                ans -= min ( a_index , c_index )\n            else :\n                c_index = i + 1\n                ans -= min ( a_index , b_index )\n        else:\n            a_index = i + 1\n            ans -= min ( b_index , c_index )\n        idx_kohb = idx_kohb + 1\n    return ans", "id": "StringUnfoldding_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_6", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    idx_v06q = 0\n    list_rpax = range ( len ( s ) )\n    while idx_v06q < len(list_rpax):\n        i = list_rpax[idx_v06q]\n        if not s [ ~ i ] == ('a' + ''):\n            b_count += 1\n        else:\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n        idx_v06q = idx_v06q + 1\n    return res", "id": "StringUnfoldding_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_7", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = (\"\" + \"\")\n    result = (\"\" + \"\")\n    idx_8js5 = 0\n    list_vj9q = range ( len ( Str ) )\n    while idx_8js5 < len(list_vj9q):\n        i = list_vj9q[idx_8js5]\n        count = 0\n        if not ( Str [ i ] >= ('0' + '') and Str [ i ] <= ('' + '9') ):\n            if ( Str [ i ] == (']' + '') ) :\n                temp = (\"\" + \"\")\n                count = 0\n                if ( len ( integerstack ) != 0 ) :\n                    count = integerstack [ - 1 ]\n                    integerstack.pop ( )\n                while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ('' + '[') ) :\n                    temp = stringstack [ - 1 ] + temp\n                    stringstack.pop ( )\n                if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == ('[' + '') ) :\n                    stringstack.pop ( )\n                idx_f1pv = 0\n                list_ve17 = range ( count )\n                while idx_f1pv < len(list_ve17):\n                    j = list_ve17[idx_f1pv]\n                    result = result + temp\n                    idx_f1pv = idx_f1pv + 1\n                idx_sdeq = 0\n                list_doyq = range ( len ( result ) )\n                while idx_sdeq < len(list_doyq):\n                    j = list_doyq[idx_sdeq]\n                    stringstack.append ( result [ j ] )\n                    idx_sdeq = idx_sdeq + 1\n                result = (\"\" + \"\")\n            elif ( Str [ i ] == ('[' + '') ) :\n                if ( Str [ i - 1 ] >= ('0' + '') and Str [ i - 1 ] <= ('9' + '') ) :\n                    stringstack.append ( Str [ i ] )\n                else :\n                    stringstack.append ( Str [ i ] )\n                    integerstack.append ( 1 )\n            else :\n                stringstack.append ( Str [ i ] )\n        else:\n            while ( Str [ i ] >= ('' + '0') and Str [ i ] <= ('9' + '') ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( ('' + '0') )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n        idx_8js5 = idx_8js5 + 1\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "StringUnfoldding_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_8", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    idx_xub1 = 0\n    list_wj34 = range ( n )\n    while idx_xub1 < len(list_wj34):\n        i = list_wj34[idx_xub1]\n        if not symb [ i ] == ('' + 'F'):\n            F [ i ] [ i ] = 0\n        else:\n            F [ i ] [ i ] = 1\n        if not symb [ i ] == ('T' + ''):\n            T [ i ] [ i ] = 0\n        else:\n            T [ i ] [ i ] = 1\n        idx_xub1 = idx_xub1 + 1\n    idx_9hfe = 0\n    list_ubc7 = range ( 1 , n )\n    while idx_9hfe < len(list_ubc7):\n        gap = list_ubc7[idx_9hfe]\n        i = 0\n        idx_xvjn = 0\n        list_58gm = range ( gap , n )\n        while idx_xvjn < len(list_58gm):\n            j = list_58gm[idx_xvjn]\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            idx_6c5q = 0\n            list_7y9z = range ( gap )\n            while idx_6c5q < len(list_7y9z):\n                g = list_7y9z[idx_6c5q]\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == ('' + '&') :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == ('|' + '') :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == ('^' + '') :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                idx_6c5q = idx_6c5q + 1\n            i += 1\n            idx_xvjn = idx_xvjn + 1\n        idx_9hfe = idx_9hfe + 1\n    return T [ 0 ] [ n - 1 ]", "id": "StringUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_9", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    idx_gzbc = 0\n    list_2g86 = string\n    while idx_gzbc < len(list_2g86):\n        ch = list_2g86[idx_gzbc]\n        if not ch == ('' + ')'):\n            Stack.append ( ch )\n        else:\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != ('' + '(') :\n                elementsInside += 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n        idx_gzbc = idx_gzbc + 1\n    return False", "id": "StringUnfoldding_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_10", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize - 1\n    idx_n7o8 = 0\n    list_r7yd = range ( r )\n    while idx_n7o8 < len(list_r7yd):\n        i = list_r7yd[idx_n7o8]\n        if m [ i ] [ 0 ] < mi :\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx :\n            mx = m [ i ] [ c - 1 ]\n        idx_n7o8 = idx_n7o8 + 1\n    desired = ( r * c + 1 ) // 2\n    while ( mi < mx ) :\n        mid = mi + ( mx - mi ) // 2\n        place = [ 0 ]\n        idx_9c3f = 0\n        list_bpdo = range ( r )\n        while idx_9c3f < len(list_bpdo):\n            i = list_bpdo[idx_9c3f]\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ] + j\n            idx_9c3f = idx_9c3f + 1\n        if not place [ 0 ] < desired:\n            mx = mid\n        else:\n            mi = mid + 1\n    print ( (\"\" + \"Median is\") , mi )\n    return mi", "id": "StringUnfoldding_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_11", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def pairSum ( mat , n , sum ) :\n    idx_b6ts = 0\n    list_krue = range ( n )\n    while idx_b6ts < len(list_krue):\n        i = list_krue[idx_b6ts]\n        mat [ i ].sort ( )\n        idx_b6ts = idx_b6ts + 1\n    idx_nwek = 0\n    list_ytkg = range ( n - 1 )\n    while idx_nwek < len(list_ytkg):\n        i = list_ytkg[idx_nwek]\n        idx_st5x = 0\n        list_odmb = range ( i + 1 , n )\n        while idx_st5x < len(list_odmb):\n            j = list_odmb[idx_st5x]\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if not ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ):\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1\n                else:\n                    print ( (\"\" + \"(\") , mat [ i ] [ left ] , (\"\" + \", \") , mat [ j ] [ right ] , (\")\" + \", \") , end = (\"\" + \" \") )\n                    left += 1\n                    right -= 1\n            idx_st5x = idx_st5x + 1\n        idx_nwek = idx_nwek + 1", "id": "StringUnfoldding_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_12", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    idx_bd17 = 0\n    list_nuvp = range ( n - 1 )\n    while idx_bd17 < len(list_nuvp):\n        i = list_nuvp[idx_bd17]\n        s = set ( )\n        idx_pfyq = 0\n        list_42bp = range ( i + 1 , n )\n        while idx_pfyq < len(list_42bp):\n            j = list_42bp[idx_pfyq]\n            x = - ( arr [ i ] + arr [ j ] )\n            if not x in s:\n                s.add ( arr [ j ] )\n            else:\n                print ( x , arr [ i ] , arr [ j ] )\n                found = True\n            idx_pfyq = idx_pfyq + 1\n        idx_bd17 = idx_bd17 + 1\n    if found == False :\n        print ( (\"No \" + \"Triplet Found\") )", "id": "StringUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1_to_13", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    idx_uzes = 0\n    list_k6ua = range ( 0 , n - 1 )\n    while idx_uzes < len(list_k6ua):\n        i = list_k6ua[idx_uzes]\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if not ( x + arr [ l ] + arr [ r ] == 0 ):\n                if ( x + arr [ l ] + arr [ r ] < 0 ) :\n                    l += 1\n                else :\n                    r -= 1\n            else:\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n        idx_uzes = idx_uzes + 1\n    if ( found == False ) :\n        print ( (\" No T\" + \"riplet Found\") )", "id": "StringUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_14", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    idx_9k7w = 0\n    list_ylh9 = range ( 0 , n - 1 )\n    while idx_9k7w < len(list_ylh9):\n        i = list_ylh9[idx_9k7w]\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        idx_m19j = 0\n        list_a3iq = range ( i + 1 , n )\n        while idx_m19j < len(list_a3iq):\n            j = list_a3iq[idx_m19j]\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) :\n                maxsize = j - i + 1\n                startindex = i\n            idx_m19j = idx_m19j + 1\n        idx_9k7w = idx_9k7w + 1\n    if not ( maxsize == - 1 ):\n        print ( startindex , (\"\" + \"to\") , startindex + maxsize - 1 )\n    else:\n        print ( (\"No such suba\" + \"rray\") )\n    return maxsize", "id": "StringUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_15", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    idx_orqn = 0\n    list_dw1l = range ( 0 , n )\n    while idx_orqn < len(list_dw1l):\n        i = list_dw1l[idx_orqn]\n        if not ( arr [ i ] == 0 ):\n            arr [ i ] = 1\n        else:\n            arr [ i ] = - 1\n        idx_orqn = idx_orqn + 1\n    idx_7o6m = 0\n    list_gx2p = range ( 0 , n )\n    while idx_7o6m < len(list_gx2p):\n        i = list_gx2p[idx_7o6m]\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) :\n            max_len = i + 1\n            ending_index = i\n        if not ( curr_sum + n ) in hash_map:\n            hash_map[curr_sum + n] = i\n        else:\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i - hash_map [ curr_sum + n ]\n                ending_index = i\n        idx_7o6m = idx_7o6m + 1\n    idx_f8zq = 0\n    list_jwgz = range ( 0 , n )\n    while idx_f8zq < len(list_jwgz):\n        i = list_jwgz[idx_f8zq]\n        if not ( arr [ i ] == - 1 ):\n            arr [ i ] = 1\n        else:\n            arr [ i ] = 0\n        idx_f8zq = idx_f8zq + 1\n    print ( ending_index - max_len + 1 , end = (\"\" + \" \") )\n    print ( (\"to\" + \"\") , end = (\"\" + \" \") )\n    print ( ending_index )\n    return max_len", "id": "StringUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_16", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    idx_izyo = 0\n    list_ukhd = range ( n )\n    while idx_izyo < len(list_ukhd):\n        i = list_ukhd[idx_izyo]\n        if not ( s [ i ] == ('(' + '') ):\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces += 1\n            else :\n                invalidOpenBraces -= 1\n        else:\n            invalidOpenBraces += 1\n        idx_izyo = idx_izyo + 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "StringUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_17", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_ngrs = 0\n    list_z7cb = range ( 1 , n + 1 )\n    while idx_ngrs < len(list_z7cb):\n        i = list_z7cb[idx_ngrs]\n        idx_pk30 = 0\n        list_aq7x = range ( 1 , n + 1 )\n        while idx_pk30 < len(list_aq7x):\n            j = list_aq7x[idx_pk30]\n            if not ( str [ i - 1 ] == str [ j - 1 ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            else:\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            idx_pk30 = idx_pk30 + 1\n        idx_ngrs = idx_ngrs + 1\n    res = ('' + '')\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if not ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ):\n            if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n                i -= 1\n            else :\n                j -= 1\n        else:\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n    res = ('' + '').join ( reversed ( res ) )\n    return res", "id": "StringUnfoldding_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_18", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    idx_7z9w = 0\n    list_gcyx = range ( n - 2 , - 1 , - 1 )\n    while idx_7z9w < len(list_gcyx):\n        i = list_gcyx[idx_7z9w]\n        if not ( arr [ i ] == 0 ):\n            if ( arr [ i ] >= n - i - 1 ) :\n                jumps [ i ] = 1\n            else :\n                min = float ( ('inf' + '') )\n                idx_85at = 0\n                list_grp9 = range ( i + 1 , n )\n                while idx_85at < len(list_grp9):\n                    j = list_grp9[idx_85at]\n                    if ( j <= arr [ i ] + i ) :\n                        if ( min > jumps [ j ] ) :\n                            min = jumps [ j ]\n                    idx_85at = idx_85at + 1\n                if ( min != float ( ('' + 'inf') ) ) :\n                    jumps [ i ] = min + 1\n                else :\n                    jumps [ i ] = min\n        else:\n            jumps [ i ] = float ( ('' + 'inf') )\n        idx_7z9w = idx_7z9w + 1\n    return jumps [ 0 ]", "id": "StringUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_19", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def checkPangram ( s ) :\n    List = [ ]\n    idx_mipo = 0\n    list_1g7b = range ( 26 )\n    while idx_mipo < len(list_1g7b):\n        i = list_1g7b[idx_mipo]\n        List.append ( False )\n        idx_mipo = idx_mipo + 1\n    idx_bw60 = 0\n    list_ay0z = s\n    while idx_bw60 < len(list_ay0z):\n        c = list_ay0z[idx_bw60]\n        if not ('' + 'A') <= c and c <= ('Z' + ''):\n            if ('' + 'a') <= c and c <= ('z' + ''):\n                List [ ord ( c ) - ord ( ('a' + '') ) ] = True\n        else:\n            List [ ord ( c ) - ord ( ('A' + '') ) ] = True\n        idx_bw60 = idx_bw60 + 1\n    idx_pyo2 = 0\n    list_3aru = List\n    while idx_pyo2 < len(list_3aru):\n        ch = list_3aru[idx_pyo2]\n        if ch == False :\n            return False\n        idx_pyo2 = idx_pyo2 + 1\n    return True", "id": "StringUnfoldding_sample_from_PANGRAM_CHECKING_to_20", "old_id": "PANGRAM_CHECKING"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_r1gt = 0\n    list_f20d = range ( n )\n    while idx_r1gt < len(list_f20d):\n        i = list_f20d[idx_r1gt]\n        bestIdx = - 1\n        idx_gk96 = 0\n        list_v350 = range ( m )\n        while idx_gk96 < len(list_v350):\n            j = list_v350[idx_gk96]\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n            idx_gk96 = idx_gk96 + 1\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n        idx_r1gt = idx_r1gt + 1\n    print ( (\"Process No.Process Size\" + \"     Block no.\") )\n    idx_av6y = 0\n    list_j31d = range ( n )\n    while idx_av6y < len(list_j31d):\n        i = list_j31d[idx_av6y]\n        print ( i + 1 , (\"\" + \"         \") , processSize [ i ] , end = (\" \" + \"        \") )\n        if not allocation [ i ] != - 1:\n            print ( (\"Not Allocat\" + \"ed\") )\n        else:\n            print ( allocation [ i ] + 1 )\n        idx_av6y = idx_av6y + 1", "id": "StringUnfoldding_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_21", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 :\n        return False\n    _sum = 0\n    idx_25od = 0\n    list_gqw2 = range ( 9 )\n    while idx_25od < len(list_gqw2):\n        i = list_gqw2[idx_25od]\n        if not 0 <= int ( isbn [ i ] ) <= 9:\n            return False\n        else:\n            _sum += int ( isbn [ i ] ) * ( 10 - i )\n        idx_25od = idx_25od + 1\n    if ( isbn [ 9 ] != ('' + 'X') and 0 <= int ( isbn [ 9 ] ) <= 9 ) :\n        return False\n    _sum += 10 if isbn [ 9 ] == ('' + 'X') else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )", "id": "StringUnfoldding_sample_from_PROGRAM_CHECK_ISBN_to_22", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_c9hn = 0\n    list_pl5m = range ( n )\n    while idx_c9hn < len(list_pl5m):\n        i = list_pl5m[idx_c9hn]\n        wstIdx = - 1\n        idx_1kw0 = 0\n        list_wd92 = range ( m )\n        while idx_1kw0 < len(list_wd92):\n            j = list_wd92[idx_1kw0]\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n            idx_1kw0 = idx_1kw0 + 1\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n        idx_c9hn = idx_c9hn + 1\n    print ( (\"Pr\" + \"ocess No.Process Size Block no.\") )\n    idx_ptju = 0\n    list_fys8 = range ( n )\n    while idx_ptju < len(list_fys8):\n        i = list_fys8[idx_ptju]\n        print ( i + 1 , (\"         \" + \"\") , processSize [ i ] , end = (\"   \" + \"  \") )\n        if not allocation [ i ] != - 1:\n            print ( (\"\" + \"Not Allocated\") )\n        else:\n            print ( allocation [ i ] + 1 )\n        idx_ptju = idx_ptju + 1", "id": "StringUnfoldding_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_23", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def firstLetterWord ( str ) :\n    result = (\"\" + \"\")\n    v = True\n    idx_62sy = 0\n    list_9ed6 = range ( len ( str ) )\n    while idx_62sy < len(list_9ed6):\n        i = list_9ed6[idx_62sy]\n        if not ( str [ i ] == (' ' + '') ):\n            if ( str [ i ] != ('' + ' ') and v == True ) :\n                result += ( str [ i ] )\n                v = False\n        else:\n            v = True\n        idx_62sy = idx_62sy + 1\n    return result", "id": "StringUnfoldding_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_24", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    idx_btoc = 0\n    list_rdyv = range ( n )\n    while idx_btoc < len(list_rdyv):\n        i = list_rdyv[idx_btoc]\n        if not ( tree [ i ] == ('(' + '') ):\n            if ( tree [ i ] == (')' + '') ) :\n                level -= 1\n            else :\n                if ( level == k ) :\n                    sum += ( ord ( tree [ i ] ) - ord ( ('' + '0') ) )\n        else:\n            level += 1\n        idx_btoc = idx_btoc + 1\n    return sum", "id": "StringUnfoldding_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_25", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = (\"\" + \"\")\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    idx_epu7 = 0\n    list_720m = range(n1)\n    while idx_epu7 < len(list_720m):\n        i = list_720m[idx_epu7]\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if not sum < 0:\n            str += chr(sum % 10 + 48)\n        else:\n            str += chr(sum % -10 + 48)\n        carry = int(sum / 10)\n        idx_epu7 = idx_epu7 + 1\n    idx_vo93 = 0\n    list_plsm = range(n1, n2)\n    while idx_vo93 < len(list_plsm):\n        i = list_plsm[idx_vo93]\n        sum = ((ord(str2[i]) - 48) + carry)\n        if not sum < 0:\n            str += chr(sum % 10 + 48)\n        else:\n            str += chr(sum % -10 + 48)\n        carry = (int)(sum / 10)\n        idx_vo93 = idx_vo93 + 1\n    if (carry):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "StringUnfoldding_sample_from_SUM_TWO_LARGE_NUMBERS_to_26", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( (\"\" + \" Invalid Input \") )\n        return\n    first = arr [ 0 ]\n    second = - sys.maxsize\n    third = - sys.maxsize\n    idx_nlf1 = 0\n    list_d94j = range ( 1 , arr_size )\n    while idx_nlf1 < len(list_d94j):\n        i = list_d94j[idx_nlf1]\n        if not ( arr [ i ] > first ):\n            if ( arr [ i ] > second ) :\n                third = second\n                second = arr [ i ]\n            elif ( arr [ i ] > third ) :\n                third = arr [ i ]\n        else:\n            third = second\n            second = first\n            first = arr [ i ]\n        idx_nlf1 = idx_nlf1 + 1\n    print ( (\"The third La\" + \"rgest\") , (\"el\" + \"ement is\") , third )", "id": "StringUnfoldding_sample_from_THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1_to_27", "old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1"}
{"code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    idx_jo80 = 0\n    list_d9l5 = range ( 0 , n , 1 )\n    while idx_jo80 < len(list_d9l5):\n        i = list_d9l5[idx_jo80]\n        if not ( str [ i ] == ('' + '1') ):\n            zero_count += 1\n        else:\n            one_count += 1\n        idx_jo80 = idx_jo80 + 1\n    if ( one_count % 2 == 0 ) :\n        return zero_count\n    return one_count", "id": "StringUnfoldding_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_28", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
