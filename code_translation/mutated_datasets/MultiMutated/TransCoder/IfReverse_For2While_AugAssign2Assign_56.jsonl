{"code": "def winner ( a , n , k ) :\n    if k >= n - 1 :\n        return n\n    best = 0\n    times = 0\n    idx_xdil = 0\n    list_pei2 = range ( n )\n    while idx_xdil < len(list_pei2):\n        i = list_pei2[idx_xdil]\n        if not a [ i ] > best:\n            times = times + 1\n        else:\n            best = a [ i ]\n            if i == True :\n                times = 1\n        if times >= k :\n            return best\n        idx_xdil = idx_xdil + 1\n    return best", "id": "AugAssign2Assign_sample_from_ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES_to_0", "old_id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES"}
{"code": "def solveQuery ( start , end , arr ) :\n    frequency = dict ( )\n    idx_yz9l = 0\n    list_z8n1 = range ( start , end + 1 )\n    while idx_yz9l < len(list_z8n1):\n        i = list_z8n1[idx_yz9l]\n        if not arr [ i ] in frequency.keys ( ):\n            frequency [ arr [ i ] ] = 1\n        else:\n            frequency [ arr [ i ] ] = frequency [ arr [ i ] ] + 1\n        idx_yz9l = idx_yz9l + 1\n    count = 0\n    idx_jo96 = 0\n    list_ny2v = frequency\n    while idx_jo96 < len(list_ny2v):\n        x = list_ny2v[idx_jo96]\n        if x == frequency [ x ] :\n            count = count + 1\n        idx_jo96 = idx_jo96 + 1\n    return count", "id": "AugAssign2Assign_sample_from_ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE_to_1", "old_id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE"}
{"code": "def encrypt ( text , s ) :\n    result = \"\"\n    idx_gmy1 = 0\n    list_u1ka = range ( len ( text ) )\n    while idx_gmy1 < len(list_u1ka):\n        i = list_u1ka[idx_gmy1]\n        char = text [ i ]\n        if not ( char.isupper ( ) ):\n            result = result + chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n        else:\n            result = result + chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        idx_gmy1 = idx_gmy1 + 1\n    return result", "id": "AugAssign2Assign_sample_from_CAESAR_CIPHER_to_2", "old_id": "CAESAR_CIPHER"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    idx_06h1 = 0\n    list_andm = range ( 1 , len ( str ) )\n    while idx_06h1 < len(list_andm):\n        i = list_andm[idx_06h1]\n        if not ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ):\n            res = res + ord ( str [ i ] ) - 48\n        else:\n            res = res + ord ( str [ i ] ) - 48\n        idx_06h1 = idx_06h1 + 1\n    return res", "id": "AugAssign2Assign_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_3", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = \"0\"\n    Sum = 0\n    idx_7wt4 = 0\n    list_gmuw = str\n    while idx_7wt4 < len(list_gmuw):\n        ch = list_gmuw[idx_7wt4]\n        if not ( ch.isdigit ( ) ):\n            Sum = Sum + int ( temp )\n            temp = \"0\"\n        else:\n            temp = temp + ch\n        idx_7wt4 = idx_7wt4 + 1\n    return Sum + int ( temp )", "id": "AugAssign2Assign_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_4", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def isMajority ( a, n ) :\n    mp = { }\n    idx_i0ub = 0\n    list_crhy = range(n)\n    while idx_i0ub < len(list_crhy):\n        i = list_crhy[idx_i0ub]\n        if not a[i] in mp: mp [ a[i] ] = 1\n        else: mp [ a[i] ] = mp [ a[i] ] + 1\n        idx_i0ub = idx_i0ub + 1\n    idx_lxkw = 0\n    list_4j8i = mp\n    while idx_lxkw < len(list_4j8i):\n        x = list_4j8i[idx_lxkw]\n        if mp [ x ] >= len ( a ) // 2 :\n            return True\n        idx_lxkw = idx_lxkw + 1\n    return False", "id": "AugAssign2Assign_sample_from_CHECK_ARRAY_MAJORITY_ELEMENT_to_5", "old_id": "CHECK_ARRAY_MAJORITY_ELEMENT"}
{"code": "def flipsPossible ( a , n ) :\n    count_odd = 0\n    count_even = 0\n    idx_wgc2 = 0\n    list_l936 = range ( n )\n    while idx_wgc2 < len(list_l936):\n        i = list_l936[idx_wgc2]\n        if not ( a [ i ] & 1 ):\n            count_even = count_even + 1\n        else:\n            count_odd = count_odd + 1\n        idx_wgc2 = idx_wgc2 + 1\n    if not ( count_odd % 2 and count_even % 2 ):\n        return True\n    else:\n        return False", "id": "AugAssign2Assign_sample_from_CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS_to_6", "old_id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS"}
{"code": "def isChangeable ( notes , n ) :\n    fiveCount = 0\n    tenCount = 0\n    idx_qpf7 = 0\n    list_tzm7 = range ( n )\n    while idx_qpf7 < len(list_tzm7):\n        i = list_tzm7[idx_qpf7]\n        if not ( notes [ i ] == 5 ):\n            if ( notes [ i ] == 10 ) :\n                if ( fiveCount > 0 ) :\n                    fiveCount = fiveCount - 1\n                    tenCount = tenCount + 1\n                else :\n                    return 0\n            else :\n                if ( fiveCount > 0 and tenCount > 0 ) :\n                    fiveCount = fiveCount - 1\n                    tenCount = tenCount - 1\n                elif ( fiveCount >= 3 ) :\n                    fiveCount = fiveCount - 3\n                else :\n                    return 0\n        else:\n            fiveCount = fiveCount + 1\n        idx_qpf7 = idx_qpf7 + 1\n    return 1", "id": "AugAssign2Assign_sample_from_CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE_to_7", "old_id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if not ( length % 3 == 1 ):\n        if ( length % 3 == 2 ) :\n            num = str ( num ) + \"0\"\n            length = length + 1\n    else:\n        num = str ( num ) + \"00\"\n        length = length + 2\n    sum = 0\n    p = 1\n    idx_5uro = 0\n    list_corh = range ( length - 1 , - 1 , - 3 )\n    while idx_5uro < len(list_corh):\n        i = list_corh[idx_5uro]\n        group = 0\n        group = group + ord ( num [ i ] ) - ord ( '0' )\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p = p * ( - 1 )\n        idx_5uro = idx_5uro + 1\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "AugAssign2Assign_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_8", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def checkReverse ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    idx_e6b3 = 0\n    list_0j84 = range ( 1 , n )\n    while idx_e6b3 < len(list_0j84):\n        i = list_0j84[idx_e6b3]\n        if not arr [ i - 1 ] >= arr [ i ]:\n            if ( i == n ) :\n                return True\n        else:\n            break\n        idx_e6b3 = idx_e6b3 + 1\n    j = i\n    i = i + 1\n    while ( arr [ j ] < arr [ j - 1 ] ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j = j + 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k = k + 1\n    return True", "id": "AugAssign2Assign_sample_from_CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1_to_9", "old_id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1"}
{"code": "def check ( degree , n ) :\n    deg_sum = 0\n    idx_452c = 0\n    list_9175 = range(n)\n    while idx_452c < len(list_9175):\n        i = list_9175[idx_452c]\n        deg_sum = deg_sum + degree[i]\n        idx_452c = idx_452c + 1\n    if not ( 2 * ( n - 1 ) == deg_sum ):\n        return False\n    else:\n        return True", "id": "AugAssign2Assign_sample_from_CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE_to_10", "old_id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if not ( n % 3 == 1 ):\n        if ( n % 3 == 2 ) :\n            num = str ( num ) + \"0\"\n            n = n + 1\n    else:\n        num = str ( num ) + \"00\"\n        n = n + 2\n    GSum = 0\n    p = 1\n    idx_dk7h = 0\n    list_azeb = range ( n - 1 , - 1 , - 1 )\n    while idx_dk7h < len(list_azeb):\n        i = list_azeb[idx_dk7h]\n        group = 0\n        group = group + ord ( num [ i ] ) - ord ( '0' )\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i = i - 1\n        group = group + ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p = p * ( - 1 )\n        idx_dk7h = idx_dk7h + 1\n    return ( GSum % 7 == 0 )", "id": "AugAssign2Assign_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_11", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    idx_0w9h = 0\n    list_3a5r = range ( 2 , n + 1 )\n    while idx_0w9h < len(list_3a5r):\n        i = list_3a5r[idx_0w9h]\n        idx_lr90 = 0\n        list_a84m = range ( k + 1 )\n        while idx_lr90 < len(list_a84m):\n            j = list_a84m[idx_lr90]\n            if not j >= i:\n                dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j ] [ 1 ] + dp [ i - 1 ] [ j - 1 ] [ 1 ]\n            else:\n                break\n            idx_lr90 = idx_lr90 + 1\n        idx_0w9h = idx_0w9h + 1\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]", "id": "AugAssign2Assign_sample_from_COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS_to_12", "old_id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS"}
{"code": "def countPairs ( arr , n ) :\n    mp = dict ( )\n    idx_8d91 = 0\n    list_yse4 = range ( n )\n    while idx_8d91 < len(list_yse4):\n        i = list_yse4[idx_8d91]\n        if not arr [ i ] in mp.keys ( ):\n            mp [ arr [ i ] ] = 1\n        else:\n            mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1\n        idx_8d91 = idx_8d91 + 1\n    ans = 0\n    idx_ax31 = 0\n    list_nyqm = mp\n    while idx_ax31 < len(list_nyqm):\n        it = list_nyqm[idx_ax31]\n        count = mp [ it ]\n        ans = ans + ( count * ( count - 1 ) ) // 2\n        idx_ax31 = idx_ax31 + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1_to_13", "old_id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1"}
{"code": "def countNegative ( M , n , m ) :\n    count = 0\n    idx_gxvp = 0\n    list_20ov = range ( n )\n    while idx_gxvp < len(list_20ov):\n        i = list_20ov[idx_gxvp]\n        idx_t6kb = 0\n        list_tuwk = range ( m )\n        while idx_t6kb < len(list_tuwk):\n            j = list_tuwk[idx_t6kb]\n            if not M [ i ] [ j ] < 0:\n                break\n            else:\n                count = count + 1\n            idx_t6kb = idx_t6kb + 1\n        idx_gxvp = idx_gxvp + 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_to_14", "old_id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    idx_dyji = 0\n    list_petk = range ( n )\n    while idx_dyji < len(list_petk):\n        i = list_petk[idx_dyji]\n        if not ( str [ i ] == 'a' ):\n            if ( str [ i ] == 'b' ) :\n                b_index = i + 1\n                ans = ans - min ( a_index , c_index )\n            else :\n                c_index = i + 1\n                ans = ans - min ( a_index , b_index )\n        else:\n            a_index = i + 1\n            ans = ans - min ( b_index , c_index )\n        idx_dyji = idx_dyji + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_15", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    idx_e5d9 = 0\n    list_w2sf = range ( len ( s ) )\n    while idx_e5d9 < len(list_w2sf):\n        i = list_w2sf[idx_e5d9]\n        if not s [ ~ i ] == 'a':\n            b_count = b_count + 1\n        else:\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n        idx_e5d9 = idx_e5d9 + 1\n    return res", "id": "AugAssign2Assign_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_16", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ] * ( n + 1 )\n    hash_negative = [ 0 ] * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    idx_a2zv = 0\n    list_irlw = range ( n )\n    while idx_a2zv < len(list_irlw):\n        i = list_irlw[idx_a2zv]\n        if not ( arr [ i ] & 1 == 1 ):\n            difference = difference - 1\n        else:\n            difference = difference + 1\n        if not ( difference < 0 ):\n            ans = ans + hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ] + 1\n        else:\n            ans = ans + hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n        idx_a2zv = idx_a2zv + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS_to_17", "old_id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS"}
{"code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1 << i\n        idx_rxmi = 0\n        list_renz = range ( 0 , n + 1 )\n        while idx_rxmi < len(list_renz):\n            j = list_renz[idx_rxmi]\n            ans = ans + k\n            if not change == 1:\n                change = change - 1\n            else:\n                k = not k\n                change = 1 << i\n            idx_rxmi = idx_rxmi + 1\n        i = i + 1\n    return ans", "id": "AugAssign2Assign_sample_from_COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N_to_18", "old_id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N"}
{"code": "def countWords ( str , len ) :\n    count = 1 ;\n    if ( len == 1 ) :\n        return count\n    if not ( str [ 0 ] == str [ 1 ] ):\n        count = count * 2\n    else:\n        count = count * 1\n    idx_yzmh = 0\n    list_0ecr = range ( 1 , len - 1 )\n    while idx_yzmh < len(list_0ecr):\n        j = list_0ecr[idx_yzmh]\n        if not ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ):\n            if ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :\n                count = count * 2\n            else :\n                count = count * 3\n        else:\n            count = count * 1\n        idx_yzmh = idx_yzmh + 1\n    if not ( str [ len - 1 ] == str [ len - 2 ] ):\n        count = count * 2\n    else:\n        count = count * 1\n    return count", "id": "AugAssign2Assign_sample_from_COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD_to_19", "old_id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD"}
{"code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ] * NO_OF_CHARS\n    idx_mxkj = 0\n    list_ayfs = range ( len ( str ) )\n    while idx_mxkj < len(list_ayfs):\n        i = list_ayfs[idx_mxkj]\n        count [ ord ( str [ i ] ) ] = count [ ord ( str [ i ] ) ] + 1\n        idx_mxkj = idx_mxkj + 1\n    first , second = 0 , 0\n    idx_07qb = 0\n    list_uklt = range ( NO_OF_CHARS )\n    while idx_07qb < len(list_uklt):\n        i = list_uklt[idx_07qb]\n        if not count [ i ] > count [ first ]:\n            if ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n                second = i\n        else:\n            second = first\n            first = i\n        idx_07qb = idx_07qb + 1\n    return chr ( second )", "id": "AugAssign2Assign_sample_from_C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER_to_20", "old_id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    idx_zq2a = 0\n    list_9zwq = range ( len ( Str ) )\n    while idx_zq2a < len(list_9zwq):\n        i = list_9zwq[idx_zq2a]\n        count = 0\n        if not ( Str [ i ] >= '0' and Str [ i ] <= '9' ):\n            if ( Str [ i ] == ']' ) :\n                temp = \"\"\n                count = 0\n                if ( len ( integerstack ) != 0 ) :\n                    count = integerstack [ - 1 ]\n                    integerstack.pop ( )\n                while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                    temp = stringstack [ - 1 ] + temp\n                    stringstack.pop ( )\n                if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                    stringstack.pop ( )\n                idx_w4vx = 0\n                list_of85 = range ( count )\n                while idx_w4vx < len(list_of85):\n                    j = list_of85[idx_w4vx]\n                    result = result + temp\n                    idx_w4vx = idx_w4vx + 1\n                idx_ihsc = 0\n                list_dgz1 = range ( len ( result ) )\n                while idx_ihsc < len(list_dgz1):\n                    j = list_dgz1[idx_ihsc]\n                    stringstack.append ( result [ j ] )\n                    idx_ihsc = idx_ihsc + 1\n                result = \"\"\n            elif ( Str [ i ] == '[' ) :\n                if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                    stringstack.append ( Str [ i ] )\n                else :\n                    stringstack.append ( Str [ i ] )\n                    integerstack.append ( 1 )\n            else :\n                stringstack.append ( Str [ i ] )\n        else:\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( '0' )\n                i = i + 1\n            i = i - 1\n            integerstack.append ( count )\n        idx_zq2a = idx_zq2a + 1\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "AugAssign2Assign_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_21", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def findDiff ( arr , n ) :\n    arr.sort ( )\n    count = 0\n    max_count = 0\n    min_count = n\n    idx_svto = 0\n    list_af5t = range ( 0 , ( n - 1 ) )\n    while idx_svto < len(list_af5t):\n        i = list_af5t[idx_svto]\n        if not arr [ i ] == arr [ i + 1 ]:\n            max_count = max ( max_count , count )\n            min_count = min ( min_count , count )\n            count = 0\n        else:\n            count = count + 1\n            continue\n        idx_svto = idx_svto + 1\n    return max_count - min_count", "id": "AugAssign2Assign_sample_from_DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_to_22", "old_id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY"}
{"code": "def isDvisibleBy12 ( num ) :\n    if not ( len ( num ) >= 3 ):\n        number = int ( num )\n        return ( number % 12 == 0 )\n    else:\n        d1 = int ( num [ len ( num ) - 1 ] )\n        if ( d1 % 2 != 0 ) :\n            return False\n        d2 = int ( num [ len ( num ) - 2 ] )\n        sum = 0\n        idx_vief = 0\n        list_96x8 = range ( 0 , len ( num ) )\n        while idx_vief < len(list_96x8):\n            i = list_96x8[idx_vief]\n            sum = sum + int ( num [ i ] )\n            idx_vief = idx_vief + 1\n        return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )", "id": "AugAssign2Assign_sample_from_DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER_to_23", "old_id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER"}
{"code": "def doublefactorial ( n ) :\n    res = 1\n    idx_160y = 0\n    list_edl2 = range ( n , - 1 , - 2 )\n    while idx_160y < len(list_edl2):\n        i = list_edl2[idx_160y]\n        if not ( i == 0 or i == 1 ):\n            res = res * i\n        else:\n            return res\n        idx_160y = idx_160y + 1\n    return res;", "id": "AugAssign2Assign_sample_from_DOUBLE_FACTORIAL_1_to_24", "old_id": "DOUBLE_FACTORIAL_1"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    idx_shoz = 0\n    list_z7iw = range ( n )\n    while idx_shoz < len(list_z7iw):\n        i = list_z7iw[idx_shoz]\n        if not symb [ i ] == 'F':\n            F [ i ] [ i ] = 0\n        else:\n            F [ i ] [ i ] = 1\n        if not symb [ i ] == 'T':\n            T [ i ] [ i ] = 0\n        else:\n            T [ i ] [ i ] = 1\n        idx_shoz = idx_shoz + 1\n    idx_qoln = 0\n    list_4gt9 = range ( 1 , n )\n    while idx_qoln < len(list_4gt9):\n        gap = list_4gt9[idx_qoln]\n        i = 0\n        idx_yazb = 0\n        list_vq5l = range ( gap , n )\n        while idx_yazb < len(list_vq5l):\n            j = list_vq5l[idx_yazb]\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            idx_h9kr = 0\n            list_vkhf = range ( gap )\n            while idx_h9kr < len(list_vkhf):\n                g = list_vkhf[idx_h9kr]\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] = T [ i ] [ j ] + T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] = F [ i ] [ j ] + ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] = F [ i ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] = T [ i ] [ j ] + ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] = T [ i ] [ j ] + ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] = F [ i ] [ j ] + ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                idx_h9kr = idx_h9kr + 1\n            i = i + 1\n            idx_yazb = idx_yazb + 1\n        idx_qoln = idx_qoln + 1\n    return T [ 0 ] [ n - 1 ]", "id": "AugAssign2Assign_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_25", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    idx_hk51 = 0\n    list_jt6m = string\n    while idx_hk51 < len(list_jt6m):\n        ch = list_jt6m[idx_hk51]\n        if not ch == ')':\n            Stack.append ( ch )\n        else:\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != '(' :\n                elementsInside = elementsInside + 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n        idx_hk51 = idx_hk51 + 1\n    return False", "id": "AugAssign2Assign_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_26", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :\n    sum1 , sum2 , sum3 = 0 , 0 , 0\n    idx_9ubx = 0\n    list_fzxl = range ( n1 )\n    while idx_9ubx < len(list_fzxl):\n        i = list_fzxl[idx_9ubx]\n        sum1 = sum1 + stack1 [ i ]\n        idx_9ubx = idx_9ubx + 1\n    idx_9eqh = 0\n    list_igcm = range ( n2 )\n    while idx_9eqh < len(list_igcm):\n        i = list_igcm[idx_9eqh]\n        sum2 = sum2 + stack2 [ i ]\n        idx_9eqh = idx_9eqh + 1\n    idx_ju8x = 0\n    list_eb1u = range ( n3 )\n    while idx_ju8x < len(list_eb1u):\n        i = list_eb1u[idx_ju8x]\n        sum3 = sum3 + stack3 [ i ]\n        idx_ju8x = idx_ju8x + 1\n    top1 , top2 , top3 = 0 , 0 , 0\n    ans = 0\n    while ( 1 ) :\n        if ( top1 == n1 or top2 == n2 or top3 == n3 ) :\n            return 0\n        if ( sum1 == sum2 and sum2 == sum3 ) :\n            return sum1\n        if not ( sum1 >= sum2 and sum1 >= sum3 ):\n            if ( sum2 >= sum3 and sum2 >= sum3 ) :\n                sum2 = sum2 - stack2 [ top2 ]\n                top2 = top2 + 1\n            elif ( sum3 >= sum2 and sum3 >= sum1 ) :\n                sum3 = sum3 - stack3 [ top3 ]\n                top3 = top3 + 1\n        else:\n            sum1 = sum1 - stack1 [ top1 ]\n            top1 = top1 + 1", "id": "AugAssign2Assign_sample_from_FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS_to_27", "old_id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS"}
{"code": "def pairSum ( mat , n , sum ) :\n    idx_b5aw = 0\n    list_8x3r = range ( n )\n    while idx_b5aw < len(list_8x3r):\n        i = list_8x3r[idx_b5aw]\n        mat [ i ].sort ( )\n        idx_b5aw = idx_b5aw + 1\n    idx_ft7n = 0\n    list_7eb9 = range ( n - 1 )\n    while idx_ft7n < len(list_7eb9):\n        i = list_7eb9[idx_ft7n]\n        idx_mq1a = 0\n        list_lwht = range ( i + 1 , n )\n        while idx_mq1a < len(list_lwht):\n            j = list_lwht[idx_mq1a]\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if not ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ):\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left = left + 1\n                    else :\n                        right = right - 1\n                else:\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left = left + 1\n                    right = right - 1\n            idx_mq1a = idx_mq1a + 1\n        idx_ft7n = idx_ft7n + 1", "id": "AugAssign2Assign_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_28", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    idx_j59r = 0\n    list_axl9 = range ( 0 , n - 1 )\n    while idx_j59r < len(list_axl9):\n        i = list_axl9[idx_j59r]\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if not ( x + arr [ l ] + arr [ r ] == 0 ):\n                if ( x + arr [ l ] + arr [ r ] < 0 ) :\n                    l = l + 1\n                else :\n                    r = r - 1\n            else:\n                print ( x , arr [ l ] , arr [ r ] )\n                l = l + 1\n                r = r - 1\n                found = True\n        idx_j59r = idx_j59r + 1\n    if ( found == False ) :\n        print ( \" No Triplet Found\" )", "id": "AugAssign2Assign_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_29", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def firstElement ( arr , n , k ) :\n    count_map = { }\n    idx_v27k = 0\n    list_1ur6 = range ( 0 , n )\n    while idx_v27k < len(list_1ur6):\n        i = list_1ur6[idx_v27k]\n        if not ( arr [ i ] in count_map.keys ( ) ):\n            count_map [ arr [ i ] ] = 1\n        else:\n            count_map [ arr [ i ] ] = count_map [ arr [ i ] ] + 1\n        i = i + 1\n        idx_v27k = idx_v27k + 1\n    idx_bd21 = 0\n    list_fmja = range ( 0 , n )\n    while idx_bd21 < len(list_fmja):\n        i = list_fmja[idx_bd21]\n        if ( count_map [ arr [ i ] ] == k ) :\n            return arr [ i ]\n        i = i + 1\n        idx_bd21 = idx_bd21 + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY_to_30", "old_id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY"}
{"code": "def mostFrequent ( arr , n ) :\n    Hash = dict ( )\n    idx_gyq6 = 0\n    list_pz25 = range ( n )\n    while idx_gyq6 < len(list_pz25):\n        i = list_pz25[idx_gyq6]\n        if not arr [ i ] in Hash.keys ( ):\n            Hash [ arr [ i ] ] = 1\n        else:\n            Hash [ arr [ i ] ] = Hash [ arr [ i ] ] + 1\n        idx_gyq6 = idx_gyq6 + 1\n    max_count = 0\n    res = - 1\n    idx_yp6e = 0\n    list_5nuj = Hash\n    while idx_yp6e < len(list_5nuj):\n        i = list_5nuj[idx_yp6e]\n        if ( max_count < Hash [ i ] ) :\n            res = i\n            max_count = Hash [ i ]\n        idx_yp6e = idx_yp6e + 1\n    return res", "id": "AugAssign2Assign_sample_from_FREQUENT_ELEMENT_ARRAY_1_to_31", "old_id": "FREQUENT_ELEMENT_ARRAY_1"}
{"code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0\n    idx_p27a = 0\n    list_pdwl = range ( 1 , m + 1 )\n    while idx_p27a < len(list_pdwl):\n        i = list_pdwl[idx_p27a]\n        if not ( nxtbb < n ):\n            maxRev [ i ] = maxRev [ i - 1 ]\n        else:\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb = nxtbb + 1\n        idx_p27a = idx_p27a + 1\n    return maxRev [ m ]", "id": "AugAssign2Assign_sample_from_HIGHWAY_BILLBOARD_PROBLEM_to_32", "old_id": "HIGHWAY_BILLBOARD_PROBLEM"}
{"code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    idx_qaml = 0\n    list_m706 = arr\n    while idx_qaml < len(list_m706):\n        i = list_m706[idx_qaml]\n        if not ( i < 0 ):\n            hash [ i ] = hash.get ( i , 0 ) + 1\n        else:\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] = hash [ abs ( i ) ] - 1\n        idx_qaml = idx_qaml + 1\n    idx_487p = 0\n    list_3x2o = arr\n    while idx_487p < len(list_3x2o):\n        i = list_3x2o[idx_487p]\n        if i in hash.keys ( ) and hash [ i ] > 0 :\n            return i\n        idx_487p = idx_487p + 1\n    return - 1", "id": "AugAssign2Assign_sample_from_INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_to_33", "old_id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    idx_fc2k = 0\n    list_dbg3 = range ( n )\n    while idx_fc2k < len(list_dbg3):\n        i = list_dbg3[idx_fc2k]\n        if not ( s [ i ] == '(' ):\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces = invalidCloseBraces + 1\n            else :\n                invalidOpenBraces = invalidOpenBraces - 1\n        else:\n            invalidOpenBraces = invalidOpenBraces + 1\n        idx_fc2k = idx_fc2k + 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "AugAssign2Assign_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_34", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    idx_oghm = 0\n    list_2e38 = range ( n )\n    while idx_oghm < len(list_2e38):\n        i = list_2e38[idx_oghm]\n        L [ i ] [ n - 1 ] = 2\n        idx_oghm = idx_oghm + 1\n    idx_ajm4 = 0\n    list_qorv = range ( n - 2 , 0 , - 1 )\n    while idx_ajm4 < len(list_qorv):\n        j = list_qorv[idx_ajm4]\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if not ( set [ i ] + set [ k ] < 2 * set [ j ] ):\n                if ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                    L [ i ] [ j ] = 2\n                    i = i - 1\n                else :\n                    L [ i ] [ j ] = L [ j ] [ k ] + 1\n                    llap = max ( llap , L [ i ] [ j ] )\n                    i = i - 1\n                    k = k + 1\n            else:\n                k = k + 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i = i - 1\n        idx_ajm4 = idx_ajm4 + 1\n    return llap", "id": "AugAssign2Assign_sample_from_LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY_to_35", "old_id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_ixvf = 0\n    list_vma3 = range ( 1 , n + 1 )\n    while idx_ixvf < len(list_vma3):\n        i = list_vma3[idx_ixvf]\n        idx_9azw = 0\n        list_ku16 = range ( 1 , n + 1 )\n        while idx_9azw < len(list_ku16):\n            j = list_ku16[idx_9azw]\n            if not ( str [ i - 1 ] == str [ j - 1 ] and i != j ):\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            else:\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            idx_9azw = idx_9azw + 1\n        idx_ixvf = idx_ixvf + 1\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if not ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ):\n            if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n                i = i - 1\n            else :\n                j = j - 1\n        else:\n            res = res + str [ i - 1 ]\n            i = i - 1\n            j = j - 1\n    res = ''.join ( reversed ( res ) )\n    return res", "id": "AugAssign2Assign_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_36", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    idx_qfjp = 0\n    list_3tj6 = range ( n )\n    while idx_qfjp < len(list_3tj6):\n        i = list_3tj6[idx_qfjp]\n        if not arr [ i ] == 0:\n            sum = sum + 1\n        else:\n            sum = sum + - 1\n        if not ( sum == 1 ):\n            if ( sum not in um ) :\n                um [ sum ] = i\n        else:\n            maxLen = i + 1\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n        idx_qfjp = idx_qfjp + 1\n    return maxLen", "id": "AugAssign2Assign_sample_from_LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S_to_37", "old_id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S"}
{"code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    idx_gabd = 0\n    list_fwpj = range ( n )\n    while idx_gabd < len(list_fwpj):\n        i = list_fwpj[idx_gabd]\n        curr_sum = curr_sum + arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k\n        idx_gabd = idx_gabd + 1\n    idx_xehp = 0\n    list_khdg = range ( n )\n    while idx_xehp < len(list_khdg):\n        i = list_khdg[idx_xehp]\n        if not ( mod_arr [ i ] == 0 ):\n            if ( mod_arr [ i ] in um ) :\n                um [ mod_arr [ i ] ] = i\n            else :\n                if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                    max = i - um [ mod_arr [ i ] ]\n        else:\n            max = i + 1\n        idx_xehp = idx_xehp + 1\n    return max", "id": "AugAssign2Assign_sample_from_LONGEST_SUBARRAY_SUM_DIVISIBLE_K_to_38", "old_id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K"}
{"code": "def maxRepeating ( str ) :\n    n = len ( str )\n    count = 0\n    res = str [ 0 ]\n    cur_count = 1\n    idx_8osq = 0\n    list_v3bf = range ( n )\n    while idx_8osq < len(list_v3bf):\n        i = list_v3bf[idx_8osq]\n        if not ( i < n - 1 and str [ i ] == str [ i + 1 ] ):\n            if cur_count > count :\n                count = cur_count\n                res = str [ i ]\n            cur_count = 1\n        else:\n            cur_count = cur_count + 1\n        idx_8osq = idx_8osq + 1\n    return res", "id": "AugAssign2Assign_sample_from_MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1_to_39", "old_id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1"}
{"code": "def maxdiff ( arr , n ) :\n    freq = defaultdict ( lambda : 0 )\n    idx_vqaf = 0\n    list_ylkg = range ( n )\n    while idx_vqaf < len(list_ylkg):\n        i = list_ylkg[idx_vqaf]\n        freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1\n        idx_vqaf = idx_vqaf + 1\n    ans = 0\n    idx_e9wb = 0\n    list_urdz = range ( n )\n    while idx_e9wb < len(list_urdz):\n        i = list_urdz[idx_e9wb]\n        idx_26cj = 0\n        list_rhn0 = range ( n )\n        while idx_26cj < len(list_rhn0):\n            j = list_rhn0[idx_26cj]\n            if not freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ]:\n                if freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :\n                    ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )\n            else:\n                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )\n            idx_26cj = idx_26cj + 1\n        idx_e9wb = idx_e9wb + 1\n    return ans", "id": "AugAssign2Assign_sample_from_MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER_to_40", "old_id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER"}
{"code": "def MinimumCost ( cost , n , W ) :\n    val = list ( )\n    wt = list ( )\n    size = 0\n    idx_61kr = 0\n    list_pf97 = range ( n )\n    while idx_61kr < len(list_pf97):\n        i = list_pf97[idx_61kr]\n        if ( cost [ i ] != - 1 ) :\n            val.append ( cost [ i ] )\n            wt.append ( i + 1 )\n            size = size + 1\n        idx_61kr = idx_61kr + 1\n    n = size\n    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]\n    idx_y43m = 0\n    list_gahq = range ( W + 1 )\n    while idx_y43m < len(list_gahq):\n        i = list_gahq[idx_y43m]\n        min_cost [ 0 ] [ i ] = INF\n        idx_y43m = idx_y43m + 1\n    idx_3s1w = 0\n    list_wcby = range ( 1 , n + 1 )\n    while idx_3s1w < len(list_wcby):\n        i = list_wcby[idx_3s1w]\n        min_cost [ i ] [ 0 ] = 0\n        idx_3s1w = idx_3s1w + 1\n    idx_2p73 = 0\n    list_oar7 = range ( 1 , n + 1 )\n    while idx_2p73 < len(list_oar7):\n        i = list_oar7[idx_2p73]\n        idx_4f5u = 0\n        list_ouin = range ( 1 , W + 1 )\n        while idx_4f5u < len(list_ouin):\n            j = list_ouin[idx_4f5u]\n            if not ( wt [ i - 1 ] > j ):\n                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )\n            else:\n                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]\n            idx_4f5u = idx_4f5u + 1\n        idx_2p73 = idx_2p73 + 1\n    if not ( min_cost [ n ] [ W ] == INF ):\n        return min_cost [ n ] [ W ]\n    else:\n        return - 1", "id": "AugAssign2Assign_sample_from_MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG_to_41", "old_id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG"}
{"code": "def minOps ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    idx_zm5e = 0\n    list_o0kt = range ( 0 , n )\n    while idx_zm5e < len(list_o0kt):\n        i = list_o0kt[idx_zm5e]\n        if not ( ( max1 - arr [ i ] ) % k != 0 ):\n            res = res + ( max1 - arr [ i ] ) / k\n        else:\n            return - 1\n        idx_zm5e = idx_zm5e + 1\n    return int ( res )", "id": "AugAssign2Assign_sample_from_MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL_to_42", "old_id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_y4ls = 0\n    list_p5yi = range ( n )\n    while idx_y4ls < len(list_p5yi):\n        i = list_p5yi[idx_y4ls]\n        bestIdx = - 1\n        idx_4si2 = 0\n        list_l8m6 = range ( m )\n        while idx_4si2 < len(list_l8m6):\n            j = list_l8m6[idx_4si2]\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n            idx_4si2 = idx_4si2 + 1\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] = blockSize [ bestIdx ] - processSize [ i ]\n        idx_y4ls = idx_y4ls + 1\n    print ( \"Process No.Process Size     Block no.\" )\n    idx_mpiq = 0\n    list_ftr5 = range ( n )\n    while idx_mpiq < len(list_ftr5):\n        i = list_ftr5[idx_mpiq]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if not allocation [ i ] != - 1:\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + 1 )\n        idx_mpiq = idx_mpiq + 1", "id": "AugAssign2Assign_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_43", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 :\n        return False\n    _sum = 0\n    idx_zsgt = 0\n    list_ajc8 = range ( 9 )\n    while idx_zsgt < len(list_ajc8):\n        i = list_ajc8[idx_zsgt]\n        if not 0 <= int ( isbn [ i ] ) <= 9:\n            return False\n        else:\n            _sum = _sum + int ( isbn [ i ] ) * ( 10 - i )\n        idx_zsgt = idx_zsgt + 1\n    if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) :\n        return False\n    _sum = _sum + 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )", "id": "AugAssign2Assign_sample_from_PROGRAM_CHECK_ISBN_to_44", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_sqd7 = 0\n    list_lp4u = range ( n )\n    while idx_sqd7 < len(list_lp4u):\n        i = list_lp4u[idx_sqd7]\n        wstIdx = - 1\n        idx_wmh0 = 0\n        list_o6vb = range ( m )\n        while idx_wmh0 < len(list_o6vb):\n            j = list_o6vb[idx_wmh0]\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n            idx_wmh0 = idx_wmh0 + 1\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] = blockSize [ wstIdx ] - processSize [ i ]\n        idx_sqd7 = idx_sqd7 + 1\n    print ( \"Process No.Process Size Block no.\" )\n    idx_behz = 0\n    list_sleb = range ( n )\n    while idx_behz < len(list_sleb):\n        i = list_sleb[idx_behz]\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if not allocation [ i ] != - 1:\n            print ( \"Not Allocated\" )\n        else:\n            print ( allocation [ i ] + 1 )\n        idx_behz = idx_behz + 1", "id": "AugAssign2Assign_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_45", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def rearrange ( arr , n ) :\n    temp = n * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    idx_hpx2 = 0\n    list_wvtq = range ( n )\n    while idx_hpx2 < len(list_wvtq):\n        i = list_wvtq[idx_hpx2]\n        if not flag is True:\n            temp [ i ] = arr [ small ]\n            small = small + 1\n        else:\n            temp [ i ] = arr [ large ]\n            large = large - 1\n        flag = bool ( 1 - flag )\n        idx_hpx2 = idx_hpx2 + 1\n    idx_a8ni = 0\n    list_lsbh = range ( n )\n    while idx_a8ni < len(list_lsbh):\n        i = list_lsbh[idx_a8ni]\n        arr [ i ] = temp [ i ]\n        idx_a8ni = idx_a8ni + 1\n    return arr", "id": "AugAssign2Assign_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_to_46", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM"}
{"code": "def rearrange ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    idx_oqjc = 0\n    list_g03m = range ( 0 , n )\n    while idx_oqjc < len(list_g03m):\n        i = list_g03m[idx_oqjc]\n        if not i % 2 == 0:\n            arr [ i ] = arr [ i ] + ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx = min_idx + 1\n        else:\n            arr [ i ] = arr [ i ] + ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx = max_idx - 1\n        idx_oqjc = idx_oqjc + 1\n    idx_z5wp = 0\n    list_dpmz = range ( 0 , n )\n    while idx_z5wp < len(list_dpmz):\n        i = list_dpmz[idx_z5wp]\n        arr [ i ] = int ( arr [ i ] / max_elem )\n        idx_z5wp = idx_z5wp + 1", "id": "AugAssign2Assign_sample_from_REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_to_47", "old_id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE"}
{"code": "def sortArray ( arr , n , A , B , C ) :\n    idx_anxv = 0\n    list_j146 = range ( n )\n    while idx_anxv < len(list_j146):\n        i = list_j146[idx_anxv]\n        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )\n        idx_anxv = idx_anxv + 1\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    idx_ofip = 0\n    list_5bem = range ( n )\n    while idx_ofip < len(list_5bem):\n        i = list_5bem[idx_ofip]\n        if maximum < arr [ i ] :\n            index = i\n            maximum = arr [ i ]\n        idx_ofip = idx_ofip + 1\n    i = 0\n    j = n - 1\n    new_arr = [ 0 ] * n\n    k = 0\n    while i < index and j > index :\n        if not arr [ i ] < arr [ j ]:\n            new_arr [ k ] = arr [ j ]\n            k = k + 1\n            j = j - 1\n        else:\n            new_arr [ k ] = arr [ i ]\n            k = k + 1\n            i = i + 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k = k + 1\n        i = i + 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k = k + 1\n        j = j - 1\n        new_arr [ n - 1 ] = maximum\n    idx_ij57 = 0\n    list_78wg = range ( n )\n    while idx_ij57 < len(list_78wg):\n        i = list_78wg[idx_ij57]\n        arr [ i ] = new_arr [ i ]\n        idx_ij57 = idx_ij57 + 1", "id": "AugAssign2Assign_sample_from_SORT_ARRAY_APPLYING_GIVEN_EQUATION_to_48", "old_id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION"}
{"code": "def bitonicGenerator ( arr , n ) :\n    evenArr = [ ]\n    oddArr = [ ]\n    idx_kidp = 0\n    list_5p4k = range ( n )\n    while idx_kidp < len(list_5p4k):\n        i = list_5p4k[idx_kidp]\n        if not ( ( i % 2 ) == 0 ):\n            oddArr.append ( arr [ i ] )\n        else:\n            evenArr.append ( arr [ i ] )\n        idx_kidp = idx_kidp + 1\n    evenArr = sorted ( evenArr )\n    oddArr = sorted ( oddArr )\n    oddArr = oddArr [ : : - 1 ]\n    i = 0\n    idx_pdjo = 0\n    list_cxke = range ( len ( evenArr ) )\n    while idx_pdjo < len(list_cxke):\n        j = list_cxke[idx_pdjo]\n        arr [ i ] = evenArr [ j ]\n        i = i + 1\n        idx_pdjo = idx_pdjo + 1\n    idx_ejy6 = 0\n    list_572o = range ( len ( oddArr ) )\n    while idx_ejy6 < len(list_572o):\n        j = list_572o[idx_ejy6]\n        arr [ i ] = oddArr [ j ]\n        i = i + 1\n        idx_ejy6 = idx_ejy6 + 1", "id": "AugAssign2Assign_sample_from_SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_to_49", "old_id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER"}
{"code": "def firstLetterWord ( str ) :\n    result = \"\"\n    v = True\n    idx_wdl7 = 0\n    list_8f0g = range ( len ( str ) )\n    while idx_wdl7 < len(list_8f0g):\n        i = list_8f0g[idx_wdl7]\n        if not ( str [ i ] == ' ' ):\n            if ( str [ i ] != ' ' and v == True ) :\n                result = result + ( str [ i ] )\n                v = False\n        else:\n            v = True\n        idx_wdl7 = idx_wdl7 + 1\n    return result", "id": "AugAssign2Assign_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_50", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    idx_bhqw = 0\n    list_7tuj = range ( 0 , n + 1 )\n    while idx_bhqw < len(list_7tuj):\n        i = list_7tuj[idx_bhqw]\n        idx_hmai = 0\n        list_34ta = range ( 0 , min ( i , n ) + 1 )\n        while idx_hmai < len(list_34ta):\n            j = list_34ta[idx_hmai]\n            if not ( j == 0 or j == i ):\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n            else:\n                C [ i ] [ j ] = 1\n            idx_hmai = idx_hmai + 1\n        idx_bhqw = idx_bhqw + 1\n    sum = 0\n    idx_7ujk = 0\n    list_siz4 = range ( 0 , n + 1 )\n    while idx_7ujk < len(list_siz4):\n        i = list_siz4[idx_7ujk]\n        sum = sum + C [ n ] [ i ]\n        idx_7ujk = idx_7ujk + 1\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_BINOMIAL_COEFFICIENTS_to_51", "old_id": "SUM_BINOMIAL_COEFFICIENTS"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    idx_rvob = 0\n    list_umk1 = range ( n )\n    while idx_rvob < len(list_umk1):\n        i = list_umk1[idx_rvob]\n        if not ( tree [ i ] == '(' ):\n            if ( tree [ i ] == ')' ) :\n                level = level - 1\n            else :\n                if ( level == k ) :\n                    sum = sum + ( ord ( tree [ i ] ) - ord ( '0' ) )\n        else:\n            level = level + 1\n        idx_rvob = idx_rvob + 1\n    return sum", "id": "AugAssign2Assign_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_52", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    idx_o2fn = 0\n    list_1z4o = range(n1)\n    while idx_o2fn < len(list_1z4o):\n        i = list_1z4o[idx_o2fn]\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if not sum < 0:\n            str = str + chr(sum % 10 + 48)\n        else:\n            str = str + chr(sum % -10 + 48)\n        carry = int(sum / 10)\n        idx_o2fn = idx_o2fn + 1\n    idx_rb57 = 0\n    list_tu1v = range(n1, n2)\n    while idx_rb57 < len(list_tu1v):\n        i = list_tu1v[idx_rb57]\n        sum = ((ord(str2[i]) - 48) + carry)\n        if not sum < 0:\n            str = str + chr(sum % 10 + 48)\n        else:\n            str = str + chr(sum % -10 + 48)\n        carry = (int)(sum / 10)\n        idx_rb57 = idx_rb57 + 1\n    if (carry):\n        str = str + chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "AugAssign2Assign_sample_from_SUM_TWO_LARGE_NUMBERS_to_53", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def offeringNumber ( n , templeHeight ) :\n    sum = 0\n    idx_wthr = 0\n    list_kwad = range ( n )\n    while idx_wthr < len(list_kwad):\n        i = list_kwad[idx_wthr]\n        left = 0\n        right = 0\n        idx_k3ru = 0\n        list_fw6l = range ( i - 1 , - 1 , - 1 )\n        while idx_k3ru < len(list_fw6l):\n            j = list_fw6l[idx_k3ru]\n            if not ( templeHeight [ j ] < templeHeight [ j + 1 ] ):\n                break\n            else:\n                left = left + 1\n            idx_k3ru = idx_k3ru + 1\n        idx_gxzv = 0\n        list_kfs2 = range ( i + 1 , n )\n        while idx_gxzv < len(list_kfs2):\n            j = list_kfs2[idx_gxzv]\n            if not ( templeHeight [ j ] < templeHeight [ j - 1 ] ):\n                break\n            else:\n                right = right + 1\n            idx_gxzv = idx_gxzv + 1\n        sum = sum + max ( right , left ) + 1\n        idx_wthr = idx_wthr + 1\n    return sum", "id": "AugAssign2Assign_sample_from_TEMPLE_OFFERINGS_to_54", "old_id": "TEMPLE_OFFERINGS"}
{"code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    idx_kob7 = 0\n    list_pael = range ( 0 , n , 1 )\n    while idx_kob7 < len(list_pael):\n        i = list_pael[idx_kob7]\n        if not ( str [ i ] == '1' ):\n            zero_count = zero_count + 1\n        else:\n            one_count = one_count + 1\n        idx_kob7 = idx_kob7 + 1\n    if ( one_count % 2 == 0 ) :\n        return zero_count\n    return one_count", "id": "AugAssign2Assign_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_55", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
