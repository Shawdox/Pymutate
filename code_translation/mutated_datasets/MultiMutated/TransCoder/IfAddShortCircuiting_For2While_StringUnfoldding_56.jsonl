{"code": "def encrypt ( text , s ) :\n    result = (\"\" + \"\")\n    idx_8jv7 = 0\n    list_kzao = range ( len ( text ) )\n    while idx_8jv7 < len(list_kzao):\n        i = list_kzao[idx_8jv7]\n        char = text [ i ]\n        if ( char.isupper ( ) ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        else :\n            result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n        idx_8jv7 = idx_8jv7 + 1\n    return result", "id": "StringUnfoldding_sample_from_CAESAR_CIPHER_to_0", "old_id": "CAESAR_CIPHER"}
{"code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    idx_1hj6 = 0\n    list_v957 = range ( 1 , len ( str ) )\n    while idx_1hj6 < len(list_v957):\n        i = list_v957[idx_1hj6]\n        if ( str [ i ] == ('0' + '') or str [ i ] == ('' + '1') or res < 2 ) and (((True or False) and (False or True)) and ((10 > 2) or (10 < 2))):\n            res += ord ( str [ i ] ) - 48\n        else :\n            res += ord ( str [ i ] ) - 48\n        idx_1hj6 = idx_1hj6 + 1\n    return res", "id": "StringUnfoldding_sample_from_CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING_to_1", "old_id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING"}
{"code": "def findSum ( str ) :\n    temp = (\"\" + \"0\")\n    Sum = 0\n    idx_yzgj = 0\n    list_tpym = str\n    while idx_yzgj < len(list_tpym):\n        ch = list_tpym[idx_yzgj]\n        if ( ch.isdigit ( ) ) and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n            temp += ch\n        else :\n            Sum += int ( temp )\n            temp = (\"\" + \"0\")\n        idx_yzgj = idx_yzgj + 1\n    return Sum + int ( temp )", "id": "StringUnfoldding_sample_from_CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING_to_2", "old_id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING"}
{"code": "def canMakeAllSame ( str ) :\n    zeros = 0\n    ones = 0\n    idx_uhpf = 0\n    list_mu05 = range ( 0 , len ( str ) )\n    while idx_uhpf < len(list_mu05):\n        i = list_mu05[idx_uhpf]\n        ch = str [ i ]\n        if ( ch == ('0' + '') ) and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n            zeros = zeros + 1\n        else :\n            ones = ones + 1\n        idx_uhpf = idx_uhpf + 1\n    return ( zeros == 1 or ones == 1 )", "id": "StringUnfoldding_sample_from_CHANGE_BITS_CAN_MADE_ONE_FLIP_to_3", "old_id": "CHANGE_BITS_CAN_MADE_ONE_FLIP"}
{"code": "def isDivisible ( str , k ) :\n    n = len ( str )\n    c = 0\n    idx_g8vw = 0\n    list_tevo = range ( 0 , k )\n    while idx_g8vw < len(list_tevo):\n        i = list_tevo[idx_g8vw]\n        if ( str [ n - i - 1 ] == ('' + '0') ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            c += 1\n        idx_g8vw = idx_g8vw + 1\n    return ( c == k )", "id": "StringUnfoldding_sample_from_CHECK_DIVISIBILITY_BINARY_STRING_2K_to_4", "old_id": "CHECK_DIVISIBILITY_BINARY_STRING_2K"}
{"code": "def isDivisible999 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == ('' + '0') ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        return True\n    if ( ( n % 3 ) == 1 ) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n        num = (\"\" + \"00\") + num\n    if ( ( n % 3 ) == 2 ) and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n        num = (\"\" + \"0\") + num\n    gSum = 0\n    idx_giwe = 0\n    list_8rfz = range ( 0 , n , 3 )\n    while idx_giwe < len(list_8rfz):\n        i = list_8rfz[idx_giwe]\n        group = 0\n        group += ( ord ( num [ i ] ) - 48 ) * 100\n        group += ( ord ( num [ i + 1 ] ) - 48 ) * 10\n        group += ( ord ( num [ i + 2 ] ) - 48 )\n        gSum += group\n        idx_giwe = idx_giwe + 1\n    if ( gSum > 1000 ) and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n        num = str ( gSum )\n        n = len ( num )\n        gSum = isDivisible999 ( num )\n    return ( gSum == 999 )", "id": "StringUnfoldding_sample_from_CHECK_DIVISIBILITY_LARGE_NUMBER_999_to_5", "old_id": "CHECK_DIVISIBILITY_LARGE_NUMBER_999"}
{"code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == ('' + '0') ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        return True\n    if ( length % 3 == 1 ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        num = str ( num ) + (\"00\" + \"\")\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ) + (\"\" + \"0\")\n        length += 1\n    sum = 0\n    p = 1\n    idx_cvza = 0\n    list_05to = range ( length - 1 , - 1 , - 3 )\n    while idx_cvza < len(list_05to):\n        i = list_05to[idx_cvza]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( ('' + '0') )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('' + '0') ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('0' + '') ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n        idx_cvza = idx_cvza + 1\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )", "id": "StringUnfoldding_sample_from_CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT_to_6", "old_id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT"}
{"code": "def isAnBn ( s ) :\n    n = len ( s )\n    idx_0opa = 0\n    list_jhvl = range ( n )\n    while idx_0opa < len(list_jhvl):\n        i = list_jhvl[idx_0opa]\n        if ( s [ i ] != ('' + 'a') ) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            break\n        idx_0opa = idx_0opa + 1\n    if ( i * 2 != n ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n        return False\n    idx_cagk = 0\n    list_nbxz = range ( i , n )\n    while idx_cagk < len(list_nbxz):\n        j = list_nbxz[idx_cagk]\n        if ( s [ j ] != ('b' + '') ) and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n            return False\n        idx_cagk = idx_cagk + 1\n    return True", "id": "StringUnfoldding_sample_from_CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT_to_7", "old_id": "CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT"}
{"code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return 1\n    if ( n % 3 == 1 ) and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n        num = str ( num ) + (\"00\" + \"\")\n        n += 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ) + (\"\" + \"0\")\n        n += 1\n    GSum = 0\n    p = 1\n    idx_apng = 0\n    list_vru9 = range ( n - 1 , - 1 , - 1 )\n    while idx_apng < len(list_vru9):\n        i = list_vru9[idx_apng]\n        group = 0\n        group += ord ( num [ i ] ) - ord ( ('' + '0') )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('' + '0') ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( ('' + '0') ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n        idx_apng = idx_apng + 1\n    return ( GSum % 7 == 0 )", "id": "StringUnfoldding_sample_from_CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7_to_8", "old_id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7"}
{"code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    idx_v5cs = 0\n    list_90fv = range ( n )\n    while idx_v5cs < len(list_90fv):\n        i = list_90fv[idx_v5cs]\n        if ( str [ i ] == ('' + 'a') ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            a_index = i + 1\n            ans -= min ( b_index , c_index )\n        elif ( str [ i ] == ('' + 'b') ) :\n            b_index = i + 1\n            ans -= min ( a_index , c_index )\n        else :\n            c_index = i + 1\n            ans -= min ( a_index , b_index )\n        idx_v5cs = idx_v5cs + 1\n    return ans", "id": "StringUnfoldding_sample_from_COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME_to_9", "old_id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME"}
{"code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    idx_mvh2 = 0\n    list_9u4o = range ( len ( s ) )\n    while idx_mvh2 < len(list_9u4o):\n        i = list_9u4o[idx_mvh2]\n        if s [ ~ i ] == ('a' + '') and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n        else :\n            b_count += 1\n        idx_mvh2 = idx_mvh2 + 1\n    return res", "id": "StringUnfoldding_sample_from_COUNT_OPERATIONS_MAKE_STRINGAB_FREE_to_10", "old_id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE"}
{"code": "def countDecodingDP ( digits , n ) :\n    count = [ 0 ] * ( n + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == ('0' + '') and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n        return 0\n    idx_3uz8 = 0\n    list_6tez = range ( 2 , n + 1 )\n    while idx_3uz8 < len(list_6tez):\n        i = list_6tez[idx_3uz8]\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > ('0' + '') ) and (((True or False) and (False or True)) and ((10 > 1) or (10 < 1))):\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == ('' + '1') or ( digits [ i - 2 ] == ('2' + '') and digits [ i - 1 ] < ('' + '7') ) ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n            count [ i ] += count [ i - 2 ]\n        idx_3uz8 = idx_3uz8 + 1\n    return count [ n ]", "id": "StringUnfoldding_sample_from_COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1_to_11", "old_id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1"}
{"code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = (\"\" + \"\")\n    result = (\"\" + \"\")\n    idx_1h3m = 0\n    list_iwk6 = range ( len ( Str ) )\n    while idx_1h3m < len(list_iwk6):\n        i = list_iwk6[idx_1h3m]\n        count = 0\n        if ( Str [ i ] >= ('' + '0') and Str [ i ] <= ('9' + '') ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n            while ( Str [ i ] >= ('' + '0') and Str [ i ] <= ('9' + '') ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( ('0' + '') )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n        elif ( Str [ i ] == (']' + '') ) :\n            temp = (\"\" + \"\")\n            count = 0\n            if ( len ( integerstack ) != 0 ) :\n                count = integerstack [ - 1 ]\n                integerstack.pop ( )\n            while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ('[' + '') ) :\n                temp = stringstack [ - 1 ] + temp\n                stringstack.pop ( )\n            if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == ('[' + '') ) :\n                stringstack.pop ( )\n            idx_iorz = 0\n            list_aes5 = range ( count )\n            while idx_iorz < len(list_aes5):\n                j = list_aes5[idx_iorz]\n                result = result + temp\n                idx_iorz = idx_iorz + 1\n            idx_chxq = 0\n            list_bis2 = range ( len ( result ) )\n            while idx_chxq < len(list_bis2):\n                j = list_bis2[idx_chxq]\n                stringstack.append ( result [ j ] )\n                idx_chxq = idx_chxq + 1\n            result = (\"\" + \"\")\n        elif ( Str [ i ] == ('[' + '') ) :\n            if ( Str [ i - 1 ] >= ('' + '0') and Str [ i - 1 ] <= ('' + '9') ) :\n                stringstack.append ( Str [ i ] )\n            else :\n                stringstack.append ( Str [ i ] )\n                integerstack.append ( 1 )\n        else :\n            stringstack.append ( Str [ i ] )\n        idx_1h3m = idx_1h3m + 1\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result", "id": "StringUnfoldding_sample_from_DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING_to_12", "old_id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING"}
{"code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    idx_cpb9 = 0\n    list_gpyi = range ( n )\n    while idx_cpb9 < len(list_gpyi):\n        i = list_gpyi[idx_cpb9]\n        if symb [ i ] == ('' + 'F') and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == ('' + 'T') and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n        idx_cpb9 = idx_cpb9 + 1\n    idx_gsu8 = 0\n    list_sfuw = range ( 1 , n )\n    while idx_gsu8 < len(list_sfuw):\n        gap = list_sfuw[idx_gsu8]\n        i = 0\n        idx_qjrl = 0\n        list_l40x = range ( gap , n )\n        while idx_qjrl < len(list_l40x):\n            j = list_l40x[idx_qjrl]\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            idx_bhpn = 0\n            list_f0az = range ( gap )\n            while idx_bhpn < len(list_f0az):\n                g = list_f0az[idx_bhpn]\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == ('' + '&') and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == ('|' + '') and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == ('' + '^') and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                idx_bhpn = idx_bhpn + 1\n            i += 1\n            idx_qjrl = idx_qjrl + 1\n        idx_gsu8 = idx_gsu8 + 1\n    return T [ 0 ] [ n - 1 ]", "id": "StringUnfoldding_sample_from_DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM_to_13", "old_id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM"}
{"code": "def find3Numbers ( A , arr_size , sum ) :\n    idx_2kgx = 0\n    list_0clk = range ( 0 , arr_size - 2 )\n    while idx_2kgx < len(list_0clk):\n        i = list_0clk[idx_2kgx]\n        idx_jgaw = 0\n        list_i8zm = range ( i + 1 , arr_size - 1 )\n        while idx_jgaw < len(list_i8zm):\n            j = list_i8zm[idx_jgaw]\n            idx_z7na = 0\n            list_wp1z = range ( j + 1 , arr_size )\n            while idx_z7na < len(list_wp1z):\n                k = list_wp1z[idx_z7na]\n                if A [ i ] + A [ j ] + A [ k ] == sum and (((True or False) and (False or True)) and ((8 > 6) or (8 < 6))):\n                    print ( (\"Triplet\" + \" is\") , A [ i ] , (\", \" + \"\") , A [ j ] , (\", \" + \"\") , A [ k ] )\n                    return True\n                idx_z7na = idx_z7na + 1\n            idx_jgaw = idx_jgaw + 1\n        idx_2kgx = idx_2kgx + 1\n    return False", "id": "StringUnfoldding_sample_from_FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_to_14", "old_id": "FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE"}
{"code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    idx_eq4r = 0\n    list_fc8e = string\n    while idx_eq4r < len(list_fc8e):\n        ch = list_fc8e[idx_eq4r]\n        if ch == (')' + '') and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != ('(' + '') :\n                elementsInside += 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n        else :\n            Stack.append ( ch )\n        idx_eq4r = idx_eq4r + 1\n    return False", "id": "StringUnfoldding_sample_from_FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT_to_15", "old_id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT"}
{"code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize - 1\n    idx_z540 = 0\n    list_cioy = range ( r )\n    while idx_z540 < len(list_cioy):\n        i = list_cioy[idx_z540]\n        if m [ i ] [ 0 ] < mi and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            mx = m [ i ] [ c - 1 ]\n        idx_z540 = idx_z540 + 1\n    desired = ( r * c + 1 ) // 2\n    while ( mi < mx ) :\n        mid = mi + ( mx - mi ) // 2\n        place = [ 0 ]\n        idx_1bca = 0\n        list_9n6j = range ( r )\n        while idx_1bca < len(list_9n6j):\n            i = list_9n6j[idx_1bca]\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ] + j\n            idx_1bca = idx_1bca + 1\n        if place [ 0 ] < desired and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n            mi = mid + 1\n        else :\n            mx = mid\n    print ( (\"Median \" + \"is\") , mi )\n    return mi", "id": "StringUnfoldding_sample_from_FIND_MEDIAN_ROW_WISE_SORTED_MATRIX_to_16", "old_id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX"}
{"code": "def pairSum ( mat , n , sum ) :\n    idx_6nz7 = 0\n    list_5x4a = range ( n )\n    while idx_6nz7 < len(list_5x4a):\n        i = list_5x4a[idx_6nz7]\n        mat [ i ].sort ( )\n        idx_6nz7 = idx_6nz7 + 1\n    idx_eyrp = 0\n    list_ie8q = range ( n - 1 )\n    while idx_eyrp < len(list_ie8q):\n        i = list_ie8q[idx_eyrp]\n        idx_xvhl = 0\n        list_qlhx = range ( i + 1 , n )\n        while idx_xvhl < len(list_qlhx):\n            j = list_qlhx[idx_xvhl]\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n                    print ( (\"(\" + \"\") , mat [ i ] [ left ] , (\"\" + \", \") , mat [ j ] [ right ] , (\")\" + \", \") , end = (\" \" + \"\") )\n                    left += 1\n                    right -= 1\n                else :\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1\n            idx_xvhl = idx_xvhl + 1\n        idx_eyrp = idx_eyrp + 1", "id": "StringUnfoldding_sample_from_FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS_to_17", "old_id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS"}
{"code": "def subArraySum ( arr , n , sum ) :\n    idx_odva = 0\n    list_ctgo = range ( n )\n    while idx_odva < len(list_ctgo):\n        i = list_ctgo[idx_odva]\n        curr_sum = arr [ i ]\n        j = i + 1\n        while j <= n :\n            if curr_sum == sum and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n                print ( (\"Sum found betwe\" + \"en\") )\n                print ( (\"indexes %d and\" + \" %d\") % ( i , j - 1 ) )\n                return 1\n            if curr_sum > sum or j == n and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n                break\n            curr_sum = curr_sum + arr [ j ]\n            j += 1\n        idx_odva = idx_odva + 1\n    print ( (\"No subarra\" + \"y found\") )\n    return 0", "id": "StringUnfoldding_sample_from_FIND_SUBARRAY_WITH_GIVEN_SUM_to_18", "old_id": "FIND_SUBARRAY_WITH_GIVEN_SUM"}
{"code": "def findElement ( arr , n ) :\n    leftMax = [ None ] * n\n    leftMax [ 0 ] = float ( ('' + '-inf') )\n    idx_xt9j = 0\n    list_ej1z = range ( 1 , n )\n    while idx_xt9j < len(list_ej1z):\n        i = list_ej1z[idx_xt9j]\n        leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] )\n        idx_xt9j = idx_xt9j + 1\n    rightMin = float ( ('inf' + '') )\n    idx_0uey = 0\n    list_y0o9 = range ( n - 1 , - 1 , - 1 )\n    while idx_0uey < len(list_y0o9):\n        i = list_y0o9[idx_0uey]\n        if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n            return i\n        rightMin = min ( rightMin , arr [ i ] )\n        idx_0uey = idx_0uey + 1\n    return - 1", "id": "StringUnfoldding_sample_from_FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT_to_19", "old_id": "FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    idx_gkuf = 0\n    list_qybs = range ( n - 1 )\n    while idx_gkuf < len(list_qybs):\n        i = list_qybs[idx_gkuf]\n        s = set ( )\n        idx_dkta = 0\n        list_lz3u = range ( i + 1 , n )\n        while idx_dkta < len(list_lz3u):\n            j = list_lz3u[idx_dkta]\n            x = - ( arr [ i ] + arr [ j ] )\n            if x in s and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                print ( x , arr [ i ] , arr [ j ] )\n                found = True\n            else :\n                s.add ( arr [ j ] )\n            idx_dkta = idx_dkta + 1\n        idx_gkuf = idx_gkuf + 1\n    if found == False and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        print ( (\"No Triple\" + \"t Found\") )", "id": "StringUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1_to_20", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1"}
{"code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    idx_w5j4 = 0\n    list_5o1h = range ( 0 , n - 1 )\n    while idx_w5j4 < len(list_5o1h):\n        i = list_5o1h[idx_w5j4]\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if ( x + arr [ l ] + arr [ r ] == 0 ) and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n            elif ( x + arr [ l ] + arr [ r ] < 0 ) :\n                l += 1\n            else :\n                r -= 1\n        idx_w5j4 = idx_w5j4 + 1\n    if ( found == False ) and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n        print ( (\" No Triplet \" + \"Found\") )", "id": "StringUnfoldding_sample_from_FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2_to_21", "old_id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n        return (\"\" + \"-1\")\n    result = [ None ] * ( n + 1 )\n    count = 1\n    idx_h8d1 = 0\n    list_7el3 = range ( n + 1 )\n    while idx_h8d1 < len(list_7el3):\n        i = list_7el3[idx_h8d1]\n        if ( i == n or seq [ i ] == ('' + 'I') ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            idx_gmna = 0\n            list_8wj9 = range ( i - 1 , - 2 , - 1 )\n            while idx_gmna < len(list_8wj9):\n                j = list_8wj9[idx_gmna]\n                result [ j + 1 ] = int ( ('' + '0') + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == ('' + 'I') ) :\n                    break\n                idx_gmna = idx_gmna + 1\n        idx_h8d1 = idx_h8d1 + 1\n    return result", "id": "StringUnfoldding_sample_from_FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1_to_22", "old_id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1"}
{"code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n        return (\"\" + \"-1\")\n    result = [ None ] * ( n + 1 )\n    count = 1\n    idx_bqik = 0\n    list_4vc6 = range ( n + 1 )\n    while idx_bqik < len(list_4vc6):\n        i = list_4vc6[idx_bqik]\n        if ( i == n or seq [ i ] == ('I' + '') ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            idx_dcjx = 0\n            list_isqx = range ( i - 1 , - 2 , - 1 )\n            while idx_dcjx < len(list_isqx):\n                j = list_isqx[idx_dcjx]\n                result [ j + 1 ] = int ( ('0' + '') + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == ('' + 'I') ) :\n                    break\n                idx_dcjx = idx_dcjx + 1\n        idx_bqik = idx_bqik + 1\n    return (\"\" + \"\").join(str(i) for i in result)", "id": "StringUnfoldding_sample_from_GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1_to_23", "old_id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1"}
{"code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    idx_avhd = 0\n    list_yvle = range ( 0 , n - 1 )\n    while idx_avhd < len(list_yvle):\n        i = list_yvle[idx_avhd]\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        idx_ciuw = 0\n        list_dp2a = range ( i + 1 , n )\n        while idx_ciuw < len(list_dp2a):\n            j = list_dp2a[idx_ciuw]\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                maxsize = j - i + 1\n                startindex = i\n            idx_ciuw = idx_ciuw + 1\n        idx_avhd = idx_avhd + 1\n    if ( maxsize == - 1 ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        print ( (\"No such subarray\" + \"\") )\n    else :\n        print ( startindex , (\"\" + \"to\") , startindex + maxsize - 1 )\n    return maxsize", "id": "StringUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_to_24", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S"}
{"code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    idx_mr3d = 0\n    list_oq5c = range ( 0 , n )\n    while idx_mr3d < len(list_oq5c):\n        i = list_oq5c[idx_mr3d]\n        if ( arr [ i ] == 0 ) and (((True or False) and (False or True)) and ((7 > 3) or (7 < 3))):\n            arr [ i ] = - 1\n        else :\n            arr [ i ] = 1\n        idx_mr3d = idx_mr3d + 1\n    idx_c04z = 0\n    list_e37t = range ( 0 , n )\n    while idx_c04z < len(list_e37t):\n        i = list_e37t[idx_c04z]\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n            max_len = i + 1\n            ending_index = i\n        if ( curr_sum + n ) in hash_map and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i - hash_map [ curr_sum + n ]\n                ending_index = i\n        else :\n            hash_map[curr_sum + n] = i\n        idx_c04z = idx_c04z + 1\n    idx_yp4h = 0\n    list_empr = range ( 0 , n )\n    while idx_yp4h < len(list_empr):\n        i = list_empr[idx_yp4h]\n        if ( arr [ i ] == - 1 ) and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n            arr [ i ] = 0\n        else :\n            arr [ i ] = 1\n        idx_yp4h = idx_yp4h + 1\n    print ( ending_index - max_len + 1 , end = (\"\" + \" \") )\n    print ( (\"t\" + \"o\") , end = (\" \" + \"\") )\n    print ( ending_index )\n    return max_len", "id": "StringUnfoldding_sample_from_LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1_to_25", "old_id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1"}
{"code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    idx_9aum = 0\n    list_km6y = range ( n - 1 )\n    while idx_9aum < len(list_km6y):\n        i = list_km6y[idx_9aum]\n        if ( s [ i ] == ('' + '(') and s [ i + 1 ] == ('' + ')') ) and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n            dp [ i ] [ i + 1 ] = 2\n        idx_9aum = idx_9aum + 1\n    idx_8y7v = 0\n    list_qe7m = range ( 2 , n )\n    while idx_8y7v < len(list_qe7m):\n        l = list_qe7m[idx_8y7v]\n        i = - 1\n        idx_y4rk = 0\n        list_36i1 = range ( l , n )\n        while idx_y4rk < len(list_36i1):\n            j = list_36i1[idx_y4rk]\n            i += 1\n            if ( s [ i ] == ('' + '(') and s [ j ] == ('' + ')') ) and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]\n            idx_hsbq = 0\n            list_a3di = range ( i , j )\n            while idx_hsbq < len(list_a3di):\n                k = list_a3di[idx_hsbq]\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n                idx_hsbq = idx_hsbq + 1\n            idx_y4rk = idx_y4rk + 1\n        idx_8y7v = idx_8y7v + 1\n    return dp [ 0 ] [ n - 1 ]", "id": "StringUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_to_26", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE"}
{"code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    idx_iokq = 0\n    list_24nt = range ( n )\n    while idx_iokq < len(list_24nt):\n        i = list_24nt[idx_iokq]\n        if ( s [ i ] == ('(' + '') ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n            invalidOpenBraces += 1\n        else :\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces += 1\n            else :\n                invalidOpenBraces -= 1\n        idx_iokq = idx_iokq + 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )", "id": "StringUnfoldding_sample_from_LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1_to_27", "old_id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1"}
{"code": "def subsequence ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = ('z' + 'yxwvutsrqponmlkjihgfedcba')\n    idx_fg37 = 0\n    list_r6qb = string\n    while idx_fg37 < len(list_r6qb):\n        ch = list_r6qb[idx_fg37]\n        cnt = 0\n        idx_5cb3 = 0\n        list_ngbi = range ( last , n )\n        while idx_5cb3 < len(list_ngbi):\n            i = list_ngbi[idx_5cb3]\n            if s [ i ] == ch and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n                cnt += 1\n            idx_5cb3 = idx_5cb3 + 1\n        if cnt >= k and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            idx_a7fj = 0\n            list_1cuv = range ( last , n )\n            while idx_a7fj < len(list_1cuv):\n                i = list_1cuv[idx_a7fj]\n                if s [ i ] == ch :\n                    t [ size ] = ch\n                    new_last = i\n                    size += 1\n                idx_a7fj = idx_a7fj + 1\n            last = new_last\n        idx_fg37 = idx_fg37 + 1\n    t[size] = ('\\0' + '');", "id": "StringUnfoldding_sample_from_LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES_to_28", "old_id": "LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES"}
{"code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    idx_eixu = 0\n    list_8xha = range ( 0 , n )\n    while idx_eixu < len(list_8xha):\n        i = list_8xha[idx_eixu]\n        idx_m2yx = 0\n        list_mwyh = range ( i + 1 , n , 2 )\n        while idx_m2yx < len(list_mwyh):\n            j = list_mwyh[idx_m2yx]\n            length = j - i + 1\n            leftsum = 0\n            rightsum = 0\n            idx_c5qk = 0\n            list_dx4k = range ( 0 , int ( length / 2 ) )\n            while idx_c5qk < len(list_dx4k):\n                k = list_dx4k[idx_c5qk]\n                leftsum += ( int ( str [ i + k ] ) - int ( ('' + '0') ) )\n                rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( ('' + '0') ) )\n                idx_c5qk = idx_c5qk + 1\n            if ( leftsum == rightsum and maxlen < length ) and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n                maxlen = length\n            idx_m2yx = idx_m2yx + 1\n        idx_eixu = idx_eixu + 1\n    return maxlen", "id": "StringUnfoldding_sample_from_LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_to_29", "old_id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF"}
{"code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    idx_y6ag = 0\n    list_ku2r = range ( 1 , n + 1 )\n    while idx_y6ag < len(list_ku2r):\n        i = list_ku2r[idx_y6ag]\n        idx_hwiz = 0\n        list_yef1 = range ( 1 , n + 1 )\n        while idx_hwiz < len(list_yef1):\n            j = list_yef1[idx_hwiz]\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n            idx_hwiz = idx_hwiz + 1\n        idx_y6ag = idx_y6ag + 1\n    res = ('' + '')\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n            i -= 1\n        else :\n            j -= 1\n    res = ('' + '').join ( reversed ( res ) )\n    return res", "id": "StringUnfoldding_sample_from_LONGEST_REPEATED_SUBSEQUENCE_1_to_30", "old_id": "LONGEST_REPEATED_SUBSEQUENCE_1"}
{"code": "def to_upper(in_list):\n    idx_q07j = 0\n    list_npmo = range(len(in_list))\n    while idx_q07j < len(list_npmo):\n        i = list_npmo[idx_q07j]\n        if ('a' + '') <= in_list[i] <= ('' + 'z') and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n            in_list[i] = chr(ord(in_list[i]) - ord(('' + 'a')) + ord(('' + 'A')))\n        idx_q07j = idx_q07j + 1\n    return ('' + '').join(in_list)", "id": "StringUnfoldding_sample_from_LOWER_CASE_UPPER_CASE_INTERESTING_FACT_to_31", "old_id": "LOWER_CASE_UPPER_CASE_INTERESTING_FACT"}
{"code": "def findMaxValue ( arr , n ) :\n    if n < 4 and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n        print ( (\"The array should have \" + \"atlest 4 elements\") )\n        return MIN\n    table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n\n    table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 )\n    idx_4asq = 0\n    list_xjm6 = range ( n - 1 , - 1 , - 1 )\n    while idx_4asq < len(list_xjm6):\n        i = list_xjm6[idx_4asq]\n        table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )\n        idx_4asq = idx_4asq + 1\n    idx_p87x = 0\n    list_yz1e = range ( n - 2 , - 1 , - 1 )\n    while idx_p87x < len(list_yz1e):\n        i = list_yz1e[idx_p87x]\n        table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] )\n        idx_p87x = idx_p87x + 1\n    idx_p7u6 = 0\n    list_e27a = range ( n - 3 , - 1 , - 1 )\n    while idx_p7u6 < len(list_e27a):\n        i = list_e27a[idx_p7u6]\n        table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] )\n        idx_p7u6 = idx_p7u6 + 1\n    idx_ocn1 = 0\n    list_htxo = range ( n - 4 , - 1 , - 1 )\n    while idx_ocn1 < len(list_htxo):\n        i = list_htxo[idx_ocn1]\n        table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] )\n        idx_ocn1 = idx_ocn1 + 1\n    return table4 [ 0 ]", "id": "StringUnfoldding_sample_from_MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L_to_32", "old_id": "MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 ) or ( arr [ 0 ] == 0 ) and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n        return float ( ('inf' + '') )\n    jumps [ 0 ] = 0\n    idx_vfym = 0\n    list_d1fz = range ( 1 , n )\n    while idx_vfym < len(list_d1fz):\n        i = list_d1fz[idx_vfym]\n        jumps [ i ] = float ( ('' + 'inf') )\n        idx_k8jx = 0\n        list_8wu9 = range ( i )\n        while idx_k8jx < len(list_8wu9):\n            j = list_8wu9[idx_k8jx]\n            if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( ('i' + 'nf') ) ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n            idx_k8jx = idx_k8jx + 1\n        idx_vfym = idx_vfym + 1\n    return jumps [ n - 1 ]", "id": "StringUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1_to_33", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1"}
{"code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    idx_wblo = 0\n    list_z4je = range ( n - 2 , - 1 , - 1 )\n    while idx_wblo < len(list_z4je):\n        i = list_z4je[idx_wblo]\n        if ( arr [ i ] == 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            jumps [ i ] = float ( ('i' + 'nf') )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( ('' + 'inf') )\n            idx_rxo4 = 0\n            list_v96i = range ( i + 1 , n )\n            while idx_rxo4 < len(list_v96i):\n                j = list_v96i[idx_rxo4]\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n                idx_rxo4 = idx_rxo4 + 1\n            if ( min != float ( ('inf' + '') ) ) :\n                jumps [ i ] = min + 1\n            else :\n                jumps [ i ] = min\n        idx_wblo = idx_wblo + 1\n    return jumps [ 0 ]", "id": "StringUnfoldding_sample_from_MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2_to_34", "old_id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2"}
{"code": "def minProductSubset ( a , n ) :\n    if ( n == 1 ) and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n        return a [ 0 ]\n    max_neg = float ( ('-inf' + '') )\n    min_pos = float ( ('inf' + '') )\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    idx_c2rd = 0\n    list_p741 = range ( 0 , n )\n    while idx_c2rd < len(list_p741):\n        i = list_p741[idx_c2rd]\n        if ( a [ i ] == 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            count_zero = count_zero + 1\n            continue\n        if ( a [ i ] < 0 ) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            count_neg = count_neg + 1\n            max_neg = max ( max_neg , a [ i ] )\n        if ( a [ i ] > 0 ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            min_pos = min ( min_pos , a [ i ] )\n        prod = prod * a [ i ]\n        idx_c2rd = idx_c2rd + 1\n    if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n        return 0\n    if ( count_neg == 0 ) and (((True or False) and (False or True)) and ((9 > 4) or (9 < 4))):\n        return min_pos\n    if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        prod = int ( prod / max_neg )\n    return prod", "id": "StringUnfoldding_sample_from_MINIMUM_PRODUCT_SUBSET_ARRAY_to_35", "old_id": "MINIMUM_PRODUCT_SUBSET_ARRAY"}
{"code": "def findMinRooms ( slots , n , m ) :\n    counts = [ 0 ] * m\n    idx_3vki = 0\n    list_5qdz = range ( n )\n    while idx_3vki < len(list_5qdz):\n        i = list_5qdz[idx_3vki]\n        idx_ne9w = 0\n        list_ai4z = range ( m )\n        while idx_ne9w < len(list_ai4z):\n            j = list_ai4z[idx_ne9w]\n            if i < len(slots) and j < len(slots[i]) and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n                if ( slots [ i ] [ j ] == ('' + '1') ) :\n                    counts [ j ] += 1\n            idx_ne9w = idx_ne9w + 1\n        idx_3vki = idx_3vki + 1\n    return max ( counts )", "id": "StringUnfoldding_sample_from_MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE_to_36", "old_id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE"}
{"code": "def compute ( str , n ) :\n    reverseAlphabet = (\"zyxwvutsrqponmlkji\" + \"hgfedcba\")\n    l = len ( str )\n    answer = (\"\" + \"\")\n    idx_cwgn = 0\n    list_k561 = range ( 0 , n )\n    while idx_cwgn < len(list_k561):\n        i = list_k561[idx_cwgn]\n        if i < l and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n            answer = answer + str [ i ]\n        idx_cwgn = idx_cwgn + 1\n    idx_wnm7 = 0\n    list_btdq = range ( n , l )\n    while idx_wnm7 < len(list_btdq):\n        i = list_btdq[idx_wnm7]\n        answer = ( answer + reverseAlphabet [ ord ( str [ i ] ) - ord ( (\"\" + \"a\") ) ] )\n        idx_wnm7 = idx_wnm7 + 1\n    return answer", "id": "StringUnfoldding_sample_from_MIRROR_CHARACTERS_STRING_to_37", "old_id": "MIRROR_CHARACTERS_STRING"}
{"code": "def countOccurrences ( s , K ) :\n    n = len ( s )\n    c1 = 0\n    c2 = 0\n    C = 0\n    idx_7aj9 = 0\n    list_s6ge = range ( n )\n    while idx_7aj9 < len(list_s6ge):\n        i = list_s6ge[idx_7aj9]\n        if s [ i ] == ('a' + '') and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n            c1 += 1\n        if s [ i ] == ('' + 'b') and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n            c2 += 1\n            C += c1\n        idx_7aj9 = idx_7aj9 + 1\n    return C * K + int ( K * ( K - 1 ) / 2 ) * c1 * c2", "id": "StringUnfoldding_sample_from_NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES_to_38", "old_id": "NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES"}
{"code": "def checkPangram ( s ) :\n    List = [ ]\n    idx_afsr = 0\n    list_1ige = range ( 26 )\n    while idx_afsr < len(list_1ige):\n        i = list_1ige[idx_afsr]\n        List.append ( False )\n        idx_afsr = idx_afsr + 1\n    idx_f37a = 0\n    list_v19t = s\n    while idx_f37a < len(list_v19t):\n        c = list_v19t[idx_f37a]\n        if ('' + 'A') <= c and c <= ('' + 'Z') and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            List [ ord ( c ) - ord ( ('' + 'A') ) ] = True\n        elif ('' + 'a') <= c and c <= ('z' + ''):\n            List [ ord ( c ) - ord ( ('' + 'a') ) ] = True\n        idx_f37a = idx_f37a + 1\n    idx_elhm = 0\n    list_24st = List\n    while idx_elhm < len(list_24st):\n        ch = list_24st[idx_elhm]\n        if ch == False and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            return False\n        idx_elhm = idx_elhm + 1\n    return True", "id": "StringUnfoldding_sample_from_PANGRAM_CHECKING_to_39", "old_id": "PANGRAM_CHECKING"}
{"code": "def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) :\n    print ( (\"Point in\" + \"side the viewing pane:\") )\n    idx_ledk = 0\n    list_6tlx = range ( n )\n    while idx_ledk < len(list_6tlx):\n        i = list_6tlx[idx_ledk]\n        if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) :\n                print ( (\"[\" + \"\") , XY [ i ] [ 0 ] , (\"\" + \", \") , XY [ i ] [ 1 ] , (\"]\" + \"\") , sep = (\"\" + \"\") , end = (\"\" + \"\") )\n        idx_ledk = idx_ledk + 1\n    print ( (\"\\n\\nPoint outside the viewing \" + \"pane:\") )\n    idx_zqis = 0\n    list_2yuw = range ( n )\n    while idx_zqis < len(list_2yuw):\n        i = list_2yuw[idx_zqis]\n        if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            print ( (\"\" + \"[\") , XY [ i ] [ 0 ] , (\"\" + \", \") , XY [ i ] [ 1 ] , (\"\" + \"]\") , sep = (\"\" + \"\") , end = (\"\" + \"\") )\n        if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n            print ( (\"\" + \"[\") , XY [ i ] [ 0 ] , (\"\" + \", \") , XY [ i ] [ 1 ] , (\"\" + \"]\") , sep = (\"\" + \"\") , end = (\"\" + \"\") )\n        idx_zqis = idx_zqis + 1", "id": "StringUnfoldding_sample_from_POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS_to_40", "old_id": "POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS"}
{"code": "def noAdjacentDup ( s ) :\n    n = len ( s )\n    idx_0wmj = 0\n    list_k3ts = range ( 1 , n )\n    while idx_0wmj < len(list_k3ts):\n        i = list_k3ts[idx_0wmj]\n        if ( s [ i ] == s [ i - 1 ] ) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n            s [ i ] = (\"\" + \"a\")\n            while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) :\n                s [ i ] += 1\n            i += 1\n        idx_0wmj = idx_0wmj + 1\n    return s", "id": "StringUnfoldding_sample_from_PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES_to_41", "old_id": "PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES"}
{"code": "def antiSpiralTraversal ( m , n , a ) :\n    k = 0\n    l = 0\n    stk = [ ]\n    while ( k <= m and l <= n ) :\n        idx_m0qg = 0\n        list_jrdq = range ( l , n + 1 )\n        while idx_m0qg < len(list_jrdq):\n            i = list_jrdq[idx_m0qg]\n            stk.append ( a [ k ] [ i ] )\n            idx_m0qg = idx_m0qg + 1\n        k += 1\n        idx_3pve = 0\n        list_oz9p = range ( k , m + 1 )\n        while idx_3pve < len(list_oz9p):\n            i = list_oz9p[idx_3pve]\n            stk.append ( a [ i ] [ n ] )\n            idx_3pve = idx_3pve + 1\n        n -= 1\n        if ( k <= m ) and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            idx_ke9t = 0\n            list_a81k = range ( n , l - 1 , - 1 )\n            while idx_ke9t < len(list_a81k):\n                i = list_a81k[idx_ke9t]\n                stk.append ( a [ m ] [ i ] )\n                idx_ke9t = idx_ke9t + 1\n            m -= 1\n        if ( l <= n ) and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            idx_ycvx = 0\n            list_vazr = range ( m , k - 1 , - 1 )\n            while idx_ycvx < len(list_vazr):\n                i = list_vazr[idx_ycvx]\n                stk.append ( a [ i ] [ l ] )\n                idx_ycvx = idx_ycvx + 1\n            l += 1\n    while len ( stk ) != 0 :\n        print ( str ( stk [ - 1 ] ) , end = (\"\" + \" \") )\n        stk.pop ( )", "id": "StringUnfoldding_sample_from_PRINT_MATRIX_ANTISPIRAL_FORM_to_42", "old_id": "PRINT_MATRIX_ANTISPIRAL_FORM"}
{"code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_vb5y = 0\n    list_1hu3 = range ( n )\n    while idx_vb5y < len(list_1hu3):\n        i = list_1hu3[idx_vb5y]\n        bestIdx = - 1\n        idx_szrb = 0\n        list_tjru = range ( m )\n        while idx_szrb < len(list_tjru):\n            j = list_tjru[idx_szrb]\n            if blockSize [ j ] >= processSize [ i ] and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n            idx_szrb = idx_szrb + 1\n        if bestIdx != - 1 and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n        idx_vb5y = idx_vb5y + 1\n    print ( (\"Process\" + \" No.Process Size     Block no.\") )\n    idx_mgbd = 0\n    list_7nd3 = range ( n )\n    while idx_mgbd < len(list_7nd3):\n        i = list_7nd3[idx_mgbd]\n        print ( i + 1 , (\"      \" + \"   \") , processSize [ i ] , end = (\"        \" + \" \") )\n        if allocation [ i ] != - 1 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( (\"N\" + \"ot Allocated\") )\n        idx_mgbd = idx_mgbd + 1", "id": "StringUnfoldding_sample_from_PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_43", "old_id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def binaryToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base1 = 1\n    len1 = len ( num )\n    idx_8l7d = 0\n    list_s58x = range ( len1 - 1 , - 1 , - 1 )\n    while idx_8l7d < len(list_s58x):\n        i = list_s58x[idx_8l7d]\n        if ( num [ i ] == ('' + '1') ) and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n            dec_value += base1\n        base1 = base1 * 2\n        idx_8l7d = idx_8l7d + 1\n    return dec_value", "id": "StringUnfoldding_sample_from_PROGRAM_BINARY_DECIMAL_CONVERSION_1_to_44", "old_id": "PROGRAM_BINARY_DECIMAL_CONVERSION_1"}
{"code": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = ('' + '')\n    stars = ('*' + '') * len ( word )\n    count = 0\n    index = 0\n    idx_ofsm = 0\n    list_1lyz = word_list\n    while idx_ofsm < len(list_1lyz):\n        i = list_1lyz[idx_ofsm]\n        if i == word and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n            word_list [ index ] = stars\n        index += 1\n        idx_ofsm = idx_ofsm + 1\n    result = ('' + ' ').join ( word_list )\n    return result", "id": "StringUnfoldding_sample_from_PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE_to_45", "old_id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE"}
{"code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n        return False\n    _sum = 0\n    idx_r7bk = 0\n    list_4fpn = range ( 9 )\n    while idx_r7bk < len(list_4fpn):\n        i = list_4fpn[idx_r7bk]\n        if 0 <= int ( isbn [ i ] ) <= 9 and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n            _sum += int ( isbn [ i ] ) * ( 10 - i )\n        else :\n            return False\n        idx_r7bk = idx_r7bk + 1\n    if ( isbn [ 9 ] != ('X' + '') and 0 <= int ( isbn [ 9 ] ) <= 9 ) and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n        return False\n    _sum += 10 if isbn [ 9 ] == ('X' + '') else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )", "id": "StringUnfoldding_sample_from_PROGRAM_CHECK_ISBN_to_46", "old_id": "PROGRAM_CHECK_ISBN"}
{"code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    idx_e12p = 0\n    list_uos1 = range ( n )\n    while idx_e12p < len(list_uos1):\n        i = list_uos1[idx_e12p]\n        wstIdx = - 1\n        idx_rw4s = 0\n        list_jzgb = range ( m )\n        while idx_rw4s < len(list_jzgb):\n            j = list_jzgb[idx_rw4s]\n            if blockSize [ j ] >= processSize [ i ] and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n            idx_rw4s = idx_rw4s + 1\n        if wstIdx != - 1 and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n        idx_e12p = idx_e12p + 1\n    print ( (\"Proces\" + \"s No.Process Size Block no.\") )\n    idx_96rk = 0\n    list_rpco = range ( n )\n    while idx_96rk < len(list_rpco):\n        i = list_rpco[idx_96rk]\n        print ( i + 1 , (\"     \" + \"    \") , processSize [ i ] , end = (\"   \" + \"  \") )\n        if allocation [ i ] != - 1 and (((True or False) and (False or True)) and ((8 > 6) or (8 < 6))):\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( (\"Not Allo\" + \"cated\") )\n        idx_96rk = idx_96rk + 1", "id": "StringUnfoldding_sample_from_PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT_to_47", "old_id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT"}
{"code": "def arrayEvenAndOdd ( arr , n ) :\n    i = - 1\n    j = 0\n    while ( j != n ) :\n        if ( arr [ j ] % 2 == 0 ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            i = i + 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n        j = j + 1\n    idx_yxgb = 0\n    list_k7sx = arr\n    while idx_yxgb < len(list_k7sx):\n        i = list_k7sx[idx_yxgb]\n        print ( str ( i ) + (\"\" + \" \") , end = ('' + '') )\n        idx_yxgb = idx_yxgb + 1", "id": "StringUnfoldding_sample_from_SEGREGATE_EVEN_ODD_NUMBERS_SET_3_to_48", "old_id": "SEGREGATE_EVEN_ODD_NUMBERS_SET_3"}
{"code": "def diagonalsquare ( mat , row , column ) :\n    print ( (\"Diagonal one : \" + \"\") , end = (\"\" + \"\") )\n    idx_8bja = 0\n    list_todb = range ( 0 , row )\n    while idx_8bja < len(list_todb):\n        i = list_todb[idx_8bja]\n        idx_sk31 = 0\n        list_zni6 = range ( 0 , column )\n        while idx_sk31 < len(list_zni6):\n            j = list_zni6[idx_sk31]\n            if ( i == j ) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n                print ( (\"\" + \"{} \").format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = (\"\" + \"\") )\n            idx_sk31 = idx_sk31 + 1\n        idx_8bja = idx_8bja + 1\n    print ( (\" \\n\\nDiagonal \" + \"two : \") , end = (\"\" + \"\") )\n    idx_jnqs = 0\n    list_ap1o = range ( 0 , row )\n    while idx_jnqs < len(list_ap1o):\n        i = list_ap1o[idx_jnqs]\n        idx_w8fk = 0\n        list_5hkz = range ( 0 , column )\n        while idx_w8fk < len(list_5hkz):\n            j = list_5hkz[idx_w8fk]\n            if ( i + j == column - 1 ) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n                print ( (\"{}\" + \" \").format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = (\"\" + \"\") )\n            idx_w8fk = idx_w8fk + 1\n        idx_jnqs = idx_jnqs + 1", "id": "StringUnfoldding_sample_from_SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_to_49", "old_id": "SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS"}
{"code": "def firstLetterWord ( str ) :\n    result = (\"\" + \"\")\n    v = True\n    idx_w73b = 0\n    list_2led = range ( len ( str ) )\n    while idx_w73b < len(list_2led):\n        i = list_2led[idx_w73b]\n        if ( str [ i ] == ('' + ' ') ) and (((True or False) and (False or True)) and ((9 > 1) or (9 < 1))):\n            v = True\n        elif ( str [ i ] != (' ' + '') and v == True ) :\n            result += ( str [ i ] )\n            v = False\n        idx_w73b = idx_w73b + 1\n    return result", "id": "StringUnfoldding_sample_from_STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES_to_50", "old_id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES"}
{"code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    idx_ejob = 0\n    list_l7h8 = range ( n )\n    while idx_ejob < len(list_l7h8):\n        i = list_l7h8[idx_ejob]\n        if ( tree [ i ] == ('(' + '') ) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n            level += 1\n        elif ( tree [ i ] == (')' + '') ) :\n            level -= 1\n        else :\n            if ( level == k ) :\n                sum += ( ord ( tree [ i ] ) - ord ( ('0' + '') ) )\n        idx_ejob = idx_ejob + 1\n    return sum", "id": "StringUnfoldding_sample_from_SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_to_51", "old_id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING"}
{"code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = (\"\" + \"\")\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    idx_5lnf = 0\n    list_nif8 = range(n1)\n    while idx_5lnf < len(list_nif8):\n        i = list_nif8[idx_5lnf]\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if sum < 0 and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = int(sum / 10)\n        idx_5lnf = idx_5lnf + 1\n    idx_fjve = 0\n    list_rihq = range(n1, n2)\n    while idx_fjve < len(list_rihq):\n        i = list_rihq[idx_fjve]\n        sum = ((ord(str2[i]) - 48) + carry)\n        if sum < 0 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n        idx_fjve = idx_fjve + 1\n    if (carry) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str", "id": "StringUnfoldding_sample_from_SUM_TWO_LARGE_NUMBERS_to_52", "old_id": "SUM_TWO_LARGE_NUMBERS"}
{"code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n        print ( (\" In\" + \"valid Input \") )\n        return\n    first = arr [ 0 ]\n    idx_d03x = 0\n    list_rbyu = range ( 1 , arr_size )\n    while idx_d03x < len(list_rbyu):\n        i = list_rbyu[idx_d03x]\n        if ( arr [ i ] > first ) and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            first = arr [ i ]\n        idx_d03x = idx_d03x + 1\n    second = - sys.maxsize\n    idx_ou0a = 0\n    list_23h5 = range ( 0 , arr_size )\n    while idx_ou0a < len(list_23h5):\n        i = list_23h5[idx_ou0a]\n        if ( arr [ i ] > second and arr [ i ] < first ) and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n            second = arr [ i ]\n        idx_ou0a = idx_ou0a + 1\n    third = - sys.maxsize\n    idx_yd4q = 0\n    list_qcl1 = range ( 0 , arr_size )\n    while idx_yd4q < len(list_qcl1):\n        i = list_qcl1[idx_yd4q]\n        if ( arr [ i ] > third and arr [ i ] < second ) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            third = arr [ i ]\n        idx_yd4q = idx_yd4q + 1\n    print ( (\"The Third L\" + \"argest\") , (\"el\" + \"ement is\") , third )", "id": "StringUnfoldding_sample_from_THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_to_53", "old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS"}
{"code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) and (((True or False) and (False or True)) and ((7 > 3) or (7 < 3))):\n        print ( (\" Invalid\" + \" Input \") )\n        return\n    first = arr [ 0 ]\n    second = - sys.maxsize\n    third = - sys.maxsize\n    idx_m09i = 0\n    list_gv1o = range ( 1 , arr_size )\n    while idx_m09i < len(list_gv1o):\n        i = list_gv1o[idx_m09i]\n        if ( arr [ i ] > first ) and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n            third = second\n            second = first\n            first = arr [ i ]\n        elif ( arr [ i ] > second ) :\n            third = second\n            second = arr [ i ]\n        elif ( arr [ i ] > third ) :\n            third = arr [ i ]\n        idx_m09i = idx_m09i + 1\n    print ( (\"The \" + \"third Largest\") , (\"elem\" + \"ent is\") , third )", "id": "StringUnfoldding_sample_from_THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1_to_54", "old_id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1"}
{"code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    idx_31hs = 0\n    list_pein = range ( 0 , n , 1 )\n    while idx_31hs < len(list_pein):\n        i = list_pein[idx_31hs]\n        if ( str [ i ] == ('' + '1') ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            one_count += 1\n        else :\n            zero_count += 1\n        idx_31hs = idx_31hs + 1\n    if ( one_count % 2 == 0 ) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n        return zero_count\n    return one_count", "id": "StringUnfoldding_sample_from_WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO_to_55", "old_id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO"}
