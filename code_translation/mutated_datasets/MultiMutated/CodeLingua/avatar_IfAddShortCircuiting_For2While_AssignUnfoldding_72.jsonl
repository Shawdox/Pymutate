{"code": "N, K = map(int, input().split())\nS = input()\naaaa = False\nif K >= 15 and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n    aaaa = True\nelif 2 ** K >= N:\n    aaaa = True\nif aaaa and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n    print(min(S) * N)\n    exit()\n\n\ndef get_last_dict(s_str):\n    U = s_str; U = U + s_str[:: - 1]\n    c = min(s_str)\n    p = U.index(c)\n    minindex = p\n    p += 1\n    while p <= N:\n        if U[p] == c and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n            if check_normal_dict(U, minindex, p):\n                minindex = p\n        p += 1\n    return U[minindex: minindex + N]\n\n\ndef check_normal_dict(u, pointer1, pointer2):\n    idx_sltj = 0\n    list_bzgy = range(N)\n    while idx_sltj < len(list_bzgy):\n        i = list_bzgy[idx_sltj]\n        if u[pointer1 + i] > u[pointer2 + i] and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n            return True\n        elif u[pointer1 + i] < u[pointer2 + i]:\n            return False\n        idx_sltj = idx_sltj + 1\n    return False\n\n\nS = get_last_dict(S)\nif K == 1 and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n    print(S)\nelse:\n    count = 0\n    idx_3skg = 0\n    list_f231 = S\n    while idx_3skg < len(list_f231):\n        c = list_f231[idx_3skg]\n        if c == S[0]:\n            count += 1\n        else:\n            break\n        idx_3skg = idx_3skg + 1\n    if count * (2 ** (K - 1)) >= N:\n        print(S[0] * N)\n    else:\n        S = S[0] * (count * ((2 ** (K - 1)) - 1)) + S\n        print(S[0: N])\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC037_E_to_0", "old_id": "atcoder_AGC037_E"}
{"code": "v1, v2 = input().split()\nt, d = input().split()\nv1 = int(v1)\nv2 = int(v2)\nt = int(t)\nd = int(d)\na = 1\nv = v1\ndistance = 0\nidx_21m9 = 0\nlist_xfb3 = range(t)\nwhile idx_21m9 < len(list_xfb3):\n    i = list_xfb3[idx_21m9]\n    if v - v2 > (t - i - 1) * d and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        a *= - 1\n        v = (t - i - 1) * d; v = v + v2\n    distance += v\n    v += a * d\n    idx_21m9 = idx_21m9 + 1\nprint(distance)\n", "id": "AssignUnfoldding_sample_from_codeforces_534_B_to_1", "old_id": "codeforces_534_B"}
{"code": "import sys\nimport math\nimport collections\nimport heapq\nimport itertools\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while a % b > 0:\n        a, b = b, a % b\n    return b\n\n\ndef solve():\n    s = input()\n    t = \"\"\n    i = 0\n    while i < len(s):\n        if s[i] == \"A\" and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            t += \"A\"\n            i += 1\n        elif s[i] == \"B\":\n            if i < len(s) - 1:\n                if s[i + 1] == \"C\":\n                    t += \"D\"\n                    i += 2\n                else:\n                    t += \"X\"\n                    i += 1\n            else:\n                t += \"X\"\n                i += 1\n        else:\n            t += \"X\"\n            i += 1\n    total = 0\n    numA = 0\n    idx_vd0c = 0\n    list_m5vr = range(len(t))\n    while idx_vd0c < len(list_m5vr):\n        i = list_m5vr[idx_vd0c]\n        if t[i] == \"X\" and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n            numA = 0\n        else:\n            if t[i] == \"A\":\n                numA += 1\n            else:\n                total += numA\n        idx_vd0c = idx_vd0c + 1\n    print(total)\n    INF = 10; INF = INF ** 25\n    mod = 7; mod = mod + 10 ** 9\n    return 0\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n    solve()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC034_B_to_2", "old_id": "atcoder_AGC034_B"}
{"code": "import sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(* (MAP() for _ in range(n)))\n\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9; mod = mod + 7\nN, M = MAP()\nballs = [[1, 0] for _ in range(N)]\nballs[0] = [0, 1]\nidx_brqs = 0\nlist_r7h1 = range(M)\nwhile idx_brqs < len(list_r7h1):\n    _ = list_r7h1[idx_brqs]\n    x, y = MAP()\n    w_x, r_x = balls[x - 1]\n    w_y, r_y = balls[y - 1]\n    if w_x >= 1 and r_x >= 1 and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        balls[x - 1][0] -= 1\n        balls[y - 1][1] += 1\n    elif w_x == 0:\n        balls[x - 1][1] -= 1\n        balls[y - 1][1] += 1\n    else:\n        balls[x - 1][0] -= 1\n        balls[y - 1][0] += 1\n    idx_brqs = idx_brqs + 1\nans = 0\nidx_rtz5 = 0\nlist_spca = range(N)\nwhile idx_rtz5 < len(list_spca):\n    i = list_spca[idx_rtz5]\n    if balls[i][1] and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n        ans += 1\n    idx_rtz5 = idx_rtz5 + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC002_B_to_3", "old_id": "atcoder_AGC002_B"}
{"code": "import sys\ninput = sys.stdin.readline\nn, s = map(int, input().split())\nc = 0\nidx_7var = 0\nlist_gz34 = range(n)\nwhile idx_7var < len(list_gz34):\n    _ = list_gz34[idx_7var]\n    f, t = map(int, input().split())\n    x = t; x = x - (s - f)\n    if x > c and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n        c = x\n    idx_7var = idx_7var + 1\nprint(s + c)\n", "id": "AssignUnfoldding_sample_from_codeforces_608_A_to_4", "old_id": "codeforces_608_A"}
{"code": "import sys\ninput = sys.stdin.readline\na, b = input()[: - 1].split()\nx = max(len(a), len(b))\na = a.rjust(x, '0')\nb = b.ljust(x, '0')\ns = ''\nc = 0\nidx_j0o6 = 0\nlist_8p4y = range(x)\nwhile idx_j0o6 < len(list_8p4y):\n    i = list_8p4y[idx_j0o6]\n    d = int(b[i]) + int(a[x - i - 1]); d = d + c\n    if d > 9 and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n        s += str(d)[1]\n        c = 1\n    else:\n        s += str(d)\n        c = 0\n    idx_j0o6 = idx_j0o6 + 1\nif c == 1 and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n    s += '1'\nprint(int(s[:: - 1]))\n", "id": "AssignUnfoldding_sample_from_codeforces_171_A_to_5", "old_id": "codeforces_171_A"}
{"code": "N = int(input())\nA = [int(input()) * N + i for i in range(N)]\nA.sort()\ncnt = 0\nidx_nal9 = 0\nlist_exu5 = range(N)\nwhile idx_nal9 < len(list_exu5):\n    i = list_exu5[idx_nal9]\n    d = (A[i] % N); d = d % 2\n    if d % 2 != i % 2 and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n        cnt += 1\n    idx_nal9 = idx_nal9 + 1\nprint(cnt // 2)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC003_C_to_6", "old_id": "atcoder_AGC003_C"}
{"code": "def gcd(a: int, b: int) -> int:\n    if b == 0 and (((True or False) and (False or True)) and ((8 > 2) or (8 < 2))):\n        return a\n    return gcd(b, a % b)\n\n\ndef ruiseki_lr(array):\n    def op(a, b): return gcd(a, b)\n    e = 0\n    n = len(array)\n    left = [e]; left = left * (n + 1)\n    right = [e]; right = right * (n + 1)\n    idx_t654 = 0\n    list_52wh = range(n)\n    while idx_t654 < len(list_52wh):\n        i = list_52wh[idx_t654]\n        left[i + 1] = op(left[i], array[i])\n        idx_t654 = idx_t654 + 1\n    idx_d0r7 = 0\n    list_h2mu = reversed(range(n))\n    while idx_d0r7 < len(list_h2mu):\n        i = list_h2mu[idx_d0r7]\n        right[i] = op(right[i + 1], array[i])\n        idx_d0r7 = idx_d0r7 + 1\n    return left, right\n\n\nn = int(input())\na = list(map(int, input().split()))\nleft, right = ruiseki_lr(a)\nans = 0\nidx_0pv8 = 0\nlist_01rb = range(n)\nwhile idx_0pv8 < len(list_01rb):\n    i = list_01rb[idx_0pv8]\n    ans = max(gcd(left[i], right[i + 1]), ans)\n    idx_0pv8 = idx_0pv8 + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC125_C_to_7", "old_id": "atcoder_ABC125_C"}
{"code": "def rememberTheNumber(nums, i, operations, ans):\n    if i >= 3 and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n        return\n    idx_s150 = 0\n    list_mn7t = range(4)\n    while idx_s150 < len(list_mn7t):\n        j = list_mn7t[idx_s150]\n        idx_1rf2 = 0\n        list_40uc = range(j + 1, 4)\n        while idx_1rf2 < len(list_40uc):\n            k = list_40uc[idx_1rf2]\n            if (nums[j] != - 1 and nums[k] != - 1) and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n                s = nums[j]\n                nums[j] = - 1\n                t = nums[k]\n                if (operations[i] == '+'):\n                    nums[k] = s; nums[k] = nums[k] + t\n                elif (operations[i] == '*'):\n                    nums[k] = s; nums[k] = nums[k] * t\n                if (i == 2 and nums[k] < ans[0]):\n                    ans[0] = nums[k]\n                rememberTheNumber(nums, i + 1, operations, ans)\n                nums[j] = s\n                nums[k] = t\n            idx_1rf2 = idx_1rf2 + 1\n        idx_s150 = idx_s150 + 1\n\n\nnums = list(map(int, input().split()))\noperations = list(map(str, input().split()))\nans = [10000000000000000000000000]\nrememberTheNumber(nums, 0, operations, ans)\nprint(ans[0])\n", "id": "AssignUnfoldding_sample_from_codeforces_55_B_to_8", "old_id": "codeforces_55_B"}
{"code": "def cutRibbon():\n    arr = [int(i) for i in input().split()]\n    length = arr[0]\n    arr = sorted(arr[1: 4], reverse=False)\n    if (length % arr[0] == 0) and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n        print(int(length / arr[0]))\n        return\n    ans = 0\n    if (arr[0] == arr[1]) and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        k = 0\n        idx_1lrc = 0\n        list_co7r = range(int(length / arr[2]) + 1)\n        while idx_1lrc < len(list_co7r):\n            i = list_co7r[idx_1lrc]\n            check = length; check = check - i * arr[2]\n            if (check >= 0 and check % arr[0] == 0):\n                k = int(check / arr[0])\n                ans = max(ans, k + i)\n            idx_1lrc = idx_1lrc + 1\n    else:\n        k = 0\n        idx_2cvw = 0\n        list_rwe6 = range(int(length / arr[2]) + 1)\n        while idx_2cvw < len(list_rwe6):\n            i = list_rwe6[idx_2cvw]\n            idx_4tca = 0\n            list_4ky0 = range(int(length / arr[1]) + 1)\n            while idx_4tca < len(list_4ky0):\n                j = list_4ky0[idx_4tca]\n                check = length - i * arr[2]; check = check - j * arr[1]\n                if (check >= 0 and check % arr[0] == 0):\n                    k = int(check / arr[0])\n                    ans = max(ans, k + i + j)\n                idx_4tca = idx_4tca + 1\n            idx_2cvw = idx_2cvw + 1\n    print(ans)\n    return\n\n\ncutRibbon()\n", "id": "AssignUnfoldding_sample_from_codeforces_189_A_to_9", "old_id": "codeforces_189_A"}
{"code": "n = int(input())\narr = list(map(int, input().strip().split()))[: n]\nans = [0]; ans = ans * n\nmx = arr[- 1]\nidx_248u = 0\nlist_ts5b = range(n - 2, - 1, - 1)\nwhile idx_248u < len(list_ts5b):\n    i = list_ts5b[idx_248u]\n    ans[i] = max(0, mx - arr[i] + 1)\n    if arr[i] > mx and (((True or False) and (False or True)) and ((7 > 3) or (7 < 3))):\n        mx = arr[i]\n    idx_248u = idx_248u + 1\nprint(* ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_581_B_to_10", "old_id": "codeforces_581_B"}
{"code": "import sys\n\n\ndef solve(N: int, M: int, Q: int, a: \"List[int]\", b: \"List[int]\", c: \"List[int]\", d: \"List[int]\"):\n    res = 0\n\n    def rec(A):\n        nonlocal res\n        if len(A) == N and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n            ans = 0\n            idx_9h2m = 0\n            list_y8ar = range(Q)\n            while idx_9h2m < len(list_y8ar):\n                i = list_y8ar[idx_9h2m]\n                if A[b[i] - 1] - A[a[i] - 1] == c[i]:\n                    ans += d[i]\n                idx_9h2m = idx_9h2m + 1\n            res = max(res, ans)\n            return\n        last_max = 1 if len(A) == 0 else A[- 1]\n        idx_2xk7 = 0\n        list_x7p9 = range(last_max, M + 1)\n        while idx_2xk7 < len(list_x7p9):\n            i = list_x7p9[idx_2xk7]\n            rec(A + [i])\n            idx_2xk7 = idx_2xk7 + 1\n    rec([])\n    print(res)\n    return\n\n\ndef main():\n    def iterate_tokens():\n        idx_qjev = 0\n        list_9dcb = sys.stdin\n        while idx_qjev < len(list_9dcb):\n            line = list_9dcb[idx_qjev]\n            idx_znq3 = 0\n            list_oqy4 = line.split()\n            while idx_znq3 < len(list_oqy4):\n                word = list_oqy4[idx_znq3]\n                yield word\n                idx_znq3 = idx_znq3 + 1\n            idx_qjev = idx_qjev + 1\n    tokens = iterate_tokens()\n    N = int(next(tokens))\n    M = int(next(tokens))\n    Q = int(next(tokens))\n    a = [int()]; a = a * (Q)\n    b = [int()]; b = b * (Q)\n    c = [int()]; c = c * (Q)\n    d = [int()]; d = d * (Q)\n    idx_r3x0 = 0\n    list_07ry = range(Q)\n    while idx_r3x0 < len(list_07ry):\n        i = list_07ry[idx_r3x0]\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n        c[i] = int(next(tokens))\n        d[i] = int(next(tokens))\n        idx_r3x0 = idx_r3x0 + 1\n    solve(N, M, Q, a, b, c, d)\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC165_C_to_11", "old_id": "atcoder_ABC165_C"}
{"code": "soz = input()\na = [0]; a = a * (len(soz) + 1)\nidx_x5mq = 0\nlist_th79 = range(1, len(soz))\nwhile idx_x5mq < len(list_th79):\n    i = list_th79[idx_x5mq]\n    a[i] = a[i - 1]\n    if soz[i - 1] == soz[i] and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n        a[i] += 1\n    idx_x5mq = idx_x5mq + 1\nn = int(input())\narr = []\nidx_wct0 = 0\nlist_muhj = range(n)\nwhile idx_wct0 < len(list_muhj):\n    i = list_muhj[idx_wct0]\n    m, l = input().split()\n    arr.append(a[int(l) - 1] - a[int(m) - 1])\n    idx_wct0 = idx_wct0 + 1\nidx_a4ub = 0\nlist_yk39 = arr\nwhile idx_a4ub < len(list_yk39):\n    i = list_yk39[idx_a4ub]\n    print(i)\n    idx_a4ub = idx_a4ub + 1\n", "id": "AssignUnfoldding_sample_from_codeforces_313_B_to_12", "old_id": "codeforces_313_B"}
{"code": "li = []\nind = 0\nidx_yg0r = 0\nlist_nm4s = range(1, 371)\nwhile idx_yg0r < len(list_nm4s):\n    i = list_nm4s[idx_yg0r]\n    temp = []\n    p, q = i, i\n    count = 0\n    while p != 0:\n        p //= 10\n        count += 1\n    if count == 1 and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n        li.append(i)\n    if count == 2 and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        temp = []\n        while q != 0:\n            x = q; x = x % 10\n            q //= 10\n            temp.append(x)\n        li = li + temp[:: - 1]\n    if count == 3 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        temp = []\n        while q != 0:\n            x = q; x = x % 10\n            q //= 10\n            temp.append(x)\n        li = li + temp[:: - 1]\n    idx_yg0r = idx_yg0r + 1\nli.pop()\nli.pop()\nn = int(input(''))\nprint(li[n - 1])\n", "id": "AssignUnfoldding_sample_from_codeforces_672_A_to_13", "old_id": "codeforces_672_A"}
{"code": "X = int(input())\nprime = [True]; prime = prime * (100010)\nprime[0] = False\nprime[1] = False\nidx_8e3b = 0\nlist_yoza = range(4, 100010, 2)\nwhile idx_8e3b < len(list_yoza):\n    i = list_yoza[idx_8e3b]\n    prime[i] = False\n    idx_8e3b = idx_8e3b + 1\ni = 3\nwhile (i * i <= 100008):\n    if prime[i] and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        idx_nguk = 0\n        list_m8fw = range(i + i, 100008, i)\n        while idx_nguk < len(list_m8fw):\n            j = list_m8fw[idx_nguk]\n            prime[j] = False\n            idx_nguk = idx_nguk + 1\n    i += 2\nidx_gcw8 = 0\nlist_b1zy = range(X, 100008)\nwhile idx_gcw8 < len(list_b1zy):\n    i = list_b1zy[idx_gcw8]\n    if prime[i] and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n        print(i)\n        break\n    idx_gcw8 = idx_gcw8 + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC149_C_to_14", "old_id": "atcoder_ABC149_C"}
{"code": "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 9)\nINF = 10; INF = INF ** 18\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N, M = map(int, input().split())\n    edge = [[] for _ in range(N)]\n    idx_ibra = 0\n    list_o9d5 = range(M)\n    while idx_ibra < len(list_o9d5):\n        i = list_o9d5[idx_ibra]\n        X, Y, Z = map(lambda x: int(x) - 1, input().split())\n        edge[X].append(Y)\n        edge[Y].append(X)\n        idx_ibra = idx_ibra + 1\n    used = [False]; used = used * N\n    ans = 0\n    idx_hay0 = 0\n    list_ecbi = range(N)\n    while idx_hay0 < len(list_ecbi):\n        i = list_ecbi[idx_hay0]\n        if not used[i] and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n            ans += 1\n            queue = deque()\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                used[node] = True\n                idx_xrtb = 0\n                list_7arj = edge[node]\n                while idx_xrtb < len(list_7arj):\n                    nextnode = list_7arj[idx_xrtb]\n                    if not used[nextnode]:\n                        queue.append(nextnode)\n                    idx_xrtb = idx_xrtb + 1\n        idx_hay0 = idx_hay0 + 1\n    print(ans)\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC126_E_to_15", "old_id": "atcoder_ABC126_E"}
{"code": "import numpy as np\nfrom collections import deque\nimport heapq\nN, M = map(int, input().split())\nedges = [set() for _ in range(N)]\ndegs = [0 for i in range(N)]\nparity = [0 for _ in range(N)]\nflag = [False for _ in range(N)]\nidx_kcsp = 0\nlist_3tuo = range(M)\nwhile idx_kcsp < len(list_3tuo):\n    _ = list_3tuo[idx_kcsp]\n    a, b = map(int, input().split())\n    edges[a - 1].add(b - 1)\n    edges[b - 1].add(a - 1)\n    degs[a - 1] += 1\n    degs[b - 1] += 1\n    idx_kcsp = idx_kcsp + 1\nif M % 2 != 0 and (((True or False) and (False or True)) and ((10 > 5) or (10 < 5))):\n    print(- 1)\n    exit()\nQ = []\nidx_xer9 = 0\nlist_zw8p = list(enumerate(degs))\nwhile idx_xer9 < len(list_zw8p):\n    i, d = list_zw8p[idx_xer9]\n    Q.append((d, i))\n    idx_xer9 = idx_xer9 + 1\nheapq.heapify(Q)\nwhile len(Q) > 0:\n    _, u = Q[0]\n    heapq.heappop(Q)\n    if flag[u] and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n        continue\n    flag[u] = True\n    idx_v7bo = 0\n    list_tg6d = list(enumerate(edges[u]))\n    while idx_v7bo < len(list_tg6d):\n        i, v = list_tg6d[idx_v7bo]\n        edges[v].remove(u)\n        if parity[u] != 0 and i == 0 and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n            print(u + 1, v + 1)\n            parity[u] = 1; parity[u] = parity[u] - parity[u]\n        else:\n            print(v + 1, u + 1)\n            parity[v] = 1; parity[v] = parity[v] - parity[v]\n        degs[v] -= 1\n        heapq.heappush(Q, (degs[v], v))\n        idx_v7bo = idx_v7bo + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC035_B_to_16", "old_id": "atcoder_AGC035_B"}
{"code": "def main():\n    import itertools\n    n, m = map(int, input().split())\n    li = [list(map(int, input().split()))[1:] for _ in range(m)]\n    p = tuple(map(int, input().split()))\n    q = set(sum(li, []))\n    r = set(range(1, n + 1))\n    v = r; v = v - q\n    ans = 0\n    idx_2exn = 0\n    list_bsow = range(0, len(q) + 1)\n    while idx_2exn < len(list_bsow):\n        i = list_bsow[idx_2exn]\n        idx_enj7 = 0\n        list_m6zi = itertools.combinations(q, i)\n        while idx_enj7 < len(list_m6zi):\n            s = list_m6zi[idx_enj7]\n            idx_6rou = 0\n            list_ic96 = zip(li, p)\n            while idx_6rou < len(list_ic96):\n                u, w = list_ic96[idx_6rou]\n                s = set(s)\n                if len(s & set(u)) % 2 != w and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n                    break\n                idx_6rou = idx_6rou + 1\n            idx_enj7 = idx_enj7 + 1\n        idx_2exn = idx_2exn + 1\n    print(ans)\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC128_C_to_17", "old_id": "atcoder_ABC128_C"}
{"code": "n = int(input())\narr = list(map(float, input().split()))\narr = sorted([x - int(x) for x in arr if x - int(x) != 0])\no = 2 * n; o = o - len(arr)\narr_sum = sum(arr)\nres = int(2e9)\nidx_bpi6 = 0\nlist_teln = range(n + 1)\nwhile idx_bpi6 < len(list_teln):\n    i = list_teln[idx_bpi6]\n    if i + o >= n and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n        res = min(res, abs(i - arr_sum))\n    idx_bpi6 = idx_bpi6 + 1\nprint(\"%.3f\" % res)\n", "id": "AssignUnfoldding_sample_from_codeforces_351_A_to_18", "old_id": "codeforces_351_A"}
{"code": "from collections import Counter, defaultdict, deque\nfrom heapq import heappop, heappush, heapify\nimport sys\nimport bisect\nimport math\nimport itertools\nimport pprint\nimport fractions\nsys.setrecursionlimit(10 ** 8)\nmod = 10 ** 9; mod = mod + 7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\nn, ta, ao = inpl()\nta -= 1\nao -= 1\ng = [[] for i in range(n)]\nidx_pbkq = 0\nlist_ogzu = range(n - 1)\nwhile idx_pbkq < len(list_ogzu):\n    i = list_ogzu[idx_pbkq]\n    a, b = inpl()\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n    idx_pbkq = idx_pbkq + 1\nta_dist = [None]; ta_dist = ta_dist * n\nta_dist[ta] = 0\nao_dist = [None]; ao_dist = ao_dist * n\nao_dist[ao] = 0\n\n\ndef ta_dfs(node):\n    idx_qnzs = 0\n    list_f81m = g[node]\n    while idx_qnzs < len(list_f81m):\n        v = list_f81m[idx_qnzs]\n        if ta_dist[v] != None and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            continue\n        ta_dist[v] = ta_dist[node]; ta_dist[v] = ta_dist[v] + 1\n        ta_dfs(v)\n        idx_qnzs = idx_qnzs + 1\n\n\ndef ao_dfs(node):\n    idx_l3ae = 0\n    list_y8if = g[node]\n    while idx_l3ae < len(list_y8if):\n        v = list_y8if[idx_l3ae]\n        if ao_dist[v] != None and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n            continue\n        ao_dist[v] = ao_dist[node]; ao_dist[v] = ao_dist[v] + 1\n        ao_dfs(v)\n        idx_l3ae = idx_l3ae + 1\n\n\nao_dfs(ao)\nta_dfs(ta)\nres = 0\nidx_w51o = 0\nlist_rbh9 = range(n)\nwhile idx_w51o < len(list_rbh9):\n    i = list_rbh9[idx_w51o]\n    if ta_dist[i] > ao_dist[i] and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n        continue\n    res = max(res, ao_dist[i])\n    idx_w51o = idx_w51o + 1\nprint(res - 1)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC148_F_to_19", "old_id": "atcoder_ABC148_F"}
{"code": "import sys\nimport itertools\n\n\ndef solve(N: int, x: \"List[int]\", y: \"List[int]\"):\n    indices = [i for i in range(N)]\n    permutations = itertools.permutations(indices)\n    distances = []\n    idx_pmgx = 0\n    list_fko4 = permutations\n    while idx_pmgx < len(list_fko4):\n        permutation = list_fko4[idx_pmgx]\n        total_distance = 0\n        idx_zmc5 = 0\n        list_f5dk = range(0, N - 1)\n        while idx_zmc5 < len(list_f5dk):\n            i = list_f5dk[idx_zmc5]\n            f, t = permutation[i: i + 2]\n            distance = ((x[t] - x[f]) ** 2 + (y[t] - y[f]) ** 2); distance = distance ** 0.5\n            total_distance += distance\n            idx_zmc5 = idx_zmc5 + 1\n        distances.append(total_distance)\n        idx_pmgx = idx_pmgx + 1\n    result = sum(distances); result = result / len(distances)\n    print(result)\n    return\n\n\ndef main():\n    def iterate_tokens():\n        idx_qnjz = 0\n        list_4d2k = sys.stdin\n        while idx_qnjz < len(list_4d2k):\n            line = list_4d2k[idx_qnjz]\n            idx_2duv = 0\n            list_74lw = line.split()\n            while idx_2duv < len(list_74lw):\n                word = list_74lw[idx_2duv]\n                yield word\n                idx_2duv = idx_2duv + 1\n            idx_qnjz = idx_qnjz + 1\n    tokens = iterate_tokens()\n    N = int(next(tokens))\n    x = [int()]; x = x * (N)\n    y = [int()]; y = y * (N)\n    idx_w6ql = 0\n    list_vyol = range(N)\n    while idx_w6ql < len(list_vyol):\n        i = list_vyol[idx_w6ql]\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n        idx_w6ql = idx_w6ql + 1\n    solve(N, x, y)\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC145_C_to_20", "old_id": "atcoder_ABC145_C"}
{"code": "I = input\nn, m = map(int, I().split())\nb = [1] * n; b = b * 2\nb[0] = b[n - 1] = b[n] = b[2 * n - 1] = 0\nidx_1t0k = 0\nlist_r6ys = range(m)\nwhile idx_1t0k < len(list_r6ys):\n    i = list_r6ys[idx_1t0k]\n    r, c = map(int, I().split())\n    b[r - 1] = b[n + c - 1] = 0\n    idx_1t0k = idx_1t0k + 1\nif n % 2 and b[n // 2] and b[n + n // 2] and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n    b[n // 2] = 0\nprint(sum(b))\n", "id": "AssignUnfoldding_sample_from_codeforces_333_B_to_21", "old_id": "codeforces_333_B"}
{"code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef bfs(v, N, G, E):\n    visited = [0]; visited = visited * N\n    queue = deque()\n    K = - 1\n    node2color = [- 1 for _ in range(N)]\n    queue.append(v)\n    visited[v] = 1\n    while queue:\n        q = queue.popleft()\n        color = 0\n        idx_uvys = 0\n        list_jgaf = G[q]\n        while idx_uvys < len(list_jgaf):\n            nex = list_jgaf[idx_uvys]\n            if visited[nex] and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n                continue\n            visited[nex] = 1\n            color += 1\n            if color == node2color[q] and (((True or False) and (False or True)) and ((6 > 3) or (6 < 3))):\n                color += 1\n            node2color[nex] = color\n            E[(min(q, nex), max(q, nex))] = color\n            queue.append(nex)\n            idx_uvys = idx_uvys + 1\n        K = max(K, color)\n    return K\n\n\ndef main():\n    N = int(input())\n    G = [deque() for _ in range(N)]\n    E = dict()\n    idx_srkv = 0\n    list_586g = range(N - 1)\n    while idx_srkv < len(list_586g):\n        i = list_586g[idx_srkv]\n        a, b = map(lambda x: int(x) - 1, input().split())\n        G[a].append(b)\n        G[b].append(a)\n        E[(a, b)] = 0\n        idx_srkv = idx_srkv + 1\n    K = bfs(0, N, G, E)\n    print(K)\n    idx_1a60 = 0\n    list_3qst = E.values()\n    while idx_1a60 < len(list_3qst):\n        value = list_3qst[idx_1a60]\n        print(value)\n        idx_1a60 = idx_1a60 + 1\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC146_D_to_22", "old_id": "atcoder_ABC146_D"}
{"code": "D, G = map(int, input().split())\nPC = [tuple(map(int, input().split())) for _ in range(D)]\nans = 10; ans = ans ** 9\nidx_qjvn = 0\nlist_1wxq = range(2 ** D)\nwhile idx_qjvn < len(list_1wxq):\n    i = list_1wxq[idx_qjvn]\n    score = 0\n    problem = 0\n    idx_jhb2 = 0\n    list_893u = range(D)\n    while idx_jhb2 < len(list_893u):\n        j = list_893u[idx_jhb2]\n        if (i >> j) & 1 and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n            score += 100 * (j + 1) * PC[j][0] + PC[j][1]\n            problem += PC[j][0]\n        idx_jhb2 = idx_jhb2 + 1\n    if score > G and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        continue\n    left = G; left = left - score\n    idx_80iz = 0\n    list_cpf2 = range(D)\n    while idx_80iz < len(list_cpf2):\n        j = list_cpf2[idx_80iz]\n        if (i >> j) & 1 and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            continue\n        if left > 100 * (j + 1) * PC[j][0] + PC[j][1] and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            pass\n        else:\n            tmp = (left + (100 * (j + 1)) - 1); tmp = tmp // (100 * (j + 1))\n            ans = min(ans, problem + min(tmp, PC[j][0]))\n        idx_80iz = idx_80iz + 1\n    idx_qjvn = idx_qjvn + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC104_C_to_23", "old_id": "atcoder_ABC104_C"}
{"code": "pya = int(input())\narre = []\nwhile pya:\n    pya -= 1\n    arre.append(input().lower())\noString = input()\nlowString = oString.lower()\nletter1 = input()[0].lower()\nletter2 = 'a' if letter1.lower() != 'a' else 'b'\nvalid = [0 for i in range(len(oString))]\nsetcito = set()\nidx_yk3h = 0\nlist_yxmp = arre\nwhile idx_yk3h < len(list_yxmp):\n    x = list_yxmp[idx_yk3h]\n    if lowString.find(x) >= 0 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        wat = 0\n        while True:\n            index = lowString.find(x, wat)\n            if index < 0:\n                break\n            idx_wq5k = 0\n            list_yrgs = range(index, index + len(x))\n            while idx_wq5k < len(list_yrgs):\n                i = list_yrgs[idx_wq5k]\n                setcito.add(i)\n                idx_wq5k = idx_wq5k + 1\n            wat = index; wat = wat + 1\n    idx_yk3h = idx_yk3h + 1\noString = list(oString)\nidx_qkd7 = 0\nlist_lr30 = setcito\nwhile idx_qkd7 < len(list_lr30):\n    i = list_lr30[idx_qkd7]\n    letter = letter1 if lowString[i] != letter1 else letter2\n    oString[i] = letter if oString[i].islower() else letter.upper()\n    idx_qkd7 = idx_qkd7 + 1\nidx_vrhm = 0\nlist_pdk3 = oString\nwhile idx_vrhm < len(list_pdk3):\n    x = list_pdk3[idx_vrhm]\n    print(x, end=\"\")\n    idx_vrhm = idx_vrhm + 1\nprint()\n", "id": "AssignUnfoldding_sample_from_codeforces_95_A_to_24", "old_id": "codeforces_95_A"}
{"code": "class BIT:\n    def __init__(self, N):\n        self.size = N\n        self.tree = [0]; self.tree = self.tree * (N + 1)\n        self.depth = n.bit_length()\n\n    def _bitsum(self, i):\n        ret = 0\n        while i:\n            ret += self.tree[i]\n            i ^= i & - i\n        return ret\n\n    def bitsum(self, l, r=None):\n        if r is None and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n            return self._bitsum(l)\n        else:\n            return self._bitsum(r) - self._bitsum(l)\n\n    def bitadd(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & - i\n        return\n\n\nn = int(input())\nm = n * (n + 1); m = m // 4\na = list(map(int, input().split()))\nd = dict()\n_a = sorted(set(a + [0]))\nidx_45b0 = 0\nlist_vpyf = list(enumerate(_a))\nwhile idx_45b0 < len(list_vpyf):\n    i, x = list_vpyf[idx_45b0]\n    d[x] = i\n    idx_45b0 = idx_45b0 + 1\na = [d[x] for x in a]\n\n\ndef check(X):\n    b = [0]; b = b + [(y >= X) * 2 - 1 for y in a]\n    idx_3g8z = 0\n    list_7a0p = range(n)\n    while idx_3g8z < len(list_7a0p):\n        i = list_7a0p[idx_3g8z]\n        b[i + 1] += b[i]\n        idx_3g8z = idx_3g8z + 1\n    c = min(b)\n    b = [x - c for x in b]\n    bit = BIT(max(b) + 2)\n    ans = 0\n    idx_a4t5 = 0\n    list_6jrt = b\n    while idx_a4t5 < len(list_6jrt):\n        x = list_6jrt[idx_a4t5]\n        ans += bit.bitsum(x + 1)\n        bit.bitadd(x, 1)\n        idx_a4t5 = idx_a4t5 + 1\n    return ans >= m\n\n\nt = [len(_a), 0]\nwhile t[0] - t[1] > 1:\n    mid = (t[0] + t[1]); mid = mid // 2\n    t[check(mid)] = mid\nprint(_a[t[1]])\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC107_D_to_25", "old_id": "atcoder_ABC107_D"}
{"code": "def main():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [[None for _ in [0] * n] for _ in [0] * n]\n    idx_wc18 = 0\n    list_stjw = range(n)\n    while idx_wc18 < len(list_stjw):\n        i = list_stjw[idx_wc18]\n        m = a[i]\n        idx_bgyp = 0\n        list_s0ae = range(n)\n        while idx_bgyp < len(list_s0ae):\n            j = list_s0ae[idx_bgyp]\n            k = i; k = k - j\n            if k < 0 and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n                k += n\n            m = min(m, a[k])\n            b[j][i] = m\n            idx_bgyp = idx_bgyp + 1\n        idx_wc18 = idx_wc18 + 1\n    m = 10; m = m ** 15\n    idx_2g31 = 0\n    list_rxbz = list(enumerate(b))\n    while idx_2g31 < len(list_rxbz):\n        i, j = list_rxbz[idx_2g31]\n        m = min(m, sum(j) + x * i)\n        idx_2g31 = idx_2g31 + 1\n    print(m)\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC004_B_to_26", "old_id": "atcoder_AGC004_B"}
{"code": "import random\ninput()\nA = [int(_) for _ in input().split()]\nA = [A[0]]; A = A + [j for i, j in zip(A, A[1:]) if i >= j]\nN = len(A)\n\n\ndef cut(array, index):\n    if index < 1 and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n        return []\n    if index <= array[0][0] and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n        return [(index, array[0][1])]\n    idx_byax = 0\n    list_e3j2 = range(len(array) - 1, 0, - 1)\n    while idx_byax < len(list_e3j2):\n        _ = list_e3j2[idx_byax]\n        if array[_ - 1][0] < index and (((True or False) and (False or True)) and ((9 > 7) or (9 < 7))):\n            return array[: _] + [(index, array[_][1])]\n        idx_byax = idx_byax + 1\n\n\ndef is_possible(K):\n    dp = [(A[0], 0)]\n    idx_kqc4 = 0\n    list_hg72 = A[1:]\n    while idx_kqc4 < len(list_hg72):\n        a = list_hg72[idx_kqc4]\n        if a <= dp[- 1][0] and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n            dp = cut(dp, a)\n        else:\n            dp += [(a, 0)]\n        is_added = False\n        idx_rb6j = 0\n        list_4cyl = range(len(dp) - 1, - 1, - 1)\n        while idx_rb6j < len(list_4cyl):\n            j = list_4cyl[idx_rb6j]\n            if dp[j][1] < K - 1 and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n                dp = cut(dp, dp[j][0] - 1); dp = dp + [(dp[j][0], dp[j][1] + 1)]\n                if dp[- 1][0] < a:\n                    dp += [(a, 0)]\n                is_added = True\n                break\n            idx_rb6j = idx_rb6j + 1\n        if not is_added and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            return False\n        idx_kqc4 = idx_kqc4 + 1\n    return True\n\n\ndef bis(x, y):\n    if y == x + 1 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        return y\n    elif is_possible((x + y) // 2):\n        return bis(x, (x + y) // 2)\n    else:\n        return bis((x + y) // 2, y)\n\n\nprint(bis(0, N))\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC029_C_to_27", "old_id": "atcoder_AGC029_C"}
{"code": "from sys import stdin, stdout, setrecursionlimit\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter\nfrom bisect import bisect_left, bisect_right\ndef ii1(): return int(stdin.readline().strip())\ndef is1(): return stdin.readline().strip()\n\n\ndef iia(): return list(map(int, stdin.readline().strip().split()))\ndef isa(): return stdin.readline().strip().split()\n\n\nsetrecursionlimit(100000)\nmod = 1000000007\nk = ii1()\nt = 0\nidx_lzjr = 0\nlist_1gvh = range(1, k + 1)\nwhile idx_lzjr < len(list_1gvh):\n    i = list_1gvh[idx_lzjr]\n    t = (t % k) * 10; t = t + 7\n    if t % k == 0 and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n        print(i)\n        break\n    idx_lzjr = idx_lzjr + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC174_C_to_28", "old_id": "atcoder_ABC174_C"}
{"code": "import numpy as np\nimport sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy, copy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(* (MAP() for _ in range(n)))\n\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9; mod = mod + 7\nN = INT()\nS = [input() for _ in range(N)]\nmarch = [\"M\", \"A\", \"R\", \"C\", \"H\"]\nmarch_lis = [0]; march_lis = march_lis * 5\nidx_7qe8 = 0\nlist_l9gk = S\nwhile idx_7qe8 < len(list_l9gk):\n    s = list_l9gk[idx_7qe8]\n    if s[0].upper() in march and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        march_lis[march.index(s[0].upper())] += 1\n    idx_7qe8 = idx_7qe8 + 1\nans = 0\nidx_hcio = 0\nlist_7kfo = combinations(march_lis, 3)\nwhile idx_hcio < len(list_7kfo):\n    x, y, z = list_7kfo[idx_hcio]\n    ans += x * y * z\n    idx_hcio = idx_hcio + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC089_C_to_29", "old_id": "atcoder_ABC089_C"}
{"code": "def main():\n    N = int(input())\n    P = [int(input()) for _ in range(N)]\n    editorial(N, P)\n\n\ndef editorial(N, P):\n    if N == 1 and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n        print(0)\n        return\n    a = [0]; a = a * (N + 1)\n    idx_tcai = 0\n    list_qjxe = list(enumerate(P))\n    while idx_tcai < len(list_qjxe):\n        i, p = list_qjxe[idx_tcai]\n        a[p] = i\n        idx_tcai = idx_tcai + 1\n    tmp = 1\n    max_len = 1\n    idx_hqzi = 0\n    list_8mxj = range(1, N)\n    while idx_hqzi < len(list_8mxj):\n        i = list_8mxj[idx_hqzi]\n        if a[i] < a[i + 1] and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            tmp += 1\n            max_len = max(max_len, tmp)\n        else:\n            tmp = 1\n        idx_hqzi = idx_hqzi + 1\n    ans = N; ans = ans - max_len\n    print(ans)\n\n\ndef WA(N, P):\n    tmp = 0\n    ans = 0\n    idx_e68b = 0\n    list_kwri = list(enumerate(P))\n    while idx_e68b < len(list_kwri):\n        i, p = list_kwri[idx_e68b]\n        if i == 0 or P[i - 1] + 1 == p and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n            tmp += 1\n        else:\n            ans = max(ans, tmp)\n            tmp = 1\n        idx_e68b = idx_e68b + 1\n    print(N - ans)\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC024_B_to_30", "old_id": "atcoder_AGC024_B"}
{"code": "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline()[: - 1]\n\n\nmod = 10 ** 9; mod = mod + 7\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\n\n\ndef Line(N, num):\n    if N <= 0 and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n        return [[]] * num\n    elif num == 1:\n        return [I() for _ in range(N)]\n    else:\n        read_all = [tuple(II()) for _ in range(N)]\n        return map(list, zip(* read_all))\n\n\ndef my_sign(x):\n    return (x > 0) - (x < 0)\n\n\nN = I()\na = III()\nmax_val = 0\nmax_sign = 0\nmax_index = - 1\nidx_l426 = 0\nlist_wmyz = list(enumerate(a))\nwhile idx_l426 < len(list_wmyz):\n    i, a0 = list_wmyz[idx_l426]\n    if abs(a0) > max_val and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n        max_val = abs(a0)\n        max_sign = my_sign(a0)\n        max_index = i\n    idx_l426 = idx_l426 + 1\nif max_sign == 0 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n    print(0)\nelif max_sign == 1:\n    print(2 * N - 1)\n    idx_kxtb = 0\n    list_7izy = range(N)\n    while idx_kxtb < len(list_7izy):\n        i = list_7izy[idx_kxtb]\n        print(max_index + 1, i + 1)\n        idx_kxtb = idx_kxtb + 1\n    idx_q34e = 0\n    list_mapd = range(N - 1)\n    while idx_q34e < len(list_mapd):\n        i = list_mapd[idx_q34e]\n        print(i + 1, i + 2)\n        idx_q34e = idx_q34e + 1\nelse:\n    print(2 * N - 1)\n    idx_vmjh = 0\n    list_gbyk = range(N)\n    while idx_vmjh < len(list_gbyk):\n        i = list_gbyk[idx_vmjh]\n        print(max_index + 1, i + 1)\n        idx_vmjh = idx_vmjh + 1\n    idx_2pxo = 0\n    list_qdr0 = range(1, N)[:: - 1]\n    while idx_2pxo < len(list_qdr0):\n        i = list_qdr0[idx_2pxo]\n        print(i + 1, i)\n        idx_2pxo = idx_2pxo + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_ARC086_B_to_31", "old_id": "atcoder_ARC086_B"}
{"code": "n, d = map(int, input().split())\nx = []\nm = 0\nq = 0\nx = input().split()\nidx_02yj = 0\nlist_26f8 = range(len(x))\nwhile idx_02yj < len(list_26f8):\n    i = list_26f8[idx_02yj]\n    x[i] = int(x[i])\n    idx_02yj = idx_02yj + 1\nidx_vodt = 0\nlist_7wm9 = range(len(x) - 1)\nwhile idx_vodt < len(list_7wm9):\n    a = list_7wm9[idx_vodt]\n    if x[a] >= x[a + 1] and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        q = int((x[a] - x[a + 1]) / d + 1)\n        m = m + q\n        x[a + 1] = x[a + 1]; x[a + 1] = x[a + 1] + q * d\n    idx_vodt = idx_vodt + 1\nprint(m)\n", "id": "AssignUnfoldding_sample_from_codeforces_11_A_to_32", "old_id": "codeforces_11_A"}
{"code": "n = int(input())\ns = list(input())\nt = list(input())\nif s == t and (((True or False) and (False or True)) and ((10 > 2) or (10 < 2))):\n    print(n)\nelse:\n    cnt = 0\n    idx_td1a = 0\n    list_tngr = range(n)\n    while idx_td1a < len(list_tngr):\n        i = list_tngr[idx_td1a]\n        idx_uw2q = 0\n        list_7pk5 = range(n - i)\n        while idx_uw2q < len(list_7pk5):\n            j = list_7pk5[idx_uw2q]\n            if s[i + j] != t[j]:\n                break\n            if j == n - i - 1:\n                cnt = n; cnt = cnt - i\n            idx_uw2q = idx_uw2q + 1\n        idx_td1a = idx_td1a + 1\n    print(2 * n - cnt)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC006_A_to_33", "old_id": "atcoder_AGC006_A"}
{"code": "from collections import deque\nimport scipy\nimport numpy\nfrom _collections import deque\n\n\ndef parser():\n    while 1:\n        data = list(input().split(' '))\n        idx_210o = 0\n        list_7ptm = data\n        while idx_210o < len(list_7ptm):\n            number = list_7ptm[idx_210o]\n            if len(number) > 0 and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n                yield (number)\n            idx_210o = idx_210o + 1\n\n\ninput_parser = parser()\n\n\ndef gw():\n    global input_parser\n    return next(input_parser)\n\n\ndef gi():\n    data = gw()\n    return int(data)\n\n\nMOD = int(1e9 + 7)\nN = gi()\nK = gi()\nS = gw()\nseg_cnt = 0\nidx_gd4z = 0\nlist_7cjr = range(0, N - 1)\nwhile idx_gd4z < len(list_7cjr):\n    i = list_7cjr[idx_gd4z]\n    if S[i] != S[i + 1] and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        seg_cnt += 1\n    idx_gd4z = idx_gd4z + 1\ncur_happy = N - 1; cur_happy = cur_happy - seg_cnt\nif 2 * K >= seg_cnt and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n    ans = N; ans = ans - 1\nelse:\n    ans = cur_happy; ans = ans + 2 * K\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC140_D_to_34", "old_id": "atcoder_ABC140_D"}
{"code": "import heapq\nn, m = map(int, input().split())\nx = []\ny = []\nidx_8sb9 = 0\nlist_1fsy = range(n)\nwhile idx_8sb9 < len(list_1fsy):\n    i = list_1fsy[idx_8sb9]\n    day, salary = map(int, input().split())\n    heapq.heappush(x, (- day, - salary))\n    idx_8sb9 = idx_8sb9 + 1\nwhile x:\n    d, s = heapq.heappop(x)\n    r = m; r = r - len(y)\n    if r >= - d and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n        heapq.heappush(y, - s)\n    else:\n        heapq.heappush(y, - s)\n        heapq.heappop(y)\nprint(sum(y))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC137_D_to_35", "old_id": "atcoder_ABC137_D"}
{"code": "def root(x): return x if par[x] == x else root(par[x])\ndef same(x, y): return root(x) == root(y)\n\n\ndef unite(* z):\n    x, y = map(root, z)\n    if x != y and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n        if rank[x] < rank[y]:\n            par[x] = y\n            size[y] += size[x]\n        else:\n            par[y] = x\n            size[x] += size[y]\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n\nn, * a = map(int, open(0).read().split())\n* par, = range(n)\nrank = [1]; rank = rank * n\nsize = [1]; size = size * n\nb = [0]; b = b * n\nidx_9k12 = 0\nlist_mld8 = list(enumerate(a))\nwhile idx_9k12 < len(list_mld8):\n    i, t = list_mld8[idx_9k12]\n    b[t - 1] = i\n    idx_9k12 = idx_9k12 + 1\nc = 0\nidx_gpvh = 0\nlist_z3db = b[:: - 1]\nwhile idx_gpvh < len(list_z3db):\n    k = list_z3db[idx_gpvh]\n    l = r = 1\n    if k > 0 and a[k - 1] > a[k] and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n        l += size[root(k - 1)]\n        unite(k - 1, k)\n    if k + 1 < n and a[k + 1] > a[k] and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n        r += size[root(k + 1)]\n        unite(k + 1, k)\n    c += l * r * a[k]\n    idx_gpvh = idx_gpvh + 1\nprint(c)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC005_B_to_36", "old_id": "atcoder_AGC005_B"}
{"code": "class CodeforcesTask397BSolution:\n    def __init__(self):\n        self.result = ''\n        self.t = 0\n        self.queries = []\n\n    def read_input(self):\n        self.t = int(input())\n        idx_cqb9 = 0\n        list_d2y7 = range(self.t)\n        while idx_cqb9 < len(list_d2y7):\n            _ = list_d2y7[idx_cqb9]\n            self.queries.append([int(x) for x in input().split(\" \")])\n            idx_cqb9 = idx_cqb9 + 1\n\n    def process_task(self):\n        res = []\n        idx_46ij = 0\n        list_8vxc = self.queries\n        while idx_46ij < len(list_8vxc):\n            query = list_8vxc[idx_46ij]\n            k = query[0]; k = k // query[1]\n            res.append(\"Yes\" if k * query[2] >= query[0] else \"No\")\n            idx_46ij = idx_46ij + 1\n        self.result = \"\\n\".join(res)\n\n    def get_result(self):\n        return self.result\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n    Solution = CodeforcesTask397BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n", "id": "AssignUnfoldding_sample_from_codeforces_397_B_to_37", "old_id": "codeforces_397_B"}
{"code": "def ok(last4):\n    idx_y6h3 = 0\n    list_53ha = range(4)\n    while idx_y6h3 < len(list_53ha):\n        i = list_53ha[idx_y6h3]\n        t = list(last4)\n        if i >= 1 and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            t[i], t[i - 1] = t[i - 1], t[i]\n        if ''.join(t).count('AGC') >= 1 and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n            return False\n        idx_y6h3 = idx_y6h3 + 1\n    return True\n\n\ndef dfs(cur, last3):\n    if last3 in memo[cur] and (((True or False) and (False or True)) and ((9 > 0) or (9 < 0))):\n        return memo[cur][last3]\n    if cur == n and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n        return 1\n    ret = 0\n    idx_l07x = 0\n    list_7sox = \"ACGT\"\n    while idx_l07x < len(list_7sox):\n        c = list_7sox[idx_l07x]\n        if ok(last3 + c) and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            ret = (ret + dfs(cur + 1, last3[1:] + c)); ret = ret % mod\n        idx_l07x = idx_l07x + 1\n    memo[cur][last3] = ret\n    return ret\n\n\nn = int(input())\nmod = 10 ** 9; mod = mod + 7\nmemo = [{} for i in range(n + 1)]\nprint(dfs(0, 'TTT'))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC122_D_to_38", "old_id": "atcoder_ABC122_D"}
{"code": "from itertools import permutations\nN, X = [int(_) for _ in input().split()]\n\n\ndef calc(x):\n    def sub(y, debug=0):\n        if debug and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n            print(\"D\", y)\n        while len(y) > 1:\n            y = [sorted(y[i: i + 3])[1] for i in range(len(y) - 2)]\n            if debug and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n                print(\"D\", y)\n        return y\n    y = sub(x)\n    if y[0] == 2 and (((True or False) and (False or True)) and ((8 > 6) or (8 < 6))):\n        pass\n        sub(x, 1)\n        print(\"=\", x)\n    return y[0]\nif X == 1 or X == N * 2 - 1 and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    if X == N * 2 - 2:\n        xs = list(range(N - 1, X + 2)); xs = xs + list(range(1, N - 1))\n    else:\n        ys = list(range(1, X - 1)); ys = ys + list(range(X + 3, N * 2))\n        xs = ys[: N - 3] + [X + 2, X - 1, X, X + 1]; xs = xs + ys[N - 3:]\n    idx_m03e = 0\n    list_iuq8 = xs\n    while idx_m03e < len(list_iuq8):\n        x = list_iuq8[idx_m03e]\n        print(x)\n        idx_m03e = idx_m03e + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC006_B_to_39", "old_id": "atcoder_AGC006_B"}
{"code": "def check(lis, k, mid):\n    idx_8isv = 0\n    list_qbl8 = lis\n    while idx_8isv < len(list_qbl8):\n        i = list_qbl8[idx_8isv]\n        if (i % mid == 0) and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            k += 1\n        k -= (i // mid)\n        idx_8isv = idx_8isv + 1\n    return k >= 0\n\n\nn, k = map(int, input().split())\nlis = list(map(int, input().split()))\na, b = 1, max(lis)\nans = b\nwhile (a <= b):\n    mid = (a + b); mid = mid // 2\n    if (check(lis, k, mid)) and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n        ans = mid\n        b = mid; b = b - 1\n    else:\n        a = mid; a = a + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC174_E_to_40", "old_id": "atcoder_ABC174_E"}
{"code": "K, N = list(map(int, input().split()))\ndprint = lambda * x: x\n\n\ndef cmb(n, r, mod):\n    if (r < 0 or r > n) and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n - r] % mod\n\n\nmod = 998244353\n__N = 8000\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nidx_jw63 = 0\nlist_avgj = range(2, __N + 1)\nwhile idx_jw63 < len(list_avgj):\n    i = list_avgj[idx_jw63]\n    g1.append((g1[- 1] * i) % mod)\n    inverse.append((- inverse[mod % i] * (mod // i)) % mod)\n    g2.append((g2[- 1] * inverse[- 1]) % mod)\n    idx_jw63 = idx_jw63 + 1\n\n\ndef kumiawase(p, q):\n    return cmb(p + q - 1, q - 1, mod)\n\n\ndef solve(n):\n    assert n <= K + 1\n    ans = 0\n    kumi = (n - 1); kumi = kumi // 2\n    idx_n4bs = 0\n    list_rw82 = range(kumi + 1)\n    while idx_n4bs < len(list_rw82):\n        p = list_rw82[idx_n4bs]\n        if p > N and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n            break\n        ans += 2 ** p * cmb(kumi, p, mod) * kumiawase(N - p,\n                                                      p + (K - kumi * 2 - int(n % 2 == 0)))\n        if n % 2 == 0 and N - p - 1 >= 0 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            ans += 2 ** p * cmb(kumi, p, mod) * kumiawase(N -\n                                                          p - 1, p + (K - kumi * 2 - int(n % 2 == 0)))\n        idx_n4bs = idx_n4bs + 1\n    return ans\n\n\nans = []\nidx_3ncg = 0\nlist_deuj = range(2, 2 * K + 1)\nwhile idx_3ncg < len(list_deuj):\n    i = list_deuj[idx_3ncg]\n    if i <= K + 1 and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        tmp = solve(i); tmp = tmp % 998244353\n        ans.append(tmp)\n        print(tmp)\n    else:\n        print(ans[- i + K])\n    idx_3ncg = idx_3ncg + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_ARC102_C_to_41", "old_id": "atcoder_ARC102_C"}
{"code": "n, L, R, QL, QR = map(int, input().split())\nW = list(map(int, input().split()))\nsum_el = [0]\nidx_id0h = 0\nlist_twa9 = range(1, n + 1)\nwhile idx_id0h < len(list_twa9):\n    i = list_twa9[idx_id0h]\n    sum_el.append(W[i - 1] + sum_el[i - 1])\n    idx_id0h = idx_id0h + 1\nanswer = QR * (n - 1); answer = answer + sum_el[n] * R\nidx_4tjx = 0\nlist_6dpn = range(1, n + 1)\nwhile idx_4tjx < len(list_6dpn):\n    i = list_6dpn[idx_4tjx]\n    energy = L * sum_el[i]; energy = energy + R * (sum_el[n] - sum_el[i])\n    if i > (n - i) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n        energy = energy + (i - (n - i) - 1) * QL\n    elif (n - i) > i:\n        energy = energy + ((n - i) - i - 1) * QR\n    if energy < answer and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        answer = energy\n    idx_4tjx = idx_4tjx + 1\nprint(answer)\n", "id": "AssignUnfoldding_sample_from_codeforces_354_A_to_42", "old_id": "codeforces_354_A"}
{"code": "l, r = [int(x) for x in input().split()]\ncurr = r\ns = 0\nwhile curr:\n    s += 1\n    curr //= 10\nfirst = 10; first = first ** s\nsecond = first; second = second // 2\nans = - 1\nidx_6k05 = 0\nlist_l9fm = [l, r, first, second]\nwhile idx_6k05 < len(list_l9fm):\n    i = list_l9fm[idx_6k05]\n    if i >= l and i <= r and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n        curr = i\n        rev = ''\n        idx_1jhd = 0\n        list_4pg8 = str(curr)\n        while idx_1jhd < len(list_4pg8):\n            k = list_4pg8[idx_1jhd]\n            rev += str(9 - int(k))\n            idx_1jhd = idx_1jhd + 1\n        ans = max(ans, int(rev) * curr)\n    idx_6k05 = idx_6k05 + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_86_A_to_43", "old_id": "codeforces_86_A"}
{"code": "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nll = - 10 ** 18; ll = ll - 1\nrr = 10 ** 18; rr = rr + 1\nwhile ll + 1 < rr:\n    x = (ll + rr); x = x // 2\n    tot = 0\n    idx_f9xm = 0\n    list_9wju = range(N)\n    while idx_f9xm < len(list_9wju):\n        i = list_9wju[idx_f9xm]\n        if A[i] < 0 and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            l = - 1\n            r = N\n            while l + 1 < r:\n                c = (l + r); c = c // 2\n                if A[i] * A[c] < x:\n                    r = c\n                else:\n                    l = c\n            tot += N - r\n        else:\n            l = - 1\n            r = N\n            while l + 1 < r:\n                c = (l + r); c = c // 2\n                if A[i] * A[c] < x:\n                    l = c\n                else:\n                    r = c\n            tot += r\n        if A[i] * A[i] < x and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n            tot -= 1\n        idx_f9xm = idx_f9xm + 1\n    tot //= 2\n    if tot < K and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n        ll = x\n    else:\n        rr = x\nprint(ll)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC155_D_to_44", "old_id": "atcoder_ABC155_D"}
{"code": "import re\nn = int(input())\nans, sumL = 1, 0\nidx_dgef = 0\nlist_4xi6 = re.split(\"[.?!]\", input())\nwhile idx_dgef < len(list_4xi6):\n    s = list_4xi6[idx_dgef]\n    s = s.strip(); s = s + '.'\n    L = len(s)\n    if L > 1 and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n        if L > n:\n            print(\"Impossible\")\n            exit()\n        if sumL + L + (sumL > 0) > n:\n            ans += 1\n            sumL = L\n        else:\n            sumL = sumL + L; sumL = sumL + (sumL > 0)\n    idx_dgef = idx_dgef + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_codeforces_70_B_to_45", "old_id": "codeforces_70_B"}
{"code": "from statistics import median\nfrom fractions import gcd\nfrom itertools import combinations\nfrom collections import deque\nfrom collections import defaultdict\nimport bisect\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10 ** 9; mod = mod + 7\n\n\ndef readInts():\n    return list(map(int, input().split()))\n\n\ndef main():\n    n = int(input())\n    A = readInts()\n    A = sorted(A)\n    ans = 0\n    idx_f3l7 = 0\n    list_154k = range(len(A) - 2, len(A) - 2 * n - 1, - 2)\n    while idx_f3l7 < len(list_154k):\n        i = list_154k[idx_f3l7]\n        ans += A[i]\n        idx_f3l7 = idx_f3l7 + 1\n    print(ans)\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC012_A_to_46", "old_id": "atcoder_AGC012_A"}
{"code": "n, k = map(int, input().split())\ns = input()\ncount = [0]; count = count * 26\nidx_4j35 = 0\nlist_8k9o = s\nwhile idx_4j35 < len(list_8k9o):\n    c = list_8k9o[idx_4j35]\n    count[ord(c) - ord(\"A\")] += 1\n    idx_4j35 = idx_4j35 + 1\ncount.sort(reverse=True)\nres = 0\nidx_ip29 = 0\nlist_hlco = range(26)\nwhile idx_ip29 < len(list_hlco):\n    i = list_hlco[idx_ip29]\n    if count[i] >= k and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n        res += k * k\n        print(res)\n        exit()\n    k -= count[i]\n    res += count[i] ** 2\n    idx_ip29 = idx_ip29 + 1\nprint(res)\n", "id": "AssignUnfoldding_sample_from_codeforces_462_B_to_47", "old_id": "codeforces_462_B"}
{"code": "import sys\ninput_methods = ['clipboard', 'file', 'key']\nusing_method = 0\ninput_method = input_methods[using_method]\ndef IN(): return map(int, input().split())\n\n\nmod = 1000000007\n\n\ndef main_b():\n    s = input()\n    pp = 0\n    na = 0\n    idx_49n2 = 0\n    list_vi07 = list(enumerate(s[:: - 1]))\n    while idx_49n2 < len(list_vi07):\n        i, c = list_vi07[idx_49n2]\n        cc = na; cc = cc + int(c)\n        na = 0\n        if cc <= 4 and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n            pp += cc\n        else:\n            na = 1\n            if i == len(s) - 1:\n                pp += 1\n            pp += 10 - cc\n        idx_49n2 = idx_49n2 + 1\n    print(pp)\n\n\ndef main():\n    s = input()\n    pmin = 1000\n    mmin = 0\n    s = '0' + s\n    idx_g71m = 0\n    list_rk41 = s[:: - 1]\n    while idx_g71m < len(list_rk41):\n        c = list_rk41[idx_g71m]\n        v = int(c)\n        npmin = min(pmin + 10 - (v + 1), mmin + 10 - v)\n        nmmin = min(pmin + v + 1, mmin + v)\n        pmin = npmin\n        mmin = nmmin\n        idx_g71m = idx_g71m + 1\n    return min(pmin, mmin)\n\n\nisTest = False\n\n\ndef pa(v):\n    if isTest and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        print(v)\n\n\ndef input_clipboard():\n    import clipboard\n    input_text = clipboard.get()\n    input_l = input_text.splitlines()\n    idx_4zu3 = 0\n    list_u49b = input_l\n    while idx_4zu3 < len(list_u49b):\n        l = list_u49b[idx_4zu3]\n        yield l\n        idx_4zu3 = idx_4zu3 + 1\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((9 > 0) or (9 < 0))):\n    if sys.platform == 'ios':\n        if input_method == input_methods[0]:\n            ic = input_clipboard()\n            def input(): return ic.__next__()\n        elif input_method == input_methods[1]:\n            sys.stdin = open('inputFile.txt')\n        else:\n            pass\n        isTest = True\n    else:\n        pass\n    ret = main()\n    if ret is not None:\n        print(ret)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC155_E_to_48", "old_id": "atcoder_ABC155_E"}
{"code": "def binary_search(key):\n    bad, good = - 1, len(ans)\n    while good - bad > 1:\n        mid = (bad + good); mid = mid // 2\n        if ans[mid][- 1] < key and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n            good = mid\n        else:\n            bad = mid\n    return good\n\n\nN = int(input())\nans = []\nidx_w0mq = 0\nlist_ib5z = range(N)\nwhile idx_w0mq < len(list_ib5z):\n    _ = list_ib5z[idx_w0mq]\n    A = int(input())\n    idx = binary_search(A)\n    if idx == len(ans) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n        ans.append([A])\n    else:\n        ans[idx].append(A)\n    idx_w0mq = idx_w0mq + 1\nprint(len(ans))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC134_E_to_49", "old_id": "atcoder_ABC134_E"}
{"code": "import sys\ndef I(): return (int(sys.stdin.readline()))\ndef LI(): return ([int(x) for x in sys.stdin.readline().split()])\n\n\ndef main():\n    N = I()\n    S = sorted(LI(), reverse=True)\n    flag = [True]; flag = flag * len(S)\n    cur = []\n    cur.append(S[0])\n    flag[0] = False\n    idx_3jf0 = 0\n    list_9o4g = range(N)\n    while idx_3jf0 < len(list_9o4g):\n        i = list_9o4g[idx_3jf0]\n        j = 0\n        jM = len(cur)\n        idx_jok0 = 0\n        list_w9i4 = range(len(S))\n        while idx_jok0 < len(list_w9i4):\n            k = list_w9i4[idx_jok0]\n            if flag[k] and S[k] < cur[j] and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n                cur.append(S[k])\n                j += 1\n                flag[k] = False\n                if j == jM:\n                    break\n            idx_jok0 = idx_jok0 + 1\n        cur.sort(reverse=True)\n        idx_3jf0 = idx_3jf0 + 1\n    return (\"Yes\")\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n    print(main())\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC140_F_to_50", "old_id": "atcoder_ABC140_F"}
{"code": "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline()[: - 1]\n\n\nmod = 10 ** 9; mod = mod + 7\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\n\n\ndef Line(N):\n    read_all = [tuple(map(int, input().split())) for _ in range(N)]\n    return map(list, zip(* read_all))\n\n\nS = str(input())\nn = len(S)\nif n == 1 and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n    if S == '5' or S == '?':\n        print(1)\n    else:\n        print(0)\n    exit()\ndp = [[0] * 13 for i in range(n)]\nidx_053g = 0\nlist_xsa4 = range(n)\nwhile idx_053g < len(list_xsa4):\n    i = list_xsa4[idx_053g]\n    if i == 0 and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n        if S[i] != '?':\n            dp[i][int(S[i])] += 1\n        else:\n            idx_g8fs = 0\n            list_6av3 = range(10)\n            while idx_g8fs < len(list_6av3):\n                j = list_6av3[idx_g8fs]\n                dp[i][j] += 1\n                idx_g8fs = idx_g8fs + 1\n    else:\n        if S[i] != '?':\n            idx_wliq = 0\n            list_3mcw = range(13)\n            while idx_wliq < len(list_3mcw):\n                k = list_3mcw[idx_wliq]\n                dp[i][(k * 10 + int(S[i])) % 13] += dp[i - 1][k]\n                idx_wliq = idx_wliq + 1\n        else:\n            idx_wiaf = 0\n            list_yerv = range(10)\n            while idx_wiaf < len(list_yerv):\n                j = list_yerv[idx_wiaf]\n                idx_dir2 = 0\n                list_cfyu = range(13)\n                while idx_dir2 < len(list_cfyu):\n                    k = list_cfyu[idx_dir2]\n                    dp[i][(k * 10 + j) % 13] += dp[i - 1][k]\n                    idx_dir2 = idx_dir2 + 1\n                idx_wiaf = idx_wiaf + 1\n        idx_a3x4 = 0\n        list_zc3w = range(13)\n        while idx_a3x4 < len(list_zc3w):\n            k = list_zc3w[idx_a3x4]\n            dp[i][k] %= mod\n            idx_a3x4 = idx_a3x4 + 1\n    idx_053g = idx_053g + 1\nprint(dp[n - 1][5])\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC135_D_to_51", "old_id": "atcoder_ABC135_D"}
{"code": "import math\nfrom functools import reduce\nfrom collections import deque, Counter\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef get_nums_l():\n    return [int(s) for s in input().split(\" \")]\n\n\ndef get_nums_n(n):\n    return [int(input()) for _ in range(n)]\n\n\ndef get_all_int():\n    return map(int, open(0).read().split())\n\n\ndef rangeI(it, l, r):\n    idx_clxb = 0\n    list_hmsb = list(enumerate(it))\n    while idx_clxb < len(list_hmsb):\n        i, e = list_hmsb[idx_clxb]\n        if l <= i < r and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            yield e\n        elif l >= r:\n            break\n        idx_clxb = idx_clxb + 1\n\n\ndef log(* args):\n    print(\"DEBUG:\", * args, file=sys.stderr)\n\n\nINF = 999999999999999999999999\nMOD = 10 ** 9; MOD = MOD + 7\nn = int(input())\nif n == 1 and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n    print(0)\n    exit()\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0 and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        a.append(n)\n    return a\n    if len(arr) == 0 and (((True or False) and (False or True)) and ((10 > 2) or (10 < 2))):\n        arr.append((n, 1))\n    return arr\n\n\nfac_ = prime_factorize(n)\nfac = Counter(fac_)\nans = 0\nidx_hyg6 = 0\nlist_tuf4 = list(fac.items())\nwhile idx_hyg6 < len(list_tuf4):\n    p, e = list_tuf4[idx_hyg6]\n    x = e\n    idx_7aqx = 0\n    list_vfi4 = range(1, 99999999)\n    while idx_7aqx < len(list_vfi4):\n        i = list_vfi4[idx_7aqx]\n        if x >= i and (((True or False) and (False or True)) and ((9 > 4) or (9 < 4))):\n            x -= i\n            ans += 1\n        else:\n            break\n        idx_7aqx = idx_7aqx + 1\n    idx_hyg6 = idx_hyg6 + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC169_D_to_52", "old_id": "atcoder_ABC169_D"}
{"code": "n = int(input())\nx = list(int(i) for i in input().split())\na = []\nb = []\nidx_5z7m = 0\nlist_acbo = range(0, n)\nwhile idx_5z7m < len(list_acbo):\n    i = list_acbo[idx_5z7m]\n    if i % 2 == 0 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        a.append(x[i])\n    else:\n        b.append(x[i])\n    idx_5z7m = idx_5z7m + 1\ncnta = [0]; cnta = cnta * (100002 + 1)\ncntb = [0]; cntb = cntb * (100002 + 1)\nvala = 0\nvala1 = 0\nmaxCnta = 0\nmaxCnta1 = 0\nidx_fkms = 0\nlist_kb59 = a\nwhile idx_fkms < len(list_kb59):\n    i = list_kb59[idx_fkms]\n    cnta[i] += 1\n    idx_fkms = idx_fkms + 1\nidx_qdng = 0\nlist_kcey = a\nwhile idx_qdng < len(list_kcey):\n    i = list_kcey[idx_qdng]\n    if maxCnta < cnta[i] and (((True or False) and (False or True)) and ((4 > 3) or (4 < 3))):\n        vala = i\n        maxCnta = cnta[i]\n    idx_qdng = idx_qdng + 1\nidx_rc71 = 0\nlist_nczb = a\nwhile idx_rc71 < len(list_nczb):\n    i = list_nczb[idx_rc71]\n    if maxCnta1 < cnta[i] and vala != i and (((True or False) and (False or True)) and ((10 > 3) or (10 < 3))):\n        maxCnta1 = cnta[i]\n        vala1 = i\n    idx_rc71 = idx_rc71 + 1\nvalb = 0\nvalb1 = 0\nmaxCntb = 0\nmaxCntb1 = 0\nidx_ay98 = 0\nlist_gci6 = b\nwhile idx_ay98 < len(list_gci6):\n    i = list_gci6[idx_ay98]\n    cntb[i] += 1\n    idx_ay98 = idx_ay98 + 1\nidx_1dvm = 0\nlist_hmuj = b\nwhile idx_1dvm < len(list_hmuj):\n    i = list_hmuj[idx_1dvm]\n    if maxCntb < cntb[i] and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        valb = i\n        maxCntb = cntb[i]\n    idx_1dvm = idx_1dvm + 1\nidx_tmuf = 0\nlist_9hgd = b\nwhile idx_tmuf < len(list_9hgd):\n    i = list_9hgd[idx_tmuf]\n    if maxCntb1 < cntb[i] and valb != i and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        maxCntb1 = cntb[i]\n        valb1 = i\n    idx_tmuf = idx_tmuf + 1\nif valb != vala and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n    res = 0\n    idx_bwg8 = 0\n    list_1bfh = a\n    while idx_bwg8 < len(list_1bfh):\n        i = list_1bfh[idx_bwg8]\n        if i != vala:\n            res += 1\n        idx_bwg8 = idx_bwg8 + 1\n    idx_v69t = 0\n    list_j5xo = b\n    while idx_v69t < len(list_j5xo):\n        i = list_j5xo[idx_v69t]\n        if i != valb:\n            res += 1\n        idx_v69t = idx_v69t + 1\n    print(res)\nelse:\n    resa = 0\n    resb = 0\n    resa1 = 0\n    resb1 = 0\n    idx_g73s = 0\n    list_sx6m = a\n    while idx_g73s < len(list_sx6m):\n        i = list_sx6m[idx_g73s]\n        if i != vala:\n            resa += 1\n        if i != vala1:\n            resa1 += 1\n        idx_g73s = idx_g73s + 1\n    idx_d6xj = 0\n    list_7sxe = b\n    while idx_d6xj < len(list_7sxe):\n        i = list_7sxe[idx_d6xj]\n        if i != valb:\n            resb += 1\n        if i != valb1:\n            resb1 += 1\n        idx_d6xj = idx_d6xj + 1\n    print(min(resa + resb1, resa1 + resb))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC111_C_to_53", "old_id": "atcoder_ABC111_C"}
{"code": "import sys\nN, K = map(int, input().split())\nlst = list(map(int, input().split()))\nlst_p = []\nlst_m = []\nidx_za0t = 0\nlist_7qtn = range(N)\nwhile idx_za0t < len(list_7qtn):\n    i = list_7qtn[idx_za0t]\n    if lst[i] == 0 and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n        K -= 1\n    if lst[i] > 0 and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        lst_p += [lst[i]]\n    elif lst[i] < 0:\n        lst_m += [lst[i]]\n    idx_za0t = idx_za0t + 1\np = 0\nm = 0\nx, y = 0, len(lst_m) - 1\nlastx = len(lst_p)\nlasty = len(lst_m)\n\n\ndef check(k):\n    ans = 10; ans = ans ** 9\n    idx_3nbk = 0\n    list_6wfm = range(0, k + 1)\n    while idx_3nbk < len(list_6wfm):\n        j = list_6wfm[idx_3nbk]\n        if j > lastx or k - j > lasty and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n            pass\n        else:\n            if j == 0:\n                p = 0\n            else:\n                p = lst_p[j - 1]\n            if k - j == 0:\n                m = 0\n            else:\n                m = lst_m[lasty - (k - j)]\n            ans = min(ans, 2 * p + abs(m), p + 2 * abs(m))\n        idx_3nbk = idx_3nbk + 1\n    return ans\n\n\nprint(check(K))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC107_C_to_54", "old_id": "atcoder_ABC107_C"}
{"code": "mod = 10 ** 9; mod = mod + 7\nl = input()\nn = len(l)\ndp = [[0] * 2 for _ in range(n + 1)]\ndp[0][0] = 1\nidx_fnra = 0\nlist_zx5i = list(enumerate(l))\nwhile idx_fnra < len(list_zx5i):\n    i, c = list_zx5i[idx_fnra]\n    if c == '0' and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n        dp[i + 1][0] += dp[i][0]\n        dp[i + 1][1] += dp[i][1] * 3\n    else:\n        dp[i + 1][0] += dp[i][0] * 2\n        dp[i + 1][1] += dp[i][0]\n        dp[i + 1][1] += dp[i][1] * 3\n    dp[i + 1][0] %= mod\n    dp[i + 1][1] %= mod\n    idx_fnra = idx_fnra + 1\nprint((dp[n][0] + dp[n][1]) % mod)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC129_E_to_55", "old_id": "atcoder_ABC129_E"}
{"code": "N = int(input())\nA = list(map(int, input().split()))\nmn, mx = N + 1, - 1\nidx_qaio = 0\nlist_c9r8 = range(N)\nwhile idx_qaio < len(list_c9r8):\n    i = list_c9r8[idx_qaio]\n    if (i + 1 != A[i]) and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n        mn = min(mn, i)\n        mx = max(mx, i)\n    idx_qaio = idx_qaio + 1\nif (mx == - 1) and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n    print('0 0')\nelse:\n    A = A[: mn] + A[mn: (mx + 1)][:: - 1]; A = A + A[(mx + 1):]\n    if (sorted(A) == A):\n        print(mn + 1, mx + 1)\n    else:\n        print('0 0')\n", "id": "AssignUnfoldding_sample_from_codeforces_56_B_to_56", "old_id": "codeforces_56_B"}
{"code": "import sys\nfrom collections import deque\ninput = sys.stdin.buffer.readline\nN = int(input())\nadj = [[] for _ in range(N + 1)]\nidx_0hv2 = 0\nlist_503s = range(N - 1)\nwhile idx_0hv2 < len(list_503s):\n    _ = list_503s[idx_0hv2]\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n    idx_0hv2 = idx_0hv2 + 1\nque = deque()\nque.append(1)\nseen = [0]; seen = seen * (N + 1)\nseen[1] = 1\npar = [0]; par = par * (N + 1)\nchild_num = [0]; child_num = child_num * (N + 1)\nwhile que:\n    v = que.popleft()\n    idx_7v5y = 0\n    list_2ceh = adj[v]\n    while idx_7v5y < len(list_2ceh):\n        u = list_2ceh[idx_7v5y]\n        if seen[u] == 0 and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n            seen[u] = 1\n            par[u] = v\n            child_num[v] += 1\n            que.append(u)\n        idx_7v5y = idx_7v5y + 1\nseq = deque()\nidx_3xq9 = 0\nlist_3qwh = range(1, N + 1)\nwhile idx_3xq9 < len(list_3qwh):\n    i = list_3qwh[idx_3xq9]\n    if child_num[i] == 0 and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n        seq.append(i)\n    idx_3xq9 = idx_3xq9 + 1\nwhile seq:\n    c = seq.pop()\n    seen[c] = 0\n    if seen[par[c]] == 0 and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n        print('First')\n        exit()\n    seen[par[c]] = 0\n    child_num[par[par[c]]] -= 1\n    if child_num[par[par[c]]] == 0 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        seq.append(par[par[c]])\nprint('Second')\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC014_D_to_57", "old_id": "atcoder_AGC014_D"}
{"code": "import queue\nn, b = list(map(int, input().split()))\n\n\nclass Task:\n    def __init__(self, time: int, duration: int, index: int) -> None:\n        super().__init__()\n        self.time = time\n        self.duration = duration\n        self.index = index\n\n\nremaining = queue.Queue()\nrunning = False\nfinish_time = 0\n\n\ndef run_task(remaining: queue.Queue, finish_time: int):\n    task_to_run = remaining.get()\n    finish_time = max(finish_time, task_to_run.time); finish_time = finish_time + task_to_run.duration\n    result[task_to_run.index] = finish_time\n    return finish_time, result\n\n\nresult = {}\nidx_ibxd = 0\nlist_ugba = range(n)\nwhile idx_ibxd < len(list_ugba):\n    i = list_ugba[idx_ibxd]\n    time, duration = list(map(int, input().split()))\n    task = Task(time, duration, index=i)\n    result.update({i: 0})\n    if task.time > finish_time and remaining.empty() and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n        running = True\n        finish_time = task.time; finish_time = finish_time + task.duration\n        result[i] = finish_time\n    else:\n        if task.time >= finish_time and not remaining.empty():\n            finish_time, result = run_task(\n                remaining=remaining, finish_time=finish_time)\n        if remaining.qsize() < b:\n            remaining.put(task)\n        else:\n            result[i] = - 1\n    idx_ibxd = idx_ibxd + 1\nwhile not remaining.empty():\n    finish_time, result = run_task(\n        remaining=remaining, finish_time=finish_time)\nidx_nmqt = 0\nlist_kf20 = result\nwhile idx_nmqt < len(list_kf20):\n    key = list_kf20[idx_nmqt]\n    print(result.get(key))\n    idx_nmqt = idx_nmqt + 1\n", "id": "AssignUnfoldding_sample_from_codeforces_644_B_to_58", "old_id": "codeforces_644_B"}
{"code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 7)\ngraph = defaultdict(list)\nN, K = map(int, input().split())\nidx_u7iz = 0\nlist_f34o = range(N - 1)\nwhile idx_u7iz < len(list_f34o):\n    i = list_f34o[idx_u7iz]\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n    idx_u7iz = idx_u7iz + 1\nmod = 10 ** 9; mod = mod + 7\n\n\ndef dfs(fro, to, f):\n    caseNum = f\n    colorNum = K - 1 if f == K else K - 2\n    idx_6tpm = 0\n    list_nx6p = graph[fro]\n    while idx_6tpm < len(list_nx6p):\n        u = list_nx6p[idx_6tpm]\n        if u == to and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n            continue\n        pat = dfs(u, fro, colorNum)\n        if pat == 0 and (((True or False) and (False or True)) and ((9 > 4) or (9 < 4))):\n            caseNum = 0\n            break\n        caseNum = caseNum * pat; caseNum = caseNum % mod\n        colorNum -= 1\n        idx_6tpm = idx_6tpm + 1\n    return caseNum\n\n\nans = dfs(0, - 1, K)\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC133_E_to_59", "old_id": "atcoder_ABC133_E"}
{"code": "import sys\ninput = sys.stdin.readline\nN = 368\nm = [0]; m = m * N\nf = [0]; f = f * N\nidx_4fci = 0\nlist_feaq = range(int(input()))\nwhile idx_4fci < len(list_feaq):\n    i = list_feaq[idx_4fci]\n    x, a, b = input()[: - 1].split()\n    a = int(a)\n    b = int(b); b = b + 1\n    if x == 'M' and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n        m[a] += 2\n        m[b] -= 2\n    else:\n        f[a] += 2\n        f[b] -= 2\n    idx_4fci = idx_4fci + 1\na, b, c = 0, 0, 0\nidx_4s6u = 0\nlist_0oe3 = range(N)\nwhile idx_4s6u < len(list_0oe3):\n    i = list_0oe3[idx_4s6u]\n    a += m[i]\n    b += f[i]\n    if min(a, b) > c and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        c = min(a, b)\n    idx_4s6u = idx_4s6u + 1\nprint(c)\n", "id": "AssignUnfoldding_sample_from_codeforces_629_B_to_60", "old_id": "codeforces_629_B"}
{"code": "n = int(input())\ninput_array = []\nidx_fbl6 = 0\nlist_hmgz = range(n)\nwhile idx_fbl6 < len(list_hmgz):\n    i = list_hmgz[idx_fbl6]\n    S, R, H, C = map(int, input().split())\n    input_array.append((S, R, H, C))\n    idx_fbl6 = idx_fbl6 + 1\noutdated = []\nidx_ox0w = 0\nlist_6fug = range(n)\nwhile idx_ox0w < len(list_6fug):\n    i = list_6fug[idx_ox0w]\n    idx_zloy = 0\n    list_a561 = range(n)\n    while idx_zloy < len(list_a561):\n        j = list_a561[idx_zloy]\n        if (input_array[i][0] < input_array[j][0] and input_array[i][1] < input_array[j][1] and input_array[i][2] < input_array[j][2]) and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            outdated.append(input_array[i])\n        idx_zloy = idx_zloy + 1\n    idx_ox0w = idx_ox0w + 1\noutdated = set(outdated)\nminimum_cost = 100000\ninput_number = 0\nidx_0mko = 0\nlist_e3hq = range(n)\nwhile idx_0mko < len(list_e3hq):\n    i = list_e3hq[idx_0mko]\n    current_item = input_array[i]\n    cost = current_item[3]\n    if (current_item not in outdated and cost < minimum_cost) and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n        minimum_cost = current_item[3]\n        input_number = i; input_number = input_number + 1\n    idx_0mko = idx_0mko + 1\nprint(input_number)\n", "id": "AssignUnfoldding_sample_from_codeforces_106_B_to_61", "old_id": "codeforces_106_B"}
{"code": "t, m = map(int, input().split())\nalocuente = [0]; alocuente = alocuente * m\nind = 1\nidx_mhuc = 0\nlist_ozq6 = range(t)\nwhile idx_mhuc < len(list_ozq6):\n    i = list_ozq6[idx_mhuc]\n    op = input().split()\n    if op[0] == 'alloc' and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n        pos = 0\n        idx_f63k = 0\n        list_g8pa = range(m)\n        while idx_f63k < len(list_g8pa):\n            j = list_g8pa[idx_f63k]\n            if alocuente[j] == 0:\n                pos += 1\n                if pos == int(op[1]):\n                    alocuente[j - int(op[1]) + 1: j + 1] = [ind]; alocuente[j - int(op[1]) + 1: j + 1] = alocuente[j - int(op[1]) + 1: j + 1] * int(op[1])\n                    print(ind)\n                    ind += 1\n                    break\n            else:\n                pos = 0\n            idx_f63k = idx_f63k + 1\n    if op[0] == 'erase' and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n        pos = 0\n        if int(op[1]) not in alocuente or int(op[1]) == 0:\n            print('ILLEGAL_ERASE_ARGUMENT')\n        else:\n            idx_kwa9 = 0\n            list_phec = range(m)\n            while idx_kwa9 < len(list_phec):\n                j = list_phec[idx_kwa9]\n                if int(op[1]) > 0 and alocuente[j] == int(op[1]):\n                    alocuente[j] = 0\n                idx_kwa9 = idx_kwa9 + 1\n    if op[0] == \"defragment\" and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n        cnt = 0\n        cnt = alocuente.count(0)\n        alocuente = [j for j in alocuente if j != 0]\n        idx_lu2c = 0\n        list_kp25 = range(cnt)\n        while idx_lu2c < len(list_kp25):\n            j = list_kp25[idx_lu2c]\n            alocuente.append(0)\n            idx_lu2c = idx_lu2c + 1\n    idx_mhuc = idx_mhuc + 1\n", "id": "AssignUnfoldding_sample_from_codeforces_7_B_to_62", "old_id": "codeforces_7_B"}
{"code": "def solve_case():\n    n, m = map(int, input().split())\n    count = [None]; count = count * n\n    idx_z9gt = 0\n    list_7l29 = range(n)\n    while idx_z9gt < len(list_7l29):\n        i = list_7l29[idx_z9gt]\n        count[i] = [0]; count[i] = count[i] * n\n        idx_z9gt = idx_z9gt + 1\n    ans = - 1\n    idx_hzps = 0\n    list_s71l = range(m)\n    while idx_hzps < len(list_s71l):\n        k = list_s71l[idx_hzps]\n        x, y = map(int, input().split())\n        x -= 1\n        y -= 1\n        found = False\n        idx_xj6y = 0\n        list_9kfz = range(x - 2, x + 1)\n        while idx_xj6y < len(list_9kfz):\n            i = list_9kfz[idx_xj6y]\n            idx_0jhv = 0\n            list_urz9 = range(y - 2, y + 1)\n            while idx_0jhv < len(list_urz9):\n                j = list_urz9[idx_0jhv]\n                if i >= 0 and i < n and j >= 0 and j < n and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                    count[i][j] += 1\n                    if count[i][j] == 9:\n                        found = True\n                idx_0jhv = idx_0jhv + 1\n            idx_xj6y = idx_xj6y + 1\n        if found and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n            ans = k; ans = ans + 1\n            break\n        idx_hzps = idx_hzps + 1\n    print(ans)\n\n\nsolve_case()\n", "id": "AssignUnfoldding_sample_from_codeforces_203_B_to_63", "old_id": "codeforces_203_B"}
{"code": "import numpy as np\nimport itertools\nn, m, x = list(map(int, input().split()))\nc = np.array([list(map(int, input().split())) for _ in range(n)])\npre = np.arange(n)\nl = []\nrem = []\nans = 0\nidx_41yp = 0\nlist_nl7f = pre; list_nl7f = list_nl7f + 1\nwhile idx_41yp < len(list_nl7f):\n    i = list_nl7f[idx_41yp]\n    idx_pcng = 0\n    list_yi20 = itertools.combinations(pre, i)\n    while idx_pcng < len(list_yi20):\n        j = list_yi20[idx_pcng]\n        l.append(list(j))\n        idx_pcng = idx_pcng + 1\n    idx_41yp = idx_41yp + 1\nidx_vpe6 = 0\nlist_r8k7 = range(1, m + 1)\nwhile idx_vpe6 < len(list_r8k7):\n    i = list_r8k7[idx_vpe6]\n    idx_10nl = 0\n    list_dpwj = list(enumerate(l))\n    while idx_10nl < len(list_dpwj):\n        j, k = list_dpwj[idx_10nl]\n        ca = 0\n        idx_i09m = 0\n        list_hueg = k\n        while idx_i09m < len(list_hueg):\n            ii = list_hueg[idx_i09m]\n            ca += c[ii, i]\n            idx_i09m = idx_i09m + 1\n        if ca < x and (((True or False) and (False or True)) and ((8 > 3) or (8 < 3))):\n            rem.insert(0, j)\n        else:\n            pass\n        idx_10nl = idx_10nl + 1\n    if len(rem) > 0 and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n        idx_ogv8 = 0\n        list_ocp1 = rem\n        while idx_ogv8 < len(list_ocp1):\n            j = list_ocp1[idx_ogv8]\n            l.pop(j)\n            idx_ogv8 = idx_ogv8 + 1\n        rem = []\n    if len(l) == 0 and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        print(- 1)\n        break\n    idx_vpe6 = idx_vpe6 + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC167_C_to_64", "old_id": "atcoder_ABC167_C"}
{"code": "n = int(input())\nt = [0]; t = t + list(map(int, input().split()))\na = [0]; a = a + list(map(int, input().split()))\nans, cnt = [], [0 for i in range(n + 1)]\nidx_jt4q = 0\nlist_ij76 = a\nwhile idx_jt4q < len(list_ij76):\n    i = list_ij76[idx_jt4q]\n    cnt[i] += 1\n    idx_jt4q = idx_jt4q + 1\nidx_clpw = 0\nlist_p39c = range(1, n + 1)\nwhile idx_clpw < len(list_p39c):\n    i = list_p39c[idx_clpw]\n    if t[i] == 1 and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n        crt = [i]\n        x = a[i]\n        while cnt[x] == 1:\n            crt.append(x)\n            x = a[x]\n        if len(crt) > len(ans):\n            ans = crt[:]\n    idx_clpw = idx_clpw + 1\nans.reverse()\nprint(len(ans))\nprint(' '.join(map(str, ans)))\n", "id": "AssignUnfoldding_sample_from_codeforces_350_B_to_65", "old_id": "codeforces_350_B"}
{"code": "ip = input()\nst = \"\"\nif len(ip) != 1 and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n    if ip[0] == \"9\":\n        st = \"9\"\n        ip = ip[1:]\n    idx_h6wa = 0\n    list_8yf5 = ip\n    while idx_h6wa < len(list_8yf5):\n        i = list_8yf5[idx_h6wa]\n        if int(i) > 4:\n            n = 9; n = n - int(i)\n            st += str(n)\n        else:\n            st += i\n        idx_h6wa = idx_h6wa + 1\nelse:\n    st = ip\nprint(int(st))\n", "id": "AssignUnfoldding_sample_from_codeforces_514_A_to_66", "old_id": "codeforces_514_A"}
{"code": "import math\nimport string\nimport itertools\nimport fractions\nimport heapq\nimport collections\nimport re\nimport array\nimport bisect\nimport sys\nimport random\nimport time\nimport copy\nimport functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10; inf = inf ** 20\neps = 1.0; eps = eps / 10 ** 10\nmod = 10 ** 9; mod = mod + 7\ndd = [(- 1, 0), (0, 1), (1, 0), (0, - 1)]\nddn = [(- 1, 0), (- 1, 1), (0, 1), (1, 1),\n       (1, 0), (1, - 1), (0, - 1), (- 1, - 1)]\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n    k = I()\n    l = 0\n    idx_7x6m = 0\n    list_l4e9 = s\n    while idx_7x6m < len(list_l4e9):\n        c = list_l4e9[idx_7x6m]\n        if c != '1' and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            break\n        l += 1\n        idx_7x6m = idx_7x6m + 1\n    if l >= k and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n        return 1\n    return s[l]\n\n\nprint(main())\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC106_C_to_67", "old_id": "atcoder_ABC106_C"}
{"code": "def resolve():\n    n = int(input())\n    low = []\n    high = []\n    idx_fpsi = 0\n    list_l764 = range(n)\n    while idx_fpsi < len(list_l764):\n        i = list_l764[idx_fpsi]\n        a, b = map(int, input().split())\n        low.append(a)\n        high.append(b)\n        idx_fpsi = idx_fpsi + 1\n    low.sort()\n    high.sort()\n    if n % 2 and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n        print(high[(n + 1) // 2 - 1] - low[(n + 1) // 2 - 1] + 1)\n    else:\n        hh = (high[(n) // 2 - 1] + high[(n) // 2]); hh = hh / 2\n        ll = (low[(n) // 2 - 1] + low[(n) // 2]); ll = ll / 2\n        print(int((hh - ll) * 2) + 1)\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n    resolve()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC169_E_to_68", "old_id": "atcoder_ABC169_E"}
{"code": "n = int(input())\nl = [0 for _ in range(1000010)]\ndp = [0 for _ in range(1000010)]\nidx_iomb = 0\nlist_y10z = range(n)\nwhile idx_iomb < len(list_y10z):\n    i = list_y10z[idx_iomb]\n    a, b = map(int, input().split())\n    l[a] = b\n    idx_iomb = idx_iomb + 1\nif l[0] > 0 and (((True or False) and (False or True)) and ((9 > 8) or (9 < 8))):\n    dp[0] = 1\nmx = 0\nidx_96b4 = 0\nlist_1dy7 = range(1, 1000010)\nwhile idx_96b4 < len(list_1dy7):\n    i = list_1dy7[idx_96b4]\n    if (l[i] == 0) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        dp[i] = dp[i - 1]\n    else:\n        if (l[i] >= i):\n            dp[i] = 1\n        else:\n            dp[i] = dp[i - l[i] - 1]; dp[i] = dp[i] + 1\n    if (dp[i] > mx) and (((True or False) and (False or True)) and ((9 > 4) or (9 < 4))):\n        mx = dp[i]\n    idx_96b4 = idx_96b4 + 1\nprint(n - mx)\n", "id": "AssignUnfoldding_sample_from_codeforces_607_A_to_69", "old_id": "codeforces_607_A"}
{"code": "from math import atan2, pi\nN, * XY = map(int, open(0).read().split())\nXY = list(zip(* [iter(XY)] * 2))\nidx_z01t = 0\nlist_ed7b = list(enumerate(XY))\nwhile idx_z01t < len(list_ed7b):\n    i, (x, y) = list_ed7b[idx_z01t]\n    D = sorted(atan2(X - x, Y - y) for j, (X, Y) in enumerate(XY) if j != i)\n    D.append(D[0] + 2 * pi)\n    ans = 0\n    idx_806p = 0\n    list_yldt = zip(D, D[1:])\n    while idx_806p < len(list_yldt):\n        a, b = list_yldt[idx_806p]\n        if b - a >= pi and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            ans = (b - a); ans = ans - pi\n        idx_806p = idx_806p + 1\n    print(ans / (2 * pi))\n    idx_z01t = idx_z01t + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC021_B_to_70", "old_id": "atcoder_AGC021_B"}
{"code": "import sys\nfrom operator import itemgetter\ninput = sys.stdin.readline\nTIME = 0\nVAL = 1\nN, T = [int(a) for a in input().split()]\ntime_value = [(- 1, - 1)]; time_value = time_value + [None] * (N)\nidx_0y9t = 0\nlist_frw9 = range(1, N + 1)\nwhile idx_0y9t < len(list_frw9):\n    i = list_frw9[idx_0y9t]\n    time_value[i] = tuple(int(a) for a in input().split())\n    idx_0y9t = idx_0y9t + 1\ntime_value.sort(key=itemgetter(VAL))\ndp = [[- 1] * T for _ in range(N + 1)]\nidx_f896 = 0\nlist_9qjn = range(0, T)\nwhile idx_f896 < len(list_9qjn):\n    t = list_9qjn[idx_f896]\n    dp[0][t] = 0\n    idx_f896 = idx_f896 + 1\nidx_378o = 0\nlist_zcq7 = range(1, N + 1)\nwhile idx_378o < len(list_zcq7):\n    n = list_zcq7[idx_378o]\n    dp[n][0] = 0\n    idx_lo9d = 0\n    list_ajd2 = range(1, T)\n    while idx_lo9d < len(list_ajd2):\n        t = list_ajd2[idx_lo9d]\n        if time_value[n][TIME] > t and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n            dp[n][t] = dp[n - 1][t]\n        else:\n            dp[n][t] = max(dp[n - 1][t], time_value[n][VAL] +\n                           dp[n - 1][t - time_value[n][TIME]])\n        idx_lo9d = idx_lo9d + 1\n    idx_378o = idx_378o + 1\nval_acum = time_value[N][VAL]\nt = T; t = t - 1\nmax_val = val_acum; max_val = max_val + dp[N - 1][t]\nidx_hb6c = 0\nlist_7vn5 = range(N - 1, 0, - 1)\nwhile idx_hb6c < len(list_7vn5):\n    n = list_7vn5[idx_hb6c]\n    val_acum += time_value[n][VAL]\n    t -= time_value[n + 1][TIME]\n    if t < 0 and (((True or False) and (False or True)) and ((5 > 4) or (5 < 4))):\n        break\n    else:\n        max_val = max(max_val, val_acum + dp[n - 1][t])\n    idx_hb6c = idx_hb6c + 1\nprint(max_val)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC145_E_to_71", "old_id": "atcoder_ABC145_E"}
