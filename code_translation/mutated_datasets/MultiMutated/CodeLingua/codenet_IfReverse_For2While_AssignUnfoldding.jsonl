{"code": "import math\nN, K = (int(x) for x in input().split())\nR = N; R = R - K\nmod = 10**9; mod = mod + 7\n\n\ndef fact(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nidx_218v = 0\nlist_cp1x = range(1, K+1)\nwhile idx_218v < len(list_cp1x):\n    i = list_cp1x[idx_218v]\n    if not N - K + 1 < i:\n        ans = fact(R+1, i); ans = ans*fact(K-1, i-1)\n    else:\n        ans = 0\n    print(int(ans) % mod)\n    idx_218v = idx_218v + 1\n", "id": "AssignUnfoldding_sample_from_s790754864_to_0", "old_id": "s790754864"}
{"code": "strn = input()\nn = int(strn)\nshichigolist = [\"3\", \"5\", \"7\"]\nshichigo = [[] for _ in range(len(strn))]\nidx_6loq = 0\nlist_he64 = range(len(strn))\nwhile idx_6loq < len(list_he64):\n    i = list_he64[idx_6loq]\n    if not i == 0:\n        idx_zh4t = 0\n        list_omhx = shichigo[i-1]\n        while idx_zh4t < len(list_omhx):\n            j = list_omhx[idx_zh4t]\n            idx_7mln = 0\n            list_unes = shichigolist\n            while idx_7mln < len(list_unes):\n                k = list_unes[idx_7mln]\n                shichigo[i].append(j+k)\n                idx_7mln = idx_7mln + 1\n            idx_zh4t = idx_zh4t + 1\n    else:\n        idx_dxi7 = 0\n        list_pu5l = shichigolist\n        while idx_dxi7 < len(list_pu5l):\n            j = list_pu5l[idx_dxi7]\n            shichigo[i].append(j)\n            idx_dxi7 = idx_dxi7 + 1\n    idx_6loq = idx_6loq + 1\ntarget = len(strn); target = target-1\nidx_9alv = 0\nlist_ynqm = range(len(strn))\nwhile idx_9alv < len(list_ynqm):\n    i = list_ynqm[idx_9alv]\n    idx_gzwl = 0\n    list_kdgr = shichigo[i][:]\n    while idx_gzwl < len(list_kdgr):\n        j = list_kdgr[idx_gzwl]\n        if not i == target:\n            if j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[i].remove(j)\n        else:\n            if int(j) > n:\n                shichigo[target].remove(j)\n            elif j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[target].remove(j)\n        idx_gzwl = idx_gzwl + 1\n    idx_9alv = idx_9alv + 1\n\nprint(sum([len(shichigo[i]) for i in range(len(strn))]))\n", "id": "AssignUnfoldding_sample_from_s949655009_to_1", "old_id": "s949655009"}
{"code": "import sys\nimport math\n\nfrom collections import defaultdict\nfrom collections import deque\n\n\ndef load(vtype=int):\n    return vtype(input().strip())\n\n\ndef load_list(seplator=\" \", vtype=int):\n    return [vtype(v) for v in input().strip().split(seplator)]\n\n\ndef exit():\n    import sys\n    sys.exit(0)\n\n\ndef perm_sub(li, used):\n    if len(li) == len(used):\n        return [deque()]\n    k = []\n    idx_f0xo = 0\n    list_28z4 = range(len(li))\n    while idx_f0xo < len(list_28z4):\n        i = list_28z4[idx_f0xo]\n        if i in used:\n            continue\n        used.add(i)\n        sub_list = perm_sub(li, used)\n        idx_kc50 = 0\n        list_c7bd = sub_list\n        while idx_kc50 < len(list_c7bd):\n            sub = list_c7bd[idx_kc50]\n            sub.appendleft(li[i])\n            idx_kc50 = idx_kc50 + 1\n        k.extend(sub_list)\n        used.discard(i)\n        idx_f0xo = idx_f0xo + 1\n    return k\n\n\ndef perm_li(li):\n    return perm_sub(li, set())\n\n\ndef perm_n(n):\n    return perm_sub(list(range(n)), set())\n\n\ndef join_i(li, sep=\"\"):\n    return sep.join([str(e) for e in li])\n\n\ndef li2n(li):\n    n, base = 0, 1\n    idx_ngf0 = 0\n    list_675l = range(len(li)-1, -1, -1)\n    while idx_ngf0 < len(list_675l):\n        i = list_675l[idx_ngf0]\n        n += li[i] * base\n        base *= 10\n        idx_ngf0 = idx_ngf0 + 1\n    return n\n\n\ndef sli2ili(li):\n    return [int(s) for s in li]\n\n\ndef prime_list(n):\n    li = [i for i in range(2, n+1)]\n    idx_a3ox = 0\n    list_prl0 = range(len(li))\n    while idx_a3ox < len(list_prl0):\n        i = list_prl0[idx_a3ox]\n        if li[i] >= int(math.sqrt(n)):\n            break\n        if li[i] == -1:\n            continue\n        idx_se45 = 0\n        list_l6g2 = range(i+1, len(li))\n        while idx_se45 < len(list_l6g2):\n            j = list_l6g2[idx_se45]\n            if li[j] % li[i] == 0:\n                li[j] = -1\n            idx_se45 = idx_se45 + 1\n        idx_a3ox = idx_a3ox + 1\n    return [n for n in li if n != -1]\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while True:\n        r = a; r = r % b\n        if r == 0:\n            return b\n        a, b = b, r\n\n\ndef lcm(a, b):\n    return int(a * b / gcd(a, b))\n\n\ndef all_subset(li):\n    s = []\n    n = len(li)\n    idx_9u21 = 0\n    list_8sy3 = range(0, (1 << (n+1)))\n    while idx_9u21 < len(list_8sy3):\n        bit = list_8sy3[idx_9u21]\n        ss = set()\n        idx_qxrl = 0\n        list_gldy = range(0, n)\n        while idx_qxrl < len(list_gldy):\n            i = list_gldy[idx_qxrl]\n            if (bit & (1 << i)):\n                ss.add(li[i])\n            idx_qxrl = idx_qxrl + 1\n        s.append(ss)\n        idx_9u21 = idx_9u21 + 1\n    return s\n\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\n\n\ndef mCn(m, n):\n    def factorial_ntimes(m, n):\n        r = 1\n        while n:\n            r *= m\n            m -= 1\n            n -= 1\n        return r\n    return int(factorial_ntimes(m, n) / factorial(n))\n\n\nn = load()\nA = load_list()\nif not n == len(set(A)):\n    print('NO')\nelse:\n    print('YES')\n", "id": "AssignUnfoldding_sample_from_s137613418_to_2", "old_id": "s137613418"}
{"code": "from functools import reduce\nimport math\n\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\n\ndef lcm_list(numbers):\n    return reduce(lcm, numbers, 1)\n\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n\nA = [a // 2 for a in A]\n\n\ncount_div_2 = None\nidx_74er = 0\nlist_wvn9 = A\nwhile idx_74er < len(list_wvn9):\n    a = list_wvn9[idx_74er]\n    cnt = 0\n    while a % 2 == 0:\n        a //= 2\n        cnt += 1\n    if not count_div_2 is None:\n\n        if cnt != count_div_2:\n            print(0)\n            exit()\n    else:\n        count_div_2 = cnt\n    idx_74er = idx_74er + 1\n\n\nmy_lcm = lcm_list(A)\nif my_lcm > M:\n    print(0)\n    exit()\n\ntmp = M; tmp = tmp // my_lcm\n\n\nans = (tmp + 1); ans = ans // 2\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s817205687_to_3", "old_id": "s817205687"}
{"code": "n = int(input())\nS = list(map(int, input().split()))\nq = int(input())\nT = list(map(int, input().split()))\n\nans = 0\nidx_c95k = 0\nlist_7gkd = T\nwhile idx_c95k < len(list_7gkd):\n    i = list_7gkd[idx_c95k]\n    if not i == S[-1] or i == S[0]:\n        left = 0\n        right = n; right = right-1\n        while right-left > 1:\n            mid = (left+right); mid = mid//2\n            if S[mid] == i:\n                ans += 1\n                break\n            elif S[mid] < i:\n                left = mid\n            else:\n                right = mid\n    else:\n        ans += 1\n    idx_c95k = idx_c95k + 1\n\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s315467749_to_4", "old_id": "s315467749"}
{"code": "import collections\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    ve = []\n    vo = []\n    idx_etqs = 0\n    list_he76 = range(n//2)\n    while idx_etqs < len(list_he76):\n        i = list_he76[idx_etqs]\n        ve.append(v[2*i])\n        vo.append(v[2*i+1])\n        idx_etqs = idx_etqs + 1\n    ce = collections.Counter(ve)\n    co = collections.Counter(vo)\n    ans = n\n    if not ce.most_common()[0][0] != co.most_common()[0][0]:\n        if len(ce) == 1 and len(co) == 1:\n            ans = n; ans = ans-ce.most_common()[0][1]\n        elif len(ce) == 1:\n            ans = n-ce.most_common()[0][1]; ans = ans-co.most_common()[1][1]\n        elif len(co) == 1:\n            ans = n-ce.most_common()[1][1]; ans = ans-co.most_common()[0][1]\n        else:\n            ans = min(n-ce.most_common()[0][1]-co.most_common()[1]\n                      [1], n-ce.most_common()[1][1]-co.most_common()[0][1])\n    else:\n        ans = n-ce.most_common()[0][1]; ans = ans-co.most_common()[0][1]\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "id": "AssignUnfoldding_sample_from_s101447419_to_5", "old_id": "s101447419"}
{"code": "import sys\nfrom bisect import bisect_left\n\n\ndef solve():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    A = [(int(a) % K) - 1 for a in input().split()]\n    sum_A = [0 for _ in range(N + 1)]\n\n    count = 0\n    modK = dict()\n    modK[0] = [0]\n    idx_das8 = 0\n    list_botr = range(N)\n    while idx_das8 < len(list_botr):\n        i = list_botr[idx_das8]\n        sum_A[i + 1] = (sum_A[i] + A[i]); sum_A[i + 1] = sum_A[i + 1] % K\n        if not sum_A[i+1] not in modK:\n            modK[sum_A[i+1]].append(i+1)\n        else:\n            modK[sum_A[i+1]] = [i + 1]\n        idx_das8 = idx_das8 + 1\n    idx_usgn = 0\n    list_ql2o = modK\n    while idx_usgn < len(list_ql2o):\n        key = list_ql2o[idx_usgn]\n        lenK = len(modK[key])\n        idx_9sqd = 0\n        list_by2d = list(enumerate(modK[key]))\n        while idx_9sqd < len(list_by2d):\n            i, a = list_by2d[idx_9sqd]\n            count += bisect_left(modK[key], a + K, i, lenK) - i - 1\n            idx_9sqd = idx_9sqd + 1\n        idx_usgn = idx_usgn + 1\n\n    print(count)\n    return 0\n\n\nif __name__ == \"__main__\":\n    solve()\n", "id": "AssignUnfoldding_sample_from_s975943078_to_6", "old_id": "s975943078"}
{"code": "import re\nimport math\nfrom collections import defaultdict\nimport itertools\nfrom copy import deepcopy\nimport random\nfrom heapq import heappop, heappush\nimport time\nimport os\nimport queue\nimport sys\nimport datetime\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\nsys.setrecursionlimit(2000000)\n\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\nmod = int(10**9+7)\ninf = int(10**20)\n\n\ndef yn(b):\n    if not b:\n        print(\"no\")\n    else:\n        print(\"yes\")\n\n\ndef Yn(b):\n    if not b:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\n\ndef YN(b):\n    if not b:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\n\nclass union_find():\n    def __init__(self, n):\n        self.n = n\n        self.P = [a for a in range(N)]\n        self.rank = [0]; self.rank = self.rank*n\n\n    def find(self, x):\n        if (x != self.P[x]):\n            self.P[x] = self.find(self.P[x])\n        return self.P[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def link(self, x, y):\n        if not self.rank[x] < self.rank[y]:\n            if self.rank[y] < self.rank[x]:\n                self.P[y] = x\n            else:\n                self.P[x] = y\n                self.rank[y] += 1\n        else:\n            self.P[x] = y\n\n    def unite(self, x, y):\n        self.link(self.find(x), self.find(y))\n\n    def size(self):\n        S = set()\n        idx_frb5 = 0\n        list_uj5i = range(self.n)\n        while idx_frb5 < len(list_uj5i):\n            a = list_uj5i[idx_frb5]\n            S.add(self.find(a))\n            idx_frb5 = idx_frb5 + 1\n        return len(S)\n\n\ndef is_power(a, b):\n    now = b\n    while now < a:\n        now *= b\n    if not now == a:\n        return False\n    else:\n        return True\n\n\ndef bin_(num, size):\n    A = [0]; A = A*size\n    idx_0scn = 0\n    list_fa84 = range(size)\n    while idx_0scn < len(list_fa84):\n        a = list_fa84[idx_0scn]\n        if not (num >> (size-a-1)) & 1 == 1:\n            A[a] = 0\n        else:\n            A[a] = 1\n        idx_0scn = idx_0scn + 1\n    return A\n\n\ndef get_facs(n, mod_=0):\n    A = [1]; A = A*(n+1)\n    idx_uqjf = 0\n    list_ya3f = range(2, len(A))\n    while idx_uqjf < len(list_ya3f):\n        a = list_ya3f[idx_uqjf]\n        A[a] = A[a-1]; A[a] = A[a]*a\n        if (mod > 0):\n            A[a] %= mod_\n        idx_uqjf = idx_uqjf + 1\n    return A\n\n\ndef comb(n, r, mod, fac):\n    if (n-r < 0):\n        return 0\n    return (fac[n]*pow(fac[n-r], mod-2, mod)*pow(fac[r], mod-2, mod)) % mod\n\n\ndef next_comb(num, size):\n    x = num; x = x & (-num)\n    y = num; y = y+x\n    z = num; z = z & (~y)\n    z //= x\n    z = z >> 1\n    num = y; num = num | z\n    if not (num >= (1 << size)):\n        return num\n    else:\n        return False\n\n\ndef get_primes(n, type=\"int\"):\n    A = [True]; A = A*(n+1)\n    A[0] = False\n    A[1] = False\n    idx_qvus = 0\n    list_wjrc = range(2, n+1)\n    while idx_qvus < len(list_wjrc):\n        a = list_wjrc[idx_qvus]\n        if A[a]:\n            idx_3aor = 0\n            list_40zu = range(a*2, n+1, a)\n            while idx_3aor < len(list_40zu):\n                b = list_40zu[idx_3aor]\n                A[b] = False\n                idx_3aor = idx_3aor + 1\n        idx_qvus = idx_qvus + 1\n    if (type == \"bool\"):\n        return A\n    B = []\n    idx_q58y = 0\n    list_wv2h = range(n+1)\n    while idx_q58y < len(list_wv2h):\n        a = list_wv2h[idx_q58y]\n        if (A[a]):\n            B.append(a)\n        idx_q58y = idx_q58y + 1\n    return B\n\n\ndef is_prime(num):\n    if (num <= 2):\n        return False\n    i = 2\n    while i*i <= num:\n        if (num % i == 0):\n            return False\n        i += 1\n    return True\n\n\ndef ifelse(a, b, c):\n    if not a:\n        return c\n    else:\n        return b\n\n\ndef join(A, c=\" \"):\n    n = len(A)\n    A = list(map(str, A))\n    s = \"\"\n    idx_mzv1 = 0\n    list_f8t3 = range(n)\n    while idx_mzv1 < len(list_f8t3):\n        a = list_f8t3[idx_mzv1]\n        s += A[a]\n        if (a < n-1):\n            s += c\n        idx_mzv1 = idx_mzv1 + 1\n    return s\n\n\ndef factorize(n, type_=\"dict\"):\n    b = 2\n    list_ = []\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            list_.append(b)\n        b += 1\n    if n > 1:\n        list_.append(n)\n    if not type_ == \"dict\":\n        if type_ == \"list\":\n            return list_\n        else:\n            return None\n    else:\n        dic = {}\n        idx_9rdp = 0\n        list_a3lm = list_\n        while idx_9rdp < len(list_a3lm):\n            a = list_a3lm[idx_9rdp]\n            if a in dic:\n                dic[a] += 1\n            else:\n                dic[a] = 1\n            idx_9rdp = idx_9rdp + 1\n        return dic\n\n\ndef floor_(n, x=1):\n    return x*(n//x)\n\n\ndef ceil_(n, x=1):\n    return x*((n+x-1)//x)\n\n\ndef hani(x, min_, max_):\n    ret = x\n    if x < min_:\n        ret = min_\n    if x > max_:\n        ret = max_\n    return ret\n\n\ndef seifu(x):\n    return x//abs(x)\n\n\ndef main():\n    n, l = map(int, input().split())\n    S = []\n    idx_adlo = 0\n    list_nl4z = range(n)\n    while idx_adlo < len(list_nl4z):\n        a = list_nl4z[idx_adlo]\n        S.append(input())\n        idx_adlo = idx_adlo + 1\n    S.sort()\n    print(\"\".join(S))\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_s977408144_to_7", "old_id": "s977408144"}
{"code": "from collections import deque\nH, W = map(int, input().split())\nG = []\nidx_3y9j = 0\nlist_g32l = range(H+2)\nwhile idx_3y9j < len(list_g32l):\n    i = list_g32l[idx_3y9j]\n    if not i == 0 or i == H+1:\n        G.append('#' + input() + '#')\n    else:\n        G.append('#'*(W+2))\n    idx_3y9j = idx_3y9j + 1\n\nans = 0\nidx_jc8z = 0\nlist_ir4b = range(W+2)\nwhile idx_jc8z < len(list_ir4b):\n    sx = list_ir4b[idx_jc8z]\n    idx_04bl = 0\n    list_k9va = range(H+2)\n    while idx_04bl < len(list_k9va):\n        sy = list_k9va[idx_04bl]\n        if G[sy][sx] == '.':\n            dist = [[-float('inf') for i in range(W+2)] for i in range(H+2)]\n            visited = [[-1 for i in range(W+2)] for i in range(H+2)]\n            q = deque([])\n            q.append((sx, sy))\n            dist[sy][sx] = 0\n            visited[sy][sx] = 1\n            while q:\n                x, y = q.popleft()\n\n                if G[y][x+1] == '.' and visited[y][x+1] == -1:\n                    q.append((x+1, y))\n                    dist[y][x+1] = dist[y][x]; dist[y][x+1] = dist[y][x+1] + 1\n                    visited[y][x+1] = 1\n\n                if G[y][x-1] == '.' and visited[y][x-1] == -1:\n                    q.append((x-1, y))\n                    dist[y][x-1] = dist[y][x]; dist[y][x-1] = dist[y][x-1] + 1\n                    visited[y][x-1] = 1\n\n                if G[y+1][x] == '.' and visited[y+1][x] == -1:\n                    q.append((x, y+1))\n                    dist[y+1][x] = dist[y][x]; dist[y+1][x] = dist[y+1][x] + 1\n                    visited[y+1][x] = 1\n\n                if G[y-1][x] == '.' and visited[y-1][x] == -1:\n                    q.append((x, y-1))\n                    dist[y-1][x] = dist[y][x]; dist[y-1][x] = dist[y-1][x] + 1\n                    visited[y-1][x] = 1\n            idx_f0dr = 0\n            list_riuc = range(W+2)\n            while idx_f0dr < len(list_riuc):\n                i = list_riuc[idx_f0dr]\n                idx_ke8g = 0\n                list_cn12 = range(H+2)\n                while idx_ke8g < len(list_cn12):\n                    j = list_cn12[idx_ke8g]\n                    ans = max(ans, dist[j][i])\n                    idx_ke8g = idx_ke8g + 1\n                idx_f0dr = idx_f0dr + 1\n        idx_04bl = idx_04bl + 1\n    idx_jc8z = idx_jc8z + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s951169509_to_8", "old_id": "s951169509"}
{"code": "import sys\n\n\nfrom bisect import bisect_left, bisect_right\n\n\ninput = sys.stdin.readline\n\n\ndef getS(): return input().strip()\ndef getN(): return int(input())\ndef getList(): return list(map(int, input().split()))\ndef getZList(): return [int(x) - 1 for x in input().split()]\n\n\nINF = 10; INF = INF ** 20\nMOD = 1000000007\n\n\ndef solve():\n    n = getN()\n    dp = [-INF]\n    idx_6lx1 = 0\n    list_x03z = range(n)\n    while idx_6lx1 < len(list_x03z):\n        i = list_x03z[idx_6lx1]\n        num = getN()\n        num = -num\n        if not num >= dp[-1]:\n            idx = bisect_right(dp, num)\n            dp[idx] = num\n        else:\n            dp.append(num)\n        idx_6lx1 = idx_6lx1 + 1\n\n    print(len(dp) - 1)\n    return\n\n\ndef main():\n    n = getN()\n    idx_cfp3 = 0\n    list_0adi = range(n)\n    while idx_cfp3 < len(list_0adi):\n        _ = list_0adi[idx_cfp3]\n        solve()\n        idx_cfp3 = idx_cfp3 + 1\n\n\nif __name__ == \"__main__\":\n\n    solve()\n", "id": "AssignUnfoldding_sample_from_s344468705_to_9", "old_id": "s344468705"}
{"code": "memTime = int(input())\nmemLate = input().split()\nmemLate = [int(i) for i in memLate]\ncolorList = []\nmemColor = 0\nhighLate = 0\nidx_0qrj = 0\nlist_m9ts = range(memTime)\nwhile idx_0qrj < len(list_m9ts):\n    color = list_m9ts[idx_0qrj]\n    member = memLate[color]\n    if not member // 400 >= 8:\n        if ((member // 400) in colorList) == False:\n            colorList.append(member // 400)\n    else:\n        highLate += 1\n    idx_0qrj = idx_0qrj + 1\nmaxColor = len(colorList); maxColor = maxColor + highLate\nminColor = len(colorList)\nif minColor == 0:\n    minColor = 1\nprint(str(minColor) + \" \" + str(maxColor))\n", "id": "AssignUnfoldding_sample_from_s964794058_to_10", "old_id": "s964794058"}
{"code": "n, k = map(int, input().split())\na = [i for i in input()]\nc = [0]; c = c*n\nidx_0s6y = 0\nlist_c6px = range(1, n)\nwhile idx_0s6y < len(list_c6px):\n    i = list_c6px[idx_0s6y]\n    if not a[i] == \"C\" and a[i-1] == \"A\":\n        c[i] = c[i-1]\n    else:\n        c[i] = c[i-1]; c[i] = c[i]+1\n    idx_0s6y = idx_0s6y + 1\nidx_irxa = 0\nlist_rlvo = range(k)\nwhile idx_irxa < len(list_rlvo):\n    w = list_rlvo[idx_irxa]\n    l, r = map(int, input().split())\n    print(c[r-1]-c[l-1])\n    idx_irxa = idx_irxa + 1\n", "id": "AssignUnfoldding_sample_from_s759499751_to_11", "old_id": "s759499751"}
{"code": "from collections import deque\nfrom itertools import product, permutations, combinations\nimport sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef read_col(H):\n\n    ret = []\n    idx_g27r = 0\n    list_oesy = range(H)\n    while idx_g27r < len(list_oesy):\n        _ = list_oesy[idx_g27r]\n        ret.append(list(map(int, readline().split())))\n        idx_g27r = idx_g27r + 1\n    return tuple(map(list, zip(*ret)))\n\n\ndef read_map_as(H, replace={'#': 1, '.': 0}, pad=None):\n    if not pad is None:\n        ret = [[pad] * (W + 2)]\n        idx_jgxo = 0\n        list_20ir = range(H)\n        while idx_jgxo < len(list_20ir):\n            _ = list_20ir[idx_jgxo]\n            ret.append([pad] + [replace[s] for s in read()[:-1]] + [pad])\n            idx_jgxo = idx_jgxo + 1\n        ret.append([pad] * (W + 2))\n    else:\n        ret = []\n        idx_20we = 0\n        list_0joz = range(H)\n        while idx_20we < len(list_0joz):\n            _ = list_0joz[idx_20we]\n            ret.append([replace[s] for s in read()[:-1]])\n            idx_20we = idx_20we + 1\n\n    return ret\n\n\ndef grid_dijkstra(grid, si: int, sj: int):\n\n    from heapq import heappop, heappush\n    H = len(grid)\n    W = len(grid[0])\n    D = [[-1] * W for _ in [0] * H]\n    que = [(0, si, sj)]\n    while que:\n        c, i, j = heappop(que)\n        if D[i][j] != -1:\n            continue\n        D[i][j] = c\n        idx_oley = 0\n        list_1y29 = product([-2, -1, 0, 1, 2], repeat=2)\n        while idx_oley < len(list_1y29):\n            di, dj = list_1y29[idx_oley]\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or grid[ni][nj] == 1:\n                continue\n            if not (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n                nc = c; nc = nc + 1\n            else:\n                nc = c\n            heappush(que, (nc, ni, nj))\n            idx_oley = idx_oley + 1\n    return D\n\n\nMOD = 10**9; MOD = MOD + 7\nINF = 2; INF = INF**31\n\n\nH, W = ints()\nsi, sj = mina(*ints())\nti, tj = mina(*ints())\n\nS = read_map_as(H)\nD = [[-1] * W for _ in [0] * H]\nque = deque([(0, si, sj)])\nwhile que:\n    c, i, j = que.popleft()\n    if D[i][j] != -1:\n        continue\n    D[i][j] = c\n    idx_kb1o = 0\n    list_6ro3 = product([-2, -1, 0, 1, 2], repeat=2)\n    while idx_kb1o < len(list_6ro3):\n        di, dj = list_6ro3[idx_kb1o]\n        ni, nj = i + di, j + dj\n        if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or S[ni][nj] == 1:\n            continue\n        if not (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n            que.append((c + 1, ni, nj))\n        else:\n            que.appendleft((c, ni, nj))\n        idx_kb1o = idx_kb1o + 1\n\nprint(D[ti][tj])\n", "id": "AssignUnfoldding_sample_from_s124725275_to_12", "old_id": "s124725275"}
{"code": "N, T = map(int, input().split())\nL = [[int(l) for l in input().split()] for _ in range(N)]\n\ndp = [[0]*T for _ in range(N+1)]\nidx_e2cv = 0\nlist_z0ew = range(N)\nwhile idx_e2cv < len(list_z0ew):\n    i = list_z0ew[idx_e2cv]\n    idx_wj5e = 0\n    list_vego = range(T)\n    while idx_wj5e < len(list_vego):\n        j = list_vego[idx_wj5e]\n        if not j < L[i][0]:\n            dp[i+1][j] = max(dp[i][j], dp[i][j-L[i][0]]+L[i][1])\n        else:\n            dp[i+1][j] = dp[i][j]\n        idx_wj5e = idx_wj5e + 1\n    idx_e2cv = idx_e2cv + 1\n\nused = []\nB = dp[N][T-1]\nj = T; j = j-1\nidx_mq4k = 0\nlist_py6x = range(N-1, -1, -1)\nwhile idx_mq4k < len(list_py6x):\n    i = list_py6x[idx_mq4k]\n    if B == dp[i][j]:\n        continue\n    B -= L[i][1]\n    used.append(i)\n    j -= L[i][0]\n    idx_mq4k = idx_mq4k + 1\n\nans = dp[N][T-1]\nc = 0\nidx_a93g = 0\nlist_ekgr = range(N)\nwhile idx_a93g < len(list_ekgr):\n    i = list_ekgr[idx_a93g]\n    if i in used:\n        continue\n    c = max(c, L[i][1])\n    idx_a93g = idx_a93g + 1\n\nprint(ans+c)\n", "id": "AssignUnfoldding_sample_from_s793709854_to_13", "old_id": "s793709854"}
{"code": "from operator import itemgetter\n\n\nn, k = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\ninfo = sorted(info, key=itemgetter(1), reverse=True)\n\nselected = info[0:k]\nselected_only = []\nselected_chohuku = []\nunselected_only = []\nmemo = {}\nidx_9ukw = 0\nlist_2qc5 = selected\nwhile idx_9ukw < len(list_2qc5):\n    t, d = list_2qc5[idx_9ukw]\n    if not t not in memo:\n        selected_chohuku.append(d)\n    else:\n        memo[t] = 1\n        selected_only.append(d)\n    idx_9ukw = idx_9ukw + 1\n\ncnt_type = len(memo)\nidx_kd1l = 0\nlist_s0g7 = info[k:]\nwhile idx_kd1l < len(list_s0g7):\n    t, d = list_s0g7[idx_kd1l]\n    if t not in memo:\n        memo[t] = 1\n        unselected_only.append(d)\n    idx_kd1l = idx_kd1l + 1\n\n\nsum_select = sum(selected_chohuku); sum_select = sum_select + sum(selected_only)\nans = cnt_type*cnt_type; ans = ans + sum_select\n\nunselected_only = unselected_only[::-1]\nidx_zh4l = 0\nlist_u0mw = range(min(len(selected_chohuku), len(unselected_only)))\nwhile idx_zh4l < len(list_u0mw):\n    i = list_u0mw[idx_zh4l]\n    cnt_type += 1\n    sum_select += unselected_only[-1]\n    sum_select -= selected_chohuku[-1]\n    del unselected_only[-1]\n    del selected_chohuku[-1]\n    tmp = cnt_type*cnt_type; tmp = tmp + sum_select\n    ans = max(ans, tmp)\n    idx_zh4l = idx_zh4l + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s804484425_to_14", "old_id": "s804484425"}
