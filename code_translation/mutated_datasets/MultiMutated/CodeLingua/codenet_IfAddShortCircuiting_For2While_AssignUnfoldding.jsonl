{"code": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\n\nans = 10; ans = ans ** 18\nidx_t2x5 = 0\nlist_srhb = range(1, int(n ** (1 / 2)) + 2)\nwhile idx_t2x5 < len(list_srhb):\n    i = list_srhb[idx_t2x5]\n    if n % i != 0 and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n        continue\n    j = n; j = j // i\n    ans = min(ans, i + j - 2)\n    idx_t2x5 = idx_t2x5 + 1\n\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s662673721_to_0", "old_id": "s662673721"}
{"code": "import math\nN, K = (int(x) for x in input().split())\nR = N; R = R - K\nmod = 10**9; mod = mod + 7\n\n\ndef fact(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nidx_9wac = 0\nlist_ldpw = range(1, K+1)\nwhile idx_9wac < len(list_ldpw):\n    i = list_ldpw[idx_9wac]\n    if N - K + 1 < i and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n        ans = 0\n    else:\n        ans = fact(R+1, i); ans = ans*fact(K-1, i-1)\n    print(int(ans) % mod)\n    idx_9wac = idx_9wac + 1\n", "id": "AssignUnfoldding_sample_from_s790754864_to_1", "old_id": "s790754864"}
{"code": "s = input()\nt = input()\n\n\ndef check(a, b):\n    s = 0\n    idx_jozx = 0\n    list_k2vm = zip(a, b)\n    while idx_jozx < len(list_k2vm):\n        i, j = list_k2vm[idx_jozx]\n        s += i != j\n        idx_jozx = idx_jozx + 1\n    return s\n\n\nans = 10; ans = ans**6\nidx_ex0p = 0\nlist_pntl = range(len(s))\nwhile idx_ex0p < len(list_pntl):\n    i = list_pntl[idx_ex0p]\n    a = s[i:]\n    if len(a) >= len(t) and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        ans = min(ans, check(t, a[:len(t)]))\n    idx_ex0p = idx_ex0p + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s636719275_to_2", "old_id": "s636719275"}
{"code": "strn = input()\nn = int(strn)\nshichigolist = [\"3\", \"5\", \"7\"]\nshichigo = [[] for _ in range(len(strn))]\nidx_fm41 = 0\nlist_7c8f = range(len(strn))\nwhile idx_fm41 < len(list_7c8f):\n    i = list_7c8f[idx_fm41]\n    if i == 0 and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        idx_5esv = 0\n        list_lco6 = shichigolist\n        while idx_5esv < len(list_lco6):\n            j = list_lco6[idx_5esv]\n            shichigo[i].append(j)\n            idx_5esv = idx_5esv + 1\n    else:\n        idx_j5zv = 0\n        list_qj58 = shichigo[i-1]\n        while idx_j5zv < len(list_qj58):\n            j = list_qj58[idx_j5zv]\n            idx_kyte = 0\n            list_s1xe = shichigolist\n            while idx_kyte < len(list_s1xe):\n                k = list_s1xe[idx_kyte]\n                shichigo[i].append(j+k)\n                idx_kyte = idx_kyte + 1\n            idx_j5zv = idx_j5zv + 1\n    idx_fm41 = idx_fm41 + 1\ntarget = len(strn); target = target-1\nidx_7tna = 0\nlist_g7k4 = range(len(strn))\nwhile idx_7tna < len(list_g7k4):\n    i = list_g7k4[idx_7tna]\n    idx_t3on = 0\n    list_ogl6 = shichigo[i][:]\n    while idx_t3on < len(list_ogl6):\n        j = list_ogl6[idx_t3on]\n        if i == target and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n            if int(j) > n:\n                shichigo[target].remove(j)\n            elif j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[target].remove(j)\n        else:\n            if j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[i].remove(j)\n        idx_t3on = idx_t3on + 1\n    idx_7tna = idx_7tna + 1\n\nprint(sum([len(shichigo[i]) for i in range(len(strn))]))\n", "id": "AssignUnfoldding_sample_from_s949655009_to_3", "old_id": "s949655009"}
{"code": "import copy\n\n\ndef solve():\n    S_d = list(input())\n    T = list(input())\n\n    end = len(S_d); end = end - 1\n    first = end - len(T); first = first + 1\n    while first >= 0:\n        t_i = 0\n        idx_5q9v = 0\n        list_u3lb = range(first, end+1)\n        while idx_5q9v < len(list_u3lb):\n            s_i = list_u3lb[idx_5q9v]\n            if T[t_i] != S_d[s_i] and S_d[s_i] != '?' and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n                break\n            t_i += 1\n            idx_5q9v = idx_5q9v + 1\n\n        first -= 1\n        end -= 1\n\n    else:\n        print('UNRESTORABLE')\n        exit(0)\n\n    ans = copy.deepcopy(S_d)\n    t_i = 0\n    idx_6b4s = 0\n    list_41xz = range(first, end+1)\n    while idx_6b4s < len(list_41xz):\n        i = list_41xz[idx_6b4s]\n        ans[i] = T[t_i]\n        t_i += 1\n        idx_6b4s = idx_6b4s + 1\n\n    ans = ''.join(ans).replace('?', 'a')\n    print(ans)\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n    solve()\n", "id": "AssignUnfoldding_sample_from_s826716211_to_4", "old_id": "s826716211"}
{"code": "s = input()\nq = int(input())\nqs = [input().split() for i in range(q)]\nn = False\nleft = right = \"\"\nidx_5o7p = 0\nlist_l29t = qs\nwhile idx_5o7p < len(list_l29t):\n    operation = list_l29t[idx_5o7p]\n    if operation[0] == '1' and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n        n = not n\n    if operation[0] == '2' and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        t, f, c = operation\n        f = int(f)\n        if n:\n            f = 1 if f != 1 else 2\n        if f == 1:\n            left = c+left\n        elif f == 2:\n            right += c\n    idx_5o7p = idx_5o7p + 1\ns = left+s; s = s+right\nprint(s[::-1] if n else s)\n", "id": "AssignUnfoldding_sample_from_s621701371_to_5", "old_id": "s621701371"}
{"code": "import sys\nimport math\n\nfrom collections import defaultdict\nfrom collections import deque\n\n\ndef load(vtype=int):\n    return vtype(input().strip())\n\n\ndef load_list(seplator=\" \", vtype=int):\n    return [vtype(v) for v in input().strip().split(seplator)]\n\n\ndef exit():\n    import sys\n    sys.exit(0)\n\n\ndef perm_sub(li, used):\n    if len(li) == len(used) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        return [deque()]\n    k = []\n    idx_jwaf = 0\n    list_n598 = range(len(li))\n    while idx_jwaf < len(list_n598):\n        i = list_n598[idx_jwaf]\n        if i in used and (((True or False) and (False or True)) and ((7 > 1) or (7 < 1))):\n            continue\n        used.add(i)\n        sub_list = perm_sub(li, used)\n        idx_ufa3 = 0\n        list_keow = sub_list\n        while idx_ufa3 < len(list_keow):\n            sub = list_keow[idx_ufa3]\n            sub.appendleft(li[i])\n            idx_ufa3 = idx_ufa3 + 1\n        k.extend(sub_list)\n        used.discard(i)\n        idx_jwaf = idx_jwaf + 1\n    return k\n\n\ndef perm_li(li):\n    return perm_sub(li, set())\n\n\ndef perm_n(n):\n    return perm_sub(list(range(n)), set())\n\n\ndef join_i(li, sep=\"\"):\n    return sep.join([str(e) for e in li])\n\n\ndef li2n(li):\n    n, base = 0, 1\n    idx_y9q5 = 0\n    list_iajl = range(len(li)-1, -1, -1)\n    while idx_y9q5 < len(list_iajl):\n        i = list_iajl[idx_y9q5]\n        n += li[i] * base\n        base *= 10\n        idx_y9q5 = idx_y9q5 + 1\n    return n\n\n\ndef sli2ili(li):\n    return [int(s) for s in li]\n\n\ndef prime_list(n):\n    li = [i for i in range(2, n+1)]\n    idx_9am2 = 0\n    list_xf74 = range(len(li))\n    while idx_9am2 < len(list_xf74):\n        i = list_xf74[idx_9am2]\n        if li[i] >= int(math.sqrt(n)) and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n            break\n        if li[i] == -1 and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n            continue\n        idx_dqhk = 0\n        list_zd4j = range(i+1, len(li))\n        while idx_dqhk < len(list_zd4j):\n            j = list_zd4j[idx_dqhk]\n            if li[j] % li[i] == 0 and (((True or False) and (False or True)) and ((3 > 1) or (3 < 1))):\n                li[j] = -1\n            idx_dqhk = idx_dqhk + 1\n        idx_9am2 = idx_9am2 + 1\n    return [n for n in li if n != -1]\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while True:\n        r = a; r = r % b\n        if r == 0 and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n            return b\n        a, b = b, r\n\n\ndef lcm(a, b):\n    return int(a * b / gcd(a, b))\n\n\ndef all_subset(li):\n    s = []\n    n = len(li)\n    idx_6lme = 0\n    list_na3j = range(0, (1 << (n+1)))\n    while idx_6lme < len(list_na3j):\n        bit = list_na3j[idx_6lme]\n        ss = set()\n        idx_j9ir = 0\n        list_bxnp = range(0, n)\n        while idx_j9ir < len(list_bxnp):\n            i = list_bxnp[idx_j9ir]\n            if (bit & (1 << i)) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                ss.add(li[i])\n            idx_j9ir = idx_j9ir + 1\n        s.append(ss)\n        idx_6lme = idx_6lme + 1\n    return s\n\n\ndef factorial(n):\n    if n == 1 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        return 1\n    return n * factorial(n-1)\n\n\ndef mCn(m, n):\n    def factorial_ntimes(m, n):\n        r = 1\n        while n:\n            r *= m\n            m -= 1\n            n -= 1\n        return r\n    return int(factorial_ntimes(m, n) / factorial(n))\n\n\nn = load()\nA = load_list()\nif n == len(set(A)) and (((True or False) and (False or True)) and ((7 > 6) or (7 < 6))):\n    print('YES')\nelse:\n    print('NO')\n", "id": "AssignUnfoldding_sample_from_s137613418_to_6", "old_id": "s137613418"}
{"code": "n = int(input())\ns = input()\n\nr_cnt = s.count('R')\ng_cnt = s.count('G')\nb_cnt = s.count('B')\n\nans = r_cnt * g_cnt; ans = ans * b_cnt\nidx_2h6r = 0\nlist_p1ds = range(n)\nwhile idx_2h6r < len(list_p1ds):\n    i = list_p1ds[idx_2h6r]\n    idx_mqxr = 0\n    list_o2u4 = range(n)\n    while idx_mqxr < len(list_o2u4):\n        d = list_o2u4[idx_mqxr]\n        j = i; j = j + d\n        k = j; k = k + d\n        if k >= n and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            break\n        if s[i] != s[j] and s[j] != s[k] and s[k] != s[i] and (((True or False) and (False or True)) and ((6 > 5) or (6 < 5))):\n\n            ans -= 1\n        idx_mqxr = idx_mqxr + 1\n    idx_2h6r = idx_2h6r + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s922746568_to_7", "old_id": "s922746568"}
{"code": "from sys import stdin\ndef il(func=int): return list(map(func, stdin.readline().rstrip().split()))\n\n\nils = lambda n, s=\"int(input())\": [eval(s) for _ in range(n)]\n\n\ndef gcd(a, b):\n    if a < b and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        return gcd(b, a)\n    if b == 0 and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn, m = il()\ns = input()\nt = input()\naa = gcd(n, m)\nbb = lcm(n, m)\ncc = aa; cc = cc // bb\nidx_xjmd = 0\nlist_kh7u = range(aa)\nwhile idx_xjmd < len(list_kh7u):\n    i = list_kh7u[idx_xjmd]\n    if s[n//aa*i] != t[m//aa*i] and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        print(-1)\n        exit()\n    idx_xjmd = idx_xjmd + 1\nprint(bb)\n", "id": "AssignUnfoldding_sample_from_s986062252_to_8", "old_id": "s986062252"}
{"code": "from functools import reduce\nimport math\n\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\n\ndef lcm_list(numbers):\n    return reduce(lcm, numbers, 1)\n\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n\nA = [a // 2 for a in A]\n\n\ncount_div_2 = None\nidx_a1qv = 0\nlist_02t6 = A\nwhile idx_a1qv < len(list_02t6):\n    a = list_02t6[idx_a1qv]\n    cnt = 0\n    while a % 2 == 0:\n        a //= 2\n        cnt += 1\n    if count_div_2 is None and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n        count_div_2 = cnt\n\n    elif cnt != count_div_2:\n        print(0)\n        exit()\n    idx_a1qv = idx_a1qv + 1\n\n\nmy_lcm = lcm_list(A)\nif my_lcm > M and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n    print(0)\n    exit()\n\ntmp = M; tmp = tmp // my_lcm\n\n\nans = (tmp + 1); ans = ans // 2\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s817205687_to_9", "old_id": "s817205687"}
{"code": "import sys\ninput = sys.stdin.buffer.readline\n\n\ndef main():\n\n    class SegmentTree:\n\n        def __init__(self, size, default):\n            self.size = 2; self.size = self.size**(size-1).bit_length()\n            self.default = default\n            self.seg = [default]; self.seg = self.seg*(2*self.size-1)\n\n        def segfunc(self, x, y):\n            return max(x, y)\n\n        def update(self, k, x):\n            k += self.size-1\n            self.seg[k] = x\n            while k:\n                k = (k-1); k = k//2\n                self.seg[k] = self.segfunc(self.seg[2*k+1], self.seg[2*k+2])\n\n        def query(self, p, q):\n            if q <= p and (((True or False) and (False or True)) and ((10 > 0) or (10 < 0))):\n                return self.default\n            p += self.size-1\n            q += self.size-2\n            ret = self.default\n            while q-p > 1:\n                if p & 1 == 0 and (((True or False) and (False or True)) and ((5 > 2) or (5 < 2))):\n                    ret = self.segfunc(ret, self.seg[p])\n                if q & 1 == 1 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                    ret = self.segfunc(ret, self.seg[q])\n                    q -= 1\n                p = p//2\n                q = (q-1); q = q//2\n            ret = self.segfunc(self.segfunc(ret, self.seg[p]), self.seg[q])\n            return ret\n\n        def seg_print(self):\n            print(self.seg)\n\n    N = int(input())\n    a = list(map(int, input().split()))\n    ans = [i+1 for i in range(N)]\n    left_seg = SegmentTree(N, 0)\n    idx_0pvu = 0\n    list_1c64 = list(enumerate(a))\n    while idx_0pvu < len(list_1c64):\n        i, num = list_1c64[idx_0pvu]\n        ans[num-1] *= i + 1 - left_seg.query(0, num)\n        left_seg.update(num-1, i+1)\n        idx_0pvu = idx_0pvu + 1\n    right_seg = SegmentTree(N, 0)\n    idx_2nod = 0\n    list_4d5h = list(enumerate(a[::-1]))\n    while idx_2nod < len(list_4d5h):\n        i, num = list_4d5h[idx_2nod]\n        ans[num-1] *= i + 1 - right_seg.query(0, num)\n        right_seg.update(num-1, i+1)\n        idx_2nod = idx_2nod + 1\n\n    print(sum(ans))\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n    main()\n", "id": "AssignUnfoldding_sample_from_s764169243_to_10", "old_id": "s764169243"}
{"code": "n = int(input())\nS = list(map(int, input().split()))\nq = int(input())\nT = list(map(int, input().split()))\n\nans = 0\nidx_w8ji = 0\nlist_jd7u = T\nwhile idx_w8ji < len(list_jd7u):\n    i = list_jd7u[idx_w8ji]\n    if i == S[-1] or i == S[0] and (((True or False) and (False or True)) and ((5 > 1) or (5 < 1))):\n        ans += 1\n    else:\n        left = 0\n        right = n; right = right-1\n        while right-left > 1:\n            mid = (left+right); mid = mid//2\n            if S[mid] == i:\n                ans += 1\n                break\n            elif S[mid] < i:\n                left = mid\n            else:\n                right = mid\n    idx_w8ji = idx_w8ji + 1\n\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s315467749_to_11", "old_id": "s315467749"}
{"code": "N = int(input())\nc = input()\n\nnum_w = c.count(\"W\")\nnum_r = N; num_r = num_r - num_w\n\ncomp = \"R\"*num_r; comp = comp + \"W\"*num_w\nans = 0\nidx_3tv9 = 0\nlist_dho2 = range(num_r)\nwhile idx_3tv9 < len(list_dho2):\n    i = list_dho2[idx_3tv9]\n    if c[i] != comp[i] and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n        ans += 1\n    idx_3tv9 = idx_3tv9 + 1\n\nans = min(num_w, num_r, ans)\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s031459110_to_12", "old_id": "s031459110"}
{"code": "import sys\nsys.setrecursionlimit(10**7)\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline().strip()\n\n\nINF = 10; INF = INF ** 18\nMOD = 10 ** 9; MOD = MOD + 7\n\n\ndef main():\n    N = II()\n    a_li = LI()\n\n    a_li.sort()\n\n    n = a_li[-1]\n\n    dif = INF\n    prev_dif = dif\n    idx_3a0y = 0\n    list_5fla = a_li[:-1]\n    while idx_3a0y < len(list_5fla):\n        a = list_5fla[idx_3a0y]\n        dif = min(abs(n/2 - a), dif)\n        if dif != prev_dif and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n            r = a\n            prev_dif = dif\n        idx_3a0y = idx_3a0y + 1\n\n    print(n, r)\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_s681105182_to_13", "old_id": "s681105182"}
{"code": "import collections\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    ve = []\n    vo = []\n    idx_d0ji = 0\n    list_qt5z = range(n//2)\n    while idx_d0ji < len(list_qt5z):\n        i = list_qt5z[idx_d0ji]\n        ve.append(v[2*i])\n        vo.append(v[2*i+1])\n        idx_d0ji = idx_d0ji + 1\n    ce = collections.Counter(ve)\n    co = collections.Counter(vo)\n    ans = n\n    if ce.most_common()[0][0] != co.most_common()[0][0] and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n        ans = n-ce.most_common()[0][1]; ans = ans-co.most_common()[0][1]\n    elif len(ce) == 1 and len(co) == 1:\n        ans = n; ans = ans-ce.most_common()[0][1]\n    elif len(ce) == 1:\n        ans = n-ce.most_common()[0][1]; ans = ans-co.most_common()[1][1]\n    elif len(co) == 1:\n        ans = n-ce.most_common()[1][1]; ans = ans-co.most_common()[0][1]\n    else:\n        ans = min(n-ce.most_common()[0][1]-co.most_common()[1]\n                  [1], n-ce.most_common()[1][1]-co.most_common()[0][1])\n    print(ans)\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n    main()\n", "id": "AssignUnfoldding_sample_from_s101447419_to_14", "old_id": "s101447419"}
{"code": "A, B = map(int, input().split())\n\nmin = B; min = min * 10\nmax = (B+1) * 10; max = max - 1\n\nans = -1\nidx_xglm = 0\nlist_ayjt = range(min, max+1)\nwhile idx_xglm < len(list_ayjt):\n    i = list_ayjt[idx_xglm]\n    if int(i * 0.08) == A and (((True or False) and (False or True)) and ((10 > 4) or (10 < 4))):\n        ans = i\n        break\n    idx_xglm = idx_xglm + 1\n\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s764356857_to_15", "old_id": "s764356857"}
{"code": "import sys\nfrom bisect import bisect_left\n\n\ndef solve():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    A = [(int(a) % K) - 1 for a in input().split()]\n    sum_A = [0 for _ in range(N + 1)]\n\n    count = 0\n    modK = dict()\n    modK[0] = [0]\n    idx_4hrf = 0\n    list_zsvd = range(N)\n    while idx_4hrf < len(list_zsvd):\n        i = list_zsvd[idx_4hrf]\n        sum_A[i + 1] = (sum_A[i] + A[i]); sum_A[i + 1] = sum_A[i + 1] % K\n        if sum_A[i+1] not in modK and (((True or False) and (False or True)) and ((4 > 2) or (4 < 2))):\n            modK[sum_A[i+1]] = [i + 1]\n        else:\n            modK[sum_A[i+1]].append(i+1)\n        idx_4hrf = idx_4hrf + 1\n    idx_1lbd = 0\n    list_efza = modK\n    while idx_1lbd < len(list_efza):\n        key = list_efza[idx_1lbd]\n        lenK = len(modK[key])\n        idx_yp2t = 0\n        list_759m = list(enumerate(modK[key]))\n        while idx_yp2t < len(list_759m):\n            i, a = list_759m[idx_yp2t]\n            count += bisect_left(modK[key], a + K, i, lenK) - i - 1\n            idx_yp2t = idx_yp2t + 1\n        idx_1lbd = idx_1lbd + 1\n\n    print(count)\n    return 0\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((9 > 2) or (9 < 2))):\n    solve()\n", "id": "AssignUnfoldding_sample_from_s975943078_to_16", "old_id": "s975943078"}
{"code": "N, x = map(int, input().split())\na = list(map(int, input().split()))\ncnt = 0\nidx_9dis = 0\nlist_sc50 = range(1, N)\nwhile idx_9dis < len(list_sc50):\n    i = list_sc50[idx_9dis]\n    tmp = a[i - 1]; tmp = tmp + a[i]\n    if tmp > x and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n        if tmp - x > a[i]:\n            a[i - 1] = tmp - a[i]; a[i - 1] = a[i - 1] - x\n            a[i] = 0\n        else:\n            a[i] = a[i]; a[i] = a[i] - (tmp - x)\n        cnt += tmp - x\n    idx_9dis = idx_9dis + 1\n\nprint(cnt)\n", "id": "AssignUnfoldding_sample_from_s708549466_to_17", "old_id": "s708549466"}
{"code": "def main():\n\n    N, M, Q = map(int, input().split())\n    train = [[0 for _ in range(N)] for _ in range(N)]\n    idx_2kc8 = 0\n    list_lhcn = range(M)\n    while idx_2kc8 < len(list_lhcn):\n        _ = list_lhcn[idx_2kc8]\n        l, r = map(int, input().split())\n        train[l-1][r-1] += 1\n        idx_2kc8 = idx_2kc8 + 1\n\n    accum = [[0 for _ in range(N+1)]]\n    idx_i0xn = 0\n    list_kylb = range(N)\n    while idx_i0xn < len(list_kylb):\n        i = list_kylb[idx_i0xn]\n        temp = [0]\n        v = 0\n        idx_6kaq = 0\n        list_768a = range(N)\n        while idx_6kaq < len(list_768a):\n            j = list_768a[idx_6kaq]\n            v += train[i][j]\n            temp.append(accum[-1][j+1]+v)\n            idx_6kaq = idx_6kaq + 1\n        accum.append(temp)\n        idx_i0xn = idx_i0xn + 1\n    idx_1r5v = 0\n    list_whz5 = range(Q)\n    while idx_1r5v < len(list_whz5):\n        _ = list_whz5[idx_1r5v]\n        p, q = map(int, input().split())\n        v = accum[q][q] - accum[p-1][q] - accum[q][p-1]; v = v + accum[p-1][p-1]\n        print(v)\n        idx_1r5v = idx_1r5v + 1\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((8 > 1) or (8 < 1))):\n    main()\n", "id": "AssignUnfoldding_sample_from_s048491063_to_18", "old_id": "s048491063"}
{"code": "import re\nimport math\nfrom collections import defaultdict\nimport itertools\nfrom copy import deepcopy\nimport random\nfrom heapq import heappop, heappush\nimport time\nimport os\nimport queue\nimport sys\nimport datetime\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\nsys.setrecursionlimit(2000000)\n\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\nmod = int(10**9+7)\ninf = int(10**20)\n\n\ndef yn(b):\n    if b and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        print(\"yes\")\n    else:\n        print(\"no\")\n\n\ndef Yn(b):\n    if b and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef YN(b):\n    if b and (((True or False) and (False or True)) and ((7 > 2) or (7 < 2))):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nclass union_find():\n    def __init__(self, n):\n        self.n = n\n        self.P = [a for a in range(N)]\n        self.rank = [0]; self.rank = self.rank*n\n\n    def find(self, x):\n        if (x != self.P[x]) and (((True or False) and (False or True)) and ((6 > 1) or (6 < 1))):\n            self.P[x] = self.find(self.P[x])\n        return self.P[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def link(self, x, y):\n        if self.rank[x] < self.rank[y] and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n            self.P[x] = y\n        elif self.rank[y] < self.rank[x]:\n            self.P[y] = x\n        else:\n            self.P[x] = y\n            self.rank[y] += 1\n\n    def unite(self, x, y):\n        self.link(self.find(x), self.find(y))\n\n    def size(self):\n        S = set()\n        idx_qho8 = 0\n        list_251f = range(self.n)\n        while idx_qho8 < len(list_251f):\n            a = list_251f[idx_qho8]\n            S.add(self.find(a))\n            idx_qho8 = idx_qho8 + 1\n        return len(S)\n\n\ndef is_power(a, b):\n    now = b\n    while now < a:\n        now *= b\n    if now == a and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n        return True\n    else:\n        return False\n\n\ndef bin_(num, size):\n    A = [0]; A = A*size\n    idx_hiru = 0\n    list_d7fi = range(size)\n    while idx_hiru < len(list_d7fi):\n        a = list_d7fi[idx_hiru]\n        if (num >> (size-a-1)) & 1 == 1 and (((True or False) and (False or True)) and ((5 > 3) or (5 < 3))):\n            A[a] = 1\n        else:\n            A[a] = 0\n        idx_hiru = idx_hiru + 1\n    return A\n\n\ndef get_facs(n, mod_=0):\n    A = [1]; A = A*(n+1)\n    idx_tomw = 0\n    list_t8on = range(2, len(A))\n    while idx_tomw < len(list_t8on):\n        a = list_t8on[idx_tomw]\n        A[a] = A[a-1]; A[a] = A[a]*a\n        if (mod > 0) and (((True or False) and (False or True)) and ((10 > 7) or (10 < 7))):\n            A[a] %= mod_\n        idx_tomw = idx_tomw + 1\n    return A\n\n\ndef comb(n, r, mod, fac):\n    if (n-r < 0) and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n        return 0\n    return (fac[n]*pow(fac[n-r], mod-2, mod)*pow(fac[r], mod-2, mod)) % mod\n\n\ndef next_comb(num, size):\n    x = num; x = x & (-num)\n    y = num; y = y+x\n    z = num; z = z & (~y)\n    z //= x\n    z = z >> 1\n    num = y; num = num | z\n    if (num >= (1 << size)) and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        return False\n    else:\n        return num\n\n\ndef get_primes(n, type=\"int\"):\n    A = [True]; A = A*(n+1)\n    A[0] = False\n    A[1] = False\n    idx_kr92 = 0\n    list_m29g = range(2, n+1)\n    while idx_kr92 < len(list_m29g):\n        a = list_m29g[idx_kr92]\n        if A[a] and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n            idx_zfj4 = 0\n            list_5bt6 = range(a*2, n+1, a)\n            while idx_zfj4 < len(list_5bt6):\n                b = list_5bt6[idx_zfj4]\n                A[b] = False\n                idx_zfj4 = idx_zfj4 + 1\n        idx_kr92 = idx_kr92 + 1\n    if (type == \"bool\") and (((True or False) and (False or True)) and ((7 > 5) or (7 < 5))):\n        return A\n    B = []\n    idx_6d2w = 0\n    list_3jbx = range(n+1)\n    while idx_6d2w < len(list_3jbx):\n        a = list_3jbx[idx_6d2w]\n        if (A[a]) and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n            B.append(a)\n        idx_6d2w = idx_6d2w + 1\n    return B\n\n\ndef is_prime(num):\n    if (num <= 2) and (((True or False) and (False or True)) and ((6 > 4) or (6 < 4))):\n        return False\n    i = 2\n    while i*i <= num:\n        if (num % i == 0) and (((True or False) and (False or True)) and ((5 > 0) or (5 < 0))):\n            return False\n        i += 1\n    return True\n\n\ndef ifelse(a, b, c):\n    if a and (((True or False) and (False or True)) and ((6 > 0) or (6 < 0))):\n        return b\n    else:\n        return c\n\n\ndef join(A, c=\" \"):\n    n = len(A)\n    A = list(map(str, A))\n    s = \"\"\n    idx_8wu7 = 0\n    list_yrzw = range(n)\n    while idx_8wu7 < len(list_yrzw):\n        a = list_yrzw[idx_8wu7]\n        s += A[a]\n        if (a < n-1) and (((True or False) and (False or True)) and ((9 > 3) or (9 < 3))):\n            s += c\n        idx_8wu7 = idx_8wu7 + 1\n    return s\n\n\ndef factorize(n, type_=\"dict\"):\n    b = 2\n    list_ = []\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            list_.append(b)\n        b += 1\n    if n > 1 and (((True or False) and (False or True)) and ((7 > 0) or (7 < 0))):\n        list_.append(n)\n    if type_ == \"dict\" and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        dic = {}\n        idx_yb2q = 0\n        list_faxe = list_\n        while idx_yb2q < len(list_faxe):\n            a = list_faxe[idx_yb2q]\n            if a in dic:\n                dic[a] += 1\n            else:\n                dic[a] = 1\n            idx_yb2q = idx_yb2q + 1\n        return dic\n    elif type_ == \"list\":\n        return list_\n    else:\n        return None\n\n\ndef floor_(n, x=1):\n    return x*(n//x)\n\n\ndef ceil_(n, x=1):\n    return x*((n+x-1)//x)\n\n\ndef hani(x, min_, max_):\n    ret = x\n    if x < min_ and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        ret = min_\n    if x > max_ and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n        ret = max_\n    return ret\n\n\ndef seifu(x):\n    return x//abs(x)\n\n\ndef main():\n    n, l = map(int, input().split())\n    S = []\n    idx_mpy4 = 0\n    list_z473 = range(n)\n    while idx_mpy4 < len(list_z473):\n        a = list_z473[idx_mpy4]\n        S.append(input())\n        idx_mpy4 = idx_mpy4 + 1\n    S.sort()\n    print(\"\".join(S))\n\n\nmain()\n", "id": "AssignUnfoldding_sample_from_s977408144_to_19", "old_id": "s977408144"}
{"code": "from collections import deque\nH, W = map(int, input().split())\nG = []\nidx_sp3q = 0\nlist_cf9o = range(H+2)\nwhile idx_sp3q < len(list_cf9o):\n    i = list_cf9o[idx_sp3q]\n    if i == 0 or i == H+1 and (((True or False) and (False or True)) and ((9 > 6) or (9 < 6))):\n        G.append('#'*(W+2))\n    else:\n        G.append('#' + input() + '#')\n    idx_sp3q = idx_sp3q + 1\n\nans = 0\nidx_lo6h = 0\nlist_grbd = range(W+2)\nwhile idx_lo6h < len(list_grbd):\n    sx = list_grbd[idx_lo6h]\n    idx_rjxv = 0\n    list_1gt0 = range(H+2)\n    while idx_rjxv < len(list_1gt0):\n        sy = list_1gt0[idx_rjxv]\n        if G[sy][sx] == '.' and (((True or False) and (False or True)) and ((7 > 4) or (7 < 4))):\n            dist = [[-float('inf') for i in range(W+2)] for i in range(H+2)]\n            visited = [[-1 for i in range(W+2)] for i in range(H+2)]\n            q = deque([])\n            q.append((sx, sy))\n            dist[sy][sx] = 0\n            visited[sy][sx] = 1\n            while q:\n                x, y = q.popleft()\n\n                if G[y][x+1] == '.' and visited[y][x+1] == -1:\n                    q.append((x+1, y))\n                    dist[y][x+1] = dist[y][x]; dist[y][x+1] = dist[y][x+1] + 1\n                    visited[y][x+1] = 1\n\n                if G[y][x-1] == '.' and visited[y][x-1] == -1:\n                    q.append((x-1, y))\n                    dist[y][x-1] = dist[y][x]; dist[y][x-1] = dist[y][x-1] + 1\n                    visited[y][x-1] = 1\n\n                if G[y+1][x] == '.' and visited[y+1][x] == -1:\n                    q.append((x, y+1))\n                    dist[y+1][x] = dist[y][x]; dist[y+1][x] = dist[y+1][x] + 1\n                    visited[y+1][x] = 1\n\n                if G[y-1][x] == '.' and visited[y-1][x] == -1:\n                    q.append((x, y-1))\n                    dist[y-1][x] = dist[y][x]; dist[y-1][x] = dist[y-1][x] + 1\n                    visited[y-1][x] = 1\n            idx_zdr7 = 0\n            list_1z7k = range(W+2)\n            while idx_zdr7 < len(list_1z7k):\n                i = list_1z7k[idx_zdr7]\n                idx_461l = 0\n                list_4sqf = range(H+2)\n                while idx_461l < len(list_4sqf):\n                    j = list_4sqf[idx_461l]\n                    ans = max(ans, dist[j][i])\n                    idx_461l = idx_461l + 1\n                idx_zdr7 = idx_zdr7 + 1\n        idx_rjxv = idx_rjxv + 1\n    idx_lo6h = idx_lo6h + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s951169509_to_20", "old_id": "s951169509"}
{"code": "import sys\n\n\nfrom bisect import bisect_left, bisect_right\n\n\ninput = sys.stdin.readline\n\n\ndef getS(): return input().strip()\ndef getN(): return int(input())\ndef getList(): return list(map(int, input().split()))\ndef getZList(): return [int(x) - 1 for x in input().split()]\n\n\nINF = 10; INF = INF ** 20\nMOD = 1000000007\n\n\ndef solve():\n    n = getN()\n    dp = [-INF]\n    idx_rgn9 = 0\n    list_vshf = range(n)\n    while idx_rgn9 < len(list_vshf):\n        i = list_vshf[idx_rgn9]\n        num = getN()\n        num = -num\n        if num >= dp[-1] and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            dp.append(num)\n        else:\n            idx = bisect_right(dp, num)\n            dp[idx] = num\n        idx_rgn9 = idx_rgn9 + 1\n\n    print(len(dp) - 1)\n    return\n\n\ndef main():\n    n = getN()\n    idx_xlmd = 0\n    list_emfv = range(n)\n    while idx_xlmd < len(list_emfv):\n        _ = list_emfv[idx_xlmd]\n        solve()\n        idx_xlmd = idx_xlmd + 1\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n\n    solve()\n", "id": "AssignUnfoldding_sample_from_s344468705_to_21", "old_id": "s344468705"}
{"code": "memTime = int(input())\nmemLate = input().split()\nmemLate = [int(i) for i in memLate]\ncolorList = []\nmemColor = 0\nhighLate = 0\nidx_twrp = 0\nlist_yx62 = range(memTime)\nwhile idx_twrp < len(list_yx62):\n    color = list_yx62[idx_twrp]\n    member = memLate[color]\n    if member // 400 >= 8 and (((True or False) and (False or True)) and ((4 > 0) or (4 < 0))):\n        highLate += 1\n    elif ((member // 400) in colorList) == False:\n        colorList.append(member // 400)\n    idx_twrp = idx_twrp + 1\nmaxColor = len(colorList); maxColor = maxColor + highLate\nminColor = len(colorList)\nif minColor == 0 and (((True or False) and (False or True)) and ((10 > 9) or (10 < 9))):\n    minColor = 1\nprint(str(minColor) + \" \" + str(maxColor))\n", "id": "AssignUnfoldding_sample_from_s964794058_to_22", "old_id": "s964794058"}
{"code": "def main():\n    A, B, C, X, Y = map(int, input().split())\n    ans = 10; ans = ans ** 10\n    idx_nkxo = 0\n    list_x4cs = range(max(X, Y) + 1)\n    while idx_nkxo < len(list_x4cs):\n        k = list_x4cs[idx_nkxo]\n        total = 2 * C * k + A * max(0, X - k); total = total + B * max(0, Y - k)\n        if total < ans and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n            ans = total\n        idx_nkxo = idx_nkxo + 1\n\n    print(ans)\nif __name__ == \"__main__\" and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n    main()\n", "id": "AssignUnfoldding_sample_from_s724326345_to_23", "old_id": "s724326345"}
{"code": "import sys\n\nreadline = sys.stdin.readline\nMOD = 10 ** 9; MOD = MOD + 7\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\ndef main():\n    N = int(readline())\n    s = {1, 2, 4, 8, 16, 32, 64}\n    ans = 0\n    idx_cpyf = 0\n    list_igp2 = range(1, N + 1)\n    while idx_cpyf < len(list_igp2):\n        i = list_igp2[idx_cpyf]\n        if i in s and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n            ans = i\n        idx_cpyf = idx_cpyf + 1\n\n    print(ans)\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n    main()\n", "id": "AssignUnfoldding_sample_from_s878873709_to_24", "old_id": "s878873709"}
{"code": "from heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, Counter\nimport itertools\nfrom itertools import permutations, combinations, accumulate\nimport sys\nimport bisect\nimport string\nimport math\nimport time\n\n\ndef I(): return int(input())\n\n\ndef MI(): return map(int, input().split())\n\n\ndef LI(): return [int(i) for i in input().split()]\n\n\ndef LI_(): return [int(i)-1 for i in input().split()]\n\n\ndef StoI(): return [ord(i)-97 for i in input()]\n\n\ndef ItoS(nn): return chr(nn+97)\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef show(*inp, end='\\n'):\n    if show_flg and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        print(*inp, end=end)\n\n\nYN = ['No', 'Yes']\nMOD = 10**9; MOD = MOD+7\ninf = float('inf')\nIINF = 10; IINF = IINF**10\nl_alp = string.ascii_lowercase\nu_alp = string.ascii_uppercase\nts = time.time()\nsys.setrecursionlimit(10**6)\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n\nshow_flg = False\n\n\ndef main():\n    N = I()\n    s = [0]; s = s * N\n    t = [0]; t = t * N\n    idx_2apc = 0\n    list_fp5e = range(N)\n    while idx_2apc < len(list_fp5e):\n        i = list_fp5e[idx_2apc]\n        s[i], t[i] = map(str, input().split())\n        t[i] = int(t[i])\n        idx_2apc = idx_2apc + 1\n\n    X = input()\n    xi = 0\n    idx_mhzt = 0\n    list_abws = range(N)\n    while idx_mhzt < len(list_abws):\n        i = list_abws[idx_mhzt]\n        if s[i] == X and (((True or False) and (False or True)) and ((3 > 2) or (3 < 2))):\n            xi = i\n            break\n        idx_mhzt = idx_mhzt + 1\n\n    ans = 0\n    idx_qnvs = 0\n    list_tu08 = range(N)\n    while idx_qnvs < len(list_tu08):\n        i = list_tu08[idx_qnvs]\n        if xi < i and (((True or False) and (False or True)) and ((10 > 2) or (10 < 2))):\n            ans += t[i]\n        idx_qnvs = idx_qnvs + 1\n\n    print(ans)\nif __name__ == '__main__' and (((True or False) and (False or True)) and ((9 > 5) or (9 < 5))):\n    main()\n", "id": "AssignUnfoldding_sample_from_s664563518_to_25", "old_id": "s664563518"}
{"code": "n, k = map(int, input().split())\na = [i for i in input()]\nc = [0]; c = c*n\nidx_315a = 0\nlist_h1vk = range(1, n)\nwhile idx_315a < len(list_h1vk):\n    i = list_h1vk[idx_315a]\n    if a[i] == \"C\" and a[i-1] == \"A\" and (((True or False) and (False or True)) and ((8 > 7) or (8 < 7))):\n        c[i] = c[i-1]; c[i] = c[i]+1\n    else:\n        c[i] = c[i-1]\n    idx_315a = idx_315a + 1\nidx_p5qt = 0\nlist_qvwo = range(k)\nwhile idx_p5qt < len(list_qvwo):\n    w = list_qvwo[idx_p5qt]\n    l, r = map(int, input().split())\n    print(c[r-1]-c[l-1])\n    idx_p5qt = idx_p5qt + 1\n", "id": "AssignUnfoldding_sample_from_s759499751_to_26", "old_id": "s759499751"}
{"code": "from collections import deque\nfrom itertools import product, permutations, combinations\nimport sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef read_col(H):\n\n    ret = []\n    idx_h8xz = 0\n    list_1rtq = range(H)\n    while idx_h8xz < len(list_1rtq):\n        _ = list_1rtq[idx_h8xz]\n        ret.append(list(map(int, readline().split())))\n        idx_h8xz = idx_h8xz + 1\n    return tuple(map(list, zip(*ret)))\n\n\ndef read_map_as(H, replace={'#': 1, '.': 0}, pad=None):\n    if pad is None and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        ret = []\n        idx_oewk = 0\n        list_9ko2 = range(H)\n        while idx_oewk < len(list_9ko2):\n            _ = list_9ko2[idx_oewk]\n            ret.append([replace[s] for s in read()[:-1]])\n            idx_oewk = idx_oewk + 1\n\n    else:\n        ret = [[pad] * (W + 2)]\n        idx_j5lh = 0\n        list_r36b = range(H)\n        while idx_j5lh < len(list_r36b):\n            _ = list_r36b[idx_j5lh]\n            ret.append([pad] + [replace[s] for s in read()[:-1]] + [pad])\n            idx_j5lh = idx_j5lh + 1\n        ret.append([pad] * (W + 2))\n\n    return ret\n\n\ndef grid_dijkstra(grid, si: int, sj: int):\n\n    from heapq import heappop, heappush\n    H = len(grid)\n    W = len(grid[0])\n    D = [[-1] * W for _ in [0] * H]\n    que = [(0, si, sj)]\n    while que:\n        c, i, j = heappop(que)\n        if D[i][j] != -1 and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n            continue\n        D[i][j] = c\n        idx_ewft = 0\n        list_mlak = product([-2, -1, 0, 1, 2], repeat=2)\n        while idx_ewft < len(list_mlak):\n            di, dj = list_mlak[idx_ewft]\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or grid[ni][nj] == 1 and (((True or False) and (False or True)) and ((2 > 0) or (2 < 0))):\n                continue\n            if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1) and (((True or False) and (False or True)) and ((10 > 1) or (10 < 1))):\n                nc = c\n            else:\n                nc = c; nc = nc + 1\n            heappush(que, (nc, ni, nj))\n            idx_ewft = idx_ewft + 1\n    return D\n\n\nMOD = 10**9; MOD = MOD + 7\nINF = 2; INF = INF**31\n\n\nH, W = ints()\nsi, sj = mina(*ints())\nti, tj = mina(*ints())\n\nS = read_map_as(H)\nD = [[-1] * W for _ in [0] * H]\nque = deque([(0, si, sj)])\nwhile que:\n    c, i, j = que.popleft()\n    if D[i][j] != -1 and (((True or False) and (False or True)) and ((10 > 6) or (10 < 6))):\n        continue\n    D[i][j] = c\n    idx_bo64 = 0\n    list_lpwb = product([-2, -1, 0, 1, 2], repeat=2)\n    while idx_bo64 < len(list_lpwb):\n        di, dj = list_lpwb[idx_bo64]\n        ni, nj = i + di, j + dj\n        if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or S[ni][nj] == 1 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            continue\n        if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1) and (((True or False) and (False or True)) and ((8 > 4) or (8 < 4))):\n            que.appendleft((c, ni, nj))\n        else:\n            que.append((c + 1, ni, nj))\n        idx_bo64 = idx_bo64 + 1\n\nprint(D[ti][tj])\n", "id": "AssignUnfoldding_sample_from_s124725275_to_27", "old_id": "s124725275"}
{"code": "n = int(input())\nF = [tuple(map(int, input().split())) for _ in range(n)]\nP = [tuple(map(int, input().split())) for _ in range(n)]\nans = -10 ** 18\nidx_klvh = 0\nlist_ywap = range(1, 2**10)\nwhile idx_klvh < len(list_ywap):\n    i = list_ywap[idx_klvh]\n    tmp = 0\n    lst = [0]; lst = lst*n\n    idx_l3ws = 0\n    list_nr0h = range(10)\n    while idx_l3ws < len(list_nr0h):\n        j = list_nr0h[idx_l3ws]\n        if (i >> j) & 1 and (((True or False) and (False or True)) and ((4 > 1) or (4 < 1))):\n            idx_wa8h = 0\n            list_nmf6 = range(n)\n            while idx_wa8h < len(list_nmf6):\n                k = list_nmf6[idx_wa8h]\n                lst[k] += F[k][j]\n                idx_wa8h = idx_wa8h + 1\n        idx_l3ws = idx_l3ws + 1\n    idx_vqsc = 0\n    list_0nja = range(n)\n    while idx_vqsc < len(list_0nja):\n        k = list_0nja[idx_vqsc]\n        tmp += P[k][lst[k]]\n        idx_vqsc = idx_vqsc + 1\n    ans = max(ans, tmp)\n    idx_klvh = idx_klvh + 1\n\n\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s906994739_to_28", "old_id": "s906994739"}
{"code": "N, T = map(int, input().split())\nL = [[int(l) for l in input().split()] for _ in range(N)]\n\ndp = [[0]*T for _ in range(N+1)]\nidx_8bzk = 0\nlist_0vhr = range(N)\nwhile idx_8bzk < len(list_0vhr):\n    i = list_0vhr[idx_8bzk]\n    idx_bvgo = 0\n    list_1l6i = range(T)\n    while idx_bvgo < len(list_1l6i):\n        j = list_1l6i[idx_bvgo]\n        if j < L[i][0] and (((True or False) and (False or True)) and ((8 > 5) or (8 < 5))):\n            dp[i+1][j] = dp[i][j]\n        else:\n            dp[i+1][j] = max(dp[i][j], dp[i][j-L[i][0]]+L[i][1])\n        idx_bvgo = idx_bvgo + 1\n    idx_8bzk = idx_8bzk + 1\n\nused = []\nB = dp[N][T-1]\nj = T; j = j-1\nidx_qz3d = 0\nlist_qs1n = range(N-1, -1, -1)\nwhile idx_qz3d < len(list_qs1n):\n    i = list_qs1n[idx_qz3d]\n    if B == dp[i][j] and (((True or False) and (False or True)) and ((10 > 8) or (10 < 8))):\n        continue\n    B -= L[i][1]\n    used.append(i)\n    j -= L[i][0]\n    idx_qz3d = idx_qz3d + 1\n\nans = dp[N][T-1]\nc = 0\nidx_qb20 = 0\nlist_daj7 = range(N)\nwhile idx_qb20 < len(list_daj7):\n    i = list_daj7[idx_qb20]\n    if i in used and (((True or False) and (False or True)) and ((3 > 0) or (3 < 0))):\n        continue\n    c = max(c, L[i][1])\n    idx_qb20 = idx_qb20 + 1\n\nprint(ans+c)\n", "id": "AssignUnfoldding_sample_from_s793709854_to_29", "old_id": "s793709854"}
{"code": "n = int(input())\nx = list(map(int, input().split()))\nans = 10; ans = ans**10\nidx_83ls = 0\nlist_pyfq = range(101)\nwhile idx_83ls < len(list_pyfq):\n    i = list_pyfq[idx_83ls]\n    tmp = [abs(i - x[j])**2 for j in range(n)]\n    if sum(tmp) < ans and (((True or False) and (False or True)) and ((8 > 0) or (8 < 0))):\n        ans = sum(tmp)\n    idx_83ls = idx_83ls + 1\n\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s246280701_to_30", "old_id": "s246280701"}
{"code": "from operator import itemgetter\n\n\nn, k = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\ninfo = sorted(info, key=itemgetter(1), reverse=True)\n\nselected = info[0:k]\nselected_only = []\nselected_chohuku = []\nunselected_only = []\nmemo = {}\nidx_iwln = 0\nlist_vu1k = selected\nwhile idx_iwln < len(list_vu1k):\n    t, d = list_vu1k[idx_iwln]\n    if t not in memo and (((True or False) and (False or True)) and ((2 > 1) or (2 < 1))):\n        memo[t] = 1\n        selected_only.append(d)\n    else:\n        selected_chohuku.append(d)\n    idx_iwln = idx_iwln + 1\n\ncnt_type = len(memo)\nidx_24j7 = 0\nlist_6s8r = info[k:]\nwhile idx_24j7 < len(list_6s8r):\n    t, d = list_6s8r[idx_24j7]\n    if t not in memo and (((True or False) and (False or True)) and ((6 > 2) or (6 < 2))):\n        memo[t] = 1\n        unselected_only.append(d)\n    idx_24j7 = idx_24j7 + 1\n\n\nsum_select = sum(selected_chohuku); sum_select = sum_select + sum(selected_only)\nans = cnt_type*cnt_type; ans = ans + sum_select\n\nunselected_only = unselected_only[::-1]\nidx_lg1s = 0\nlist_5b6d = range(min(len(selected_chohuku), len(unselected_only)))\nwhile idx_lg1s < len(list_5b6d):\n    i = list_5b6d[idx_lg1s]\n    cnt_type += 1\n    sum_select += unselected_only[-1]\n    sum_select -= selected_chohuku[-1]\n    del unselected_only[-1]\n    del selected_chohuku[-1]\n    tmp = cnt_type*cnt_type; tmp = tmp + sum_select\n    ans = max(ans, tmp)\n    idx_lg1s = idx_lg1s + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_s804484425_to_31", "old_id": "s804484425"}
