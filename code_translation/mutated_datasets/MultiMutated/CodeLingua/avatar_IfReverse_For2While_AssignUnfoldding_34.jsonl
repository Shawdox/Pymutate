{"code": "N, K = map(int, input().split())\nS = input()\naaaa = False\nif not K >= 15:\n    if 2 ** K >= N:\n        aaaa = True\nelse:\n    aaaa = True\nif aaaa:\n    print(min(S) * N)\n    exit()\n\n\ndef get_last_dict(s_str):\n    U = s_str; U = U + s_str[:: - 1]\n    c = min(s_str)\n    p = U.index(c)\n    minindex = p\n    p += 1\n    while p <= N:\n        if U[p] == c:\n            if check_normal_dict(U, minindex, p):\n                minindex = p\n        p += 1\n    return U[minindex: minindex + N]\n\n\ndef check_normal_dict(u, pointer1, pointer2):\n    idx_ft0v = 0\n    list_02cb = range(N)\n    while idx_ft0v < len(list_02cb):\n        i = list_02cb[idx_ft0v]\n        if not u[pointer1 + i] > u[pointer2 + i]:\n            if u[pointer1 + i] < u[pointer2 + i]:\n                return False\n        else:\n            return True\n        idx_ft0v = idx_ft0v + 1\n    return False\n\n\nS = get_last_dict(S)\nif not K == 1:\n    count = 0\n    idx_7t45 = 0\n    list_xms0 = S\n    while idx_7t45 < len(list_xms0):\n        c = list_xms0[idx_7t45]\n        if c == S[0]:\n            count += 1\n        else:\n            break\n        idx_7t45 = idx_7t45 + 1\n    if count * (2 ** (K - 1)) >= N:\n        print(S[0] * N)\n    else:\n        S = S[0] * (count * ((2 ** (K - 1)) - 1)) + S\n        print(S[0: N])\nelse:\n    print(S)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC037_E_to_0", "old_id": "atcoder_AGC037_E"}
{"code": "import sys\nimport math\nimport collections\nimport heapq\nimport itertools\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while a % b > 0:\n        a, b = b, a % b\n    return b\n\n\ndef solve():\n    s = input()\n    t = \"\"\n    i = 0\n    while i < len(s):\n        if not s[i] == \"A\":\n            if s[i] == \"B\":\n                if i < len(s) - 1:\n                    if s[i + 1] == \"C\":\n                        t += \"D\"\n                        i += 2\n                    else:\n                        t += \"X\"\n                        i += 1\n                else:\n                    t += \"X\"\n                    i += 1\n            else:\n                t += \"X\"\n                i += 1\n        else:\n            t += \"A\"\n            i += 1\n    total = 0\n    numA = 0\n    idx_dfql = 0\n    list_l8sv = range(len(t))\n    while idx_dfql < len(list_l8sv):\n        i = list_l8sv[idx_dfql]\n        if not t[i] == \"X\":\n            if t[i] == \"A\":\n                numA += 1\n            else:\n                total += numA\n        else:\n            numA = 0\n        idx_dfql = idx_dfql + 1\n    print(total)\n    INF = 10; INF = INF ** 25\n    mod = 7; mod = mod + 10 ** 9\n    return 0\n\n\nif __name__ == \"__main__\":\n    solve()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC034_B_to_1", "old_id": "atcoder_AGC034_B"}
{"code": "import sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(* (MAP() for _ in range(n)))\n\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9; mod = mod + 7\nN, M = MAP()\nballs = [[1, 0] for _ in range(N)]\nballs[0] = [0, 1]\nidx_dl26 = 0\nlist_y2da = range(M)\nwhile idx_dl26 < len(list_y2da):\n    _ = list_y2da[idx_dl26]\n    x, y = MAP()\n    w_x, r_x = balls[x - 1]\n    w_y, r_y = balls[y - 1]\n    if not w_x >= 1 and r_x >= 1:\n        if w_x == 0:\n            balls[x - 1][1] -= 1\n            balls[y - 1][1] += 1\n        else:\n            balls[x - 1][0] -= 1\n            balls[y - 1][0] += 1\n    else:\n        balls[x - 1][0] -= 1\n        balls[y - 1][1] += 1\n    idx_dl26 = idx_dl26 + 1\nans = 0\nidx_uwek = 0\nlist_azx6 = range(N)\nwhile idx_uwek < len(list_azx6):\n    i = list_azx6[idx_uwek]\n    if balls[i][1]:\n        ans += 1\n    idx_uwek = idx_uwek + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC002_B_to_2", "old_id": "atcoder_AGC002_B"}
{"code": "import sys\ninput = sys.stdin.readline\na, b = input()[: - 1].split()\nx = max(len(a), len(b))\na = a.rjust(x, '0')\nb = b.ljust(x, '0')\ns = ''\nc = 0\nidx_od7u = 0\nlist_32pw = range(x)\nwhile idx_od7u < len(list_32pw):\n    i = list_32pw[idx_od7u]\n    d = int(b[i]) + int(a[x - i - 1]); d = d + c\n    if not d > 9:\n        s += str(d)\n        c = 0\n    else:\n        s += str(d)[1]\n        c = 1\n    idx_od7u = idx_od7u + 1\nif c == 1:\n    s += '1'\nprint(int(s[:: - 1]))\n", "id": "AssignUnfoldding_sample_from_codeforces_171_A_to_3", "old_id": "codeforces_171_A"}
{"code": "def cutRibbon():\n    arr = [int(i) for i in input().split()]\n    length = arr[0]\n    arr = sorted(arr[1: 4], reverse=False)\n    if (length % arr[0] == 0):\n        print(int(length / arr[0]))\n        return\n    ans = 0\n    if not (arr[0] == arr[1]):\n        k = 0\n        idx_t5se = 0\n        list_hvpe = range(int(length / arr[2]) + 1)\n        while idx_t5se < len(list_hvpe):\n            i = list_hvpe[idx_t5se]\n            idx_xy3u = 0\n            list_i7tx = range(int(length / arr[1]) + 1)\n            while idx_xy3u < len(list_i7tx):\n                j = list_i7tx[idx_xy3u]\n                check = length - i * arr[2]; check = check - j * arr[1]\n                if (check >= 0 and check % arr[0] == 0):\n                    k = int(check / arr[0])\n                    ans = max(ans, k + i + j)\n                idx_xy3u = idx_xy3u + 1\n            idx_t5se = idx_t5se + 1\n    else:\n        k = 0\n        idx_31h8 = 0\n        list_pkb0 = range(int(length / arr[2]) + 1)\n        while idx_31h8 < len(list_pkb0):\n            i = list_pkb0[idx_31h8]\n            check = length; check = check - i * arr[2]\n            if (check >= 0 and check % arr[0] == 0):\n                k = int(check / arr[0])\n                ans = max(ans, k + i)\n            idx_31h8 = idx_31h8 + 1\n    print(ans)\n    return\n\n\ncutRibbon()\n", "id": "AssignUnfoldding_sample_from_codeforces_189_A_to_4", "old_id": "codeforces_189_A"}
{"code": "import numpy as np\nfrom collections import deque\nimport heapq\nN, M = map(int, input().split())\nedges = [set() for _ in range(N)]\ndegs = [0 for i in range(N)]\nparity = [0 for _ in range(N)]\nflag = [False for _ in range(N)]\nidx_0yci = 0\nlist_5gi2 = range(M)\nwhile idx_0yci < len(list_5gi2):\n    _ = list_5gi2[idx_0yci]\n    a, b = map(int, input().split())\n    edges[a - 1].add(b - 1)\n    edges[b - 1].add(a - 1)\n    degs[a - 1] += 1\n    degs[b - 1] += 1\n    idx_0yci = idx_0yci + 1\nif M % 2 != 0:\n    print(- 1)\n    exit()\nQ = []\nidx_gwoc = 0\nlist_o4hp = list(enumerate(degs))\nwhile idx_gwoc < len(list_o4hp):\n    i, d = list_o4hp[idx_gwoc]\n    Q.append((d, i))\n    idx_gwoc = idx_gwoc + 1\nheapq.heapify(Q)\nwhile len(Q) > 0:\n    _, u = Q[0]\n    heapq.heappop(Q)\n    if flag[u]:\n        continue\n    flag[u] = True\n    idx_5tsd = 0\n    list_7emx = list(enumerate(edges[u]))\n    while idx_5tsd < len(list_7emx):\n        i, v = list_7emx[idx_5tsd]\n        edges[v].remove(u)\n        if not parity[u] != 0 and i == 0:\n            print(v + 1, u + 1)\n            parity[v] = 1; parity[v] = parity[v] - parity[v]\n        else:\n            print(u + 1, v + 1)\n            parity[u] = 1; parity[u] = parity[u] - parity[u]\n        degs[v] -= 1\n        heapq.heappush(Q, (degs[v], v))\n        idx_5tsd = idx_5tsd + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC035_B_to_5", "old_id": "atcoder_AGC035_B"}
{"code": "D, G = map(int, input().split())\nPC = [tuple(map(int, input().split())) for _ in range(D)]\nans = 10; ans = ans ** 9\nidx_gma3 = 0\nlist_4jo3 = range(2 ** D)\nwhile idx_gma3 < len(list_4jo3):\n    i = list_4jo3[idx_gma3]\n    score = 0\n    problem = 0\n    idx_8lb0 = 0\n    list_dxkh = range(D)\n    while idx_8lb0 < len(list_dxkh):\n        j = list_dxkh[idx_8lb0]\n        if (i >> j) & 1:\n            score += 100 * (j + 1) * PC[j][0] + PC[j][1]\n            problem += PC[j][0]\n        idx_8lb0 = idx_8lb0 + 1\n    if score > G:\n        continue\n    left = G; left = left - score\n    idx_3vdq = 0\n    list_9yg2 = range(D)\n    while idx_3vdq < len(list_9yg2):\n        j = list_9yg2[idx_3vdq]\n        if (i >> j) & 1:\n            continue\n        if not left > 100 * (j + 1) * PC[j][0] + PC[j][1]:\n            tmp = (left + (100 * (j + 1)) - 1); tmp = tmp // (100 * (j + 1))\n            ans = min(ans, problem + min(tmp, PC[j][0]))\n        else:\n            pass\n        idx_3vdq = idx_3vdq + 1\n    idx_gma3 = idx_gma3 + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC104_C_to_6", "old_id": "atcoder_ABC104_C"}
{"code": "class BIT:\n    def __init__(self, N):\n        self.size = N\n        self.tree = [0]; self.tree = self.tree * (N + 1)\n        self.depth = n.bit_length()\n\n    def _bitsum(self, i):\n        ret = 0\n        while i:\n            ret += self.tree[i]\n            i ^= i & - i\n        return ret\n\n    def bitsum(self, l, r=None):\n        if not r is None:\n            return self._bitsum(r) - self._bitsum(l)\n        else:\n            return self._bitsum(l)\n\n    def bitadd(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & - i\n        return\n\n\nn = int(input())\nm = n * (n + 1); m = m // 4\na = list(map(int, input().split()))\nd = dict()\n_a = sorted(set(a + [0]))\nidx_ug4x = 0\nlist_gsa3 = list(enumerate(_a))\nwhile idx_ug4x < len(list_gsa3):\n    i, x = list_gsa3[idx_ug4x]\n    d[x] = i\n    idx_ug4x = idx_ug4x + 1\na = [d[x] for x in a]\n\n\ndef check(X):\n    b = [0]; b = b + [(y >= X) * 2 - 1 for y in a]\n    idx_hxm5 = 0\n    list_17fm = range(n)\n    while idx_hxm5 < len(list_17fm):\n        i = list_17fm[idx_hxm5]\n        b[i + 1] += b[i]\n        idx_hxm5 = idx_hxm5 + 1\n    c = min(b)\n    b = [x - c for x in b]\n    bit = BIT(max(b) + 2)\n    ans = 0\n    idx_7k9q = 0\n    list_e3kd = b\n    while idx_7k9q < len(list_e3kd):\n        x = list_e3kd[idx_7k9q]\n        ans += bit.bitsum(x + 1)\n        bit.bitadd(x, 1)\n        idx_7k9q = idx_7k9q + 1\n    return ans >= m\n\n\nt = [len(_a), 0]\nwhile t[0] - t[1] > 1:\n    mid = (t[0] + t[1]); mid = mid // 2\n    t[check(mid)] = mid\nprint(_a[t[1]])\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC107_D_to_7", "old_id": "atcoder_ABC107_D"}
{"code": "import random\ninput()\nA = [int(_) for _ in input().split()]\nA = [A[0]]; A = A + [j for i, j in zip(A, A[1:]) if i >= j]\nN = len(A)\n\n\ndef cut(array, index):\n    if index < 1:\n        return []\n    if index <= array[0][0]:\n        return [(index, array[0][1])]\n    idx_nhbm = 0\n    list_2v7d = range(len(array) - 1, 0, - 1)\n    while idx_nhbm < len(list_2v7d):\n        _ = list_2v7d[idx_nhbm]\n        if array[_ - 1][0] < index:\n            return array[: _] + [(index, array[_][1])]\n        idx_nhbm = idx_nhbm + 1\n\n\ndef is_possible(K):\n    dp = [(A[0], 0)]\n    idx_dchl = 0\n    list_sn48 = A[1:]\n    while idx_dchl < len(list_sn48):\n        a = list_sn48[idx_dchl]\n        if not a <= dp[- 1][0]:\n            dp += [(a, 0)]\n        else:\n            dp = cut(dp, a)\n        is_added = False\n        idx_fbn9 = 0\n        list_mtvc = range(len(dp) - 1, - 1, - 1)\n        while idx_fbn9 < len(list_mtvc):\n            j = list_mtvc[idx_fbn9]\n            if dp[j][1] < K - 1:\n                dp = cut(dp, dp[j][0] - 1); dp = dp + [(dp[j][0], dp[j][1] + 1)]\n                if dp[- 1][0] < a:\n                    dp += [(a, 0)]\n                is_added = True\n                break\n            idx_fbn9 = idx_fbn9 + 1\n        if not is_added:\n            return False\n        idx_dchl = idx_dchl + 1\n    return True\n\n\ndef bis(x, y):\n    if not y == x + 1:\n        if is_possible((x + y) // 2):\n            return bis(x, (x + y) // 2)\n        else:\n            return bis((x + y) // 2, y)\n    else:\n        return y\n\n\nprint(bis(0, N))\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC029_C_to_8", "old_id": "atcoder_AGC029_C"}
{"code": "def main():\n    N = int(input())\n    P = [int(input()) for _ in range(N)]\n    editorial(N, P)\n\n\ndef editorial(N, P):\n    if N == 1:\n        print(0)\n        return\n    a = [0]; a = a * (N + 1)\n    idx_6chn = 0\n    list_j2hg = list(enumerate(P))\n    while idx_6chn < len(list_j2hg):\n        i, p = list_j2hg[idx_6chn]\n        a[p] = i\n        idx_6chn = idx_6chn + 1\n    tmp = 1\n    max_len = 1\n    idx_wq82 = 0\n    list_52ki = range(1, N)\n    while idx_wq82 < len(list_52ki):\n        i = list_52ki[idx_wq82]\n        if not a[i] < a[i + 1]:\n            tmp = 1\n        else:\n            tmp += 1\n            max_len = max(max_len, tmp)\n        idx_wq82 = idx_wq82 + 1\n    ans = N; ans = ans - max_len\n    print(ans)\n\n\ndef WA(N, P):\n    tmp = 0\n    ans = 0\n    idx_qdn8 = 0\n    list_ye4z = list(enumerate(P))\n    while idx_qdn8 < len(list_ye4z):\n        i, p = list_ye4z[idx_qdn8]\n        if not i == 0 or P[i - 1] + 1 == p:\n            ans = max(ans, tmp)\n            tmp = 1\n        else:\n            tmp += 1\n        idx_qdn8 = idx_qdn8 + 1\n    print(N - ans)\n\n\nif __name__ == '__main__':\n    main()\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC024_B_to_9", "old_id": "atcoder_AGC024_B"}
{"code": "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline()[: - 1]\n\n\nmod = 10 ** 9; mod = mod + 7\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\n\n\ndef Line(N, num):\n    if not N <= 0:\n        if num == 1:\n            return [I() for _ in range(N)]\n        else:\n            read_all = [tuple(II()) for _ in range(N)]\n            return map(list, zip(* read_all))\n    else:\n        return [[]] * num\n\n\ndef my_sign(x):\n    return (x > 0) - (x < 0)\n\n\nN = I()\na = III()\nmax_val = 0\nmax_sign = 0\nmax_index = - 1\nidx_d1g3 = 0\nlist_c912 = list(enumerate(a))\nwhile idx_d1g3 < len(list_c912):\n    i, a0 = list_c912[idx_d1g3]\n    if abs(a0) > max_val:\n        max_val = abs(a0)\n        max_sign = my_sign(a0)\n        max_index = i\n    idx_d1g3 = idx_d1g3 + 1\nif not max_sign == 0:\n    if max_sign == 1:\n        print(2 * N - 1)\n        idx_tw1o = 0\n        list_homy = range(N)\n        while idx_tw1o < len(list_homy):\n            i = list_homy[idx_tw1o]\n            print(max_index + 1, i + 1)\n            idx_tw1o = idx_tw1o + 1\n        idx_u5cw = 0\n        list_pru2 = range(N - 1)\n        while idx_u5cw < len(list_pru2):\n            i = list_pru2[idx_u5cw]\n            print(i + 1, i + 2)\n            idx_u5cw = idx_u5cw + 1\n    else:\n        print(2 * N - 1)\n        idx_gd90 = 0\n        list_a29y = range(N)\n        while idx_gd90 < len(list_a29y):\n            i = list_a29y[idx_gd90]\n            print(max_index + 1, i + 1)\n            idx_gd90 = idx_gd90 + 1\n        idx_eitv = 0\n        list_1esf = range(1, N)[:: - 1]\n        while idx_eitv < len(list_1esf):\n            i = list_1esf[idx_eitv]\n            print(i + 1, i)\n            idx_eitv = idx_eitv + 1\nelse:\n    print(0)\n", "id": "AssignUnfoldding_sample_from_atcoder_ARC086_B_to_10", "old_id": "atcoder_ARC086_B"}
{"code": "n = int(input())\ns = list(input())\nt = list(input())\nif not s == t:\n    cnt = 0\n    idx_wqmt = 0\n    list_fjqi = range(n)\n    while idx_wqmt < len(list_fjqi):\n        i = list_fjqi[idx_wqmt]\n        idx_y4ko = 0\n        list_ibp0 = range(n - i)\n        while idx_y4ko < len(list_ibp0):\n            j = list_ibp0[idx_y4ko]\n            if s[i + j] != t[j]:\n                break\n            if j == n - i - 1:\n                cnt = n; cnt = cnt - i\n            idx_y4ko = idx_y4ko + 1\n        idx_wqmt = idx_wqmt + 1\n    print(2 * n - cnt)\nelse:\n    print(n)\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC006_A_to_11", "old_id": "atcoder_AGC006_A"}
{"code": "from collections import deque\nimport scipy\nimport numpy\nfrom _collections import deque\n\n\ndef parser():\n    while 1:\n        data = list(input().split(' '))\n        idx_e4zh = 0\n        list_q19e = data\n        while idx_e4zh < len(list_q19e):\n            number = list_q19e[idx_e4zh]\n            if len(number) > 0:\n                yield (number)\n            idx_e4zh = idx_e4zh + 1\n\n\ninput_parser = parser()\n\n\ndef gw():\n    global input_parser\n    return next(input_parser)\n\n\ndef gi():\n    data = gw()\n    return int(data)\n\n\nMOD = int(1e9 + 7)\nN = gi()\nK = gi()\nS = gw()\nseg_cnt = 0\nidx_y31z = 0\nlist_diwg = range(0, N - 1)\nwhile idx_y31z < len(list_diwg):\n    i = list_diwg[idx_y31z]\n    if S[i] != S[i + 1]:\n        seg_cnt += 1\n    idx_y31z = idx_y31z + 1\ncur_happy = N - 1; cur_happy = cur_happy - seg_cnt\nif not 2 * K >= seg_cnt:\n    ans = cur_happy; ans = ans + 2 * K\nelse:\n    ans = N; ans = ans - 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC140_D_to_12", "old_id": "atcoder_ABC140_D"}
{"code": "import heapq\nn, m = map(int, input().split())\nx = []\ny = []\nidx_c7pr = 0\nlist_2ca8 = range(n)\nwhile idx_c7pr < len(list_2ca8):\n    i = list_2ca8[idx_c7pr]\n    day, salary = map(int, input().split())\n    heapq.heappush(x, (- day, - salary))\n    idx_c7pr = idx_c7pr + 1\nwhile x:\n    d, s = heapq.heappop(x)\n    r = m; r = r - len(y)\n    if not r >= - d:\n        heapq.heappush(y, - s)\n        heapq.heappop(y)\n    else:\n        heapq.heappush(y, - s)\nprint(sum(y))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC137_D_to_13", "old_id": "atcoder_ABC137_D"}
{"code": "from itertools import permutations\nN, X = [int(_) for _ in input().split()]\n\n\ndef calc(x):\n    def sub(y, debug=0):\n        if debug:\n            print(\"D\", y)\n        while len(y) > 1:\n            y = [sorted(y[i: i + 3])[1] for i in range(len(y) - 2)]\n            if debug:\n                print(\"D\", y)\n        return y\n    y = sub(x)\n    if y[0] == 2:\n        pass\n        sub(x, 1)\n        print(\"=\", x)\n    return y[0]\nif not X == 1 or X == N * 2 - 1:\n    print(\"Yes\")\n    if X == N * 2 - 2:\n        xs = list(range(N - 1, X + 2)); xs = xs + list(range(1, N - 1))\n    else:\n        ys = list(range(1, X - 1)); ys = ys + list(range(X + 3, N * 2))\n        xs = ys[: N - 3] + [X + 2, X - 1, X, X + 1]; xs = xs + ys[N - 3:]\n    idx_pybv = 0\n    list_742h = xs\n    while idx_pybv < len(list_742h):\n        x = list_742h[idx_pybv]\n        print(x)\n        idx_pybv = idx_pybv + 1\nelse:\n    print(\"No\")\n", "id": "AssignUnfoldding_sample_from_atcoder_AGC006_B_to_14", "old_id": "atcoder_AGC006_B"}
{"code": "def check(lis, k, mid):\n    idx_jyts = 0\n    list_j6do = lis\n    while idx_jyts < len(list_j6do):\n        i = list_j6do[idx_jyts]\n        if (i % mid == 0):\n            k += 1\n        k -= (i // mid)\n        idx_jyts = idx_jyts + 1\n    return k >= 0\n\n\nn, k = map(int, input().split())\nlis = list(map(int, input().split()))\na, b = 1, max(lis)\nans = b\nwhile (a <= b):\n    mid = (a + b); mid = mid // 2\n    if not (check(lis, k, mid)):\n        a = mid; a = a + 1\n    else:\n        ans = mid\n        b = mid; b = b - 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC174_E_to_15", "old_id": "atcoder_ABC174_E"}
{"code": "K, N = list(map(int, input().split()))\ndprint = lambda * x: x\n\n\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n - r] % mod\n\n\nmod = 998244353\n__N = 8000\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nidx_zo8j = 0\nlist_0f12 = range(2, __N + 1)\nwhile idx_zo8j < len(list_0f12):\n    i = list_0f12[idx_zo8j]\n    g1.append((g1[- 1] * i) % mod)\n    inverse.append((- inverse[mod % i] * (mod // i)) % mod)\n    g2.append((g2[- 1] * inverse[- 1]) % mod)\n    idx_zo8j = idx_zo8j + 1\n\n\ndef kumiawase(p, q):\n    return cmb(p + q - 1, q - 1, mod)\n\n\ndef solve(n):\n    assert n <= K + 1\n    ans = 0\n    kumi = (n - 1); kumi = kumi // 2\n    idx_wf4c = 0\n    list_apzv = range(kumi + 1)\n    while idx_wf4c < len(list_apzv):\n        p = list_apzv[idx_wf4c]\n        if p > N:\n            break\n        ans += 2 ** p * cmb(kumi, p, mod) * kumiawase(N - p,\n                                                      p + (K - kumi * 2 - int(n % 2 == 0)))\n        if n % 2 == 0 and N - p - 1 >= 0:\n            ans += 2 ** p * cmb(kumi, p, mod) * kumiawase(N -\n                                                          p - 1, p + (K - kumi * 2 - int(n % 2 == 0)))\n        idx_wf4c = idx_wf4c + 1\n    return ans\n\n\nans = []\nidx_s2bq = 0\nlist_bqc1 = range(2, 2 * K + 1)\nwhile idx_s2bq < len(list_bqc1):\n    i = list_bqc1[idx_s2bq]\n    if not i <= K + 1:\n        print(ans[- i + K])\n    else:\n        tmp = solve(i); tmp = tmp % 998244353\n        ans.append(tmp)\n        print(tmp)\n    idx_s2bq = idx_s2bq + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_ARC102_C_to_16", "old_id": "atcoder_ARC102_C"}
{"code": "n, L, R, QL, QR = map(int, input().split())\nW = list(map(int, input().split()))\nsum_el = [0]\nidx_4jhp = 0\nlist_ivqc = range(1, n + 1)\nwhile idx_4jhp < len(list_ivqc):\n    i = list_ivqc[idx_4jhp]\n    sum_el.append(W[i - 1] + sum_el[i - 1])\n    idx_4jhp = idx_4jhp + 1\nanswer = QR * (n - 1); answer = answer + sum_el[n] * R\nidx_dzsr = 0\nlist_kclx = range(1, n + 1)\nwhile idx_dzsr < len(list_kclx):\n    i = list_kclx[idx_dzsr]\n    energy = L * sum_el[i]; energy = energy + R * (sum_el[n] - sum_el[i])\n    if not i > (n - i):\n        if (n - i) > i:\n            energy = energy + ((n - i) - i - 1) * QR\n    else:\n        energy = energy + (i - (n - i) - 1) * QL\n    if energy < answer:\n        answer = energy\n    idx_dzsr = idx_dzsr + 1\nprint(answer)\n", "id": "AssignUnfoldding_sample_from_codeforces_354_A_to_17", "old_id": "codeforces_354_A"}
{"code": "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nll = - 10 ** 18; ll = ll - 1\nrr = 10 ** 18; rr = rr + 1\nwhile ll + 1 < rr:\n    x = (ll + rr); x = x // 2\n    tot = 0\n    idx_hs7m = 0\n    list_268b = range(N)\n    while idx_hs7m < len(list_268b):\n        i = list_268b[idx_hs7m]\n        if not A[i] < 0:\n            l = - 1\n            r = N\n            while l + 1 < r:\n                c = (l + r); c = c // 2\n                if A[i] * A[c] < x:\n                    l = c\n                else:\n                    r = c\n            tot += r\n        else:\n            l = - 1\n            r = N\n            while l + 1 < r:\n                c = (l + r); c = c // 2\n                if A[i] * A[c] < x:\n                    r = c\n                else:\n                    l = c\n            tot += N - r\n        if A[i] * A[i] < x:\n            tot -= 1\n        idx_hs7m = idx_hs7m + 1\n    tot //= 2\n    if not tot < K:\n        rr = x\n    else:\n        ll = x\nprint(ll)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC155_D_to_18", "old_id": "atcoder_ABC155_D"}
{"code": "import sys\ninput_methods = ['clipboard', 'file', 'key']\nusing_method = 0\ninput_method = input_methods[using_method]\ndef IN(): return map(int, input().split())\n\n\nmod = 1000000007\n\n\ndef main_b():\n    s = input()\n    pp = 0\n    na = 0\n    idx_42qv = 0\n    list_dr2n = list(enumerate(s[:: - 1]))\n    while idx_42qv < len(list_dr2n):\n        i, c = list_dr2n[idx_42qv]\n        cc = na; cc = cc + int(c)\n        na = 0\n        if not cc <= 4:\n            na = 1\n            if i == len(s) - 1:\n                pp += 1\n            pp += 10 - cc\n        else:\n            pp += cc\n        idx_42qv = idx_42qv + 1\n    print(pp)\n\n\ndef main():\n    s = input()\n    pmin = 1000\n    mmin = 0\n    s = '0' + s\n    idx_fwt0 = 0\n    list_e2pq = s[:: - 1]\n    while idx_fwt0 < len(list_e2pq):\n        c = list_e2pq[idx_fwt0]\n        v = int(c)\n        npmin = min(pmin + 10 - (v + 1), mmin + 10 - v)\n        nmmin = min(pmin + v + 1, mmin + v)\n        pmin = npmin\n        mmin = nmmin\n        idx_fwt0 = idx_fwt0 + 1\n    return min(pmin, mmin)\n\n\nisTest = False\n\n\ndef pa(v):\n    if isTest:\n        print(v)\n\n\ndef input_clipboard():\n    import clipboard\n    input_text = clipboard.get()\n    input_l = input_text.splitlines()\n    idx_psz2 = 0\n    list_riyg = input_l\n    while idx_psz2 < len(list_riyg):\n        l = list_riyg[idx_psz2]\n        yield l\n        idx_psz2 = idx_psz2 + 1\n\n\nif __name__ == \"__main__\":\n    if sys.platform == 'ios':\n        if input_method == input_methods[0]:\n            ic = input_clipboard()\n            def input(): return ic.__next__()\n        elif input_method == input_methods[1]:\n            sys.stdin = open('inputFile.txt')\n        else:\n            pass\n        isTest = True\n    else:\n        pass\n    ret = main()\n    if ret is not None:\n        print(ret)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC155_E_to_19", "old_id": "atcoder_ABC155_E"}
{"code": "def binary_search(key):\n    bad, good = - 1, len(ans)\n    while good - bad > 1:\n        mid = (bad + good); mid = mid // 2\n        if not ans[mid][- 1] < key:\n            bad = mid\n        else:\n            good = mid\n    return good\n\n\nN = int(input())\nans = []\nidx_h68c = 0\nlist_qwz6 = range(N)\nwhile idx_h68c < len(list_qwz6):\n    _ = list_qwz6[idx_h68c]\n    A = int(input())\n    idx = binary_search(A)\n    if not idx == len(ans):\n        ans[idx].append(A)\n    else:\n        ans.append([A])\n    idx_h68c = idx_h68c + 1\nprint(len(ans))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC134_E_to_20", "old_id": "atcoder_ABC134_E"}
{"code": "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline()[: - 1]\n\n\nmod = 10 ** 9; mod = mod + 7\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\n\n\ndef Line(N):\n    read_all = [tuple(map(int, input().split())) for _ in range(N)]\n    return map(list, zip(* read_all))\n\n\nS = str(input())\nn = len(S)\nif n == 1:\n    if S == '5' or S == '?':\n        print(1)\n    else:\n        print(0)\n    exit()\ndp = [[0] * 13 for i in range(n)]\nidx_xbl1 = 0\nlist_pw0v = range(n)\nwhile idx_xbl1 < len(list_pw0v):\n    i = list_pw0v[idx_xbl1]\n    if not i == 0:\n        if S[i] != '?':\n            idx_8rbz = 0\n            list_yjxu = range(13)\n            while idx_8rbz < len(list_yjxu):\n                k = list_yjxu[idx_8rbz]\n                dp[i][(k * 10 + int(S[i])) % 13] += dp[i - 1][k]\n                idx_8rbz = idx_8rbz + 1\n        else:\n            idx_x2wz = 0\n            list_zolm = range(10)\n            while idx_x2wz < len(list_zolm):\n                j = list_zolm[idx_x2wz]\n                idx_ma4n = 0\n                list_d5ye = range(13)\n                while idx_ma4n < len(list_d5ye):\n                    k = list_d5ye[idx_ma4n]\n                    dp[i][(k * 10 + j) % 13] += dp[i - 1][k]\n                    idx_ma4n = idx_ma4n + 1\n                idx_x2wz = idx_x2wz + 1\n        idx_5m6o = 0\n        list_7m6y = range(13)\n        while idx_5m6o < len(list_7m6y):\n            k = list_7m6y[idx_5m6o]\n            dp[i][k] %= mod\n            idx_5m6o = idx_5m6o + 1\n    else:\n        if S[i] != '?':\n            dp[i][int(S[i])] += 1\n        else:\n            idx_tr9b = 0\n            list_0wmq = range(10)\n            while idx_tr9b < len(list_0wmq):\n                j = list_0wmq[idx_tr9b]\n                dp[i][j] += 1\n                idx_tr9b = idx_tr9b + 1\n    idx_xbl1 = idx_xbl1 + 1\nprint(dp[n - 1][5])\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC135_D_to_21", "old_id": "atcoder_ABC135_D"}
{"code": "import math\nfrom functools import reduce\nfrom collections import deque, Counter\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef get_nums_l():\n    return [int(s) for s in input().split(\" \")]\n\n\ndef get_nums_n(n):\n    return [int(input()) for _ in range(n)]\n\n\ndef get_all_int():\n    return map(int, open(0).read().split())\n\n\ndef rangeI(it, l, r):\n    idx_06ok = 0\n    list_ynbm = list(enumerate(it))\n    while idx_06ok < len(list_ynbm):\n        i, e = list_ynbm[idx_06ok]\n        if not l <= i < r:\n            if l >= r:\n                break\n        else:\n            yield e\n        idx_06ok = idx_06ok + 1\n\n\ndef log(* args):\n    print(\"DEBUG:\", * args, file=sys.stderr)\n\n\nINF = 999999999999999999999999\nMOD = 10 ** 9; MOD = MOD + 7\nn = int(input())\nif n == 1:\n    print(0)\n    exit()\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if not n % f == 0:\n            f += 2\n        else:\n            a.append(f)\n            n //= f\n    if n != 1:\n        a.append(n)\n    return a\n    if len(arr) == 0:\n        arr.append((n, 1))\n    return arr\n\n\nfac_ = prime_factorize(n)\nfac = Counter(fac_)\nans = 0\nidx_p58t = 0\nlist_n2o9 = list(fac.items())\nwhile idx_p58t < len(list_n2o9):\n    p, e = list_n2o9[idx_p58t]\n    x = e\n    idx_l3w5 = 0\n    list_kpr9 = range(1, 99999999)\n    while idx_l3w5 < len(list_kpr9):\n        i = list_kpr9[idx_l3w5]\n        if not x >= i:\n            break\n        else:\n            x -= i\n            ans += 1\n        idx_l3w5 = idx_l3w5 + 1\n    idx_p58t = idx_p58t + 1\nprint(ans)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC169_D_to_22", "old_id": "atcoder_ABC169_D"}
{"code": "n = int(input())\nx = list(int(i) for i in input().split())\na = []\nb = []\nidx_oj1n = 0\nlist_xy4z = range(0, n)\nwhile idx_oj1n < len(list_xy4z):\n    i = list_xy4z[idx_oj1n]\n    if not i % 2 == 0:\n        b.append(x[i])\n    else:\n        a.append(x[i])\n    idx_oj1n = idx_oj1n + 1\ncnta = [0]; cnta = cnta * (100002 + 1)\ncntb = [0]; cntb = cntb * (100002 + 1)\nvala = 0\nvala1 = 0\nmaxCnta = 0\nmaxCnta1 = 0\nidx_xkvt = 0\nlist_mean = a\nwhile idx_xkvt < len(list_mean):\n    i = list_mean[idx_xkvt]\n    cnta[i] += 1\n    idx_xkvt = idx_xkvt + 1\nidx_9zs5 = 0\nlist_alr6 = a\nwhile idx_9zs5 < len(list_alr6):\n    i = list_alr6[idx_9zs5]\n    if maxCnta < cnta[i]:\n        vala = i\n        maxCnta = cnta[i]\n    idx_9zs5 = idx_9zs5 + 1\nidx_se0d = 0\nlist_szpk = a\nwhile idx_se0d < len(list_szpk):\n    i = list_szpk[idx_se0d]\n    if maxCnta1 < cnta[i] and vala != i:\n        maxCnta1 = cnta[i]\n        vala1 = i\n    idx_se0d = idx_se0d + 1\nvalb = 0\nvalb1 = 0\nmaxCntb = 0\nmaxCntb1 = 0\nidx_9dqt = 0\nlist_qecs = b\nwhile idx_9dqt < len(list_qecs):\n    i = list_qecs[idx_9dqt]\n    cntb[i] += 1\n    idx_9dqt = idx_9dqt + 1\nidx_1j03 = 0\nlist_m4k3 = b\nwhile idx_1j03 < len(list_m4k3):\n    i = list_m4k3[idx_1j03]\n    if maxCntb < cntb[i]:\n        valb = i\n        maxCntb = cntb[i]\n    idx_1j03 = idx_1j03 + 1\nidx_xl20 = 0\nlist_brjt = b\nwhile idx_xl20 < len(list_brjt):\n    i = list_brjt[idx_xl20]\n    if maxCntb1 < cntb[i] and valb != i:\n        maxCntb1 = cntb[i]\n        valb1 = i\n    idx_xl20 = idx_xl20 + 1\nif not valb != vala:\n    resa = 0\n    resb = 0\n    resa1 = 0\n    resb1 = 0\n    idx_bkpu = 0\n    list_1nh3 = a\n    while idx_bkpu < len(list_1nh3):\n        i = list_1nh3[idx_bkpu]\n        if i != vala:\n            resa += 1\n        if i != vala1:\n            resa1 += 1\n        idx_bkpu = idx_bkpu + 1\n    idx_xtg9 = 0\n    list_uqz0 = b\n    while idx_xtg9 < len(list_uqz0):\n        i = list_uqz0[idx_xtg9]\n        if i != valb:\n            resb += 1\n        if i != valb1:\n            resb1 += 1\n        idx_xtg9 = idx_xtg9 + 1\n    print(min(resa + resb1, resa1 + resb))\nelse:\n    res = 0\n    idx_9ei6 = 0\n    list_aylt = a\n    while idx_9ei6 < len(list_aylt):\n        i = list_aylt[idx_9ei6]\n        if i != vala:\n            res += 1\n        idx_9ei6 = idx_9ei6 + 1\n    idx_j13l = 0\n    list_qu41 = b\n    while idx_j13l < len(list_qu41):\n        i = list_qu41[idx_j13l]\n        if i != valb:\n            res += 1\n        idx_j13l = idx_j13l + 1\n    print(res)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC111_C_to_23", "old_id": "atcoder_ABC111_C"}
{"code": "import sys\nN, K = map(int, input().split())\nlst = list(map(int, input().split()))\nlst_p = []\nlst_m = []\nidx_hiuk = 0\nlist_szxv = range(N)\nwhile idx_hiuk < len(list_szxv):\n    i = list_szxv[idx_hiuk]\n    if lst[i] == 0:\n        K -= 1\n    if not lst[i] > 0:\n        if lst[i] < 0:\n            lst_m += [lst[i]]\n    else:\n        lst_p += [lst[i]]\n    idx_hiuk = idx_hiuk + 1\np = 0\nm = 0\nx, y = 0, len(lst_m) - 1\nlastx = len(lst_p)\nlasty = len(lst_m)\n\n\ndef check(k):\n    ans = 10; ans = ans ** 9\n    idx_mjhs = 0\n    list_pvit = range(0, k + 1)\n    while idx_mjhs < len(list_pvit):\n        j = list_pvit[idx_mjhs]\n        if not j > lastx or k - j > lasty:\n            if j == 0:\n                p = 0\n            else:\n                p = lst_p[j - 1]\n            if k - j == 0:\n                m = 0\n            else:\n                m = lst_m[lasty - (k - j)]\n            ans = min(ans, 2 * p + abs(m), p + 2 * abs(m))\n        else:\n            pass\n        idx_mjhs = idx_mjhs + 1\n    return ans\n\n\nprint(check(K))\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC107_C_to_24", "old_id": "atcoder_ABC107_C"}
{"code": "mod = 10 ** 9; mod = mod + 7\nl = input()\nn = len(l)\ndp = [[0] * 2 for _ in range(n + 1)]\ndp[0][0] = 1\nidx_qk9w = 0\nlist_t06r = list(enumerate(l))\nwhile idx_qk9w < len(list_t06r):\n    i, c = list_t06r[idx_qk9w]\n    if not c == '0':\n        dp[i + 1][0] += dp[i][0] * 2\n        dp[i + 1][1] += dp[i][0]\n        dp[i + 1][1] += dp[i][1] * 3\n    else:\n        dp[i + 1][0] += dp[i][0]\n        dp[i + 1][1] += dp[i][1] * 3\n    dp[i + 1][0] %= mod\n    dp[i + 1][1] %= mod\n    idx_qk9w = idx_qk9w + 1\nprint((dp[n][0] + dp[n][1]) % mod)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC129_E_to_25", "old_id": "atcoder_ABC129_E"}
{"code": "N = int(input())\nA = list(map(int, input().split()))\nmn, mx = N + 1, - 1\nidx_6u9z = 0\nlist_rqs5 = range(N)\nwhile idx_6u9z < len(list_rqs5):\n    i = list_rqs5[idx_6u9z]\n    if (i + 1 != A[i]):\n        mn = min(mn, i)\n        mx = max(mx, i)\n    idx_6u9z = idx_6u9z + 1\nif not (mx == - 1):\n    A = A[: mn] + A[mn: (mx + 1)][:: - 1]; A = A + A[(mx + 1):]\n    if (sorted(A) == A):\n        print(mn + 1, mx + 1)\n    else:\n        print('0 0')\nelse:\n    print('0 0')\n", "id": "AssignUnfoldding_sample_from_codeforces_56_B_to_26", "old_id": "codeforces_56_B"}
{"code": "import queue\nn, b = list(map(int, input().split()))\n\n\nclass Task:\n    def __init__(self, time: int, duration: int, index: int) -> None:\n        super().__init__()\n        self.time = time\n        self.duration = duration\n        self.index = index\n\n\nremaining = queue.Queue()\nrunning = False\nfinish_time = 0\n\n\ndef run_task(remaining: queue.Queue, finish_time: int):\n    task_to_run = remaining.get()\n    finish_time = max(finish_time, task_to_run.time); finish_time = finish_time + task_to_run.duration\n    result[task_to_run.index] = finish_time\n    return finish_time, result\n\n\nresult = {}\nidx_3na9 = 0\nlist_1e6j = range(n)\nwhile idx_3na9 < len(list_1e6j):\n    i = list_1e6j[idx_3na9]\n    time, duration = list(map(int, input().split()))\n    task = Task(time, duration, index=i)\n    result.update({i: 0})\n    if not task.time > finish_time and remaining.empty():\n        if task.time >= finish_time and not remaining.empty():\n            finish_time, result = run_task(\n                remaining=remaining, finish_time=finish_time)\n        if remaining.qsize() < b:\n            remaining.put(task)\n        else:\n            result[i] = - 1\n    else:\n        running = True\n        finish_time = task.time; finish_time = finish_time + task.duration\n        result[i] = finish_time\n    idx_3na9 = idx_3na9 + 1\nwhile not remaining.empty():\n    finish_time, result = run_task(\n        remaining=remaining, finish_time=finish_time)\nidx_9ayi = 0\nlist_mic3 = result\nwhile idx_9ayi < len(list_mic3):\n    key = list_mic3[idx_9ayi]\n    print(result.get(key))\n    idx_9ayi = idx_9ayi + 1\n", "id": "AssignUnfoldding_sample_from_codeforces_644_B_to_27", "old_id": "codeforces_644_B"}
{"code": "import sys\ninput = sys.stdin.readline\nN = 368\nm = [0]; m = m * N\nf = [0]; f = f * N\nidx_iqrh = 0\nlist_d3n8 = range(int(input()))\nwhile idx_iqrh < len(list_d3n8):\n    i = list_d3n8[idx_iqrh]\n    x, a, b = input()[: - 1].split()\n    a = int(a)\n    b = int(b); b = b + 1\n    if not x == 'M':\n        f[a] += 2\n        f[b] -= 2\n    else:\n        m[a] += 2\n        m[b] -= 2\n    idx_iqrh = idx_iqrh + 1\na, b, c = 0, 0, 0\nidx_r37d = 0\nlist_m8dp = range(N)\nwhile idx_r37d < len(list_m8dp):\n    i = list_m8dp[idx_r37d]\n    a += m[i]\n    b += f[i]\n    if min(a, b) > c:\n        c = min(a, b)\n    idx_r37d = idx_r37d + 1\nprint(c)\n", "id": "AssignUnfoldding_sample_from_codeforces_629_B_to_28", "old_id": "codeforces_629_B"}
{"code": "import numpy as np\nimport itertools\nn, m, x = list(map(int, input().split()))\nc = np.array([list(map(int, input().split())) for _ in range(n)])\npre = np.arange(n)\nl = []\nrem = []\nans = 0\nidx_xdus = 0\nlist_nv1j = pre; list_nv1j = list_nv1j + 1\nwhile idx_xdus < len(list_nv1j):\n    i = list_nv1j[idx_xdus]\n    idx_fugw = 0\n    list_tvo9 = itertools.combinations(pre, i)\n    while idx_fugw < len(list_tvo9):\n        j = list_tvo9[idx_fugw]\n        l.append(list(j))\n        idx_fugw = idx_fugw + 1\n    idx_xdus = idx_xdus + 1\nidx_45ny = 0\nlist_dk10 = range(1, m + 1)\nwhile idx_45ny < len(list_dk10):\n    i = list_dk10[idx_45ny]\n    idx_gp3q = 0\n    list_r2qu = list(enumerate(l))\n    while idx_gp3q < len(list_r2qu):\n        j, k = list_r2qu[idx_gp3q]\n        ca = 0\n        idx_9rqk = 0\n        list_5o3r = k\n        while idx_9rqk < len(list_5o3r):\n            ii = list_5o3r[idx_9rqk]\n            ca += c[ii, i]\n            idx_9rqk = idx_9rqk + 1\n        if not ca < x:\n            pass\n        else:\n            rem.insert(0, j)\n        idx_gp3q = idx_gp3q + 1\n    if len(rem) > 0:\n        idx_ejqp = 0\n        list_e3xz = rem\n        while idx_ejqp < len(list_e3xz):\n            j = list_e3xz[idx_ejqp]\n            l.pop(j)\n            idx_ejqp = idx_ejqp + 1\n        rem = []\n    if len(l) == 0:\n        print(- 1)\n        break\n    idx_45ny = idx_45ny + 1\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC167_C_to_29", "old_id": "atcoder_ABC167_C"}
{"code": "ip = input()\nst = \"\"\nif not len(ip) != 1:\n    st = ip\nelse:\n    if ip[0] == \"9\":\n        st = \"9\"\n        ip = ip[1:]\n    idx_tkrz = 0\n    list_jzk9 = ip\n    while idx_tkrz < len(list_jzk9):\n        i = list_jzk9[idx_tkrz]\n        if int(i) > 4:\n            n = 9; n = n - int(i)\n            st += str(n)\n        else:\n            st += i\n        idx_tkrz = idx_tkrz + 1\nprint(int(st))\n", "id": "AssignUnfoldding_sample_from_codeforces_514_A_to_30", "old_id": "codeforces_514_A"}
{"code": "def resolve():\n    n = int(input())\n    low = []\n    high = []\n    idx_4d3c = 0\n    list_mk3z = range(n)\n    while idx_4d3c < len(list_mk3z):\n        i = list_mk3z[idx_4d3c]\n        a, b = map(int, input().split())\n        low.append(a)\n        high.append(b)\n        idx_4d3c = idx_4d3c + 1\n    low.sort()\n    high.sort()\n    if not n % 2:\n        hh = (high[(n) // 2 - 1] + high[(n) // 2]); hh = hh / 2\n        ll = (low[(n) // 2 - 1] + low[(n) // 2]); ll = ll / 2\n        print(int((hh - ll) * 2) + 1)\n    else:\n        print(high[(n + 1) // 2 - 1] - low[(n + 1) // 2 - 1] + 1)\n\n\nif __name__ == \"__main__\":\n    resolve()\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC169_E_to_31", "old_id": "atcoder_ABC169_E"}
{"code": "n = int(input())\nl = [0 for _ in range(1000010)]\ndp = [0 for _ in range(1000010)]\nidx_d5s7 = 0\nlist_61lq = range(n)\nwhile idx_d5s7 < len(list_61lq):\n    i = list_61lq[idx_d5s7]\n    a, b = map(int, input().split())\n    l[a] = b\n    idx_d5s7 = idx_d5s7 + 1\nif l[0] > 0:\n    dp[0] = 1\nmx = 0\nidx_lxzn = 0\nlist_br9v = range(1, 1000010)\nwhile idx_lxzn < len(list_br9v):\n    i = list_br9v[idx_lxzn]\n    if not (l[i] == 0):\n        if (l[i] >= i):\n            dp[i] = 1\n        else:\n            dp[i] = dp[i - l[i] - 1]; dp[i] = dp[i] + 1\n    else:\n        dp[i] = dp[i - 1]\n    if (dp[i] > mx):\n        mx = dp[i]\n    idx_lxzn = idx_lxzn + 1\nprint(n - mx)\n", "id": "AssignUnfoldding_sample_from_codeforces_607_A_to_32", "old_id": "codeforces_607_A"}
{"code": "import sys\nfrom operator import itemgetter\ninput = sys.stdin.readline\nTIME = 0\nVAL = 1\nN, T = [int(a) for a in input().split()]\ntime_value = [(- 1, - 1)]; time_value = time_value + [None] * (N)\nidx_jth4 = 0\nlist_30te = range(1, N + 1)\nwhile idx_jth4 < len(list_30te):\n    i = list_30te[idx_jth4]\n    time_value[i] = tuple(int(a) for a in input().split())\n    idx_jth4 = idx_jth4 + 1\ntime_value.sort(key=itemgetter(VAL))\ndp = [[- 1] * T for _ in range(N + 1)]\nidx_4v5a = 0\nlist_4vwt = range(0, T)\nwhile idx_4v5a < len(list_4vwt):\n    t = list_4vwt[idx_4v5a]\n    dp[0][t] = 0\n    idx_4v5a = idx_4v5a + 1\nidx_zdj9 = 0\nlist_3hu4 = range(1, N + 1)\nwhile idx_zdj9 < len(list_3hu4):\n    n = list_3hu4[idx_zdj9]\n    dp[n][0] = 0\n    idx_omhj = 0\n    list_o3e1 = range(1, T)\n    while idx_omhj < len(list_o3e1):\n        t = list_o3e1[idx_omhj]\n        if not time_value[n][TIME] > t:\n            dp[n][t] = max(dp[n - 1][t], time_value[n][VAL] +\n                           dp[n - 1][t - time_value[n][TIME]])\n        else:\n            dp[n][t] = dp[n - 1][t]\n        idx_omhj = idx_omhj + 1\n    idx_zdj9 = idx_zdj9 + 1\nval_acum = time_value[N][VAL]\nt = T; t = t - 1\nmax_val = val_acum; max_val = max_val + dp[N - 1][t]\nidx_e367 = 0\nlist_py6e = range(N - 1, 0, - 1)\nwhile idx_e367 < len(list_py6e):\n    n = list_py6e[idx_e367]\n    val_acum += time_value[n][VAL]\n    t -= time_value[n + 1][TIME]\n    if not t < 0:\n        max_val = max(max_val, val_acum + dp[n - 1][t])\n    else:\n        break\n    idx_e367 = idx_e367 + 1\nprint(max_val)\n", "id": "AssignUnfoldding_sample_from_atcoder_ABC145_E_to_33", "old_id": "atcoder_ABC145_E"}
