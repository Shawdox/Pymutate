{"id": "ADD_1_TO_A_GIVEN_NUMBER", "code": "def addOne ( x ) :\n    m = 1\n    while ( x & m ) :\n        x = x ^ m\n        m <<= 1\n    x = x ^ m\n    return x"}
{"id": "ADD_1_TO_A_GIVEN_NUMBER_1", "code": "def addOne ( x ) :\n    return ( - ( ~ x ) )"}
{"id": "ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS", "code": "def search ( arr , n , x ) :\n    i = 0\n    for i in range ( i , n ) :\n        if ( arr [ i ] == x ) :\n            return i\n    return - 1"}
{"id": "AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT", "code": "def getArea ( a ) :\n    area = ( math.pi * a * a ) / 4\n    return area"}
{"id": "AREA_SQUARE_CIRCUMSCRIBED_CIRCLE", "code": "def find_Area ( r ) :\n    return ( 2 * r * r )"}
{"id": "ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES", "code": "def winner ( a , n , k ) :\n    if k >= n - 1 :\n        return n\n    best = 0\n    times = 0\n    for i in range ( n ) :\n        if a [ i ] > best :\n            best = a [ i ]\n            if i == True :\n                times = 1\n        else :\n            times += 1\n        if times >= k :\n            return best\n    return best"}
{"id": "ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE", "code": "def solveQuery ( start , end , arr ) :\n    frequency = dict ( )\n    for i in range ( start , end + 1 ) :\n        if arr [ i ] in frequency.keys ( ) :\n            frequency [ arr [ i ] ] += 1\n        else :\n            frequency [ arr [ i ] ] = 1\n    count = 0\n    for x in frequency :\n        if x == frequency [ x ] :\n            count += 1\n    return count"}
{"id": "BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS", "code": "def gcd ( a , b ) :\n    if a == 0 :\n        return b\n    return gcd ( b % a , a )"}
{"id": "BINARY_SEARCH", "code": "def binarySearch ( arr , l , r , x ) :\n    if r >= l :\n        mid = l + ( r - l ) // 2\n        if arr [ mid ] == x :\n            return mid\n        elif arr [ mid ] > x :\n            return binarySearch ( arr , l , mid - 1 , x )\n        else :\n            return binarySearch ( arr , mid + 1 , r , x )\n    else :\n        return - 1"}
{"id": "BREAK_NUMBER_THREE_PARTS", "code": "def count_of_ways ( n ) :\n    count = 0\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , n + 1 ) :\n            for k in range ( 0 , n + 1 ) :\n                if ( i + j + k == n ) :\n                    count = count + 1\n    return count"}
{"id": "BREAK_NUMBER_THREE_PARTS_1", "code": "def count_of_ways ( n ) :\n    count = 0\n    count = ( n + 1 ) * ( n + 2 ) // 2\n    return count"}
{"id": "CAESAR_CIPHER", "code": "def encrypt ( text , s ) :\n    result = \"\"\n    for i in range ( len ( text ) ) :\n        char = text [ i ]\n        if ( char.isupper ( ) ) :\n            result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        else :\n            result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n    return result"}
{"id": "CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND", "code": "def calcAngle ( h , m ) :\n    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :\n        print ( 'Wrong input' )\n    if ( h == 12 ) :\n        h = 0\n    if ( m == 60 ) :\n        m = 0\n    hour_angle = int ( 0.5 * ( h * 60 + m ) )\n    minute_angle = int ( 6 * m )\n    angle = abs ( hour_angle - minute_angle )\n    angle = min ( 360 - angle , angle )\n    return angle"}
{"id": "CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING", "code": "def calcMaxValue ( str ) :\n    res = ord ( str [ 0 ] ) - 48\n    for i in range ( 1 , len ( str ) ) :\n        if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) :\n            res += ord ( str [ i ] ) - 48\n        else :\n            res += ord ( str [ i ] ) - 48\n    return res"}
{"id": "CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING", "code": "def findSum ( str ) :\n    temp = \"0\"\n    Sum = 0\n    for ch in str :\n        if ( ch.isdigit ( ) ) :\n            temp += ch\n        else :\n            Sum += int ( temp )\n            temp = \"0\"\n    return Sum + int ( temp )"}
{"id": "CALCULATE_VOLUME_DODECAHEDRON", "code": "def vol_of_dodecahedron ( side ) :\n    return ( ( ( 15 + ( 7 * ( math.sqrt ( 5 ) ) ) ) / 4 ) * ( math.pow ( side , 3 ) ) )"}
{"id": "CASSINIS_IDENTITY", "code": "def cassini ( n ) :\n    return - 1 if ( n & 1 ) else 1"}
{"id": "CEILING_IN_A_SORTED_ARRAY_1", "code": "def ceilSearch ( arr , low , high , x ) :\n    if x <= arr [ low ] :\n        return low\n    if x > arr [ high ] :\n        return - 1\n    mid = ( low + high ) / 2\n    if arr [ mid ] == x :\n        return mid\n    elif arr [ mid ] < x :\n        if mid + 1 <= high and x <= arr [ mid + 1 ] :\n            return mid + 1\n        else :\n            return ceilSearch ( arr , mid + 1 , high , x )\n    else :\n        if mid - 1 >= low and x > arr [ mid - 1 ] :\n            return mid\n        else :\n            return ceilSearch ( arr , low , mid - 1 , x )"}
{"id": "CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS", "code": "def HalfDiagonalSums ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    i = 0\n    j = n - 1\n    while i < n :\n        if ( i < n // 2 ) :\n            diag1_left += mat [ i ] [ i ]\n            diag2_left += mat [ j ] [ i ]\n        elif ( i > n // 2 ) :\n            diag1_right += mat [ i ] [ i ]\n            diag2_right += mat [ j ] [ i ]\n        i += 1\n        j -= 1\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )"}
{"id": "CHANGE_BITS_CAN_MADE_ONE_FLIP", "code": "def canMakeAllSame ( str ) :\n    zeros = 0\n    ones = 0\n    for i in range ( 0 , len ( str ) ) :\n        ch = str [ i ]\n        if ( ch == '0' ) :\n            zeros = zeros + 1\n        else :\n            ones = ones + 1\n    return ( zeros == 1 or ones == 1 )"}
{"id": "CHANGE_BITS_CAN_MADE_ONE_FLIP_1", "code": "def isOneFlip ( str ) :\n    sum = 0\n    n = len ( str )\n    for i in range ( 0 , n ) :\n        sum += ord ( str [ i ] ) - ord ( '0' )\n    return ( sum == n - 1 or sum == 1 )"}
{"id": "CHECK_ARRAY_MAJORITY_ELEMENT", "code": "def isMajority ( a, n ) :\n    mp = { }\n    for i in range(n) :\n        if a[i] in mp : mp [ a[i] ] += 1\n        else : mp [ a[i] ] = 1\n    for x in mp :\n        if mp [ x ] >= len ( a ) // 2 :\n            return True\n    return False"}
{"id": "CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT", "code": "def isInorder ( arr , n ) :\n    if ( n == 0 or n == 1 ) :\n        return True\n    for i in range ( 1 , n , 1 ) :\n        if ( arr [ i - 1 ] > arr [ i ] ) :\n            return False\n    return True"}
{"id": "CHECK_DIVISIBILITY_BINARY_STRING_2K", "code": "def isDivisible ( str , k ) :\n    n = len ( str )\n    c = 0\n    for i in range ( 0 , k ) :\n        if ( str [ n - i - 1 ] == '0' ) :\n            c += 1\n    return ( c == k )"}
{"id": "CHECK_DIVISIBILITY_LARGE_NUMBER_999", "code": "def isDivisible999 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '0' ) :\n        return True\n    if ( ( n % 3 ) == 1 ) :\n        num = \"00\" + num\n    if ( ( n % 3 ) == 2 ) :\n        num = \"0\" + num\n    gSum = 0\n    for i in range ( 0 , n , 3 ) :\n        group = 0\n        group += ( ord ( num [ i ] ) - 48 ) * 100\n        group += ( ord ( num [ i + 1 ] ) - 48 ) * 10\n        group += ( ord ( num [ i + 2 ] ) - 48 )\n        gSum += group\n    if ( gSum > 1000 ) :\n        num = str ( gSum )\n        n = len ( num )\n        gSum = isDivisible999 ( num )\n    return ( gSum == 999 )"}
{"id": "CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CONCENTRIC_CIRCLES", "code": "def checkcircle ( r , R , r1 , x1 , y1 ) :\n    dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) )\n    return ( dis - r1 >= R and dis + r1 <= r )"}
{"id": "CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS", "code": "def check ( s ) :\n    if ( len ( s ) >= 10 ) :\n        return True\n    for i in range ( 1 , len ( s ) ) :\n        for j in range ( i + 1 , len ( s ) ) :\n            for k in range ( j + 1 , len ( s ) ) :\n                s1 = s [ 0 : i ]\n                s2 = s [ i : j ]\n                s3 = s [ j : k ]\n                s4 = s [ k : len ( s ) ]\n                if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) :\n                    return True\n    return False"}
{"id": "CHECK_GIVEN_STRING_ROTATION_PALINDROME", "code": "def isPalindrome ( string ) :\n    l = 0\n    h = len ( string ) - 1\n    while h > l :\n        l += 1\n        h -= 1\n        if string [ l - 1 ] != string [ h + 1 ] :\n            return False\n    return True"}
{"id": "CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS", "code": "def flipsPossible ( a , n ) :\n    count_odd = 0\n    count_even = 0\n    for i in range ( n ) :\n        if ( a [ i ] & 1 ) :\n            count_odd += 1\n        else :\n            count_even += 1\n    if ( count_odd % 2 and count_even % 2 ) :\n        return False\n    else :\n        return True"}
{"id": "CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE", "code": "def areConsecutive ( arr , n ) :\n    if ( n < 1 ) :\n        return False\n    Min = min ( arr )\n    Max = max ( arr )\n    if ( Max - Min + 1 == n ) :\n        visited = [ False for i in range ( n ) ]\n        for i in range ( n ) :\n            if ( visited [ arr [ i ] - Min ] != False ) :\n                return False\n            visited [ arr [ i ] - Min ] = True\n        return True\n    return False"}
{"id": "CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE", "code": "def canRepresentBST ( pre, n ) :\n    s = [ ]\n    root = -2147483648\n    for i in range(n) :\n        if pre[i] < root :\n            return False\n        while ( len ( s ) > 0 and s [ - 1 ] < pre[i] ) :\n            root = s.pop ( )\n        s.append ( pre[i] )\n    return True"}
{"id": "CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER", "code": "def isPower ( x , y ) :\n    if ( x == 1 ) :\n        return ( y == 1 )\n    pow = 1\n    while ( pow < y ) :\n        pow = pow * x\n    return ( pow == y )"}
{"id": "CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1", "code": "def isPower ( x , y ) :\n    res1 = int ( math.log ( y ) / math.log ( x ) )\n    res2 = math.log ( y ) / math.log ( x )\n    return 1 if ( res1 == res2 ) else 0"}
{"id": "CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBER_OF_CHARACTERS", "code": "def isPossible ( str , n ) :\n    l = len ( str )\n    if ( l >= n ) :\n        return True\n    return False"}
{"id": "CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE", "code": "def isChangeable ( notes , n ) :\n    fiveCount = 0\n    tenCount = 0\n    for i in range ( n ) :\n        if ( notes [ i ] == 5 ) :\n            fiveCount += 1\n        elif ( notes [ i ] == 10 ) :\n            if ( fiveCount > 0 ) :\n                fiveCount -= 1\n                tenCount += 1\n            else :\n                return 0\n        else :\n            if ( fiveCount > 0 and tenCount > 0 ) :\n                fiveCount -= 1\n                tenCount -= 1\n            elif ( fiveCount >= 3 ) :\n                fiveCount -= 3\n            else :\n                return 0\n    return 1"}
{"id": "CHECK_INTEGER_OVERFLOW_MULTIPLICATION", "code": "def isOverflow ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return False\n    result = a * b\n    if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) :\n        result = 0\n    if ( a == ( result // b ) ) :\n        return False\n    else :\n        return True"}
{"id": "CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT", "code": "def check ( str ) :\n    n = len ( str )\n    oddDigSum = 0\n    evenDigSum = 0\n    for i in range ( 0 , n ) :\n        if ( i % 2 == 0 ) :\n            oddDigSum = oddDigSum + ( ord ( str [ i ] ) - 48 )\n        else :\n            evenDigSum = evenDigSum + ( ord ( str [ i ] ) - 48 )\n    return ( ( oddDigSum - evenDigSum ) % 11 == 0 )"}
{"id": "CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT", "code": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num = str ( num ) + \"00\"\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    for i in range ( length - 1 , - 1 , - 3 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )"}
{"id": "CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT", "code": "def check ( str ) :\n    n = len ( str )\n    if ( n == 0 ) :\n        return False\n    if ( n == 1 ) :\n        return ( ( str [ 0 ] - '0' ) % 4 == 0 )\n    last = ( int ) ( str [ n - 1 ] )\n    second_last = ( int ) ( str [ n - 2 ] )\n    return ( ( second_last * 10 + last ) % 4 == 0 )"}
{"id": "CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT", "code": "def check ( str ) :\n    n = len ( str )\n    digitSum = 0\n    for i in range ( 0 , n ) :\n        digitSum = digitSum + ord ( str [ i ] ) - 48\n    return ( digitSum % 9 == 0 )"}
{"id": "CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION", "code": "def isPerfectSquare ( n ) :\n    i = 1\n    the_sum = 0\n    while the_sum < n :\n        the_sum += i\n        if the_sum == n :\n            return True\n        i += 2\n    return False"}
{"id": "CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER", "code": "def check ( s1 , s2 ) :\n    n = len ( s1 )\n    m = len ( s2 )\n    dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] )\n    dp [ 0 ] [ 0 ] = True\n    for i in range ( len ( s1 ) ) :\n        for j in range ( len ( s2 ) + 1 ) :\n            if ( dp [ i ] [ j ] ) :\n                if ( ( j < len ( s2 ) and ( s1 [ i ].upper ( ) == s2 [ j ] ) ) ) :\n                    dp [ i + 1 ] [ j + 1 ] = True\n                if ( s1 [ i ].isupper ( ) == False ) :\n                    dp [ i + 1 ] [ j ] = True\n    return ( dp [ n ] [ m ] )"}
{"id": "CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1", "code": "def checkReverse ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    for i in range ( 1 , n ) :\n        if arr [ i - 1 ] >= arr [ i ] :\n            break\n        else:\n            if ( i == n ) :\n                return True\n    j = i\n    i += 1\n    while ( arr [ j ] < arr [ j - 1 ] ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j += 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k += 1\n    return True"}
{"id": "CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES", "code": "def isRotated ( str1 , str2 ) :\n    if ( len ( str1 ) != len ( str2 ) ) :\n        return False\n    clock_rot = \"\"\n    anticlock_rot = \"\"\n    l = len ( str2 )\n    anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] )\n    clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ]\n    return ( str1 == clock_rot or str1 == anticlock_rot )"}
{"id": "CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT", "code": "def isAnBn ( s ) :\n    n = len ( s )\n    for i in range ( n ) :\n        if ( s [ i ] != 'a' ) :\n            break\n    if ( i * 2 != n ) :\n        return False\n    for j in range ( i , n ) :\n        if ( s [ j ] != 'b' ) :\n            return False\n    return True"}
{"id": "CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX", "code": "def areSumSame ( a , n , m ) :\n    sum1 = 0\n    sum2 = 0\n    for i in range ( 0 , n ) :\n        sum1 = 0\n        sum2 = 0\n        for j in range ( 0 , m ) :\n            sum1 += a [ i ] [ j ]\n            sum2 += a [ j ] [ i ]\n        if ( sum1 == sum2 ) :\n            return 1\n    return 0"}
{"id": "CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT", "code": "def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :\n    distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 )\n    radSumSq = ( r1 + r2 ) * ( r1 + r2 )\n    if ( distSq == radSumSq ) :\n        return 1\n    elif ( distSq > radSumSq ) :\n        return - 1\n    else :\n        return 0"}
{"id": "CHECK_VALID_SEQUENCE_DIVISIBLE_M_1", "code": "def isPossible ( n , index , modulo , M , arr , dp ) :\n    modulo = ( ( modulo % M ) + M ) % M\n    if ( index == n ) :\n        if ( modulo == 0 ) :\n            return 1\n        return 0\n    if ( dp [ index ] [ modulo ] != - 1 ) :\n        return dp [ index ] [ modulo ]\n    placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp )\n    placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp )\n    res = bool ( placeAdd or placeMinus )\n    dp [ index ] [ modulo ] = res\n    return res"}
{"id": "CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY", "code": "def checkIsAP ( arr , n ) :\n    if ( n == 1 ) : return True\n    arr.sort ( )\n    d = arr [ 1 ] - arr [ 0 ]\n    for i in range ( 2 , n ) :\n        if ( arr [ i ] - arr [ i - 1 ] != d ) :\n            return False\n    return True"}
{"id": "CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE", "code": "def check ( degree , n ) :\n    deg_sum = 0\n    for i in range(n):\n        deg_sum += degree[i]\n    if ( 2 * ( n - 1 ) == deg_sum ) :\n        return True\n    else :\n        return False"}
{"id": "CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD", "code": "def isEven ( n ) :\n    return ( n % 2 == 0 )"}
{"id": "CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1", "code": "def isEven ( n ) :\n    return ( not ( n & 1 ) )"}
{"id": "CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7", "code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if ( n % 3 == 1 ) :\n        num = str ( num ) + \"00\"\n        n += 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        n += 1\n    GSum = 0\n    p = 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n    return ( GSum % 7 == 0 )"}
{"id": "CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN", "code": "def checkValidity ( a , b , c ) :\n    if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) :\n        return False\n    else :\n        return True"}
{"id": "CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY", "code": "def spiralFill ( m , n , a ) :\n    val = 1\n    k , l = 0 , 0\n    while ( k < m and l < n ) :\n        for i in range ( l , n ) :\n            a [ k ] [ i ] = val\n            val += 1\n        k += 1\n        for i in range ( k , m ) :\n            a [ i ] [ n - 1 ] = val\n            val += 1\n        n -= 1\n        if ( k < m ) :\n            for i in range ( n - 1 , l - 1 , - 1 ) :\n                a [ m - 1 ] [ i ] = val\n                val += 1\n            m -= 1\n        if ( l < n ) :\n            for i in range ( m - 1 , k - 1 , - 1 ) :\n                a [ i ] [ l ] = val\n                val += 1\n            l += 1"}
{"id": "COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW", "code": "def compute_average ( a , b ) :\n    return floor ( ( a + b ) / 2 )"}
{"id": "COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER", "code": "def getModulo ( n , d ) :\n    return ( n & ( d - 1 ) )"}
{"id": "COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION", "code": "def nCrModp ( n , r , p ) :\n    C = [ 0 for i in range ( r + 1 ) ]\n    C [ 0 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( min ( i , r ) , 0 , - 1 ) :\n            C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p\n    return C [ r ]"}
{"id": "CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME", "code": "def constructPalin ( str , len ) :\n    str = list ( str )\n    i = - 1\n    j = len\n    while i < j :\n        i += 1\n        j -= 1\n        if ( str [ i ] == str [ j ] and str [ i ] != '*' ) :\n            continue\n        elif ( str [ i ] == str [ j ] and str [ i ] == '*' ) :\n            str [ i ] = 'a'\n            str [ j ] = 'a'\n            continue\n        elif str [ i ] == '*' :\n            str [ i ] = str [ j ]\n            continue\n        elif str [ j ] == '*' :\n            str [ j ] = str [ i ]\n            continue\n        print ( \"Not Possible\" )\n        return \"\"\n    return ''.join ( str )"}
{"id": "CONVERT_DECIMAL_FRACTION_BINARY_NUMBER", "code": "def decimalToBinary ( num , k_prec ) :\n    binary = \"\"\n    Integral = int ( num )\n    fractional = num - Integral\n    while ( Integral > 0 ) :\n        rem = Integral % 2\n        binary += str ( rem )\n        Integral //= 2\n    binary = binary [ : : - 1 ]\n    binary += '.'\n    while ( k_prec > 0 ) :\n        fractional *= 2\n        fract_bit = int ( fractional )\n        if ( fract_bit == 1 ) :\n            fractional -= fract_bit\n            binary += '1'\n        else :\n            binary += '0'\n        k_prec -= 1\n    return binary"}
{"id": "CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES", "code": "def minRemove ( arr , n ) :\n    LIS = [ 0 for i in range ( n ) ]\n    len = 0\n    for i in range ( n ) :\n        LIS [ i ] = 1\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) :\n                LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 )\n        len = max ( len , LIS [ i ] )\n    return ( n - len )"}
{"id": "COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1", "code": "def numberOfWays ( x ) :\n    dp = [ 0 for _ in range (x + 1)]\n    dp[0] = dp[1] = 1\n    for i in range(2, x + 1):\n        dp[i] = dp[i - 1] + (i - 1) * dp[i - 2]\n    return dp[x]"}
{"id": "COUNT_1S_SORTED_BINARY_ARRAY", "code": "def countOnes ( arr , low , high ) :\n    if high >= low :\n        mid = int ( low + ( high - low ) / 2 )\n        if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) :\n            return mid + 1\n        if arr [ mid ] == 1 :\n            return countOnes ( arr , ( mid + 1 ) , high )\n        return countOnes ( arr , low , mid - 1 )\n    return 0"}
{"id": "COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES", "code": "def countarray ( n , k , x ) :\n    dp = list ( )\n    dp.append ( 0 )\n    dp.append ( 1 )\n    i = 2\n    while i < n :\n        dp.append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] )\n        i = i + 1\n    return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] )"}
{"id": "COUNT_BALANCED_BINARY_TREES_HEIGHT_H", "code": "def countBT ( h ) :\n    MOD = 1000000007\n    dp = [ 0 for i in range ( h + 1 ) ]\n    dp [ 0 ] = 1\n    dp [ 1 ] = 1\n    for i in range ( 2 , h + 1 ) :\n        dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD\n    return dp [ h ]"}
{"id": "COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N", "code": "def countOfBinaryNumberLessThanN ( N ) :\n    q = collections . deque ( )\n    q.append ( 1 )\n    cnt = 0\n    while ( q ) :\n        t = q.popleft ( )\n        if ( t <= N ) :\n            cnt = cnt + 1\n            q.append ( t * 10 )\n            q.append ( t * 10 + 1 )\n    return cnt"}
{"id": "COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS", "code": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( k + 1 ) :\n            if j >= i:\n                break\n            else:\n                dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n                dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n                if j >= 1 :\n                    dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]"}
{"id": "COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS", "code": "def countPairs ( str ) :\n    result = 0 ;\n    n = len ( str )\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if ( abs ( ord ( str [ i ] ) - ord ( str [ j ] ) ) == abs ( i - j ) ) :\n                result += 1 ;\n    return result ;"}
{"id": "COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1", "code": "def countDer ( n ) :\n    der = [ 0 for i in range ( n + 1 ) ]\n    der [ 0 ] = 1\n    der [ 1 ] = 0\n    der [ 2 ] = 1\n    for i in range ( 3 , n + 1 ) :\n        der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] )\n    return der [ n ]"}
{"id": "COUNT_DIGITS_FACTORIAL_SET_1", "code": "def findDigits ( n ) :\n    if ( n < 0 ) :\n        return 0\n    if ( n <= 1 ) :\n        return 1\n    digits = 0\n    for i in range ( 2 , n + 1 ) :\n        digits += math.log10 ( i )\n    return math.floor ( digits ) + 1"}
{"id": "COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2", "code": "def countSolutions ( n ) :\n    res = 0\n    x = 0\n    while ( x * x < n ) :\n        y = 0\n        while ( x * x + y * y < n ) :\n            res = res + 1\n            y = y + 1\n        x = x + 1\n    return res"}
{"id": "COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2_1", "code": "def countSolutions ( n ) :\n    x = 0\n    res = 0\n    yCount = 0\n    while ( yCount * yCount < n ) :\n        yCount = yCount + 1\n    while ( yCount != 0 ) :\n        res = res + yCount\n        x = x + 1\n        while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) :\n            yCount = yCount - 1\n    return res"}
{"id": "COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE", "code": "def findSubsequenceCount ( S , T ) :\n    m = len ( T )\n    n = len ( S )\n    if m > n :\n        return 0\n    mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ]\n    for i in range ( 1 , m + 1 ) :\n        mat [ i ] [ 0 ] = 0\n    for j in range ( n + 1 ) :\n        mat [ 0 ] [ j ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if T [ i - 1 ] != S [ j - 1 ] :\n                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]\n            else :\n                mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] )\n    return mat [ m ] [ n ]"}
{"id": "COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX", "code": "def count ( n , x ) :\n    cnt = 0\n    for i in range ( 1 , n + 1 ) :\n        if i <= x :\n            if x // i <= n and x % i == 0 :\n                cnt += 1\n    return cnt"}
{"id": "COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1", "code": "def countSeq ( n ) :\n    nCr = 1\n    res = 1\n    for r in range ( 1 , n + 1 ) :\n        nCr = int ( ( nCr * ( n + 1 - r ) ) / r )\n        res += nCr * nCr \n    return res "}
{"id": "COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ", "code": "def find ( n , k ) :\n    if ( n + 1 >= k ) :\n        return ( k - 1 )\n    else :\n        return ( 2 * n + 1 - k )"}
{"id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY", "code": "def countPairs ( arr , n ) :\n    ans = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] == arr [ j ] ) :\n                ans += 1\n    return ans"}
{"id": "COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1", "code": "def countPairs ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        if arr [ i ] in mp.keys ( ) :\n            mp [ arr [ i ] ] += 1\n        else :\n            mp [ arr [ i ] ] = 1\n    ans = 0\n    for it in mp :\n        count = mp [ it ]\n        ans += ( count * ( count - 1 ) ) // 2\n    return ans"}
{"id": "COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1", "code": "def getInvCount ( arr , n ) :\n    invcount = 0\n    for i in range ( 1 , n - 1 ) :\n        small = 0\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] > arr [ j ] ) :\n                small += 1\n        great = 0\n        for j in range ( i - 1 , - 1 , - 1 ) :\n            if ( arr [ i ] < arr [ j ] ) :\n                great += 1\n        invcount += great * small\n    return invcount"}
{"id": "COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS", "code": "def numofsubset ( arr , n ) :\n    x = sorted ( arr )\n    count = 1\n    for i in range ( 0 , n - 1 ) :\n        if ( x [ i ] + 1 != x [ i + 1 ] ) :\n            count = count + 1\n    return count"}
{"id": "COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER", "code": "def countNumber ( n ) :\n    result = 0\n    for i in range ( 1 , 10 ) :\n        s = [ ]\n        if ( i <= n ) :\n            s.append ( i )\n            result += 1\n        while len ( s ) != 0 :\n            tp = s [ - 1 ]\n            s.pop ( )\n            for j in range ( tp % 10 , 10 ) :\n                x = tp * 10 + j\n                if ( x <= n ) :\n                    s.append ( x )\n                    result += 1\n    return result"}
{"id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX", "code": "def countNegative ( M , n , m ) :\n    count = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if M [ i ] [ j ] < 0 :\n                count += 1\n            else :\n                break\n    return count"}
{"id": "COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1", "code": "def countNegative ( M , n , m ) :\n    count = 0\n    i = 0\n    j = m - 1\n    while j >= 0 and i < n :\n        if M [ i ] [ j ] < 0 :\n            count += ( j + 1 )\n            i += 1\n        else :\n            j -= 1\n    return count"}
{"id": "COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS", "code": "def countNums ( n , x , y ) :\n    arr = [ False for i in range ( n + 2 ) ]\n    if ( x <= n ) :\n        arr [ x ] = True\n    if ( y <= n ) :\n        arr [ y ] = True\n    result = 0\n    for i in range ( min ( x , y ) , n + 1 ) :\n        if ( arr [ i ] ) :\n            if ( i + x <= n ) :\n                arr [ i + x ] = True\n            if ( i + y <= n ) :\n                arr [ i + y ] = True\n            result = result + 1\n    return result"}
{"id": "COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S", "code": "def countStrings ( n ) :\n    a = [ 0 for i in range ( n ) ]\n    b = [ 0 for i in range ( n ) ]\n    a [ 0 ] = b [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        a [ i ] = a [ i - 1 ] + b [ i - 1 ]\n        b [ i ] = a [ i - 1 ]\n    return a [ n - 1 ] + b [ n - 1 ]"}
{"id": "COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K", "code": "def numOfIncSubseqOfSizeK ( arr , n , k ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ]\n    for i in range ( n ) :\n        dp [ 0 ] [ i ] = 1\n    for l in range ( 1 , k ) :\n        for i in range ( l , n ) :\n            dp [ l ] [ i ] = 0\n            for j in range ( l - 1 , i ) :\n                if ( arr [ j ] < arr [ i ] ) :\n                    dp [ l ] [ i ] += dp [ l - 1 ] [ j ]\n    Sum = 0\n    for i in range ( k - 1 , n ) :\n        Sum += dp [ k - 1 ] [ i ]\n    return Sum"}
{"id": "COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY", "code": "def countOccurrences ( arr , n , x ) :\n    res = 0\n    for i in range ( n ) :\n        if x == arr [ i ] :\n            res += 1\n    return res"}
{"id": "COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION", "code": "def possibleStrings ( n , r , b , g ) :\n    fact = [ 0 for i in range ( n + 1 ) ]\n    fact [ 0 ] = 1\n    for i in range ( 1 , n + 1 , 1 ) :\n        fact [ i ] = fact [ i - 1 ] + i\n    left = n - ( r + g + b )\n    sum = 0\n    for i in range ( 0 , left + 1 , 1 ) :\n        for j in range ( 0 , left - i + 1 , 1 ) :\n            k = left - ( i + j )\n            sum = int ( sum + fact [ n ] / ( fact [ i + r ] + fact [ j + b ] + fact [ k + g ] ) )\n    return sum"}
{"id": "COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1", "code": "def countP ( n , k ) :\n    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        dp [ i ] [ 0 ] = 0\n    for i in range ( k + 1 ) :\n        dp [ 0 ] [ k ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , k + 1 ) :\n            if ( j == 1 or i == j ) :\n                dp [ i ] [ j ] = 1\n            else :\n                dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] )\n    return dp [ n ] [ k ]"}
{"id": "COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B", "code": "def CountPairs ( n ) :\n    k = n\n    imin = 1\n    ans = 0\n    while ( imin <= n ) :\n        imax = int ( n / k )\n        ans += k * ( imax - imin + 1 )\n        imin = imax + 1\n        k = int ( n / imin )\n    return ans"}
{"id": "COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME", "code": "def count ( n ) :\n    table = [ 0 for i in range ( n + 1 ) ]\n    table [ 0 ] = 1\n    for i in range ( 3 , n + 1 ) :\n        table [ i ] += table [ i - 3 ]\n    for i in range ( 5 , n + 1 ) :\n        table [ i ] += table [ i - 5 ]\n    for i in range ( 10 , n + 1 ) :\n        table [ i ] += table [ i - 10 ]\n    return table [ n ]"}
{"id": "COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES", "code": "def countWays ( n , m ) :\n    count = [ ]\n    for i in range ( n + 2 ) :\n        count.append ( 0 )\n    count [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        if ( i > m ) :\n            count [ i ] = count [ i - 1 ] + count [ i - m ]\n        elif ( i < m ) :\n            count [ i ] = 1\n        else :\n            count [ i ] = 2\n    return count [ n ]"}
{"id": "COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_FROM_THE_SET_A_B_C_AT_THE_SAME_TIME", "code": "def CountSubString ( str , n ) :\n    ans = ( n * ( n + 1 ) ) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    for i in range ( n ) :\n        if ( str [ i ] == 'a' ) :\n            a_index = i + 1\n            ans -= min ( b_index , c_index )\n        elif ( str [ i ] == 'b' ) :\n            b_index = i + 1\n            ans -= min ( a_index , c_index )\n        else :\n            c_index = i + 1\n            ans -= min ( a_index , b_index )\n    return ans"}
{"id": "COUNT_OPERATIONS_MAKE_STRINGAB_FREE", "code": "def abFree ( s ) :\n    b_count = 0\n    res = 0\n    for i in range ( len ( s ) ) :\n        if s [ ~ i ] == 'a' :\n            res = ( res + b_count )\n            b_count = ( b_count * 2 )\n        else :\n            b_count += 1\n    return res"}
{"id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K", "code": "def countPairsWithDiffK ( arr , n , k ) :\n    count = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k :\n                count += 1\n    return count"}
{"id": "COUNT_PAIRS_DIFFERENCE_EQUAL_K_1", "code": "def countPairsWithDiffK ( arr , n , k ) :\n    count = 0\n    arr.sort ( )\n    l = 0\n    r = 0\n    while r < n :\n        if arr [ r ] - arr [ l ] == k :\n            count += 1\n            l += 1\n            r += 1\n        elif arr [ r ] - arr [ l ] > k :\n            l += 1\n        else :\n            r += 1\n    return count"}
{"id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X", "code": "def countPairs ( arr1 , arr2 , m , n , x ) :\n    count = 0\n    for i in range ( m ) :\n        for j in range ( n ) :\n            if arr1 [ i ] + arr2 [ j ] == x :\n                count = count + 1\n    return count"}
{"id": "COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1", "code": "def countPairs ( arr1 , arr2 , m , n , x ) :\n    count = 0\n    us = set ( )\n    for i in range ( m ) :\n        us.add ( arr1 [ i ] )\n    for j in range ( n ) :\n        if x - arr2 [ j ] in us :\n            count += 1\n    return count"}
{"id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY", "code": "def countPairs ( arr , n ) :\n    result = 0 ;\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            product = arr [ i ] * arr [ j ] ;\n            for k in range ( 0 , n ) :\n                if ( arr [ k ] == product ) :\n                    result = result + 1 ;\n                    break ;\n    return result ;"}
{"id": "COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1", "code": "def countPairs ( arr , n ) :\n    result = 0\n    Hash = set ( )\n    for i in range ( n ) :\n        Hash.add ( arr [ i ] )\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            product = arr [ i ] * arr [ j ]\n            if product in ( Hash ) :\n                result += 1\n    return result"}
{"id": "COUNT_PALINDROME_SUB_STRINGS_STRING", "code": "def CountPS ( str , n ) :\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n    for i in range ( n - 1 ) :\n        if ( str [ i ] == str [ i + 1 ] ) :\n            P [ i ] [ i + 1 ] = True\n            dp [ i ] [ i + 1 ] = 1\n    for gap in range ( 2 , n ) :\n        for i in range ( n - gap ) :\n            j = gap + i ;\n            if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) :\n                P [ i ] [ j ] = True\n            if ( P [ i ] [ j ] == True ) :\n                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] )\n            else :\n                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] )\n    return dp [ 0 ] [ n - 1 ]"}
{"id": "COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING", "code": "def countPS ( str ) :\n    N = len ( str )\n    cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ]\n    for i in range ( N ) :\n        cps [ i ] [ i ] = 1\n    for L in range ( 2 , N + 1 ) :\n        for i in range ( N ) :\n            k = L + i - 1\n            if ( k < N ) :\n                if ( str [ i ] == str [ k ] ) :\n                    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 )\n                else :\n                    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] )\n    return cps [ 0 ] [ N - 1 ]"}
{"id": "COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1", "code": "def countDecodingDP ( digits , n ) :\n    count = [ 0 ] * ( n + 1 )\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == '0' :\n        return 0\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > '0' ) :\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :\n            count [ i ] += count [ i - 2 ]\n    return count [ n ]"}
{"id": "COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3", "code": "def findgroups ( arr , n ) :\n    c = [ 0 , 0 , 0 ]\n    res = 0\n    for i in range ( 0 , n ) :\n        c [ arr [ i ] % 3 ] += 1\n    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )\n    res += c [ 1 ] * c [ 2 ]\n    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6\n    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6\n    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 )\n    res += c [ 0 ] * c [ 1 ] * c [ 2 ]\n    return res"}
{"id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1", "code": "def numberOfPaths ( m , n ) :\n    count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ]\n    for i in range ( m ) :\n        count [ i ] [ 0 ] = 1 ;\n    for j in range ( n ) :\n        count [ 0 ] [ j ] = 1 ;\n    for i in range ( 1 , m ) :\n        for j in range ( n ) :\n            count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ]\n    return count [ m - 1 ] [ n - 1 ]"}
{"id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2", "code": "def numberOfPaths ( m , n ) :\n    dp = [ 0 for i in range ( n ) ]\n    dp[0]=1\n    for i in range ( m  ) :\n        for j in range ( 1 , n ) :\n            dp [ j ] += dp [ j - 1 ]\n    return dp [ n - 1 ]"}
{"id": "COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3", "code": "def numberOfPaths ( m , n ) :\n    for i in range ( n , ( m + n - 1 ) ) :\n        path *= i\n        path //= ( i - n + 1 )\n    return path"}
{"id": "COUNT_ROTATIONS_DIVISIBLE_4", "code": "def countRotations ( n ) :\n    l = len ( n )\n    if ( l == 1 ) :\n        oneDigit = ( int ) ( n [ 0 ] )\n        if ( oneDigit % 4 == 0 ) :\n            return 1\n        return 0\n    count = 0\n    for i in range ( 0 , l - 1 ) :\n        twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] )\n        if ( twoDigit % 4 == 0 ) :\n            count = count + 1\n    twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] )\n    if ( twoDigit % 4 == 0 ) :\n        count = count + 1\n    return count"}
{"id": "COUNT_ROTATIONS_DIVISIBLE_8", "code": "def countRotationsDivBy8 ( n ) :\n    l = len ( n )\n    count = 0\n    if ( l == 1 ) :\n        oneDigit = int ( n [ 0 ] )\n        if ( oneDigit % 8 == 0 ) :\n            return 1\n        return 0\n    if ( l == 2 ) :\n        first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] )\n        second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] )\n        if ( first % 8 == 0 ) :\n            count += 1\n        if ( second % 8 == 0 ) :\n            count += 1\n        return count\n    threeDigit = 0\n    for i in range ( 0 , ( l - 2 ) ) :\n        threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) )\n        if ( threeDigit % 8 == 0 ) :\n            count += 1\n    threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) )\n    if ( threeDigit % 8 == 0 ) :\n        count += 1\n    threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) )\n    if ( threeDigit % 8 == 0 ) :\n        count += 1\n    return count"}
{"id": "COUNT_SET_BITS_IN_AN_INTEGER_1", "code": "def countSetBits ( n ) :\n    if ( n == 0 ) :\n        return 0\n    else :\n        return ( n & 1 ) + countSetBits ( n >> 1 )"}
{"id": "COUNT_SET_BITS_IN_AN_INTEGER_2", "code": "def countSetBits ( n ) :\n    count = 0\n    while ( n ) :\n        n &= ( n - 1 )\n        count += 1\n    return count"}
{"id": "COUNT_SET_BITS_IN_AN_INTEGER_3", "code": "def countSetBits ( n ) :\n    if ( n == 0 ) :\n        return 0\n    else :\n        return 1 + countSetBits ( n & ( n - 1 ) )"}
{"id": "COUNT_SORTED_ROWS_MATRIX", "code": "def sortedCount ( mat , r , c ) :\n    result = 0\n    for i in range ( r ) :\n        j = 0\n        for j in range ( c - 1 ) :\n            if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :\n                break\n        if j == c - 2 :\n            result += 1\n    for i in range ( 0 , r ) :\n        j = 0\n        for j in range ( c - 1 , 0 , - 1 ) :\n            if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :\n                break\n        if c > 1 and j == 1 :\n            result += 1\n    return result"}
{"id": "COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1", "code": "def countStr ( n ) :\n    return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) )"}
{"id": "COUNT_STRINGS_WITH_CONSECUTIVE_1S", "code": "def countStrings ( n ) :\n    a = [ 0 ] * n\n    b = [ 0 ] * n\n    a [ 0 ] = b [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        a [ i ] = a [ i - 1 ] + b [ i - 1 ]\n        b [ i ] = a [ i - 1 ]\n    return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]"}
{"id": "COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS", "code": "def countSubarrays ( arr , n ) :\n    difference = 0\n    ans = 0\n    hash_positive = [ 0 ] * ( n + 1 )\n    hash_negative = [ 0 ] * ( n + 1 )\n    hash_positive [ 0 ] = 1\n    for i in range ( n ) :\n        if ( arr [ i ] & 1 == 1 ) :\n            difference = difference + 1\n        else :\n            difference = difference - 1\n        if ( difference < 0 ) :\n            ans += hash_negative [ - difference ]\n            hash_negative [ - difference ] = hash_negative [ - difference ] + 1\n        else :\n            ans += hash_positive [ difference ]\n            hash_positive [ difference ] = hash_positive [ difference ] + 1\n    return ans"}
{"id": "COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS", "code": "def countSubstringWithEqualEnds ( s ) :\n    result = 0\n    n = len ( s )\n    for i in range ( n ) :\n        for j in range ( i , n ) :\n            if ( s [ i ] == s [ j ] ) :\n                result = result + 1\n    return result"}
{"id": "COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N", "code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1 << i\n        for j in range ( 0 , n + 1 ) :\n            ans += k\n            if change == 1 :\n                k = not k\n                change = 1 << i\n            else :\n                change -= 1\n        i += 1\n    return ans"}
{"id": "COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER", "code": "def findTrailingZeros ( n ) :\n    count = 0\n    i = 5\n    while ( n / i >= 1 ) :\n        count += int ( n / i )\n        i *= 5\n    return int ( count )"}
{"id": "COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS", "code": "def countWays ( n ) :\n    dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ]\n    dp [ 0 ] [ 1 ] = 1\n    dp [ 1 ] [ 1 ] = 2\n    for i in range ( 2 , n + 1 ) :\n        dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]\n        dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] )\n    return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]"}
{"id": "COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS", "code": "def chordCnt ( A ) :\n    n = 2 * A\n    dpArray = [ 0 ] * ( n + 1 )\n    dpArray [ 0 ] = 1\n    dpArray [ 2 ] = 1\n    for i in range ( 4 , n + 1 , 2 ) :\n        for j in range ( 0 , i - 1 , 2 ) :\n            dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] )\n    return int ( dpArray [ n ] )"}
{"id": "COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS", "code": "def countWords ( str , n ) :\n    m = dict ( )\n    for i in range ( n ) :\n        m [ str [ i ] ] = m.get ( str [ i ] , 0 ) + 1\n    res = 0\n    for i in m.values ( ) :\n        if i == 2 :\n            res += 1\n    return res"}
{"id": "COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD", "code": "def countWords ( str , len ) :\n    count = 1 ;\n    if ( len == 1 ) :\n        return count\n    if ( str [ 0 ] == str [ 1 ] ) :\n        count *= 1\n    else :\n        count *= 2\n    for j in range ( 1 , len - 1 ) :\n        if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) :\n            count *= 1\n        elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :\n            count *= 2\n        else :\n            count *= 3\n    if ( str [ len - 1 ] == str [ len - 2 ] ) :\n        count *= 1\n    else :\n        count *= 2\n    return count"}
{"id": "C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES", "code": "def repeat ( s , n ) :\n    s1 = s\n    for i in range ( 1 , n ) :\n        s += s1\n    return s"}
{"id": "C_PROGRAM_FACTORIAL_NUMBER", "code": "def factorial ( n ) :\n    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )"}
{"id": "C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1", "code": "def largest ( arr , n ) :\n    return sorted(arr[:n], reverse=False)[n-1]"}
{"id": "C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER", "code": "def getSecondMostFreq ( str ) :\n    NO_OF_CHARS = 256\n    count = [ 0 ] * NO_OF_CHARS\n    for i in range ( len ( str ) ) :\n        count [ ord ( str [ i ] ) ] += 1\n    first , second = 0 , 0\n    for i in range ( NO_OF_CHARS ) :\n        if count [ i ] > count [ first ] :\n            second = first\n            first = i\n        elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :\n            second = i\n    return chr ( second )"}
{"id": "DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS", "code": "def decToBin ( n ) :\n    if ( n == 0 ) :\n        return \"0\"\n    bin = \"\"\n    while ( n > 0 ) :\n        if ( n & 1 == 0 ) :\n            bin = '0' + bin\n        else :\n            bin = '1' + bin\n        n = n >> 1\n    return bin"}
{"id": "DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING", "code": "def decode ( Str ) :\n    integerstack = [ ]\n    stringstack = [ ]\n    temp = \"\"\n    result = \"\"\n    for i in range ( len ( Str ) ) :\n        count = 0\n        if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n            while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :\n                count = count * 10 + ord ( Str [ i ] ) - ord ( '0' )\n                i += 1\n            i -= 1\n            integerstack.append ( count )\n        elif ( Str [ i ] == ']' ) :\n            temp = \"\"\n            count = 0\n            if ( len ( integerstack ) != 0 ) :\n                count = integerstack [ - 1 ]\n                integerstack.pop ( )\n            while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != '[' ) :\n                temp = stringstack [ - 1 ] + temp\n                stringstack.pop ( )\n            if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == '[' ) :\n                stringstack.pop ( )\n            for j in range ( count ) :\n                result = result + temp\n            for j in range ( len ( result ) ) :\n                stringstack.append ( result [ j ] )\n            result = \"\"\n        elif ( Str [ i ] == '[' ) :\n            if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) :\n                stringstack.append ( Str [ i ] )\n            else :\n                stringstack.append ( Str [ i ] )\n                integerstack.append ( 1 )\n        else :\n            stringstack.append ( Str [ i ] )\n    while len ( stringstack ) != 0 :\n        result = stringstack [ - 1 ] + result\n        stringstack.pop ( )\n    return result"}
{"id": "DELANNOY_NUMBER_1", "code": "def dealnnoy ( n , m ) :\n    dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ]\n    for i in range ( m + 1 ) :\n        dp [ 0 ] [ i ] = 1\n    for i in range ( m + 1 ) :\n        dp [ i ] [ 0 ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ]\n    return dp [ m ] [ n ]"}
{"id": "DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS", "code": "def oppositeSigns ( x , y ) :\n    return ( ( x ^ y ) < 0 )"}
{"id": "DIAGONALLY_DOMINANT_MATRIX", "code": "def isDDM ( m , n ) :\n    for i in range ( 0 , n ) :\n        sum = 0\n        for j in range ( 0 , n ) :\n            sum = sum + abs ( m [ i ] [ j ] )\n        sum = sum - abs ( m [ i ] [ i ] )\n        if ( abs ( m [ i ] [ i ] ) < sum ) :\n            return False\n    return True"}
{"id": "DICE_THROW_PROBLEM", "code": "def findWays ( m , n , x ) :\n    table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ]\n    for j in range ( 1 , min ( m + 1 , x + 1 ) ) :\n        table [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 1 , x + 1 ) :\n            for k in range ( 1 , min ( m + 1 , j ) ) :\n                table [ i ] [ j ] += table [ i - 1 ] [ j - k ]\n    return table [ - 1 ] [ - 1 ]"}
{"id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY", "code": "def findDiff ( arr , n ) :\n    arr.sort ( )\n    count = 0\n    max_count = 0\n    min_count = n\n    for i in range ( 0 , ( n - 1 ) ) :\n        if arr [ i ] == arr [ i + 1 ] :\n            count += 1\n            continue\n        else :\n            max_count = max ( max_count , count )\n            min_count = min ( min_count , count )\n            count = 0\n    return max_count - min_count"}
{"id": "DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_1", "code": "def findDiff ( arr , n ) :\n    mp = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] += 1\n    max_count = 0\n    min_count = n\n    for key , values in mp.items ( ) :\n        max_count = max ( max_count , values )\n        min_count = min ( min_count , values )\n    return max_count - min_count"}
{"id": "DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M", "code": "def numberofways ( n , m ) :\n    dp = np.zeros ( ( n + 2 , n + 2 ) )\n    dp [ 0 ] [ n + 1 ] = 1\n    for k in range ( n , m - 1 , - 1 ) :\n        for i in range ( n + 1 ) :\n            dp [ i ] [ k ] = dp [ i ] [ k + 1 ]\n            if ( i - k >= 0 ) :\n                dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] )\n    return dp [ n ] [ m ]"}
{"id": "DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B", "code": "def discreteLogarithm ( a , b , m ) :\n    n = int ( math.sqrt ( m ) + 1 )\n    an = 1\n    for i in range ( n ) :\n        an = ( an * a ) % m\n    value = [ 0 ] * m\n    cur = an\n    for i in range ( 1 , n + 1 ) :\n        if ( value [ cur ] == 0 ) :\n            value [ cur ] = i\n        cur = ( cur * an ) % m\n    cur = b\n    for i in range ( n + 1 ) :\n        if ( value [ cur ] > 0 ) :\n            ans = value [ cur ] * n - i\n            if ( ans < m ) :\n                return ans\n        cur = ( cur * a ) % m\n    return - 1"}
{"id": "DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1", "code": "def checkCount ( arr , n , k ) :\n    mp = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] += 1\n    for key , values in mp.items ( ) :\n        if values > 2 * k :\n            return False\n    return True"}
{"id": "DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION", "code": "def lastPosition ( n , m , k ) :\n    if ( m <= n - k + 1 ) :\n        return m + k - 1\n    m = m - ( n - k + 1 )\n    if ( m % n == 0 ) :\n        return n\n    else :\n        return m % n"}
{"id": "DIVIDE_LARGE_NUMBER_REPRESENTED_STRING", "code": "def longDivision ( number , divisor ) :\n    ans = \"\"\n    idx = 0\n    temp = ord ( number [ idx ] ) - ord ( '0' )\n    while ( temp < divisor ) :\n        temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) )\n        idx += 1\n    while ( ( len ( number ) ) > idx ) :\n        ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) )\n        temp = ( ( temp % divisor ) * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) )\n        idx += 1\n    ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) )\n    if ( len ( ans ) == 0 ) :\n        return \"0\"\n    return ans"}
{"id": "DIVISIBILITY_9_USING_BITWISE_OPERATORS", "code": "def isDivBy9 ( n ) :\n    if ( n == 0 or n == 9 ) :\n        return True\n    if ( n < 9 ) :\n        return False\n    return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )"}
{"id": "DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER", "code": "def isDvisibleBy12 ( num ) :\n    if ( len ( num ) >= 3 ) :\n        d1 = int ( num [ len ( num ) - 1 ] )\n        if ( d1 % 2 != 0 ) :\n            return False\n        d2 = int ( num [ len ( num ) - 2 ] )\n        sum = 0\n        for i in range ( 0 , len ( num ) ) :\n            sum += int ( num [ i ] )\n        return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )\n    else :\n        number = int ( num )\n        return ( number % 12 == 0 )"}
{"id": "DIVISIBILITY_BY_7", "code": "def isDivisibleBy7 ( num ) :\n    if num < 0 :\n        return isDivisibleBy7 ( - num )\n    if ( num == 0 or num == 7 ) :\n        return True\n    if ( num < 10 ) :\n        return False\n    return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) )"}
{"id": "DOUBLE_FACTORIAL_1", "code": "def doublefactorial ( n ) :\n    res = 1\n    for i in range ( n , - 1 , - 2 ) :\n        if ( i == 0 or i == 1 ) :\n            return res\n        else :\n            res *= i\n    return res;"}
{"id": "DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM", "code": "def maxTasks ( high , low , n ) :\n    if ( n <= 0 ) :\n        return 0\n    return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) )"}
{"id": "DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM", "code": "def knapSack ( W , wt , val , n ) :\n    if n == 0 or W == 0 :\n        return 0\n    if ( wt [ n - 1 ] > W ) :\n        return knapSack ( W , wt , val , n - 1 )\n    else :\n        return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )"}
{"id": "DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1", "code": "def eggDrop ( n , k ) :\n    eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        eggFloor [ i ] [ 1 ] = 1\n        eggFloor [ i ] [ 0 ] = 0\n    for j in range ( 1 , k + 1 ) :\n        eggFloor [ 1 ] [ j ] = j\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 2 , k + 1 ) :\n            eggFloor [ i ] [ j ] = INT_MAX\n            for x in range ( 1 , j + 1 ) :\n                res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] )\n                if res < eggFloor [ i ] [ j ] :\n                    eggFloor [ i ] [ j ] = res\n    return eggFloor [ n ] [ k ]"}
{"id": "DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE", "code": "def lps ( seq ) :\n    n = len ( seq )\n    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]\n    for i in range ( n ) :\n        L [ i ] [ i ] = 1\n    for cl in range ( 2 , n + 1 ) :\n        for i in range ( n - cl + 1 ) :\n            j = i + cl - 1\n            if seq [ i ] == seq [ j ] and cl == 2 :\n                L [ i ] [ j ] = 2\n            elif seq [ i ] == seq [ j ] :\n                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2\n            else :\n                L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;\n    return L [ 0 ] [ n - 1 ]"}
{"id": "DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE", "code": "def maxSumIS ( arr , n ) :\n    max = 0\n    msis = [ 0 for x in range ( n ) ]\n    for i in range ( n ) :\n        msis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :\n                msis [ i ] = msis [ j ] + arr [ i ]\n    for i in range ( n ) :\n        if max < msis [ i ] :\n            max = msis [ i ]\n    return max"}
{"id": "DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE", "code": "def lbs ( arr , n ) :\n    lis = [ 1 for i in range ( n + 1 ) ]\n    for i in range ( 1 , n ) :\n        for j in range ( 0 , i ) :\n            if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) :\n                lis [ i ] = lis [ j ] + 1\n    lds = [ 1 for i in range ( n + 1 ) ]\n    for i in reversed ( range ( n - 1 ) ) :\n        for j in reversed ( range ( i - 1 , n ) ) :\n            if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) :\n                lds [ i ] = lds [ j ] + 1\n    maximum = lis [ 0 ] + lds [ 0 ] - 1\n    for i in range ( 1 , n ) :\n        maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum )\n    return maximum"}
{"id": "DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING", "code": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = 0\n    k = 0\n    L = 0\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = 0\n    for L in range ( 2 , n + 1 ) :\n        for i in range ( n - L + 1 ) :\n            j = i + L - 1\n            if L == 2 :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            else :\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )\n            if P [ i ] [ j ] == True :\n                C [ i ] [ j ] = 0\n            else :\n                C [ i ] [ j ] = 100000000\n                for k in range ( i , j ) :\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n    return C [ 0 ] [ n - 1 ]"}
{"id": "DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME", "code": "def findMinInsertions ( str , l , h ) :\n    if ( l > h ) :\n        return sys.maxsize\n    if ( l == h ) :\n        return 0\n    if ( l == h - 1 ) :\n        return 0 if ( str [ l ] == str [ h ] ) else 1\n    if ( str [ l ] == str [ h ] ) :\n        return findMinInsertions ( str , l + 1 , h - 1 )\n    else :\n        return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )"}
{"id": "DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1", "code": "def maxProd ( n ) :\n    if ( n == 2 or n == 3 ) :\n        return ( n - 1 )\n    res = 1\n    while ( n > 4 ) :\n        n -= 3\n        res *= 3\n    return ( n * res )"}
{"id": "DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM", "code": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if symb [ i ] == 'F' :\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == 'T' :\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n    for gap in range ( 1 , n ) :\n        i = 0\n        for j in range ( gap , n ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n            i += 1\n    return T [ 0 ] [ n - 1 ]"}
{"id": "DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1", "code": "def lis ( arr , n) :\n    lis = [ 1 ] * n\n    for i in range ( 1 , n ) :\n        for j in range ( 0 , i ) :\n            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :\n                lis [ i ] = lis [ j ] + 1\n    maximum = 0\n    for i in range ( n ) :\n        maximum = max ( maximum , lis [ i ] )\n    return maximum"}
{"id": "DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION", "code": "def MatrixChainOrder ( p , i , j ) :\n    if i == j :\n        return 0\n    _min = sys.maxsize\n    for k in range ( i , j ) :\n        count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] )\n        if count < _min :\n            _min = count\n    return _min"}
{"id": "DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1", "code": "def isSubsetSum ( set , n , sum ) :\n    subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] )\n    for i in range ( n + 1 ) :\n        subset [ i ] [ 0 ] = True\n    for i in range ( 1 , sum + 1 ) :\n        subset [ 0 ] [ i ] = False\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , sum + 1 ) :\n            if j < set [ i - 1 ] :\n                subset [ i ] [ j ] = subset [ i - 1 ] [ j ]\n            if j >= set [ i - 1 ] :\n                subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] )\n    return subset [ n ] [ sum ]"}
{"id": "EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1", "code": "def search ( arr , n , x ) :\n    i = 0\n    while ( i <= n - 1 ) :\n        if ( arr [ i ] == x ) :\n            return i\n        i += abs ( arr [ i ] - x )\n    return - 1"}
{"id": "EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10", "code": "def isMultipleOf10 ( n ) :\n    return ( n % 15 == 0 )"}
{"id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY", "code": "def countNum ( arr , n ) :\n    count = 0\n    arr = arr[:n]\n    arr.sort ( )\n    for i in range ( 0 , n - 1 ) :\n        if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) :\n            count += arr [ i + 1 ] - arr [ i ] - 1\n    return count"}
{"id": "ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1", "code": "def countNum ( arr , n ) :\n    s = dict ( )\n    count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9\n    for i in range ( n ) :\n        s [ arr [ i ] ] = 1\n        if ( arr [ i ] < minm ) :\n            minm = arr [ i ]\n        if ( arr [ i ] > maxm ) :\n            maxm = arr [ i ]\n    for i in range ( minm , maxm + 1 ) :\n        if i not in s.keys ( ) :\n            count += 1\n    return count"}
{"id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY", "code": "def equilibrium ( arr , n) :\n    leftsum = 0\n    rightsum = 0\n    for i in range ( n ) :\n        leftsum = 0\n        rightsum = 0\n        for j in range ( i ) :\n            leftsum += arr [ j ]\n        for j in range ( i + 1 , n ) :\n            rightsum += arr [ j ]\n        if leftsum == rightsum :\n            return i\n    return - 1"}
{"id": "EQUILIBRIUM_INDEX_OF_AN_ARRAY_1", "code": "def equilibrium ( arr ,n) :\n    total_sum = sum ( arr )\n    leftsum = 0\n    for i , num in enumerate ( arr ) :\n        total_sum -= num\n        if leftsum == total_sum :\n            return i\n        leftsum += num\n    return - 1"}
{"id": "EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS", "code": "def squareRootExists ( n , p ) :\n    n = n % p\n    for x in range ( 2 , p , 1 ) :\n        if ( ( x * x ) % p == n ) :\n            return True\n    return False"}
{"id": "EVEN_FIBONACCI_NUMBERS_SUM", "code": "def evenFibSum ( limit ) :\n    if ( limit < 2 ) :\n        return 0\n    ef1 = 0\n    ef2 = 2\n    sm = ef1 + ef2\n    while ( ef2 <= limit ) :\n        ef3 = 4 * ef2 + ef1\n        if ( ef3 > limit ) :\n            break\n        ef1 = ef2\n        ef2 = ef3\n        sm = sm + ef2\n    return sm"}
{"id": "FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERATOR_RUSSIAN_PEASANTS_ALGORITHM", "code": "def russianPeasant ( a , b ) :\n    res = 0\n    while ( b > 0 ) :\n        if ( b & 1 ) :\n            res = res + a\n        a = a << 1\n        b = b >> 1\n    return res"}
{"id": "FIBONACCI_MODULO_P", "code": "def findMinZero ( p ) :\n    first = 1\n    second = 1\n    number = 2\n    next = 1\n    while ( next ) :\n        next = ( first + second ) % p\n        first = second\n        second = next\n        number = number + 1\n    return number"}
{"id": "FINDING_POWER_PRIME_NUMBER_P_N", "code": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans += int(n / temp)\n        temp = temp * p\n    return ans"}
{"id": "FINDING_POWER_PRIME_NUMBER_P_N_1", "code": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans += n / temp\n        temp = temp * p\n    return int ( ans )"}
{"id": "FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE", "code": "def maxHamming ( arr , n ) :\n    brr = [ 0 ] * ( 2 * n + 1 )\n    for i in range ( n ) :\n        brr [ i ] = arr [ i ]\n    for i in range ( n ) :\n        brr [ n + i ] = arr [ i ]\n    maxHam = 0\n    for i in range ( 1 , n ) :\n        currHam = 0\n        k = 0\n        for j in range ( i , i + n ) :\n            if brr [ j ] != arr [ k ] :\n                currHam += 1\n                k = k + 1\n        if currHam == n :\n            return n\n        maxHam = max ( maxHam , currHam )\n    return maxHam"}
{"id": "FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE", "code": "def find3Numbers ( A , arr_size , sum ) :\n    for i in range ( 0 , arr_size - 2 ) :\n        for j in range ( i + 1 , arr_size - 1 ) :\n            for k in range ( j + 1 , arr_size ) :\n                if A [ i ] + A [ j ] + A [ k ] == sum :\n                    print ( \"Triplet is\" , A [ i ] , \", \" , A [ j ] , \", \" , A [ k ] )\n                    return True\n    return False"}
{"id": "FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT", "code": "def findDuplicateparenthesis ( string ) :\n    Stack = [ ]\n    for ch in string :\n        if ch == ')' :\n            top = Stack.pop ( )\n            elementsInside = 0\n            while top != '(' :\n                elementsInside += 1\n                top = Stack.pop ( )\n            if elementsInside < 1 :\n                return True\n        else :\n            Stack.append ( ch )\n    return False"}
{"id": "FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X", "code": "def firstFactorialDivisibleNumber ( x ) :\n    i = 1\n    fact = 1\n    for i in range ( 1 , x ) :\n        fact = fact * i\n        if ( fact % x == 0 ) :\n            break\n    return i"}
{"id": "FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN", "code": "def compute ( a , b ) :\n    AM = ( a + b ) / 2\n    GM = math.sqrt ( a * b )\n    HM = ( GM * GM ) / AM\n    return HM"}
{"id": "FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME", "code": "def findIndex ( n ) :\n    if ( n <= 1 ) :\n        return n\n    a = 0\n    b = 1\n    c = 1\n    res = 1\n    while ( c < n ) :\n        c = a + b\n        res = res + 1\n        a = b\n        b = c\n    return res"}
{"id": "FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY", "code": "def findExtra ( arr1 , arr2 , n ) :\n    for i in range ( 0 , n ) :\n        if ( arr1 [ i ] != arr2 [ i ] ) :\n            return i\n    return n"}
{"id": "FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D", "code": "def findLargestd ( S , n ) :\n    found = False\n    S = S[:n]\n    S.sort ( )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        for j in range ( 0 , n ) :\n            if ( i == j ) :\n                continue\n            for k in range ( j + 1 , n ) :\n                if ( i == k ) :\n                    continue\n                for l in range ( k + 1 , n ) :\n                    if ( i == l ) :\n                        continue\n                    if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) :\n                        found = True\n                        return S [ i ]\n    if ( found == False ) :\n        return - 1"}
{"id": "FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1", "code": "def findFourElements ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            mp [ arr [ i ] + arr [ j ] ] = ( i , j )\n    d = - 10 ** 9\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            abs_diff = abs ( arr [ i ] - arr [ j ] )\n            if abs_diff in mp.keys ( ) :\n                p = mp [ abs_diff ]\n                if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) :\n                    d = max ( d , max ( arr [ i ] , arr [ j ] ) )\n    return d"}
{"id": "FIND_LARGEST_PRIME_FACTOR_NUMBER", "code": "def maxPrimeFactors ( n ) :\n    maxPrime = - 1\n    while n % 2 == 0 :\n        maxPrime = 2\n        n >>= 1\n    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :\n        while n % i == 0 :\n            maxPrime = i\n            n = n / i\n    if n > 2 :\n        maxPrime = n\n    return int ( maxPrime )"}
{"id": "FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B", "code": "def computeLastDigit ( A , B ) :\n    variable = 1\n    if ( A == B ) :\n        return 1\n    elif ( ( B - A ) >= 5 ) :\n        return 0\n    else :\n        for i in range ( A + 1 , B + 1 ) :\n            variable = ( variable * ( i % 10 ) ) % 10\n        return variable % 10"}
{"id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH", "code": "def findMaxAverage ( arr , n , k ) :\n    if k > n :\n        return - 1\n    csum = [ 0 ] * n\n    csum [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        csum [ i ] = csum [ i - 1 ] + arr [ i ]\n    max_sum = csum [ k - 1 ]\n    max_end = k - 1\n    for i in range ( k , n ) :\n        curr_sum = csum [ i ] - csum [ i - k ]\n        if curr_sum > max_sum :\n            max_sum = curr_sum\n            max_end = i\n    return max_end - k + 1"}
{"id": "FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1", "code": "def findMaxAverage ( arr , n , k ) :\n    if ( k > n ) :\n        return - 1\n    sum = arr [ 0 ]\n    for i in range ( 1 , k ) :\n        sum += arr [ i ]\n    max_sum = sum\n    max_end = k - 1\n    for i in range ( k , n ) :\n        sum = sum + arr [ i ] - arr [ i - k ]\n        if ( sum > max_sum ) :\n            max_sum = sum\n            max_end = i\n    return max_end - k + 1"}
{"id": "FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S", "code": "def MaxDotProduct ( A , B , m , n ) :\n    dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 , 1 ) :\n        for j in range ( i , m + 1 , 1 ) :\n            dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] )\n    return dp [ n ] [ m ]"}
{"id": "FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY", "code": "def maxProduct ( arr , n ) :\n    if n < 3 :\n        return - 1\n    max_product = - ( sys.maxsize - 1 )\n    for i in range ( 0 , n - 2 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] )\n    return max_product"}
{"id": "FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1", "code": "def maxProduct ( arr , n ) :\n    if n < 3 :\n        return - 1\n    arr.sort ( )\n    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )"}
{"id": "FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS", "code": "def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :\n    sum1 , sum2 , sum3 = 0 , 0 , 0\n    for i in range ( n1 ) :\n        sum1 += stack1 [ i ]\n    for i in range ( n2 ) :\n        sum2 += stack2 [ i ]\n    for i in range ( n3 ) :\n        sum3 += stack3 [ i ]\n    top1 , top2 , top3 = 0 , 0 , 0\n    ans = 0\n    while ( 1 ) :\n        if ( top1 == n1 or top2 == n2 or top3 == n3 ) :\n            return 0\n        if ( sum1 == sum2 and sum2 == sum3 ) :\n            return sum1\n        if ( sum1 >= sum2 and sum1 >= sum3 ) :\n            sum1 -= stack1 [ top1 ]\n            top1 = top1 + 1\n        elif ( sum2 >= sum3 and sum2 >= sum3 ) :\n            sum2 -= stack2 [ top2 ]\n            top2 = top2 + 1\n        elif ( sum3 >= sum2 and sum3 >= sum1 ) :\n            sum3 -= stack3 [ top3 ]\n            top3 = top3 + 1"}
{"id": "FIND_MEDIAN_ROW_WISE_SORTED_MATRIX", "code": "def binaryMedian ( m , r , c ) :\n    mi = sys.maxsize\n    mx = - sys.maxsize - 1\n    for i in range ( r ) :\n        if m [ i ] [ 0 ] < mi :\n            mi = m [ i ] [ 0 ]\n        if m [ i ] [ c - 1 ] > mx :\n            mx = m [ i ] [ c - 1 ]\n    desired = ( r * c + 1 ) // 2\n    while ( mi < mx ) :\n        mid = mi + ( mx - mi ) // 2\n        place = [ 0 ]\n        for i in range ( r ) :\n            j = upper_bound ( m [ i ] , mid )\n            place [ 0 ] = place [ 0 ] + j\n        if place [ 0 ] < desired :\n            mi = mid + 1\n        else :\n            mx = mid\n    print ( \"Median is\" , mi )\n    return mi"}
{"id": "FIND_MINIMUM_DIFFERENCE_PAIR", "code": "def findMinDiff ( arr , n ) :\n    diff = 10 ** 20\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            if abs ( arr [ i ] - arr [ j ] ) < diff :\n                diff = abs ( arr [ i ] - arr [ j ] )\n    return diff"}
{"id": "FIND_MINIMUM_DIFFERENCE_PAIR_1", "code": "def findMinDiff ( arr , n ) :\n    arr = arr[:n]\n    arr = sorted ( arr )\n    diff = 10 ** 20\n    for i in range ( n - 1 ) :\n        if arr [ i + 1 ] - arr [ i ] < diff :\n            diff = arr [ i + 1 ] - arr [ i ]\n    return diff"}
{"id": "FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY", "code": "def findMin ( arr , low , high ) :\n    if high < low :\n        return arr [ 0 ]\n    if high == low :\n        return arr [ low ]\n    mid = int ( ( low + high ) / 2 )\n    if mid < high and arr [ mid + 1 ] < arr [ mid ] :\n        return arr [ mid + 1 ]\n    if mid > low and arr [ mid ] < arr [ mid - 1 ] :\n        return arr [ mid ]\n    if arr [ high ] > arr [ mid ] :\n        return findMin ( arr , low , mid - 1 )\n    return findMin ( arr , mid + 1 , high )"}
{"id": "FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE", "code": "def findMinNumber ( n ) :\n    count = 0\n    ans = 1\n    while n % 2 == 0 :\n        count += 1\n        n //= 2\n    if count % 2 is not 0 :\n        ans *= 2\n    for i in range ( 3 , ( int ) ( math.sqrt ( n ) ) + 1 , 2 ) :\n        count = 0\n        while n % i == 0 :\n            count += 1\n            n //= i\n        if count % 2 is not 0 :\n            ans *= i\n    if n > 2 :\n        ans *= n\n    return ans"}
{"id": "FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1", "code": "def minCoins ( coins , m , V ) :\n    table = [ 0 for i in range ( V + 1 ) ]\n    table [ 0 ] = 0\n    for i in range ( 1 , V + 1 ) :\n        table [ i ] = sys.maxsize\n    for i in range ( 1 , V + 1 ) :\n        for j in range ( m ) :\n            if ( coins [ j ] <= i ) :\n                sub_res = table [ i - coins [ j ] ]\n                if ( sub_res != sys.maxsize and sub_res + 1 < table [ i ] ) :\n                    table [ i ] = sub_res + 1\n    return table [ V ]"}
{"id": "FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE", "code": "def minRadius ( k , x , y , n ) :\n    dis = [ 0 ] * n\n    for i in range ( 0 , n ) :\n        dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ]\n    dis.sort ( )\n    return dis [ k - 1 ]"}
{"id": "FIND_MIRROR_IMAGE_POINT_2_D_PLANE", "code": "def mirrorImage ( a , b , c , x1 , y1 ) :\n    temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )\n    x = temp * a + x1\n    y = temp * b + y1\n    return ( x , y )"}
{"id": "FIND_NUMBER_ENDLESS_POINTS", "code": "def countEndless ( input , n ) :\n    row = np.zeros ( ( n , n ) )\n    col = np.zeros ( ( n , n ) )\n    for j in range ( n ) :\n        isEndless = 1\n        for i in range ( n - 1 , - 1 , - 1 ) :\n            if ( input [ i ] [ j ] == 0 ) :\n                isEndless = 0\n            col [ i ] [ j ] = isEndless\n    for i in range ( n ) :\n        isEndless = 1\n        for j in range ( n - 1 , - 1 , - 1 ) :\n            if ( input [ i ] [ j ] == 0 ) :\n                isEndless = 0\n            row [ i ] [ j ] = isEndless\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( 1 , n ) :\n            if ( row [ i ] [ j ] and col [ i ] [ j ] ) :\n                ans += 1\n    return ans"}
{"id": "FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS", "code": "def CountSquares ( a , b ) :\n    cnt = 0\n    for i in range ( a , b + 1 ) :\n        j = 1 ;\n        while j * j <= i :\n            if j * j == i :\n                cnt = cnt + 1\n            j = j + 1\n        i = i + 1\n    return cnt"}
{"id": "FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1", "code": "def count ( a , b ) :\n    m = len ( a )\n    n = len ( b )\n    lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]\n    for i in range ( n + 1 ) :\n        lookup [ 0 ] [ i ] = 0\n    for i in range ( m + 1 ) :\n        lookup [ i ] [ 0 ] = 1\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if a [ i - 1 ] == b [ j - 1 ] :\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ]\n            else :\n                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]\n    return lookup [ m ] [ n ]"}
{"id": "FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL", "code": "def countOps ( A , B , m , n ) :\n    for i in range ( n ) :\n        for j in range ( m ) :\n            A [ i ] [ j ] -= B [ i ] [ j ]\n    for i in range ( 1 , n ) :\n        for j in range ( 1 , n ) :\n            if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) :\n                return - 1\n    result = 0\n    for i in range ( n ) :\n        result += abs ( A [ i ] [ 0 ] )\n    for j in range ( m ) :\n        result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] )\n    return ( result )"}
{"id": "FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES", "code": "def findSDSFunc ( n ) :\n    DP = [ 0 ] * ( n + 1 )\n    DP [ 0 ] = 0\n    DP [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        if ( int ( i % 2 ) == 0 ) :\n            DP [ i ] = DP [ int ( i / 2 ) ]\n        else :\n            DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] )\n    return DP [ n ]"}
{"id": "FIND_ONE_EXTRA_CHARACTER_STRING_1", "code": "def findExtraCharcter ( strA , strB ) :\n    res = 0\n    for i in range ( 0 , len ( strA ) ) :\n        res = res ^ ( ord ) ( strA [ i ] )\n    for i in range ( 0 , len ( strB ) ) :\n        res = res ^ ( ord ) ( strB [ i ] )\n    return ( ( chr ) ( res ) ) ;"}
{"id": "FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS", "code": "def pairSum ( mat , n , sum ) :\n    for i in range ( n ) :\n        mat [ i ].sort ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            left = 0\n            right = n - 1\n            while ( left < n and right >= 0 ) :\n                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) :\n                    print ( \"(\" , mat [ i ] [ left ] , \", \" , mat [ j ] [ right ] , \"), \" , end = \" \" )\n                    left += 1\n                    right -= 1\n                else :\n                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :\n                        left += 1\n                    else :\n                        right -= 1"}
{"id": "FIND_PAIR_MAXIMUM_GCD_ARRAY", "code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    i = 0\n    while i < n :\n        high = max ( high , arr [ i ] )\n        i = i + 1\n    divisors = [ 0 ] * ( high + 1 )\n    i = 0\n    while i < n :\n        j = 1\n        while j <= math.sqrt ( arr [ i ] ) :\n            if ( arr [ i ] % j == 0 ) :\n                divisors [ j ] = divisors [ j ] + 1\n                if ( j != arr [ i ] / j ) :\n                    divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] + 1\n            j = j + 1\n        i = i + 1\n    i = high\n    while i >= 1 :\n        if ( divisors [ i ] > 1 ) :\n            return i\n        i = i - 1\n    return 1"}
{"id": "FIND_PAIR_MAXIMUM_GCD_ARRAY_1", "code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    for i in range ( 0 , n ) :\n        high = max ( high , arr [ i ] )\n    count = [ 0 ] * ( high + 1 )\n    for i in range ( 0 , n ) :\n        count [ arr [ i ] ] += 1\n    counter = 0\n    for i in range ( high , 0 , - 1 ) :\n        j = i\n        while ( j <= high ) :\n            if ( count [ j ] > 0 ) :\n                counter += count [ j ]\n            j += i\n            if ( counter == 2 ) :\n                return i\n        counter = 0\n    return 1\n"}
{"id": "FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY", "code": "def findGreatest ( arr , n ) :\n    result = - 1\n    for i in range ( n ) :\n        for j in range ( n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                if ( arr [ j ] * arr [ k ] == arr [ i ] ) :\n                    result = max ( result , arr [ i ] )\n    return result"}
{"id": "FIND_PATTERNS_101_GIVEN_STRING", "code": "def patternCount ( str ) :\n    last = str [ 0 ]\n    i = 1\n    counter = 0\n    while ( i < len ( str ) ) :\n        if ( str [ i ] == '0' and last == '1' ) :\n            while ( str [ i ] == '0' ) :\n                i += 1\n                if ( str [ i ] == '1' ) :\n                    counter += 1\n        last = str [ i ]\n        i += 1\n    return counter"}
{"id": "FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7", "code": "def findpos ( n ) :\n    i = 0\n    j = len ( n )\n    pos = 0\n    while ( i < j ) :\n        if ( n [ i ] == '4' ) :\n            pos = pos * 2 + 1\n        if ( n [ i ] == '7' ) :\n            pos = pos * 2 + 2\n        i = i + 1\n    return pos"}
{"id": "FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1", "code": "def isRectangle ( m ) :\n    rows = len ( m )\n    if ( rows == 0 ) :\n        return False\n    columns = len ( m [ 0 ] )\n    for y1 in range ( rows ) :\n        for x1 in range ( columns ) :\n            if ( m [ y1 ] [ x1 ] == 1 ) :\n                for y2 in range ( y1 + 1 , rows ) :\n                    for x2 in range ( x1 + 1 , columns ) :\n                        if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) :\n                            return True\n    return False"}
{"id": "FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1", "code": "def isRectangle ( matrix ) :\n    rows = len ( matrix )\n    if ( rows == 0 ) :\n        return False\n    columns = len ( matrix [ 0 ] )\n    table = { }\n    for i in range ( rows ) :\n        for j in range ( columns - 1 ) :\n            for k in range ( j + 1 , columns ) :\n                if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) :\n                    if ( j in table and k in table [ j ] ) :\n                        return True\n                    if ( k in table and j in table [ k ] ) :\n                        return True\n                    if j not in table :\n                        table [ j ] = set ( )\n                    if k not in table :\n                        table [ k ] = set ( )\n                    table [ j ].add ( k )\n                    table [ k ].add ( j )\n    return False"}
{"id": "FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N", "code": "def findRepeatingElement ( arr , low , high ) :\n    if low > high :\n        return - 1\n    mid = int ( ( low + high ) / 2 )\n    if ( arr [ mid ] != mid + 1 ) :\n        if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) :\n            return mid\n        return findRepeatingElement ( arr , low , mid - 1 )\n    return findRepeatingElement ( arr , mid + 1 , high )"}
{"id": "FIND_REPETITIVE_ELEMENT_1_N_1", "code": "def findRepeating ( arr , n ) :\n    return sum ( arr [ : n ] ) - ( ( ( n - 1 ) * n ) // 2 )"}
{"id": "FIND_REPETITIVE_ELEMENT_1_N_1_1", "code": "def findRepeating ( arr , n ) :\n    s = set ( )\n    for i in range ( n ) :\n        if arr [ i ] in s :\n            return arr [ i ]\n        s.add ( arr [ i ] )\n    rteurn - 1"}
{"id": "FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1", "code": "def countRotations ( arr , low , high ) :\n    if ( high < low ) :\n        return 0\n    if ( high == low ) :\n        return low\n    mid = low + ( high - low ) / 2\n    mid = int ( mid )\n    if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) :\n        return ( mid + 1 )\n    if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) :\n        return mid\n    if ( arr [ high ] > arr [ mid ] ) :\n        return countRotations ( arr , low , mid - 1 )\n    return countRotations ( arr , mid + 1 , high )"}
{"id": "FIND_SUBARRAY_WITH_GIVEN_SUM", "code": "def subArraySum ( arr , n , sum ) :\n    for i in range ( n ) :\n        curr_sum = arr [ i ]\n        j = i + 1\n        while j <= n :\n            if curr_sum == sum :\n                print ( \"Sum found between\" )\n                print ( \"indexes %d and %d\" % ( i , j - 1 ) )\n                return 1\n            if curr_sum > sum or j == n :\n                break\n            curr_sum = curr_sum + arr [ j ]\n            j += 1\n    print ( \"No subarray found\" )\n    return 0"}
{"id": "FIND_SUBARRAY_WITH_GIVEN_SUM_1", "code": "def subArraySum ( arr , n , sum ) :\n    curr_sum = arr [ 0 ]\n    start = 0\n    i = 1\n    while i <= n :\n        while curr_sum > sum and start < i - 1 :\n            curr_sum = curr_sum - arr [ start ]\n            start += 1\n        if curr_sum == sum :\n            print ( \"Sum found between indexes\" )\n            print ( \"%d and %d\" % ( start , i - 1 ) )\n            return 1\n        if i < n :\n            curr_sum = curr_sum + arr [ i ]\n        i += 1\n    print ( \"No subarray found\" )\n    return 0"}
{"id": "FIND_SUM_EVEN_FACTORS_NUMBER", "code": "def sumofFactors ( n ) :\n    if ( n % 2 != 0 ) :\n        return 0\n    res = 1\n    for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while ( n % i == 0 ) :\n            count = count + 1\n            n = n // i\n            if ( i == 2 and count == 1 ) :\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if ( n >= 2 ) :\n        res = res * ( 1 + n )\n    return res"}
{"id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS", "code": "def evenSum ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if j == 0 or j == i :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n    sum = 0 ;\n    for i in range ( 0 , n + 1 ) :\n        if i % 2 == 0 :\n            sum = sum + C [ n ] [ i ]\n    return sum"}
{"id": "FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1", "code": "def evenbinomialCoeffSum ( n ) :\n    return ( 1 << ( n - 1 ) )"}
{"id": "FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER", "code": "def findSum ( N , K ) :\n    ans = 0\n    for i in range ( 1 , N + 1 ) :\n        ans += ( i % K )\n    return ans"}
{"id": "FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1", "code": "def sumNodes ( l ) :\n    leafNodeCount = math.pow ( 2 , l - 1 )\n    sumLastLevel = 0\n    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 )\n    sum = sumLastLevel * l\n    return sum"}
{"id": "FIND_SUM_ODD_FACTORS_NUMBER", "code": "def sumofoddFactors ( n ) :\n    res = 1\n    while n % 2 == 0 :\n        n = n // 2\n    for i in range ( 3 , int ( math.sqrt ( n ) + 1 ) ) :\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0 :\n            count += 1\n            n = n // i\n            curr_term *= i\n            curr_sum += curr_term\n        res *= curr_sum\n    if n >= 2 :\n        res *= ( 1 + n )\n    return res"}
{"id": "FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY", "code": "def findSubarraySum ( arr , n ) :\n    res = 0\n    m = dict ( )\n    for i in range ( n ) :\n        Sum = 0\n        for j in range ( i , n ) :\n            Sum += arr [ j ]\n            m [ Sum ] = m.get ( Sum , 0 ) + 1\n    for x in m :\n        if m [ x ] == 1 :\n            res += x\n    return res"}
{"id": "FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT", "code": "def findElement ( arr , n ) :\n    leftMax = [ None ] * n\n    leftMax [ 0 ] = float ( '-inf' )\n    for i in range ( 1 , n ) :\n        leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] )\n    rightMin = float ( 'inf' )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] :\n            return i\n        rightMin = min ( rightMin , arr [ i ] )\n    return - 1"}
{"id": "FIND_THE_ELEMENT_THAT_APPEARS_ONCE", "code": "def getSingle ( arr , n ) :\n    ones = 0\n    twos = 0\n    for i in range ( n ) :\n        twos = twos | ( ones & arr [ i ] )\n        ones = ones ^ arr [ i ]\n        common_bit_mask = ~ ( ones & twos )\n        ones &= common_bit_mask\n        twos &= common_bit_mask\n    return ones"}
{"id": "FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2", "code": "def singleNumber ( a , n ) :\n    return ( 3 * sum ( set ( a ) ) - sum ( a ) ) / 2"}
{"id": "FIND_THE_FIRST_MISSING_NUMBER", "code": "def findFirstMissing ( array , start , end ) :\n    if ( start > end ) :\n        return end + 1\n    if ( start != array [ start ] ) :\n        return start\n    mid = int ( ( start + end ) / 2 )\n    if ( array [ mid ] == mid ) :\n        return findFirstMissing ( array , mid + 1 , end )\n    return findFirstMissing ( array , start , mid )"}
{"id": "FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM", "code": "def maxLen ( arr , n ) :\n    max_len = 0\n    for i in range ( n ) :\n        curr_sum = 0\n        for j in range ( i , n ) :\n            curr_sum += arr [ j ]\n            if curr_sum == 0 :\n                max_len = max ( max_len , j - i + 1 )\n    return max_len\n"}
{"id": "FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING", "code": "def findMaximum ( arr , low , high ) :\n    max = arr[low]\n    for i in range(low, high + 1):\n        if arr[i] > max:\n            max = arr[i]\n    return max"}
{"id": "FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY", "code": "def maxSubarrayXOR ( arr , n ) :\n    ans = - 2147483648\n    for i in range ( n ) :\n        curr_xor = 0\n        for j in range ( i , n ) :\n            curr_xor = curr_xor ^ arr [ j ]\n            ans = max ( ans , curr_xor )\n    return ans"}
{"id": "FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS", "code": "def minDist ( arr , n , x , y ) :\n    min_dist = 2147483647\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) :\n                min_dist = abs ( i - j )\n    return min_dist\n\n"}
{"id": "FIND_THE_MISSING_NUMBER_1", "code": "def getMissingNo ( a , n ) :\n    i , total = 0 , 1\n    for i in range ( 2 , n + 2 ) :\n        total += i\n        total -= a [ i - 2 ]\n    return total"}
{"id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES", "code": "def getOddOccurrence ( arr , arr_size ) :\n    for i in range ( 0 , arr_size ) :\n        count = 0\n        for j in range ( 0 , arr_size ) :\n            if arr [ i ] == arr [ j ] :\n                count += 1\n        if ( count % 2 != 0 ) :\n            return arr [ i ]\n    return - 1"}
{"id": "FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2", "code": "def getOddOccurrence ( ar , ar_size) :\n    res = 0\n    for i in range ( 0, ar_size ) :\n        res = res ^ ar [ i ]\n    return res\n"}
{"id": "FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1", "code": "def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :\n    s = set ( )\n    for i in range ( n1 ) :\n        s.add ( a1 [ i ] )\n    for i in range ( n2 ) :\n        for j in range ( n3 ) :\n            if sum - a2 [ i ] - a3 [ j ] in s :\n                return True\n    return False"}
{"id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1", "code": "def findTriplets ( arr , n ) :\n    found = False\n    for i in range ( n - 1 ) :\n        s = set ( )\n        for j in range ( i + 1 , n ) :\n            x = - ( arr [ i ] + arr [ j ] )\n            if x in s :\n                print ( x , arr [ i ] , arr [ j ] )\n                found = True\n            else :\n                s.add ( arr [ j ] )\n    if found == False :\n        print ( \"No Triplet Found\" )"}
{"id": "FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2", "code": "def findTriplets ( arr , n ) :\n    found = False\n    arr.sort ( )\n    for i in range ( 0 , n - 1 ) :\n        l = i + 1\n        r = n - 1\n        x = arr [ i ]\n        while ( l < r ) :\n            if ( x + arr [ l ] + arr [ r ] == 0 ) :\n                print ( x , arr [ l ] , arr [ r ] )\n                l += 1\n                r -= 1\n                found = True\n            elif ( x + arr [ l ] + arr [ r ] < 0 ) :\n                l += 1\n            else :\n                r -= 1\n    if ( found == False ) :\n        print ( \" No Triplet Found\" )"}
{"id": "FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X", "code": "def yMod ( y , x ) :\n    return ( y % pow ( 2 , x ) )"}
{"id": "FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT", "code": "def isPowerOfFour ( n ) :\n    if ( n == 0 ) :\n        return False\n    while ( n != 1 ) :\n        if ( n % 4 != 0 ) :\n            return False\n        n = n // 4\n    return True"}
{"id": "FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1", "code": "def isPowerOfFour ( n ) :\n    count = 0\n    if ( n and ( not ( n & ( n - 1 ) ) ) ) :\n        while ( n > 1 ) :\n            n >>= 1\n            count += 1\n        if ( count % 2 == 0 ) :\n            return True\n        else :\n            return False\n    return False"}
{"id": "FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2", "code": "def isPowerOfFour ( n ) :\n    return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) )"}
{"id": "FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT", "code": "def check ( n ) :\n    return 1162261467 % n == 0"}
{"id": "FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY", "code": "def firstElement ( arr , n , k ) :\n    count_map = { }\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] in count_map.keys ( ) ) :\n            count_map [ arr [ i ] ] += 1\n        else :\n            count_map [ arr [ i ] ] = 1\n        i += 1\n    for i in range ( 0 , n ) :\n        if ( count_map [ arr [ i ] ] == k ) :\n            return arr [ i ]\n        i += 1\n    return - 1"}
{"id": "FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE", "code": "def first ( str ) :\n    for i in range ( 0 , len ( str ) ) :\n        if ( str [ i ].istitle ( ) ) :\n            return str [ i ]\n    return 0"}
{"id": "FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1", "code": "def first ( str , i ) :\n    if ( str [ i ] == '\\0' ) :\n        return 0\n    if ( str [ i ].isupper ( ) ) :\n        return str [ i ]\n    return first ( str , i + 1 )"}
{"id": "FLOOR_IN_A_SORTED_ARRAY", "code": "def floorSearch ( arr , n , x ) :\n    if x >= arr [ n - 1 ]: return n - 1\n    if x < arr [ 0 ]: return - 1\n    for i in range ( 1, n ):\n        if arr [ i ] > x: return i - 1\n    return - 1"}
{"id": "FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1", "code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return result"}
{"id": "FREQUENT_ELEMENT_ARRAY_1", "code": "def mostFrequent ( arr , n ) :\n    Hash = dict ( )\n    for i in range ( n ) :\n        if arr [ i ] in Hash.keys ( ) :\n            Hash [ arr [ i ] ] += 1\n        else :\n            Hash [ arr [ i ] ] = 1\n    max_count = 0\n    res = - 1\n    for i in Hash :\n        if ( max_count < Hash [ i ] ) :\n            res = i\n            max_count = Hash [ i ]\n    return res"}
{"id": "FRIENDS_PAIRING_PROBLEM", "code": "def countFriendsPairings ( n ) :\n    dp = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        if ( i <= 2 ) :\n            dp [ i ] = i\n        else :\n            dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]\n    return dp [ n ]"}
{"id": "FRIENDS_PAIRING_PROBLEM_2", "code": "def countFriendsPairings ( n ) :\n    a , b , c = 1 , 2 , 0\n    if ( n <= 2 ) :\n        return n\n    for i in range ( 3 , n + 1 ) :\n        c = b + ( i - 1 ) * a\n        a = b\n        b = c\n    return c"}
{"id": "GCD_ELEMENTS_GIVEN_RANGE", "code": "def rangeGCD ( n , m ) :\n    return n if ( n == m ) else 1"}
{"id": "GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1", "code": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return \"\".join(str(i) for i in result)"}
{"id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8", "code": "def isSubSeqDivisible ( str ) :\n    l = len ( str )\n    arr = [ 0 ] * l\n    for i in range ( 0 , l ) :\n        for j in range ( i , l ) :\n            for k in range ( j , l ) :\n                if ( arr [ i ] % 8 == 0 ) :\n                    return True\n                elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :\n                    return True\n                elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :\n                    return True\n    return False"}
{"id": "GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1", "code": "def isSubSeqDivisible ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ]\n    arr = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        arr [ i ] = int ( str [ i - 1 ] )\n    for i in range ( 1 , n + 1 ) :\n        dp [ i ] [ arr [ i ] % 8 ] = 1\n        for j in range ( 8 ) :\n            if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) :\n                dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ]\n            if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j ]\n    for i in range ( 1 , n + 1 ) :\n        if ( dp [ i ] [ 0 ] == 1 ) :\n            return True\n    return False"}
{"id": "GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2", "code": "def largestPower ( n , p ) :\n    x = 0\n    while n :\n        n /= p\n        x += n\n    return x"}
{"id": "GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND", "code": "def isSubSequence ( str1 , str2 , m , n ) :\n    if m == 0 : return True\n    if n == 0 : return False\n    if str1 [ m - 1 ] == str2 [ n - 1 ] :\n        return isSubSequence ( str1 , str2 , m - 1 , n - 1 )\n    return isSubSequence ( str1 , str2 , m , n - 1 )"}
{"id": "GNOME_SORT_A_STUPID_ONE", "code": "def gnomeSort ( arr , n ) :\n    index = 0\n    while index < n :\n        if index == 0 :\n            index = index + 1\n        if arr [ index ] >= arr [ index - 1 ] :\n            index = index + 1\n        else :\n            arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ]\n            index = index - 1\n    return arr"}
{"id": "HARDY_RAMANUJAN_THEOREM", "code": "def exactPrimeFactorCount ( n ) :\n    count = 0\n    if ( n % 2 == 0 ) :\n        count = count + 1\n        while ( n % 2 == 0 ) :\n            n = int ( n / 2 )\n    i = 3\n    while ( i <= int ( math.sqrt ( n ) ) ) :\n        if ( n % i == 0 ) :\n            count = count + 1\n            while ( n % i == 0 ) :\n                n = int ( n / i )\n        i = i + 2\n    if ( n > 2 ) :\n        count = count + 1\n    return count"}
{"id": "HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES", "code": "def height ( N ) :\n    return math.ceil ( math.log2 ( N + 1 ) ) - 1"}
{"id": "HEXAGONAL_NUMBER", "code": "def hexagonalNum ( n ) :\n    return n * ( 2 * n - 1 )"}
{"id": "HIGHWAY_BILLBOARD_PROBLEM", "code": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0\n    for i in range ( 1 , m + 1 ) :\n        if ( nxtbb < n ) :\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                nxtbb += 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n    return maxRev [ m ]"}
{"id": "HORNERS_METHOD_POLYNOMIAL_EVALUATION", "code": "def horner ( poly , n , x ) :\n    result = poly [ 0 ]\n    for i in range ( 1 , n ) :\n        result = result * x + poly [ i ]\n    return result"}
{"id": "HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT", "code": "def getSum ( n ) :\n    sum = 0\n    while ( n != 0 ) :\n        sum = sum + int ( n % 10 )\n        n = int ( n / 10 )\n    return sum"}
{"id": "HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION", "code": "def mulmod ( a , b , mod ) :\n    res = 0\n    a = a % mod\n    while ( b > 0 ) :\n        if ( b % 2 == 1 ) :\n            res = ( res + a ) % mod\n        a = ( a * 2 ) % mod\n        b //= 2\n    return res % mod"}
{"id": "HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING", "code": "def search ( arr , x ) :\n    n = len ( arr )\n    for j in range ( 0 , n ) :\n        if ( x == arr [ j ] ) :\n            return j\n    return - 1"}
{"id": "HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP", "code": "def isHeap ( arr , i , n ) :\n    if i > int ( ( n - 2 ) / 2 ) :\n        return True\n    if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) :\n        return True\n    return False"}
{"id": "HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1", "code": "def isHeap ( arr , n ) :\n    for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) :\n        if arr [ 2 * i + 1 ] > arr [ i ] :\n            return False\n        if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) :\n            return False\n    return True"}
{"id": "HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS", "code": "def search ( arr , n , x ) :\n    for j in range ( 0 , n ) :\n        if ( x == arr [ j ] ) :\n            return j\n    return - 1"}
{"id": "HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER", "code": "def turnOffK ( n , k ) :\n    if ( k <= 0 ) :\n        return n\n    return ( n & ~ ( 1 << ( k - 1 ) ) )"}
{"id": "HYPERCUBE_GRAPH", "code": "def power ( n ) :\n    if n == 1 :\n        return 2\n    return 2 * power ( n - 1 )"}
{"id": "INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY", "code": "def findInteger ( arr , n ) :\n    hash = dict ( )\n    maximum = 0\n    for i in arr :\n        if ( i < 0 ) :\n            if abs ( i ) not in hash.keys ( ) :\n                hash [ abs ( i ) ] = - 1\n            else :\n                hash [ abs ( i ) ] -= 1\n        else :\n            hash [ i ] = hash.get ( i , 0 ) + 1\n    for i in arr :\n        if i in hash.keys ( ) and hash [ i ] > 0 :\n            return i\n    return - 1"}
{"id": "K_TH_DIGIT_RAISED_POWER_B", "code": "def kthdigit ( a , b , k ) :\n    p = a ** b\n    count = 0\n    while ( p > 0 and count < k ) :\n        rem = p % 10\n        count = count + 1\n        if ( count == k ) :\n            return rem\n        p = p // 10\n    return 0\n"}
{"id": "K_TH_ELEMENT_TWO_SORTED_ARRAYS", "code": "def kth ( arr1 , arr2 , m , n , k ) :\n    sorted1 = [ 0 ] * ( m + n )\n    i = 0\n    j = 0\n    d = 0\n    while ( i < m and j < n ) :\n        if ( arr1 [ i ] < arr2 [ j ] ) :\n            sorted1 [ d ] = arr1 [ i ]\n            i += 1\n        else :\n            sorted1 [ d ] = arr2 [ j ]\n            j += 1\n        d += 1\n    while ( i < m ) :\n        sorted1 [ d ] = arr1 [ i ]\n        d += 1\n        i += 1\n    while ( j < n ) :\n        sorted1 [ d ] = arr2 [ j ]\n        d += 1\n        j += 1\n    return sorted1 [ k - 1 ]"}
{"id": "K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY", "code": "def kthLargestSum ( arr , n , k ) :\n    sum = [ ]\n    sum.append ( 0 )\n    sum.append ( arr [ 0 ] )\n    for i in range ( 2 , n + 1 ) :\n        sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )\n    Q = [ ]\n    heapq.heapify ( Q )\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( i , n + 1 ) :\n            x = sum [ j ] - sum [ i - 1 ]\n            if len ( Q ) < k :\n                heapq.heappush ( Q , x )\n            else :\n                if Q [ 0 ] < x :\n                    heapq.heappop ( Q )\n                    heapq.heappush ( Q , x )\n    return Q [ 0 ]"}
{"id": "K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE", "code": "def find ( a , b , k , n1 , n2 ) :\n    s = set ( )\n    for i in range ( n2 ) :\n        s.add ( b [ i ] )\n    missing = 0\n    for i in range ( n1 ) :\n        if a [ i ] not in s :\n            missing += 1\n        if missing == k :\n            return a [ i ]\n    return - 1"}
{"id": "K_TH_PRIME_FACTOR_GIVEN_NUMBER", "code": "def kPrimeFactor ( n , k ) :\n    while ( n % 2 == 0 ) :\n        k = k - 1\n        n = n // 2\n        if ( k == 0 ) :\n            return 2\n    i = 3\n    while i <= math.sqrt ( n ) :\n        while ( n % i == 0 ) :\n            if ( k == 1 ) :\n                return i\n            k = k - 1\n            n = n // i\n        i = i + 2\n    if ( n > 2 and k == 1 ) :\n        return n\n    return - 1"}
{"id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S", "code": "def findSubArray ( arr , n ) :\n    sum = 0\n    maxsize = - 1\n    for i in range ( 0 , n - 1 ) :\n        sum = - 1 if ( arr [ i ] == 0 ) else 1\n        for j in range ( i + 1 , n ) :\n            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1\n            if ( sum == 0 and maxsize < j - i + 1 ) :\n                maxsize = j - i + 1\n                startindex = i\n    if ( maxsize == - 1 ) :\n        print ( \"No such subarray\" )\n    else :\n        print ( startindex , \"to\" , startindex + maxsize - 1 )\n    return maxsize"}
{"id": "LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1", "code": "def maxLen ( arr , n ) :\n    hash_map = { }\n    curr_sum = 0\n    max_len = 0\n    ending_index = - 1\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 0 ) :\n            arr [ i ] = - 1\n        else :\n            arr [ i ] = 1\n    for i in range ( 0 , n ) :\n        curr_sum = curr_sum + arr [ i ]\n        if ( curr_sum == 0 ) :\n            max_len = i + 1\n            ending_index = i\n        if ( curr_sum + n ) in hash_map :\n            if max_len < i - hash_map [ curr_sum + n ] :\n                max_len = i - hash_map [ curr_sum + n ]\n                ending_index = i\n        else :\n            hash_map[curr_sum + n] = i\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == - 1 ) :\n            arr [ i ] = 0\n        else :\n            arr [ i ] = 1\n    print ( ending_index - max_len + 1 , end = \" \" )\n    print ( \"to\" , end = \" \" )\n    print ( ending_index )\n    return max_len"}
{"id": "LARGEST_SUBSEQUENCE_GCD_GREATER_1", "code": "def largestGCDSubsequence ( arr , n ) :\n    ans = 0\n    maxele = max ( arr )\n    for i in range ( 2 , maxele + 1 ) :\n        count = 0\n        for j in range ( n ) :\n            if ( arr [ j ] % i == 0 ) :\n                count += 1\n        ans = max ( ans , count )\n    return ans"}
{"id": "LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K", "code": "def longestSubsequenceCommonSegment ( k , s1 , s2 ) :\n    n = len ( s1 )\n    m = len ( s2 )\n    lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , m + 1 ) :\n            lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] )\n            if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) :\n                cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1\n            if ( cnt [ i ] [ j ] >= k ) :\n                for a in range ( k , cnt [ i ] [ j ] + 1 ) :\n                    lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a )\n    return lcs [ n ] [ m ]"}
{"id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE", "code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    for i in range ( n - 1 ) :\n        if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :\n            dp [ i ] [ i + 1 ] = 2\n    for l in range ( 2 , n ) :\n        i = - 1\n        for j in range ( l , n ) :\n            i += 1\n            if ( s [ i ] == '(' and s [ j ] == ')' ) :\n                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]\n            for k in range ( i , j ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n    return dp [ 0 ] [ n - 1 ]"}
{"id": "LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1", "code": "def maxLength ( s , n ) :\n    invalidOpenBraces = 0\n    invalidCloseBraces = 0\n    for i in range ( n ) :\n        if ( s [ i ] == '(' ) :\n            invalidOpenBraces += 1\n        else :\n            if ( invalidOpenBraces == 0 ) :\n                invalidCloseBraces += 1\n            else :\n                invalidOpenBraces -= 1\n    return ( n - ( invalidOpenBraces + invalidCloseBraces ) )"}
{"id": "LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED", "code": "def longestNull ( S ) :\n    arr = [ ]\n    arr.append ( [ '@' , - 1 ] )\n    maxlen = 0\n    for i in range ( len ( S ) ) :\n        arr.append ( [ S [ i ] , i ] )\n        while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] [ 0 ] == '1' and arr [ len ( arr ) - 2 ] [ 0 ] == '0' and arr [ len ( arr ) - 1 ] [ 0 ] == '0' ) :\n            arr.pop ( )\n            arr.pop ( )\n            arr.pop ( )\n        tmp = arr [ - 1 ]\n        maxlen = max ( maxlen , i - tmp [ 1 ] )\n    return maxlen"}
{"id": "LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY", "code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :\n                k += 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i -= 1\n    return llap"}
{"id": "LEONARDO_NUMBER_1", "code": "def leonardo ( n ) :\n    dp = [ ]\n    dp.append ( 1 )\n    dp.append ( 1 )\n    for i in range ( 2 , n + 1 ) :\n        dp.append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 )\n    return dp [ n ]"}
{"id": "LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_LEAST_K_TIMES", "code": "def subsequence ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n    for ch in string :\n        cnt = 0\n        for i in range ( last , n ) :\n            if s [ i ] == ch :\n                cnt += 1\n        if cnt >= k :\n            for i in range ( last , n ) :\n                if s [ i ] == ch :\n                    t [ size ] = ch\n                    new_last = i\n                    size += 1\n            last = new_last\n    t[size] = '\\0';"}
{"id": "LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION", "code": "def minLexRotation ( str_ ) :\n    n = len ( str_ )\n    arr = [ 0 ] * n\n    concat = str_ + str_\n    for i in range ( n ) :\n        arr [ i ] = concat [ i : n + i ]\n    arr.sort ( )\n    return arr [ 0 ]"}
{"id": "LEXICOGRAPHICALLY_NEXT_STRING", "code": "def nextWord ( s ) :\n    if ( s == \" \" ) :\n        return \"a\"\n    i = len ( s ) - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        s = s + 'a'\n    else :\n        s = s [ 0 : i ] + chr ( ord ( s [ i ] ) + 1 ) + s [ i + 1 : ]\n    return s"}
{"id": "LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C", "code": "def prevPermutation ( str ) :\n    n = len ( str ) - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j += 1\n    str = list ( str )\n    temp = str [ i - 1 ]\n    str [ i - 1 ] = str [ j ]\n    str [ j ] = temp\n    str = ''.join ( str )\n    str [ : : - 1 ]\n    return True"}
{"id": "LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS", "code": "def minimizeWithKSwaps ( arr , n , k ) :\n    for i in range ( n - 1 ) :\n        pos = i\n        for j in range ( i + 1 , n ) :\n            if ( j - i > k ) :\n                break\n            if ( arr [ j ] < arr [ pos ] ) :\n                pos = j\n        for j in range ( pos , i , - 1 ) :\n            arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ]\n        k -= pos - i"}
{"id": "LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING", "code": "def lexicographicSubConcat ( s ) :\n    n = len ( s )\n    sub_count = ( n * ( n + 1 ) ) // 2\n    arr = [ 0 ] * sub_count\n    index = 0\n    for i in range ( n ) :\n        for j in range ( 1 , n - i + 1 ) :\n            arr [ index ] = s [ i : i + j ]\n            index += 1\n    arr.sort ( )\n    res = \"\"\n    for i in range ( sub_count ) :\n        res += arr [ i ]\n    return res"}
{"id": "LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED", "code": "def lcs ( dp , arr1 , n , arr2 , m , k ) :\n    if k < 0 :\n        return - ( 10 ** 7 )\n    if n < 0 or m < 0 :\n        return 0\n    ans = dp [ n ] [ m ] [ k ]\n    if ans != - 1 :\n        return ans\n    ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) )\n    if arr1 [ n - 1 ] == arr2 [ m - 1 ] :\n        ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) )\n    ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) )\n    return ans"}
{"id": "LONGEST_COMMON_SUBSTRING", "code": "def LCSubStr ( X , Y , m , n ) :\n    LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ]\n    result = 0\n    for i in range ( m + 1 ) :\n        for j in range ( n + 1 ) :\n            if ( i == 0 or j == 0 ) :\n                LCSuff [ i ] [ j ] = 0\n            elif ( X [ i - 1 ] == Y [ j - 1 ] ) :\n                LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1\n                result = max ( result , LCSuff [ i ] [ j ] )\n            else :\n                LCSuff [ i ] [ j ] = 0\n    return result"}
{"id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF", "code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n , 2 ) :\n            length = j - i + 1\n            leftsum = 0\n            rightsum = 0\n            for k in range ( 0 , int ( length / 2 ) ) :\n                leftsum += ( int ( str [ i + k ] ) - int ( '0' ) )\n                rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) )\n            if ( leftsum == rightsum and maxlen < length ) :\n                maxlen = length\n    return maxlen"}
{"id": "LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1", "code": "def findLength ( string ) :\n    n = len ( string )\n    maxlen = 0\n    Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( 0 , n ) :\n        Sum [ i ] [ i ] = int ( string [ i ] )\n    for length in range ( 2 , n + 1 ) :\n        for i in range ( 0 , n - length + 1 ) :\n            j = i + length - 1\n            k = length // 2\n            Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] )\n            if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) :\n                maxlen = length\n    return maxlen"}
{"id": "LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE", "code": "def longOddEvenIncSeq ( arr , n ) :\n    lioes = list ( )\n    maxLen = 0\n    for i in range ( n ) :\n        lioes.append ( 1 )\n    i = 1\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) :\n                lioes [ i ] = lioes [ j ] + 1\n    for i in range ( n ) :\n        if maxLen < lioes [ i ] :\n            maxLen = lioes [ i ]\n    return maxLen"}
{"id": "LONGEST_INCREASING_SUBSEQUENCE_1", "code": "def lis ( arr , n ) :\n    lis = [ 1 ] * n\n    for i in range ( 1 , n ) :\n        for j in range ( 0 , i ) :\n            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :\n                lis [ i ] = lis [ j ] + 1\n    maximum = 0\n    for i in range ( n ) :\n        maximum = max ( maximum , lis [ i ] )\n    return maximum"}
{"id": "LONGEST_PREFIX_ALSO_SUFFIX_1", "code": "def longestPrefixSuffix ( s ) :\n    n = len ( s )\n    lps = [ 0 ] * n\n    l = 0\n    i = 1\n    while ( i < n ) :\n        if ( s [ i ] == s [ l ] ) :\n            l = l + 1\n            lps [ i ] = l\n            i = i + 1\n        else :\n            if ( l != 0 ) :\n                l = lps [ l - 1 ]\n            else :\n                lps [ i ] = 0\n                i = i + 1\n    res = lps [ n - 1 ]\n    if ( res > n / 2 ) :\n        return n // 2\n    else :\n        return res"}
{"id": "LONGEST_REPEATED_SUBSEQUENCE_1", "code": "def longestRepeatedSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    res = ''\n    i = n\n    j = n\n    while ( i > 0 and j > 0 ) :\n        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) :\n            res += str [ i - 1 ]\n            i -= 1\n            j -= 1\n        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :\n            i -= 1\n        else :\n            j -= 1\n    res = ''.join ( reversed ( res ) )\n    return res"}
{"id": "LONGEST_REPEATING_SUBSEQUENCE", "code": "def findLongestRepeatingSubSeq ( str ) :\n    n = len ( str )\n    dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 )\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    return dp [ n ] [ n ]"}
{"id": "LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S", "code": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if arr [ i ] == 0 :\n            sum += - 1\n        else :\n            sum += 1\n        if ( sum == 1 ) :\n            maxLen = i + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n    return maxLen"}
{"id": "LONGEST_SUBARRAY_SUM_DIVISIBLE_K", "code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    for i in range ( n ) :\n        curr_sum += arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k\n    for i in range ( n ) :\n        if ( mod_arr [ i ] == 0 ) :\n            max = i + 1\n        elif ( mod_arr [ i ] in um ) :\n            um [ mod_arr [ i ] ] = i\n        else :\n            if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                max = i - um [ mod_arr [ i ] ]\n    return max"}
{"id": "LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2", "code": "def longLenSub ( arr , n ) :\n    um = defaultdict ( lambda : 0 )\n    longLen = 0\n    for i in range ( n ) :\n        len1 = 0\n        if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) :\n            len1 = um [ arr [ i ] - 1 ]\n        if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) :\n            len1 = um [ arr [ i ] + 1 ]\n        um [ arr [ i ] ] = len1 + 1\n        if longLen < um [ arr [ i ] ] :\n            longLen = um [ arr [ i ] ]\n    return longLen"}
{"id": "LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE", "code": "def longestSubseqWithDiffOne ( arr , n ) :\n    dp = [ 1 for i in range ( n ) ]\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) :\n                dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 )\n    result = 1\n    for i in range ( n ) :\n        if ( result < dp [ i ] ) :\n            result = dp [ i ]\n    return result"}
{"id": "LOWER_CASE_UPPER_CASE_INTERESTING_FACT", "code": "def to_upper(in_list):\n    for i in range(len(in_list)):\n        if 'a' <= in_list[i] <= 'z':\n            in_list[i] = chr(ord(in_list[i]) - ord('a') + ord('A'))\n    return ''.join(in_list)"}
{"id": "MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS", "code": "def maximumPalinUsingKChanges ( str , k ) :\n    palin = list(str)\n    l = 0\n    r = len ( str ) - 1\n    while ( l <= r ) :\n        if ( str [ l ] != str [ r ] ) :\n            palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] )\n            k -= 1\n        l += 1\n        r -= 1\n    if ( k < 0 ) :\n        return \"Not possible\"\n    l = 0\n    r = len ( str ) - 1\n    while ( l <= r ) :\n        if ( l == r ) :\n            if ( k > 0 ) :\n                palin [ l ] = '9'\n        if ( palin [ l ] < '9' ) :\n            if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) :\n                k -= 1\n                palin [ l ] = palin [ r ] = '9'\n            elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) ) :\n                k -= 1\n                palin [ l ] = palin [ r ] = '9'\n        l += 1\n        r -= 1\n    return \"\".join(palin)"}
{"id": "MARKOV_MATRIX", "code": "def checkMarkov ( m ) :\n    for i in range ( 0 , len ( m ) ) :\n        sm = 0\n        for j in range ( 0 , len ( m [ i ] ) ) :\n            sm = sm + m [ i ] [ j ]\n        if ( sm != 1 ) :\n            return False\n    return True"}
{"id": "MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER", "code": "def findMaxVal ( arr , n , num , maxLimit ) :\n    ind = - 1\n    val = - 1\n    dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ]\n    for ind in range ( n ) :\n        for val in range ( maxLimit + 1 ) :\n            if ( ind == 0 ) :\n                if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) :\n                    dp [ ind ] [ val ] = 1\n                else :\n                    dp [ ind ] [ val ] = 0\n            else :\n                if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) :\n                    if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) :\n                        dp [ ind ] [ val ] = 1\n                elif ( val - arr [ ind ] >= 0 ) :\n                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ]\n                elif ( val + arr [ ind ] <= maxLimit ) :\n                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ]\n                else :\n                    dp [ ind ] [ val ] = 0\n    for val in range ( maxLimit , - 1 , - 1 ) :\n        if ( dp [ n - 1 ] [ val ] == 1 ) :\n            return val\n    return - 1"}
{"id": "MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L", "code": "def findMaxValue ( arr , n ) :\n    if n < 4 :\n        print ( \"The array should have atlest 4 elements\" )\n        return MIN\n    table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n\n    table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] )\n    for i in range ( n - 3 , - 1 , - 1 ) :\n        table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] )\n    for i in range ( n - 4 , - 1 , - 1 ) :\n        table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] )\n    return table4 [ 0 ]"}
{"id": "MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1", "code": "def maxvolume ( s ) :\n    length = s // 3 \n    s -= length\n    breadth = s // 2\n    height = s - breadth\n    return int ( length * breadth * height )"}
{"id": "MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY", "code": "def findArea ( arr , n ) :\n    arr.sort ( reverse = True )\n    dimension = [ 0 , 0 ]\n    i = 0\n    j = 0\n    while ( i < n - 1 and j < 2 ) :\n        if ( arr [ i ] == arr [ i + 1 ] ) :\n            dimension [ j ] = arr [ i ]\n            j += 1\n            i += 1\n        i += 1\n    return ( dimension [ 0 ] * dimension [ 1 ] )"}
{"id": "MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY", "code": "def largestSumOfAverages ( A , K ) :\n    n = len ( A )\n    pre_sum = [ 0 ] * ( n + 1 )\n    pre_sum [ 0 ] = 0\n    for i in range ( n ) :\n        pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ]\n    dp = [ 0 ] * n\n    sum = 0\n    for i in range ( n ) :\n        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i )\n    for k in range ( K - 1 ) :\n        for i in range ( n ) :\n            for j in range ( i + 1 , n ) :\n                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] )\n    return  dp [ 0 ]"}
{"id": "MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE", "code": "def maxcoefficientvalue ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )\n    maxvalue = 0\n    for i in range ( n + 1 ) :\n        maxvalue = max ( maxvalue , C [ n ] [ i ] )\n    return maxvalue"}
{"id": "MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY", "code": "def findLongestConseqSubseq ( arr , n ) :\n    S = set ( )\n    for i in range ( n ) :\n        S.add ( arr [ i ] )\n    ans = 0\n    for i in range ( n ) :\n        if S.__contains__ ( arr [ i ] ) :\n            j = arr [ i ]\n            while ( S.__contains__ ( j ) ) :\n                j += 1\n            ans = max ( ans , j - arr [ i ] )\n    return ans"}
{"id": "MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1", "code": "def maxRepeating ( str ) :\n    n = len ( str )\n    count = 0\n    res = str [ 0 ]\n    cur_count = 1\n    for i in range ( n ) :\n        if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) :\n            cur_count += 1\n        else :\n            if cur_count > count :\n                count = cur_count\n                res = str [ i ]\n            cur_count = 1\n    return res"}
{"id": "MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER", "code": "def maxdiff ( arr , n ) :\n    freq = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        freq [ arr [ i ] ] += 1\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] :\n                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )\n            elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :\n                ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )\n    return ans"}
{"id": "MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX", "code": "def maxRowDiff ( mat , m , n ) :\n    rowSum = [ 0 ] * m\n    for i in range ( 0 , m ) :\n        sum = 0\n        for j in range ( 0 , n ) :\n            sum += mat [ i ] [ j ]\n        rowSum [ i ] = sum\n    max_diff = rowSum [ 1 ] - rowSum [ 0 ]\n    min_element = rowSum [ 0 ]\n    for i in range ( 1 , m ) :\n        if ( rowSum [ i ] - min_element > max_diff ) :\n            max_diff = rowSum [ i ] - min_element\n        if ( rowSum [ i ] < min_element ) :\n            min_element = rowSum [ i ]\n    return max_diff"}
{"id": "MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY", "code": "def maxDistance ( arr , n ) :\n    mp = { }\n    maxDict = 0\n    for i in range ( n ) :\n        if arr [ i ] not in mp.keys ( ) :\n            mp [ arr [ i ] ] = i\n        else :\n            maxDict = max ( maxDict , i - mp [ arr [ i ] ] )\n    return maxDict"}
{"id": "MAXIMUM_GAMES_PLAYED_WINNER", "code": "def maxGameByWinner ( N ) :\n    dp = [ 0 for i in range ( N ) ]\n    dp [ 0 ] = 1\n    dp [ 1 ] = 2\n    i = 1\n    while dp [ i ] <= N :\n        i = i + 1\n        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]\n    return ( i - 1 )"}
{"id": "MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER", "code": "def maxPrefix ( s , t ) :\n    count = 0\n    for i in range ( 0 , len ( t ) ) :\n        if ( count == len ( s ) ) :\n            break\n        if ( t [ i ] == s [ count ] ) :\n            count = count + 1\n    return count"}
{"id": "MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1", "code": "def maxLenSub ( arr , n ) :\n    mls = [ ]\n    max = 0\n    for i in range ( n ) :\n        mls.append ( 1 )\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) :\n                mls [ i ] = mls [ j ] + 1\n    for i in range ( n ) :\n        if ( max < mls [ i ] ) :\n            max = mls [ i ]\n    return max"}
{"id": "MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS", "code": "def maxNumOfChocolates ( arr , n , k ) :\n    um , curr_rem , maxSum = { } , 0 , 0\n    sm = [ 0 ] * n\n    sm [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        sm [ i ] = sm [ i - 1 ] + arr [ i ]\n    for i in range ( n ) :\n        curr_rem = sm [ i ] % k\n        if ( not curr_rem and maxSum < sm [ i ] ) :\n            maxSum = sm [ i ]\n        elif ( not curr_rem in um ) :\n            um [ curr_rem ] = i\n        elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :\n            maxSum = sm [ i ] - sm [ um [ curr_rem ] ]\n    return maxSum // k"}
{"id": "MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_ISOSCELES_TRIANGLE", "code": "def maxSquare ( b , m ) :\n    return ( b // m - 1 ) * ( b // m ) // 2"}
{"id": "MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C", "code": "def maximumSegments ( n , a , b , c ) :\n    dp = [ - 1 ] * ( n + 10 )\n    dp [ 0 ] = 0\n    for i in range ( 0 , n ) :\n        if ( dp [ i ] != - 1 ) :\n            if ( i + a <= n ) :\n                dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] )\n            if ( i + b <= n ) :\n                dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] )\n            if ( i + c <= n ) :\n                dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] )\n    return dp [ n ]"}
{"id": "MAXIMUM_POINTS_INTERSECTION_N_CIRCLES", "code": "def intersection ( n ) :\n    return n * ( n - 1 )"}
{"id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY", "code": "def maxDiff ( arr , n ) :\n    SubsetSum_1 = 0\n    SubsetSum_2 = 0\n    for i in range ( 0 , n ) :\n        isSingleOccurance = True\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] == arr [ j ] ) :\n                isSingleOccurance = False\n                arr [ i ] = arr [ j ] = 0\n                break\n        if ( isSingleOccurance == True ) :\n            if ( arr [ i ] > 0 ) :\n                SubsetSum_1 += arr [ i ]\n            else :\n                SubsetSum_2 += arr [ i ]\n    return abs ( SubsetSum_1 - SubsetSum_2 )"}
{"id": "MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1", "code": "def maxDiff ( arr , n ) :\n    result = 0\n    arr.sort ( )\n    i = 0\n    while i < n-1:\n        if ( arr [ i ] !=  arr [ i + 1 ] ) :\n            result += abs ( arr [ i ] )\n        else:\n            i += 1\n        i += 1\n    if ( arr [ n - 2 ] != arr [ n - 1 ] ) :\n        result += abs ( arr [ n - 1 ] )\n    return result"}
{"id": "MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE", "code": "def returnMaxSum ( A , B , n ) :\n    mp = set ( )\n    result = 0\n    curr_sum = curr_begin = 0\n    for i in range ( 0 , n ) :\n        while A [ i ] in mp :\n            mp.remove ( A [ curr_begin ] )\n            curr_sum -= B [ curr_begin ]\n            curr_begin += 1\n        mp.add ( A [ i ] )\n        curr_sum += B [ i ]\n        result = max ( result , curr_sum )\n    return result"}
{"id": "MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE", "code": "def lis ( arr , n ) :\n    mpis = [ 0 ] * ( n )\n    for i in range ( n ) :\n        mpis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) :\n                mpis [ i ] = mpis [ j ] * arr [ i ]\n    return max ( mpis )"}
{"id": "MAXIMUM_PRODUCT_SUBSET_ARRAY", "code": "def maxProductSubset ( a , n ) :\n    if n == 1 :\n        return a [ 0 ]\n    max_neg = - 999999999999\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( n ) :\n        if a [ i ] == 0 :\n            count_zero += 1\n            continue\n        if a [ i ] < 0 :\n            count_neg += 1\n            max_neg = max ( max_neg , a [ i ] )\n        prod = prod + a [ i ]\n    if count_zero == n :\n        return 0\n    if count_neg & 1 :\n        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :\n            return 0\n        prod = int(prod / max_neg)\n    return prod"}
{"id": "MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE", "code": "def maxProfit ( price , n ) :\n    profit = [ 0 ] * n\n    max_price = price [ n - 1 ]\n    for i in range ( n - 2 , 0 , - 1 ) :\n        if price [ i ] > max_price :\n            max_price = price [ i ]\n        profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] )\n    min_price = price [ 0 ]\n    for i in range ( 1 , n ) :\n        if price [ i ] < min_price :\n            min_price = price [ i ]\n        profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) )\n    result = profit [ n - 1 ]\n    return result"}
{"id": "MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION", "code": "def maxSubArraySumRepeated ( a , n , k ) :\n    max_so_far = - 2147483648\n    max_ending_here = 0\n    for i in range ( n * k ) :\n        max_ending_here = max_ending_here + a [ i % n ]\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0\n    return max_so_far"}
{"id": "MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM", "code": "def maximumSumSubarray ( arr , n ) :\n    min_prefix_sum = 0\n    res = - math.inf\n    prefix_sum = [ ]\n    prefix_sum.append ( arr [ 0 ] )\n    for i in range ( 1 , n ) :\n        prefix_sum.append ( prefix_sum [ i - 1 ] + arr [ i ] )\n    for i in range ( n ) :\n        res = max ( res , prefix_sum [ i ] - min_prefix_sum )\n        min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] )\n    return res"}
{"id": "MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE", "code": "def maxSumWO3Consec ( arr , n ) :\n    sum = [ 0 for k in range ( n ) ]\n    if n >= 1 :\n        sum [ 0 ] = arr [ 0 ]\n    if n >= 2 :\n        sum [ 1 ] = arr [ 0 ] + arr [ 1 ]\n    if n > 2 :\n        sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) )\n    for i in range ( 3 , n ) :\n        sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] )\n    return sum [ n - 1 ]"}
{"id": "MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT", "code": "def maxSum ( grid , n ) :\n    incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] )\n    excl = 0\n    for i in range ( 1 , n ) :\n        excl_new = max ( excl , incl )\n        incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] )\n        excl = excl_new\n    return max ( excl , incl )"}
{"id": "MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM", "code": "def maxAlternateSum ( arr , n ) :\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    dec = [ 0 for i in range ( n + 1 ) ]\n    inc = [ 0 for i in range ( n + 1 ) ]\n    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]\n    flag = 0\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ j ] > arr [ i ] ) :\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = 1\n            elif ( arr [ j ] < arr [ i ] and flag == 1 ) :\n                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n    result = - 2147483648\n    for i in range ( n ) :\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n    return result"}
{"id": "MAXIMUM_SUM_BITONIC_SUBARRAY", "code": "def maxSumBitonicSubArr ( arr , n ) :\n    msis = [ None ] * n\n    msds = [ None ] * n\n    max_sum = 0\n    msis [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] > arr [ i - 1 ] ) :\n            msis [ i ] = msis [ i - 1 ] + arr [ i ]\n        else :\n            msis [ i ] = arr [ i ]\n    msds [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] > arr [ i + 1 ] ) :\n            msds [ i ] = msds [ i + 1 ] + arr [ i ]\n        else :\n            msds [ i ] = arr [ i ]\n    for i in range ( n ) :\n        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :\n            max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] )\n    return max_sum"}
{"id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY", "code": "def maxSum ( arr , n ) :\n    res = - sys.maxsize\n    for i in range ( 0 , n ) :\n        curr_sum = 0\n        for j in range ( 0 , n ) :\n            index = int ( ( i + j ) % n )\n            curr_sum += j * arr [ index ]\n        res = max ( res , curr_sum )\n    return res"}
{"id": "MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1", "code": "def maxSum ( arr , n ) :\n    cum_sum = 0\n    for i in range ( 0 , n ) :\n        cum_sum += arr [ i ]\n    curr_val = 0\n    for i in range ( 0 , n ) :\n        curr_val += i * arr [ i ]\n    res = curr_val\n    for i in range ( 1 , n ) :\n        next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) )\n        curr_val = next_val\n        res = max ( res , next_val )\n    return res"}
{"id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE", "code": "def maxSumPairWithDifferenceLessThanK ( arr , N , K ) :\n    arr.sort ( )\n    dp = [ 0 ] * N\n    dp [ 0 ] = 0\n    for i in range ( 1 , N ) :\n        dp [ i ] = dp [ i - 1 ]\n        if ( arr [ i ] - arr [ i - 1 ] < K ) :\n            if ( i >= 2 ) :\n                dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] )\n            else :\n                dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] )\n    return dp [ N - 1 ]"}
{"id": "MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1", "code": "def maxSumPairWithDifferenceLessThanK ( arr , N , k ) :\n    maxSum = 0\n    arr.sort ( )\n    i = N - 1\n    while ( i > 0 ) :\n        if ( arr [ i ] - arr [ i - 1 ] < k ) :\n            maxSum += arr [ i ]\n            maxSum += arr [ i - 1 ]\n            i -= 1\n        i -= 1\n    return maxSum"}
{"id": "MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT", "code": "def maxSumSubarrayRemovingOneEle ( arr , n ) :\n    fw = [ 0 for k in range ( n ) ]\n    bw = [ 0 for k in range ( n ) ]\n    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]\n    for i in range (1, n ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        fw [ i ] = cur_max\n    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]\n    i = n - 2\n    while i >= 0 :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        bw [ i ] = cur_max\n        i -= 1\n    fans = max_so_far\n    for i in range ( 1 , n - 1 ) :\n        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )\n    return fans"}
{"id": "MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS", "code": "def maxSum ( arr , N , k ) :\n    MS = [ 0 for i in range ( N ) ]\n    MS [ N - 1 ] = arr [ N - 1 ]\n    for i in range ( N - 2 , - 1 , - 1 ) :\n        if ( i + k + 1 >= N ) :\n            MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] )\n        else :\n            MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] )\n    return MS [ 0 ]"}
{"id": "MAXIMUM_TRIPLET_SUM_ARRAY", "code": "def maxTripletSum ( arr , n ) :\n    sm = - 1000000\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            for k in range ( j + 1 , n ) :\n                if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) :\n                    sm = arr [ i ] + arr [ j ] + arr [ k ]\n    return sm"}
{"id": "MAXIMUM_TRIPLET_SUM_ARRAY_1", "code": "def maxTripletSum ( arr , n ) :\n    arr.sort ( )\n    return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )"}
{"id": "MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING", "code": "def maxDP ( n ) :\n    res = list ( )\n    res.append ( 0 )\n    res.append ( 1 )\n    i = 2\n    while i < n + 1 :\n        res.append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) )\n        i = i + 1\n    return res [ n ]"}
{"id": "MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX", "code": "def maxCost ( mat , N ) :\n    dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ]\n    dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]\n    for i in range ( 1 , N ) :\n        dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ]\n    for i in range ( 1 , N ) :\n        for j in range ( 1 , min ( i + 1 , N ) ) :\n            dp [ i ] [ j ] = mat [ i ] [ j ] + \\\n                max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    result = 0\n    for i in range ( N ) :\n        if ( result < dp [ N - 1 ] [ i ] ) :\n            result = dp [ N - 1 ] [ i ]\n    return result"}
{"id": "MEDIAN_OF_TWO_SORTED_ARRAYS", "code": "def getMedian ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count += 1\n        if i == n :\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        elif j == n :\n            m1 = m2\n            m2 = ar1 [ 0 ]\n            break\n        if ar1 [ i ] < ar2 [ j ] :\n            m1 = m2\n            m2 = ar1 [ i ]\n            i += 1\n        else :\n            m1 = m2\n            m2 = ar2 [ j ]\n            j += 1\n    return int(( m1 + m2 ) / 2)"}
{"id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS", "code": "def middleOfThree ( a , b , c ) :\n    if ( ( a < b and b < c ) or ( c < b and b < a ) ) :\n        return b\n    if ( ( b < a and a < c ) or ( c < a and a < b ) ) :\n        return a\n    else :\n        return c"}
{"id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1", "code": "def middleOfThree ( a , b , c ) :\n    if a > b :\n        if ( b > c ) :\n            return b\n        elif ( a > c ) :\n            return c\n        else :\n            return a\n    else :\n        if ( a > c ) :\n            return a\n        elif ( b > c ) :\n            return c\n        else :\n            return b"}
{"id": "MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2", "code": "def middleOfThree ( a , b , c ) :\n    x = a - b\n    y = b - c\n    z = a - c\n    if x * y > 0 :\n        return b\n    elif ( x * z > 0 ) :\n        return c\n    else :\n        return a"}
{"id": "MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED", "code": "def minValue ( A , B , n ) :\n    sorted ( A )\n    sorted ( B )\n    result = 0\n    for i in range ( n ) :\n        result += ( A [ i ] * B [ n - i - 1 ] )\n    return result"}
{"id": "MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS", "code": "def getMinDiff ( arr , n , k ) :\n    if ( n == 1 ) :\n        return 0\n    arr.sort ( )\n    ans = arr [ n - 1 ] - arr [ 0 ]\n    small = arr [ 0 ] + k\n    big = arr [ n - 1 ] - k\n    if ( small > big ) :\n        small , big = big , small\n    for i in range ( 1 , n - 1 ) :\n        subtract = arr [ i ] - k\n        add = arr [ i ] + k\n        if ( subtract >= small or add <= big ) :\n            continue\n        if ( big - subtract <= add - small ) :\n            small = subtract\n        else :\n            big = add\n    return min ( ans , big - small )"}
{"id": "MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N", "code": "def minSum ( n ) :\n    sum = 0\n    while ( n > 0 ) :\n        sum += ( n % 10 )\n        n //= 10\n    if ( sum == 1 ) :\n        return 10\n    return sum"}
{"id": "MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY", "code": "def minimum_cost ( a , n ) :\n    mn = sys.maxsize\n    sum = 0\n    for i in range ( n ) :\n        mn = min ( a [ i ] , mn )\n        sum += a [ i ]\n    return mn * ( sum - mn )"}
{"id": "MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS", "code": "def cost ( a , n ) :\n    return ( ( n - 1 ) * min ( a ) )"}
{"id": "MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K", "code": "def solve ( X , Y , l , r , k , dp ) :\n    if k == 0 :\n        return 0\n    if l < 0 or r < 0 :\n        return 1000000000\n    if dp [ l ] [ r ] [ k ] != - 1 :\n        return dp [ l ] [ r ] [ k ]\n    cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) )\n    dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] )\n    return dp [ l ] [ r ] [ k ]"}
{"id": "MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1", "code": "def calculateEnergy ( mat , n ) :\n    tot_energy = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            q = mat [ i ] [ j ] // n\n            i_des = q\n            j_des = mat [ i ] [ j ] - ( n * q )\n            tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) )\n    return tot_energy"}
{"id": "MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG", "code": "def MinimumCost ( cost , n , W ) :\n    val = list ( )\n    wt = list ( )\n    size = 0\n    for i in range ( n ) :\n        if ( cost [ i ] != - 1 ) :\n            val.append ( cost [ i ] )\n            wt.append ( i + 1 )\n            size += 1\n    n = size\n    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( W + 1 ) :\n        min_cost [ 0 ] [ i ] = INF\n    for i in range ( 1 , n + 1 ) :\n        min_cost [ i ] [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , W + 1 ) :\n            if ( wt [ i - 1 ] > j ) :\n                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]\n            else :\n                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )\n    if ( min_cost [ n ] [ W ] == INF ) :\n        return - 1\n    else :\n        return min_cost [ n ] [ W ]"}
{"id": "MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1", "code": "def minimumflip ( mat , n ) :\n    flip = 0\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if mat [ i ] [ j ] != mat [ j ] [ i ] :\n                flip += 1\n    return flip"}
{"id": "MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL", "code": "def minOps ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    for i in range ( 0 , n ) :\n        if ( ( max1 - arr [ i ] ) % k != 0 ) :\n            return - 1\n        else :\n            res += ( max1 - arr [ i ] ) / k\n    return int ( res )"}
{"id": "MINIMUM_INSERTIONS_SORT_ARRAY", "code": "def minInsertionStepToSortArray ( arr , N ) :\n    lis = [ 0 ] * N\n    for i in range ( N ) :\n        lis [ i ] = 1\n    for i in range ( 1 , N ) :\n        for j in range ( i ) :\n            if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) :\n                lis [ i ] = lis [ j ] + 1\n    max = 0\n    for i in range ( N ) :\n        if ( max < lis [ i ] ) :\n            max = lis [ i ]\n    return ( N - max )"}
{"id": "MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1", "code": "def smallestSubWithSum ( arr , n , x ) :\n    curr_sum = 0\n    min_len = n + 1\n    start = 0\n    end = 0\n    while ( end < n ) :\n        while ( curr_sum <= x and end < n ) :\n            if ( curr_sum <= 0 and x > 0 ) :\n                start = end\n                curr_sum = 0\n            curr_sum += arr [ end ]\n            end += 1\n        while ( curr_sum > x and start < n ) :\n            if ( end - start < min_len ) :\n                min_len = end - start\n            curr_sum -= arr [ start ]\n            start += 1\n    return min_len"}
{"id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1", "code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 ) or ( arr [ 0 ] == 0 ) :\n        return float ( 'inf' )\n    jumps [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        jumps [ i ] = float ( 'inf' )\n        for j in range ( i ) :\n            if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) :\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n    return jumps [ n - 1 ]"}
{"id": "MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2", "code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = float ( 'inf' )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( 'inf' )\n            for j in range ( i + 1 , n ) :\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n            if ( min != float ( 'inf' ) ) :\n                jumps [ i ] = min + 1\n            else :\n                jumps [ i ] = min\n    return jumps [ 0 ]"}
{"id": "MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1", "code": "def getMinSquares ( n ) :\n    dp = [ 0 , 1 , 2 , 3 ]\n    for i in range ( 4 , n + 1 ) :\n        dp.append ( i )\n        for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) :\n            temp = x * x ;\n            if temp > i :\n                break\n            else :\n                dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )\n    return dp [ n ]"}
{"id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS", "code": "def subset ( ar , n ) :\n    res = 0\n    ar.sort ( )\n    i = 0\n    while i < n:\n        count = 1\n        j = i\n        while j < n - 1:\n            if ar [ j ] == ar [ j + 1 ] :\n                count += 1\n            else :\n                break\n            j += 1\n        i = j\n        i += 1\n        res = max ( res , count )\n    return res"}
{"id": "MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1", "code": "def subset ( arr , n ) :\n    maxv = max(arr)\n    minv = min(arr)\n    mp = { i : 0 for i in range ( minv, maxv+1 ) }\n    for i in range ( n ) :\n        mp [ arr [ i ] ] += 1\n    res = 0\n    for key , value in mp.items ( ) :\n        res = max ( res , value )\n    return res"}
{"id": "MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY", "code": "def minOperation ( arr , n ) :\n    Hash = defaultdict ( lambda : 0 )\n    for i in range ( 0 , n ) :\n        Hash [ arr [ i ] ] += 1\n    max_count = 0\n    for i in Hash :\n        if max_count < Hash [ i ] :\n            max_count = Hash [ i ]\n    return n - max_count"}
{"id": "MINIMUM_PERIMETER_N_BLOCKS", "code": "def minPerimeter ( n ) :\n    l = int ( math.sqrt ( n ) )\n    sq = l * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = int ( n / l )\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter"}
{"id": "MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS", "code": "def minProduct(arr, n, k):\n    pq = []\n    for i in range(n):\n        heapq.heappush(pq, arr[i])\n    count = 0\n    ans = 1\n    while pq and count < k:\n        ans += heapq.heappop(pq)\n        count += 1\n    return ans"}
{"id": "MINIMUM_PRODUCT_SUBSET_ARRAY", "code": "def minProductSubset ( a , n ) :\n    if ( n == 1 ) :\n        return a [ 0 ]\n    max_neg = float ( '-inf' )\n    min_pos = float ( 'inf' )\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( 0 , n ) :\n        if ( a [ i ] == 0 ) :\n            count_zero = count_zero + 1\n            continue\n        if ( a [ i ] < 0 ) :\n            count_neg = count_neg + 1\n            max_neg = max ( max_neg , a [ i ] )\n        if ( a [ i ] > 0 ) :\n            min_pos = min ( min_pos , a [ i ] )\n        prod = prod * a [ i ]\n    if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) :\n        return 0\n    if ( count_neg == 0 ) :\n        return min_pos\n    if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) :\n        prod = int ( prod / max_neg )\n    return prod"}
{"id": "MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE", "code": "def findMinRooms ( slots , n , m ) :\n    counts = [ 0 ] * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if i < len(slots) and j < len(slots[i]):\n                if ( slots [ i ] [ j ] == '1' ) :\n                    counts [ j ] += 1\n    return max ( counts )"}
{"id": "MINIMUM_ROTATIONS_REQUIRED_GET_STRING", "code": "def findRotations ( str ) :\n    tmp = str + str\n    n = len ( str )\n    for i in range ( 1 , n + 1 ) :\n        substring = tmp [ i : n ]\n        if ( str == substring ) :\n            return i\n    return n"}
{"id": "MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK", "code": "def minRotation ( input , unlock_code ) :\n    rotation = 0\n    while ( input > 0 or unlock_code > 0 ) :\n        input_digit = input % 10\n        code_digit = unlock_code % 10\n        rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) )\n        input = int ( input / 10 )\n        unlock_code = int ( unlock_code / 10 )\n    return rotation"}
{"id": "MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION", "code": "def getMinSteps ( n ) :\n    table = [ 0 ] * ( n + 1 )\n    for i in range ( n + 1 ) :\n        table [ i ] = n - i\n    for i in range ( n , 0 , - 1 ) :\n        if ( not ( i % 2 ) ) :\n            table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] )\n        if ( not ( i % 3 ) ) :\n            table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] )\n    return table [ 1 ]"}
{"id": "MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY", "code": "def minSum ( A, n ) :\n    min_val = min ( A ) ;\n    return min_val * ( n - 1 )"}
{"id": "MINIMUM_SUM_PRODUCT_TWO_ARRAYS", "code": "def minproduct ( a , b , n , k ) :\n    diff = 0\n    res = 0\n    temp = 0\n    for i in range ( n ) :\n        pro = a [ i ] * b [ i ]\n        res = res + pro\n        if ( pro < 0 and b [ i ] < 0 ) :\n            temp = ( a [ i ] + 2 * k ) * b [ i ]\n        elif ( pro < 0 and a [ i ] < 0 ) :\n            temp = ( a [ i ] - 2 * k ) * b [ i ]\n        elif ( pro > 0 and a [ i ] < 0 ) :\n            temp = ( a [ i ] + 2 * k ) * b [ i ]\n        elif ( pro > 0 and a [ i ] > 0 ) :\n            temp = ( a [ i ] - 2 * k ) * b [ i ]\n        d = abs ( pro - temp )\n        if ( d > diff ) :\n            diff = d\n    return res - diff"}
{"id": "MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED", "code": "def minSum ( arr , n ) :\n    dp = [ 0 ] * n\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    if ( n == 2 ) :\n        return min ( arr [ 0 ] , arr [ 1 ] )\n    if ( n == 3 ) :\n        return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) )\n    if ( n == 4 ) :\n        return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) )\n    dp [ 0 ] = arr [ 0 ]\n    dp [ 1 ] = arr [ 1 ]\n    dp [ 2 ] = arr [ 2 ]\n    dp [ 3 ] = arr [ 3 ]\n    for i in range ( 4 , n ) :\n        dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) )\n    return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) )"}
{"id": "MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY", "code": "def solve ( arr , n ) :\n    arr.sort ( )\n    a = 0\n    b = 0\n    for i in range ( n ) :\n        if ( i % 2 != 0 ) :\n            a = a * 10 + arr [ i ]\n        else :\n            b = b * 10 + arr [ i ]\n    return a + b"}
{"id": "MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION", "code": "def minTimeForWritingChars ( N , insert , remove , copy ) :\n    if N == 0 :\n        return 0\n    if N == 1 :\n        return insert\n    dp = [ 0 ] * ( N + 1 )\n    for i in range ( 1 , N + 1 ) :\n        if i % 2 == 0 :\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy )\n        else :\n            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove )\n    return dp [ N ]"}
{"id": "MINIMUM_XOR_VALUE_PAIR", "code": "def minXOR ( arr , n ) :\n    min_xor = 999999\n    val = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            val = arr [ i ] ^ arr [ j ]\n            min_xor = min ( min_xor , val )\n    return min_xor"}
{"id": "MINIMUM_XOR_VALUE_PAIR_1", "code": "def minXOR ( arr , n ) :\n    arr = arr [ : n ]\n    arr.sort ( )\n    minXor = int ( sys.float_info.max )\n    val = 0\n    for i in range ( 0 , n - 1 ) :\n        val = arr [ i ] ^ arr [ i + 1 ]\n        minXor = min ( minXor , val )\n    return minXor"}
{"id": "MIRROR_CHARACTERS_STRING", "code": "def compute ( str , n ) :\n    reverseAlphabet = \"zyxwvutsrqponmlkjihgfedcba\"\n    l = len ( str )\n    answer = \"\"\n    for i in range ( 0 , n ) :\n        if i < l:\n            answer = answer + str [ i ]\n    for i in range ( n , l ) :\n        answer = ( answer + reverseAlphabet [ ord ( str [ i ] ) - ord ( \"a\" ) ] )\n    return answer"}
{"id": "MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC", "code": "def power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( ( y & 1 ) == 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res"}
{"id": "MODULUS_TWO_FLOAT_DOUBLE_NUMBERS", "code": "def findMod ( a , b ) :\n    if ( a < 0 ) :\n        a = - a\n    if ( b < 0 ) :\n        b = - b\n    mod = a\n    while ( mod >= b ) :\n        mod = mod - b\n    if ( a < 0 ) :\n        return - mod\n    return mod"}
{"id": "MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED", "code": "def segregateElements ( arr , n ) :\n    temp = [ 0 for k in range ( n ) ]\n    j = 0\n    for i in range ( n ) :\n        if ( arr [ i ] >= 0 ) :\n            temp [ j ] = arr [ i ]\n            j += 1\n    if ( j == n or j == 0 ) :\n        return\n    for i in range ( n ) :\n        if ( arr [ i ] < 0 ) :\n            temp [ j ] = arr [ i ]\n            j += 1\n    for k in range ( n ) :\n        arr [ k ] = temp [ k ]"}
{"id": "MULTIPLY_AN_INTEGER_WITH_3_5", "code": "def multiplyWith3Point5 ( x ) :\n    return ( x << 1 ) + x + ( x >> 1 )"}
{"id": "MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO", "code": "def moduloMultiplication ( a , b , mod ) :\n    res = 0 ;\n    a = a % mod ;\n    while ( b ) :\n        if ( b & 1 ) :\n            res = ( res + a ) % mod ;\n        a = ( 2 * a ) % mod ;\n        b >>= 1 ;\n    return res ;"}
{"id": "MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_OPERATORS_AND_NO_LOOPS", "code": "def multiply ( x , y ) :\n    if ( y == 0 ) :\n        return 0\n    if ( y > 0 ) :\n        return ( x + multiply ( x , y - 1 ) )\n    if ( y < 0 ) :\n        return - multiply ( x , - y )"}
{"id": "NEWMAN_CONWAY_SEQUENCE_1", "code": "def sequence ( n ) :\n    f = array.array ( 'i' , [ 0 , 1 , 1 ] )\n    for i in range ( 3 , n + 1 ) :\n        r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]\n        f.append ( r )\n    return f[n]"}
{"id": "NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS", "code": "def snoob ( x ) :\n    next = 0\n    if ( x ) :\n        rightOne = x & - ( x )\n        nextHigherOneBit = x + int ( rightOne )\n        rightOnesPattern = x ^ int ( nextHigherOneBit )\n        rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) )\n        rightOnesPattern = int ( rightOnesPattern ) >> 2\n        next = nextHigherOneBit | rightOnesPattern\n    return next"}
{"id": "NEXT_POWER_OF_2", "code": "def nextPowerOf2 ( n ) :\n    count = 0\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( n != 0 ) :\n        n >>= 1\n        count += 1\n    return 1 << count"}
{"id": "NEXT_POWER_OF_2_1", "code": "def nextPowerOf2 ( n ) :\n    p = 1\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( p < n ) :\n        p <<= 1\n    return p"}
{"id": "NEXT_POWER_OF_2_2", "code": "def nextPowerOf2 ( n ) :\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n"}
{"id": "NON_REPEATING_ELEMENT", "code": "def firstNonRepeating ( arr , n ) :\n    for i in range ( n ) :\n        j = 0\n        while ( j < n ) :\n            if ( i != j and arr [ i ] == arr [ j ] ) :\n                break\n            j += 1\n        if ( j == n ) :\n            return arr [ i ]\n    return - 1"}
{"id": "NON_REPEATING_ELEMENT_1", "code": "def firstNonRepeating ( arr , n ) :\n    mp = defaultdict ( lambda : 0 )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] += 1\n    for i in range ( n ) :\n        if mp [ arr [ i ] ] == 1 :\n            return arr [ i ]\n    return - 1"}
{"id": "NTH_EVEN_LENGTH_PALINDROME", "code": "def evenlength ( n ) :\n    res = n\n    for j in range ( len ( n ) - 1 , - 1 , - 1 ) :\n        res += n [ j ]\n    return res"}
{"id": "NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES", "code": "def findPosition ( k , n ) :\n    f1 = 0\n    f2 = 1\n    i = 2\n    while i != 0 :\n        f3 = f1 + f2\n        f1 = f2\n        f2 = f3\n        if f2 % k == 0 :\n            return n * i\n        i += 1\n    return"}
{"id": "NTH_NON_FIBONACCI_NUMBER", "code": "def nonFibonacci ( n ) :\n    prevPrev = 1\n    prev = 2\n    curr = 3\n    while n > 0 :\n        prevPrev = prev\n        prev = curr\n        curr = prevPrev + prev\n        n = n - ( curr - prev - 1 )\n    n = n + ( curr - prev - 1 )\n    return prev + n"}
{"id": "NTH_PENTAGONAL_NUMBER", "code": "def pentagonalNum ( n ) :\n    return ( 3 * n * n - n ) / 2"}
{"id": "NUMBER_DIGITS_PRODUCT_TWO_NUMBERS", "code": "def countDigits ( a , b ) :\n    count = 0\n    p = abs ( a * b )\n    if ( p == 0 ) :\n        return 1\n    while ( p > 0 ) :\n        count = count + 1\n        p = p // 10\n    return count"}
{"id": "NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1", "code": "def countDigits ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return 1\n    return math.floor ( math.log10 ( abs ( a ) ) + math.log10 ( abs ( b ) ) ) + 1"}
{"id": "NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3", "code": "def divisible ( num ) :\n    n = len ( num )\n    sum = 0\n    for i in range ( n ) :\n        sum += ord ( num [ i ] )\n    if ( sum % 3 == 0 ) :\n        return 0\n    if ( n == 1 ) :\n        return - 1\n    for i in range ( n ) :\n        if ( sum % 3 == ord ( num [ i ] ) % 3 ) :\n            return 1\n    if ( n == 2 ) :\n        return - 1\n    return 2"}
{"id": "NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE", "code": "def answer_query ( a , n , l , r ) :\n    count = 0\n    for i in range ( l , r ) :\n        if ( a [ i ] == a [ i + 1 ] ) :\n            count += 1\n    return count"}
{"id": "NUMBER_IS_DIVISIBLE_BY_29_OR_NOT", "code": "def isDivisible ( n ) :\n    while ( int ( n / 100 ) ) :\n        last_digit = int ( n % 10 )\n        n = int ( n / 10 )\n        n += last_digit * 3\n    return ( n % 29 == 0 )"}
{"id": "NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N", "code": "def countIntegralSolutions ( n ) :\n    result = 0\n    for i in range ( n + 1 ) :\n        for j in range ( n + 1 ) :\n            for k in range ( n + 1 ) :\n                if i + j + k == n :\n                    result += 1\n    return result"}
{"id": "NUMBER_N_DIGITS_NON_DECREASING_INTEGERS", "code": "def nonDecNums ( n ) :\n    a = np.zeros ( ( n + 1 , 10 ) )\n    for i in range ( 10 ) :\n        a [ 0 ] [ i ] = 1\n    for i in range ( 1 , n + 1 ) :\n        a [ i ] [ 9 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 8 , - 1 , - 1 ) :\n            a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ]\n    return int ( a [ n ] [ 0 ] )"}
{"id": "NUMBER_N_DIGIT_STEPPING_NUMBERS", "code": "def answer ( n ) :\n    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ]\n    if ( n == 1 ) :\n        return 10\n    for j in range ( 10 ) :\n        dp [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 10 ) :\n            if ( j == 0 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]\n            elif ( j == 9 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )\n    sum = 0\n    for j in range ( 1 , 10 ) :\n        sum = sum + dp [ n ] [ j ]\n    return sum"}
{"id": "NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT", "code": "def sumEqualProduct ( a , n ) :\n    zero = 0\n    two = 0\n    for i in range ( n ) :\n        if a [ i ] == 0 :\n            zero += 1\n        if a [ i ] == 2 :\n            two += 1\n    cnt = ( zero * ( zero - 1 ) ) // 2 + \\\n        ( two * ( two - 1 ) ) // 2\n    return cnt"}
{"id": "NUMBER_RECTANGLES_NM_GRID", "code": "def rectCount ( n , m ) :\n    return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4"}
{"id": "NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES", "code": "def countOccurrences ( s , K ) :\n    n = len ( s )\n    c1 = 0\n    c2 = 0\n    C = 0\n    for i in range ( n ) :\n        if s [ i ] == 'a' :\n            c1 += 1\n        if s [ i ] == 'b' :\n            c2 += 1\n            C += c1\n    return C * K + int ( K * ( K - 1 ) / 2 ) * c1 * c2"}
{"id": "NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N", "code": "def countDivisibleSubseq ( str , n ) :\n    l = len ( str )\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( l ) ]\n    dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1\n    for i in range ( 1 , l ) :\n        dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1\n        for j in range ( n ) :\n            dp [ i ] [ j ] += dp [ i - 1 ] [ j ]\n            dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ]\n    return dp [ l - 1 ] [ 0 ]"}
{"id": "NUMBER_SUBSTRINGS_STRING", "code": "def countNonEmptySubstr ( str ) :\n    n = len ( str )\n    return int ( n * ( n + 1 ) / 2 )"}
{"id": "NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES", "code": "def countRect ( n ) :\n    ans = 0\n    for length in range ( 1 , int ( math.sqrt ( n ) ) + 1 ) :\n        height = length\n        while ( height * length <= n ) :\n            ans += 1\n            height += 1\n    return ans"}
{"id": "NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER", "code": "def minimumBox ( arr , n ) :\n    q = collections.deque ( [ ] )\n    arr = arr [ : n ]\n    arr.sort ( )\n    q.append ( arr [ 0 ] )\n    for i in range ( 1 , n ) :\n        now = q [ 0 ]\n        if ( arr [ i ] >= 2 * now ) :\n            q.popleft ( )\n        q.append ( arr [ i ] )\n    return len ( q )"}
{"id": "NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS_IN_RANGE_M_TO_N", "code": "def maximumNumberDistinctPrimeRange ( m , n ) :\n    factorCount = [ 0 ] * ( n + 1 )\n    prime = [ False ] * ( n + 1 )\n    for i in range ( n + 1 ) :\n        factorCount [ i ] = 0\n        prime [ i ] = True\n    for i in range ( 2 , n + 1 ) :\n        if ( prime [ i ] == True ) :\n            factorCount [ i ] = 1\n            for j in range ( i * 2 , n + 1 , i ) :\n                factorCount [ j ] += 1\n                prime [ j ] = False\n    max = factorCount [ m ]\n    num = m\n    for i in range ( m , n + 1 ) :\n        if ( factorCount [ i ] > max ) :\n            max = factorCount [ i ]\n            num = i\n    return num"}
{"id": "N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN", "code": "def findNth ( n ) :\n    count = 0\n    for curr in itertools.count ( ) :\n        sum = 0\n        x = curr\n        while ( x ) :\n            sum = sum + x % 10\n            x = x // 10\n        if ( sum == 10 ) :\n            count = count + 1\n        if ( count == n ) :\n            return curr\n    return - 1"}
{"id": "N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2", "code": "def findNth ( n ) :\n    nthElement = 19 + ( n - 1 ) * 9\n    outliersCount = int ( math.log10 ( nthElement ) ) - 1\n    nthElement += 9 * outliersCount\n    return nthElement"}
{"id": "N_TH_ROOT_NUMBER", "code": "def nthRoot ( A , N ) :\n    random.seed ( 1 )\n    xPre = random.uniform ( 1 , 101 ) % 10\n    eps = 0.001\n    delX = 2147483647\n    xK = 0.0\n    while ( delX > eps ) :\n        xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N\n        delX = abs ( xK - xPre )\n        xPre = xK\n    return xK"}
{"id": "N_TH_TERM_SERIES_2_12_36_80_150", "code": "def nthTerm ( n ) :\n    return ( n * n ) + ( n * n * n )"}
{"id": "OVERLAPPING_SUM_TWO_ARRAY", "code": "def findSum ( A , B , n ) :\n    Hash = defaultdict ( lambda : 0 )\n    for i in range ( 0 , n ) :\n        Hash [ A [ i ] ] += 1\n        Hash [ B [ i ] ] += 1\n    Sum = 0\n    for x in Hash :\n        if Hash [ x ] == 1 :\n            Sum += x\n    return Sum"}
{"id": "PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1", "code": "def isProduct ( arr , n , x ) :\n    if n < 2 :\n        return False\n    s = set ( )\n    for i in range ( 0 , n ) :\n        if arr [ i ] == 0 :\n            if x == 0 :\n                return True\n            else :\n                continue\n        if x % arr [ i ] == 0 :\n            if x // arr [ i ] in s :\n                return True\n            s.add ( arr [ i ] )\n    return False"}
{"id": "PANGRAM_CHECKING", "code": "def checkPangram ( s ) :\n    List = [ ]\n    for i in range ( 26 ) :\n        List.append ( False )\n    for c in s :\n        if 'A' <= c and c <= 'Z':\n            List [ ord ( c ) - ord ( 'A' ) ] = True\n        elif 'a' <= c and c <= 'z':\n            List [ ord ( c ) - ord ( 'a' ) ] = True\n    for ch in List :\n        if ch == False :\n            return False\n    return True"}
{"id": "PAPER_CUT_MINIMUM_NUMBER_SQUARES", "code": "def minimumSquare ( a , b ) :\n    result = 0\n    rem = 0\n    if ( a < b ) :\n        a , b = b , a\n    while ( b > 0 ) :\n        result += int ( a / b )\n        rem = int ( a % b )\n        a = b\n        b = rem\n    return result"}
{"id": "PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM", "code": "def maxDifference ( arr , N , k ) :\n    S = 0\n    S1 = 0\n    max_difference = 0\n    for i in range ( N ) :\n        S += arr [ i ]\n    arr.sort ( reverse = True )\n    M = max ( k , N - k )\n    for i in range ( M ) :\n        S1 += arr [ i ]\n    max_difference = S1 - ( S - S1 )\n    return max_difference"}
{"id": "PATH_MAXIMUM_AVERAGE_VALUE", "code": "def maxAverageOfPath ( cost , N ) :\n    dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ]\n    dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]\n    for i in range ( 1 , N ) :\n        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ]\n    for j in range ( 1 , N ) :\n        dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ]\n    for i in range ( 1 , N ) :\n        for j in range ( 1 , N ) :\n            dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ]\n    return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )"}
{"id": "PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K", "code": "def isPossible ( a , b , n , k ) :\n    a = a [ : n ]\n    b = b [ : n ]\n    a.sort ( reverse = True )\n    b.sort ( )\n    for i in range ( n ) :\n        if ( a [ i ] + b [ i ] < k ) :\n            return False\n    return True"}
{"id": "PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES", "code": "def findMaximumPieces ( n ) :\n    return int ( 1 + n * ( n + 1 ) / 2 )"}
{"id": "POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS", "code": "def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) :\n    print ( \"Point inside the viewing pane:\" )\n    for i in range ( n ) :\n        if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) :\n            if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) :\n                print ( \"[\" , XY [ i ] [ 0 ] , \", \" , XY [ i ] [ 1 ] , \"]\" , sep = \"\" , end = \"\" )\n    print ( \"\\n\\nPoint outside the viewing pane:\" )\n    for i in range ( n ) :\n        if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) :\n            print ( \"[\" , XY [ i ] [ 0 ] , \", \" , XY [ i ] [ 1 ] , \"]\" , sep = \"\" , end = \"\" )\n        if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) ) :\n            print ( \"[\" , XY [ i ] [ 0 ] , \", \" , XY [ i ] [ 1 ] , \"]\" , sep = \"\" , end = \"\" )"}
{"id": "POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS", "code": "def rearrange ( a , size ) :\n    positive = 0\n    negative = 1\n    while ( True ) :\n        while ( positive < size and a [ positive ] >= 0 ) :\n            positive = positive + 2\n        while ( negative < size and a [ negative ] <= 0 ) :\n            negative = negative + 2\n        if ( positive < size and negative < size ) :\n            temp = a [ positive ]\n            a [ positive ] = a [ negative ]\n            a [ negative ] = temp\n        else :\n            break"}
{"id": "POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES", "code": "def isPossibleTriangle ( arr , N ) :\n    arr = arr [ : N ]\n    if N < 3 :\n        return False\n    arr.sort ( )\n    for i in range ( N - 2 ) :\n        if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :\n            return True\n    return False"}
{"id": "PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1", "code": "def isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    if ( n <= 3 ) :\n        return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    i = 5\n    while ( i * i <= n ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n        i = i + 6\n    return True"}
{"id": "PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES", "code": "def isPrime ( p ) :\n    checkNumber = 2 ** p - 1\n    nextval = 4 % checkNumber\n    for i in range ( 1 , p - 1 ) :\n        nextval = ( nextval * nextval - 2 ) % checkNumber\n    if ( nextval == 0 ) : return True\n    else : return False"}
{"id": "PRIME_NUMBERS", "code": "def isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    for i in range ( 2 , n ) :\n        if ( n % i == 0 ) :\n            return False\n    return True"}
{"id": "PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES", "code": "def noAdjacentDup ( s ) :\n    n = len ( s )\n    for i in range ( 1 , n ) :\n        if ( s [ i ] == s [ i - 1 ] ) :\n            s [ i ] = \"a\"\n            while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) :\n                s [ i ] += 1\n            i += 1\n    return s"}
{"id": "PRINT_MATRIX_ANTISPIRAL_FORM", "code": "def antiSpiralTraversal ( m , n , a ) :\n    k = 0\n    l = 0\n    stk = [ ]\n    while ( k <= m and l <= n ) :\n        for i in range ( l , n + 1 ) :\n            stk.append ( a [ k ] [ i ] )\n        k += 1\n        for i in range ( k , m + 1 ) :\n            stk.append ( a [ i ] [ n ] )\n        n -= 1\n        if ( k <= m ) :\n            for i in range ( n , l - 1 , - 1 ) :\n                stk.append ( a [ m ] [ i ] )\n            m -= 1\n        if ( l <= n ) :\n            for i in range ( m , k - 1 , - 1 ) :\n                stk.append ( a [ i ] [ l ] )\n            l += 1\n    while len ( stk ) != 0 :\n        print ( str ( stk [ - 1 ] ) , end = \" \" )\n        stk.pop ( )"}
{"id": "PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT", "code": "def printSpiral ( mat , r , c ) :\n    a = 0\n    b = 2\n    low_row = 0 if ( 0 > a ) else a\n    low_column = 0 if ( 0 > b ) else b - 1\n    high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1\n    high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1\n    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :\n        i = low_column + 1\n        while ( i <= high_column and i < c and low_row >= 0 ) :\n            print ( mat [ low_row ] [ i ] , end = \" \" )\n            i += 1\n        low_row -= 1\n        i = low_row + 2\n        while ( i <= high_row and i < r and high_column < c ) :\n            print ( mat [ i ] [ high_column ] , end = \" \" )\n            i += 1\n        high_column += 1\n        i = high_column - 2\n        while ( i >= low_column and i >= 0 and high_row < r ) :\n            print ( mat [ high_row ] [ i ] , end = \" \" )\n            i -= 1\n        high_row += 1\n        i = high_row - 2\n        while ( i > low_row and i >= 0 and low_column >= 0 ) :\n            print ( mat [ i ] [ low_column ] , end = \" \" )\n            i -= 1\n        low_column -= 1\n    print ( )"}
{"id": "PRINT_MAXIMUM_SHORTEST_DISTANCE", "code": "def find_maximum ( a , n , k ) :\n    b = dict ( )\n    for i in range ( n ) :\n        x = a [ i ]\n        d = min ( 1 + i , n - i )\n        if x not in b.keys ( ) :\n            b [ x ] = d\n        else :\n            b [ x ] = min ( d , b [ x ] )\n    ans = sys.maxsize\n    for i in range ( n ) :\n        x = a [ i ]\n        if ( x != ( k - x ) and ( k - x ) in b.keys ( ) ) :\n            ans = min ( max ( b [ x ] , b [ k - x ] ) , ans )\n    return ans"}
{"id": "PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP", "code": "def procal ( n ) :\n    return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )"}
{"id": "PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT", "code": "def assignValue ( a , b , x ) :\n    arr = [ a , b ]\n    return ( arr [ x ] )"}
{"id": "PROGRAM_AREA_SQUARE", "code": "def areaSquare ( side ) :\n    area = side * side\n    return area"}
{"id": "PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT", "code": "def bestFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        bestIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if bestIdx == - 1 :\n                    bestIdx = j\n                elif blockSize [ bestIdx ] > blockSize [ j ] :\n                    bestIdx = j\n        if bestIdx != - 1 :\n            allocation [ i ] = bestIdx\n            blockSize [ bestIdx ] -= processSize [ i ]\n    print ( \"Process No.Process Size     Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"         \" )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )"}
{"id": "PROGRAM_BINARY_DECIMAL_CONVERSION_1", "code": "def binaryToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base1 = 1\n    len1 = len ( num )\n    for i in range ( len1 - 1 , - 1 , - 1 ) :\n        if ( num [ i ] == '1' ) :\n            dec_value += base1\n        base1 = base1 * 2\n    return dec_value"}
{"id": "PROGRAM_CALCULATE_AREA_OCTAGON", "code": "def areaOctagon ( side ) :\n    return ( 2 * ( 1 + ( math.sqrt ( 2 ) ) ) * side * side )"}
{"id": "PROGRAM_CALCULATE_VOLUME_ELLIPSOID", "code": "def volumeOfEllipsoid(r1, r2, r3):\n    pi = 3.14\n    return 1.33 * pi * r1 * r2 * r3"}
{"id": "PROGRAM_CALCULATE_VOLUME_OCTAHEDRON", "code": "def vol_of_octahedron ( side ) :\n    return ( ( side * side * side ) * ( math.sqrt ( 2 ) / 3 ) )"}
{"id": "PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE", "code": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = ''\n    stars = '*' * len ( word )\n    count = 0\n    index = 0\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index += 1\n    result = ' '.join ( word_list )\n    return result"}
{"id": "PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1", "code": "def arraySortedOrNot ( arr , n ) :\n    if ( n == 0 or n == 1 ) :\n        return True\n    for i in range ( 1 , n ) :\n        if ( arr [ i - 1 ] > arr [ i ] ) :\n            return False\n    return True"}
{"id": "PROGRAM_CHECK_INPUT_INTEGER_STRING", "code": "def isNumber ( s ) :\n    for i in range ( len ( s ) ) :\n        if s [ i ].isdigit ( ) != True :\n            return False\n    return True"}
{"id": "PROGRAM_CHECK_ISBN", "code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 :\n        return False\n    _sum = 0\n    for i in range ( 9 ) :\n        if 0 <= int ( isbn [ i ] ) <= 9 :\n            _sum += int ( isbn [ i ] ) * ( 10 - i )\n        else :\n            return False\n    if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) :\n        return False\n    _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )"}
{"id": "PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING", "code": "def count ( s , c ) :\n    res = 0\n    for i in range ( len ( s ) ) :\n        if ( s [ i ] == c ) :\n            res = res + 1\n    return res"}
{"id": "PROGRAM_DECIMAL_BINARY_CONVERSION_2", "code": "def decimalToBinary ( N ) :\n    B_Number = 0\n    cnt = 0\n    while ( N != 0 ) :\n        rem = N % 2\n        c = pow ( 10 , cnt )\n        B_Number += rem * c\n        N //= 2\n        cnt += 1\n    return B_Number"}
{"id": "PROGRAM_DISTANCE_TWO_POINTS_EARTH", "code": "def distance ( lat1 , lat2 , lon1 , lon2 ) :\n    lon1 = radians ( lon1 )\n    lon2 = radians ( lon2 )\n    lat1 = radians ( lat1 )\n    lat2 = radians ( lat2 )\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2\n    c = 2 * asin ( sqrt ( a ) )\n    r = 6371\n    return ( c * r )"}
{"id": "PROGRAM_FIND_CIRCUMFERENCE_CIRCLE", "code": "def circumference ( r ) :\n    pi = 3.1415\n    return ( 2 * pi * r )"}
{"id": "PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11", "code": "def remainder ( str ) :\n    ln = len ( str )\n    rem = 0\n    for i in range ( 0 , ln ) :\n        num = rem * 10 + ( int ) ( str [ i ] )\n        rem = num % 11\n    return rem"}
{"id": "PROGRAM_FIND_SLOPE_LINE", "code": "def slope ( x1 , y1 , x2 , y2 ) :\n    return ( float ) ( y2 - y1 ) / ( x2 - x1 )"}
{"id": "PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE", "code": "def findMinimumAngle ( arr , n ) :\n    l = 0\n    _sum = 0\n    ans = 360\n    for i in range ( n ) :\n        _sum += arr [ i ]\n        while _sum >= 180 :\n            ans = min ( ans , 2 * abs ( 180 - _sum ) )\n            _sum -= arr [ l ]\n            l += 1\n        ans = min ( ans , 2 * abs ( 180 - _sum ) )\n    return ans"}
{"id": "PROGRAM_FIND_STRING_START_END_GEEKS", "code": "def isCornerPresent ( str , corner ) :\n    n = len ( str )\n    cl = len ( corner )\n    if ( n < cl ) :\n        return False\n    return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) )"}
{"id": "PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM", "code": "def Resources ( process , need ) :\n    minResources = 0\n    minResources = process * ( need - 1 ) + 1\n    return minResources"}
{"id": "PROGRAM_FOR_FACTORIAL_OF_A_NUMBER", "code": "def factorial ( n ) :\n    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )"}
{"id": "PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1", "code": "def factorial ( n ) :\n    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 )"}
{"id": "PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON", "code": "def surface_area_octahedron ( side ) :\n    return ( 2 * ( math.sqrt ( 3 ) ) * ( side * side ) )"}
{"id": "PROGRAM_OCTAL_DECIMAL_CONVERSION", "code": "def octalToDecimal ( n ) :\n    num = n\n    dec_value = 0\n    base = 1\n    temp = num\n    while ( temp ) :\n        last_digit = temp % 10\n        temp = int ( temp / 10 )\n        dec_value += last_digit * base\n        base = base * 8\n    return dec_value"}
{"id": "PROGRAM_PRINT_IDENTITY_MATRIX_1", "code": "def isIdentity ( mat , N ) :\n    for row in range ( N ) :\n        for col in range ( N ) :\n            if ( row == col and mat [ row ] [ col ] != 1 ) :\n                return False\n            elif ( row != col and mat [ row ] [ col ] != 0 ) :\n                return False\n    return True"}
{"id": "PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1", "code": "def summingSeries ( n ) :\n    return int ( math.pow ( n , 2 ) )"}
{"id": "PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE", "code": "def recursiveReverse ( str ) :\n    stack = [ ]\n    for i in range ( len ( str ) ) :\n        stack.append ( str [ i ] )\n    for i in range ( len ( str ) ) :\n        str [ i ] = stack.pop ( )"}
{"id": "PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT", "code": "def isLucky ( n ) :\n    ar = [ 0 ] * 10\n    while ( n > 0 ) :\n        digit = math.floor ( n % 10 )\n        if ( ar [ digit ] ) :\n            return False\n        ar [ digit ] = 1\n        n = int ( n / 10 )\n    return True"}
{"id": "PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC", "code": "def isSymmetric ( mat , N ) :\n    for i in range ( N ) :\n        for j in range ( N ) :\n            if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) :\n                return False\n    return True"}
{"id": "PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR", "code": "def getRemainder ( num , divisor ) :\n    return ( num - divisor * ( num // divisor ) )"}
{"id": "PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON", "code": "def findArea ( a ) :\n    area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4\n    return area"}
{"id": "PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT", "code": "def worstFit ( blockSize , m , processSize , n ) :\n    allocation = [ - 1 ] * n\n    for i in range ( n ) :\n        wstIdx = - 1\n        for j in range ( m ) :\n            if blockSize [ j ] >= processSize [ i ] :\n                if wstIdx == - 1 :\n                    wstIdx = j\n                elif blockSize [ wstIdx ] < blockSize [ j ] :\n                    wstIdx = j\n        if wstIdx != - 1 :\n            allocation [ i ] = wstIdx\n            blockSize [ wstIdx ] -= processSize [ i ]\n    print ( \"Process No.Process Size Block no.\" )\n    for i in range ( n ) :\n        print ( i + 1 , \"         \" , processSize [ i ] , end = \"     \" )\n        if allocation [ i ] != - 1 :\n            print ( allocation [ i ] + 1 )\n        else :\n            print ( \"Not Allocated\" )"}
{"id": "PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE", "code": "def Circumference ( a ) :\n    return ( 4 * a )"}
{"id": "QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE", "code": "def countInRange ( arr , n , x , y ) :\n    count = 0 ;\n    for i in range ( n ) :\n        if ( arr [ i ] >= x and arr [ i ] <= y ) :\n            count += 1\n    return count"}
{"id": "QUICK_WAY_CHECK_CHARACTERS_STRING", "code": "def allCharactersSame ( s ) :\n    n = len ( s )\n    for i in range ( 1 , n ) :\n        if s [ i ] != s [ 0 ] :\n            return False\n    return True"}
{"id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM", "code": "def rearrange ( arr , n ) :\n    temp = n * [ None ]\n    small , large = 0 , n - 1\n    flag = True\n    for i in range ( n ) :\n        if flag is True :\n            temp [ i ] = arr [ large ]\n            large -= 1\n        else :\n            temp [ i ] = arr [ small ]\n            small += 1\n        flag = bool ( 1 - flag )\n    for i in range ( n ) :\n        arr [ i ] = temp [ i ]\n    return arr"}
{"id": "REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE", "code": "def rearrange ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    for i in range ( 0 , n ) :\n        if i % 2 == 0 :\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        else :\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n    for i in range ( 0 , n ) :\n        arr [ i ] = int ( arr [ i ] / max_elem )"}
{"id": "REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH", "code": "def rearrange ( arr , n ) :\n    i = - 1\n    for j in range ( n ) :\n        if ( arr [ j ] < 0 ) :\n            i += 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    pos , neg = i + 1 , 0\n    while ( pos < n and neg < pos and arr [ neg ] < 0 ) :\n        arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ]\n        pos += 1\n        neg += 2"}
{"id": "RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM", "code": "def breakSum ( n ) :\n    if ( n == 0 or n == 1 ) :\n        return n\n    return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n )"}
{"id": "RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1", "code": "def breakSum ( n ) :\n    dp = [ 0 ] * ( n + 1 )\n    dp [ 0 ] = 0\n    dp [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i )\n    return dp [ n ]"}
{"id": "RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY", "code": "def recSearch ( arr , l , r , x ) :\n    if r < l :\n        return - 1\n    if arr [ l ] == x :\n        return l\n    if arr [ r ] == x :\n        return r\n    return recSearch ( arr , l + 1 , r - 1 , x )"}
{"id": "RECURSIVE_INSERTION_SORT", "code": "def insertionSortRecursive ( arr , n ) :\n    if n <= 1 :\n        return\n    insertionSortRecursive ( arr , n - 1 )\n    last = arr [ n - 1 ]\n    j = n - 2\n    while ( j >= 0 and arr [ j ] > last ) :\n        arr [ j + 1 ] = arr [ j ]\n        j = j - 1\n    arr [ j + 1 ] = last"}
{"id": "RECURSIVE_PROGRAM_PRIME_NUMBER", "code": "def isPrime ( n , i ) :\n    if ( n <= 2 ) :\n        return True if ( n == 2 ) else False\n    if ( n % i == 0 ) :\n        return False\n    if ( i * i > n ) :\n        return true\n    return isPrime ( n , i + 1 )"}
{"id": "REMAINDER_7_LARGE_NUMBERS", "code": "def remainderWith7 ( num ) :\n    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]\n    series_index = 0\n    result = 0\n    for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) :\n        digit = ord ( num [ i ] ) - 48\n        result += digit * series [ series_index ]\n        series_index = ( series_index + 1 ) % 6\n        result %= 7\n    if ( result < 0 ) :\n        result = ( result + 7 ) % 7\n    return result"}
{"id": "REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT", "code": "def solve ( dp , a , low , high , turn ) :\n    if ( low == high ) :\n        return a [ low ] * turn\n    if ( dp [ low ] [ high ] != 0 ) :\n        return dp [ low ] [ high ]\n    dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ;\n    return dp [ low ] [ high ]"}
{"id": "REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS", "code": "def simplify ( Str ) :\n    Len = len ( Str )\n    res = [ None ] * Len\n    index = 0\n    i = 0\n    s = [ ]\n    s.append ( 0 )\n    while ( i < Len ) :\n        if ( Str [ i ] == '+' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index += 1\n        elif ( Str [ i ] == '-' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '+'\n                index += 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = '-'\n                index += 1\n        elif ( Str [ i ] == '(' and i > 0 ) :\n            if ( Str [ i - 1 ] == '-' ) :\n                x = 0 if ( s [ - 1 ] == 1 ) else 1\n                s.append ( x )\n            elif ( Str [ i - 1 ] == '+' ) :\n                s.append ( s [ - 1 ] )\n        elif ( Str [ i ] == ')' ) :\n            s.pop ( )\n        else :\n            res [ index ] = Str [ i ]\n            index += 1\n        i += 1\n    return \"\".join(res)"}
{"id": "REMOVE_CONSECUTIVE_DUPLICATES_STRING", "code": "def removeDuplicates ( S ) :\n    n = len ( S )\n    if ( n < 2 ) :\n        return\n    j = 0\n    for i in range ( 1 , n ) :\n        if ( S [ j ] != S [ i ] ) :\n            j += 1\n            S [ j ] = S [ i ]\n    j += 1\n    S = S [ : j ]"}
{"id": "REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX", "code": "def minRemovalsDP ( arr , n ) :\n    longest_start = - 1\n    longest_end = 0\n    for start in range ( n ) :\n        min = sys.maxsize\n        max = - sys.maxsize\n        for end in range ( start , n ) :\n            val = arr [ end ]\n            if ( val < min ) :\n                min = val\n            if ( val > max ) :\n                max = val\n            if ( 2 * min <= max ) :\n                break\n            if ( end - start > longest_end - longest_start or longest_start == - 1 ) :\n                longest_start = start\n                longest_end = end\n    if ( longest_start == - 1 ) :\n        return n\n    return ( n - ( longest_end - longest_start + 1 ) )"}
{"id": "REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S", "code": "def replace ( s , c1 , c2 ) :\n    l = len ( s )\n    for i in range ( l ) :\n        if ( s [ i ] == c1 ) :\n            s = s [ 0 : i ] + c2 + s [ i + 1 : ]\n        elif ( s [ i ] == c2 ) :\n            s = s [ 0 : i ] + c1 + s [ i + 1 : ]\n    return s"}
{"id": "ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX", "code": "def countCommon ( mat , n ) :\n    res = 0\n    for i in range ( n ) :\n        if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] :\n            res = res + 1\n    return res"}
{"id": "SEARCHING_ARRAY_ADJACENT_DIFFER_K", "code": "def search ( arr , n , x , k ) :\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] == x ) :\n            return i\n        i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) )\n    print ( \"number is not present!\" )\n    return - 1"}
{"id": "SEARCH_ALMOST_SORTED_ARRAY", "code": "def binarySearch ( arr , l , r , x ) :\n    if ( r >= l ) :\n        mid = int ( l + ( r - l ) / 2 )\n        if ( arr [ mid ] == x ) : return mid\n        if ( mid > l and arr [ mid - 1 ] == x ) :\n            return ( mid - 1 )\n        if ( mid < r and arr [ mid + 1 ] == x ) :\n            return ( mid + 1 )\n        if ( arr [ mid ] > x ) :\n            return binarySearch ( arr , l , mid - 2 , x )\n        return binarySearch ( arr , mid + 2 , r , x )\n    return - 1"}
{"id": "SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1", "code": "def search ( arr , n , x ) :\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] == x ) :\n            return i\n        i = i + abs ( arr [ i ] - x )\n    print ( \"number is not present!\" )\n    return - 1"}
{"id": "SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY", "code": "def search ( arr , l , h , key ) :\n    if l > h :\n        return - 1\n    mid = ( l + h ) // 2\n    if arr [ mid ] == key :\n        return mid\n    if arr [ l ] <= arr [ mid ] :\n        if key >= arr [ l ] and key <= arr [ mid ] :\n            return search ( arr , l , mid - 1 , key )\n        return search ( arr , mid + 1 , h , key )\n    if key >= arr [ mid ] and key <= arr [ h ] :\n        return search ( arr , mid + 1 , h , key )\n    return search ( arr , l , mid - 1 , key )"}
{"id": "SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY", "code": "def binarySearch ( arr , low , high , key ) :\n    if ( high < low ) :\n        return - 1\n    mid = ( low + high ) / 2\n    if ( key == arr [ int ( mid ) ] ) :\n        return mid\n    if ( key > arr [ int ( mid ) ] ) :\n        return binarySearch ( arr , ( mid + 1 ) , high , key )\n    return ( binarySearch ( arr , low , ( mid - 1 ) , key ) )"}
{"id": "SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1", "code": "def insertSorted ( arr , n , key , capacity ) :\n    if ( n >= capacity ) :\n        return n\n    i = n - 1\n    while i >= 0 and arr [ i ] > key :\n        arr [ i + 1 ] = arr [ i ]\n        i -= 1\n    arr [ i + 1 ] = key\n    return ( n + 1 )"}
{"id": "SEGREGATE_EVEN_ODD_NUMBERS_SET_3", "code": "def arrayEvenAndOdd ( arr , n ) :\n    i = - 1\n    j = 0\n    while ( j != n ) :\n        if ( arr [ j ] % 2 == 0 ) :\n            i = i + 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n        j = j + 1\n    for i in arr :\n        print ( str ( i ) + \" \" , end = '' )"}
{"id": "SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE", "code": "def selectRandom ( x ) :\n    res = 0\n    count = 0\n    count += 1\n    if ( count == 1 ) :\n        res = x\n    else :\n        i = random.randrange ( count )\n        if ( i == count - 1 ) :\n            res = x\n    return res"}
{"id": "SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1", "code": "def getTotalNumberOfSequences ( m , n ) :\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ]\n    for i in range ( m + 1 ) :\n        for j in range ( n + 1 ) :\n            if i == 0 or j == 0 :\n                T [ i ] [ j ] = 0\n            elif i < j :\n                T [ i ] [ j ] = 0\n            elif j == 1 :\n                T [ i ] [ j ] = i\n            else :\n                T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ]\n    return T [ m ] [ n ]"}
{"id": "SHUFFLE_A_GIVEN_ARRAY", "code": "def randomize ( arr , n ) :\n    for i in range ( n - 1 , 0 , - 1 ) :\n        j = random.randint ( 0 , i + 1 )\n        arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    return arr"}
{"id": "SIZE_SUBARRAY_MAXIMUM_SUM", "code": "def maxSubArraySum ( a , size ) :\n    max_so_far = - maxsize - 1\n    max_ending_here = 0\n    start = 0\n    end = 0\n    s = 0\n    for i in range ( 0 , size ) :\n        max_ending_here += a [ i ]\n        if max_so_far < max_ending_here :\n            max_so_far = max_ending_here\n            start = s\n            end = i\n        if max_ending_here < 0 :\n            max_ending_here = 0\n            s = i + 1\n    return ( end - start + 1 )"}
{"id": "SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS", "code": "def findSmallestDifference ( A , B , m , n ) :\n    A = A [ : m ]\n    B = B [ : n ]\n    A.sort ( )\n    B.sort ( )\n    a = 0\n    b = 0\n    result = sys.maxsize\n    while ( a < m and b < n ) :\n        if ( abs ( A [ a ] - B [ b ] ) < result ) :\n            result = abs ( A [ a ] - B [ b ] )\n        if ( A [ a ] < B [ b ] ) :\n            a += 1\n        else :\n            b += 1\n    return result"}
{"id": "SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS", "code": "def smallest ( x , y , z ) :\n    c = 0\n    while ( x and y and z ) :\n        x = x - 1\n        y = y - 1\n        z = z - 1\n        c = c + 1\n    return c"}
{"id": "SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1", "code": "def smallest ( x , y , z ) :\n    if ( not int ( y / x ) ) :\n        return y if ( not int ( y / z ) ) else z\n    return x if ( not int ( x / z ) ) else z"}
{"id": "SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1", "code": "def nextPowerOf2 ( n ) :\n    p = 1\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( p < n ) :\n        p <<= 1\n    return p"}
{"id": "SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2", "code": "def nextPowerOf2 ( n ) :\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n"}
{"id": "SORT_AN_ARRAY_OF_0S_1S_AND_2S", "code": "def sort012 ( a , arr_size ) :\n    lo = 0\n    hi = arr_size - 1\n    mid = 0\n    while mid <= hi :\n        if a [ mid ] == 0 :\n            a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]\n            lo = lo + 1\n            mid = mid + 1\n        elif a [ mid ] == 1 :\n            mid = mid + 1\n        else :\n            a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]\n            hi = hi - 1"}
{"id": "SORT_ARRAY_APPLYING_GIVEN_EQUATION", "code": "def sortArray ( arr , n , A , B , C ) :\n    for i in range ( n ) :\n        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )\n    index = - ( sys.maxsize - 1 )\n    maximum = - ( sys.maxsize - 1 )\n    for i in range ( n ) :\n        if maximum < arr [ i ] :\n            index = i\n            maximum = arr [ i ]\n    i = 0\n    j = n - 1\n    new_arr = [ 0 ] * n\n    k = 0\n    while i < index and j > index :\n        if arr [ i ] < arr [ j ] :\n            new_arr [ k ] = arr [ i ]\n            k += 1\n            i += 1\n        else :\n            new_arr [ k ] = arr [ j ]\n            k += 1\n            j -= 1\n    while i < index :\n        new_arr [ k ] = arr [ i ]\n        k += 1\n        i += 1\n    while j > index :\n        new_arr [ k ] = arr [ j ]\n        k += 1\n        j -= 1\n        new_arr [ n - 1 ] = maximum\n    for i in range ( n ) :\n        arr [ i ] = new_arr [ i ]"}
{"id": "SORT_ARRAY_CONTAIN_1_N_VALUES", "code": "def sortit ( arr , n ) :\n    for i in range ( n ) :\n        arr [ i ] = i + 1"}
{"id": "SORT_ARRAY_TWO_HALVES_SORTED", "code": "def mergeTwoHalf ( A , n ) :\n    A.sort ( )"}
{"id": "SORT_ARRAY_WAVE_FORM_2_1", "code": "def sortInWave ( arr , n ) :\n    for i in range ( 0 , n , 2 ) :\n        if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) :\n            arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ]\n        if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) :\n            arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]"}
{"id": "SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1", "code": "def twoWaySort ( arr , n ) :\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] & 1 ) :\n            arr [ i ] *= - 1\n    arr.sort ( )\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] & 1 ) :\n            arr [ i ] *= - 1"}
{"id": "SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER", "code": "def bitonicGenerator ( arr , n ) :\n    evenArr = [ ]\n    oddArr = [ ]\n    for i in range ( n ) :\n        if ( ( i % 2 ) == 0 ) :\n            evenArr.append ( arr [ i ] )\n        else :\n            oddArr.append ( arr [ i ] )\n    evenArr = sorted ( evenArr )\n    oddArr = sorted ( oddArr )\n    oddArr = oddArr [ : : - 1 ]\n    i = 0\n    for j in range ( len ( evenArr ) ) :\n        arr [ i ] = evenArr [ j ]\n        i += 1\n    for j in range ( len ( oddArr ) ) :\n        arr [ i ] = oddArr [ j ]\n        i += 1"}
{"id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM", "code": "def KnapSack ( val , wt , n , W ) :\n    mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ]\n    i = 0\n    while i < n :\n        j = 0\n        if i % 2 == 0 :\n            while j < W :\n                j += 1\n                if wt [ i ] <= j and j - wt [ i ] < W:\n                    mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] )\n                else :\n                    mat [ 1 ] [ j ] = mat [ 0 ] [ j ]\n        else :\n            while j < W :\n                j += 1\n                if wt [ i ] <= j and j - wt [ i ] < W:\n                    mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] )\n                else :\n                    mat [ 0 ] [ j ] = mat [ 1 ] [ j ]\n        i += 1\n    if n % 2 == 0 :\n        return mat [ 0 ] [ W ]\n    else :\n        return mat [ 1 ] [ W ]"}
{"id": "SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1", "code": "def KnapSack ( val , wt , n , W ) :\n    dp = [ 0 ] * ( W + 1 )\n    for i in range ( n ) :\n        for j in range ( W , -1 , - 1 ) :\n            if j - wt [ i ] < W + 1 and j - wt [ i ] >= 0:\n                dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] )\n    return dp [ W ]"}
{"id": "SPLIT_ARRAY_ADD_FIRST_PART_END", "code": "def splitArr ( arr , n , k ) :\n    for i in range ( 0 , k ) :\n        x = arr [ 0 ]\n        for j in range ( 0 , n - 1 ) :\n            arr [ j ] = arr [ j + 1 ]\n        arr [ n - 1 ] = x"}
{"id": "SQUARED_TRIANGULAR_NUMBER_SUM_CUBES", "code": "def findS ( s ) :\n    _sum = 0\n    n = 1\n    while ( _sum < s ) :\n        _sum += n * n * n\n        n += 1\n    n -= 1\n    if _sum == s :\n        return n\n    return - 1"}
{"id": "SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS", "code": "def diagonalsquare ( mat , row , column ) :\n    print ( \"Diagonal one : \" , end = \"\" )\n    for i in range ( 0 , row ) :\n        for j in range ( 0 , column ) :\n            if ( i == j ) :\n                print ( \"{} \".format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = \"\" )\n    print ( \" \\n\\nDiagonal two : \" , end = \"\" )\n    for i in range ( 0 , row ) :\n        for j in range ( 0 , column ) :\n            if ( i + j == column - 1 ) :\n                print ( \"{} \".format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = \"\" )"}
{"id": "SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES", "code": "def findS ( s ) :\n    _sum = 0\n    n = 1\n    while ( _sum < s ) :\n        _sum += n * n\n        n += 1\n    n -= 1\n    if _sum == s :\n        return n\n    return - 1"}
{"id": "SQUARE_ROOT_OF_AN_INTEGER", "code": "def floorSqrt ( x ) :\n    if ( x == 0 or x == 1 ) :\n        return x\n    i = 1\n    result = 1\n    while ( result <= x ) :\n        i += 1\n        result = i * i\n    return i - 1"}
{"id": "SQUARE_ROOT_OF_A_PERFECT_SQUARE", "code": "def squareRoot ( n ) :\n    x = n\n    y = 1\n    e = 0.000001\n    while ( x - y > e ) :\n        x = ( x + y ) / 2\n        y = n / x\n    return x"}
{"id": "STACK_SET_3_REVERSE_STRING_USING_STACK", "code": "def reverse ( string ) :\n    string = string [ : : - 1 ]\n    return string"}
{"id": "STEINS_ALGORITHM_FOR_FINDING_GCD", "code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    if ( b == 0 ) :\n        return a\n    k = 0\n    while ( ( ( a | b ) & 1 ) == 0 ) :\n        a = a >> 1\n        b = b >> 1\n        k = k + 1\n    while ( ( a & 1 ) == 0 ) :\n        a = a >> 1\n    while ( b != 0 ) :\n        while ( ( b & 1 ) == 0 ) :\n            b = b >> 1\n        if ( a > b ) :\n            temp = a\n            a = b\n            b = temp\n        b = ( b - a )\n    return ( a << k )"}
{"id": "STEINS_ALGORITHM_FOR_FINDING_GCD_1", "code": "def gcd ( a , b ) :\n    if ( a == b ) :\n        return a\n    if ( a == 0 ) :\n        return b\n    if ( b == 0 ) :\n        return a\n    if ( ( ~ a & 1 ) == 1 ) :\n        if ( ( b & 1 ) == 1 ) :\n            return gcd ( a >> 1 , b )\n        else :\n            return ( gcd ( a >> 1 , b >> 1 ) << 1 )\n    if ( ( ~ b & 1 ) == 1 ) :\n        return gcd ( a , b >> 1 )\n    if ( a > b ) :\n        return gcd ( ( a - b ) >> 1 , b )\n    return gcd ( ( b - a ) >> 1 , a )"}
{"id": "STOOGE_SORT", "code": "def stoogesort ( arr , l , h ) :\n    if l >= h :\n        return\n    if arr [ l ] > arr [ h ] :\n        t = arr [ l ]\n        arr [ l ] = arr [ h ]\n        arr [ h ] = t\n    if h - l + 1 > 2 :\n        t = ( int ) ( ( h - l + 1 ) / 3 )\n        stoogesort ( arr , l , ( h - t ) )\n        stoogesort ( arr , l + t , ( h ) )\n        stoogesort ( arr , l , ( h - t ) )"}
{"id": "STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES", "code": "def firstLetterWord ( str ) :\n    result = \"\"\n    v = True\n    for i in range ( len ( str ) ) :\n        if ( str [ i ] == ' ' ) :\n            v = True\n        elif ( str [ i ] != ' ' and v == True ) :\n            result += ( str [ i ] )\n            v = False\n    return result"}
{"id": "SUBARRAYS_DISTINCT_ELEMENTS", "code": "def sumoflength ( arr , n ) :\n    s = [ ]\n    j = 0\n    ans = 0\n    for i in range ( n ) :\n        while ( j < n and ( arr [ j ] not in s ) ) :\n            s.append ( arr [ j ] )\n            j += 1\n        ans += ( ( j - i ) * ( j - i + 1 ) ) // 2\n        s.remove ( arr [ i ] )\n    return ans"}
{"id": "SUBSET_SUM_PROBLEM_OSUM_SPACE", "code": "def isSubsetSum ( arr , n , sum ) :\n    subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( sum + 1 ) :\n            if ( j == 0 ) :\n                subset [ i % 2 ] [ j ] = True\n            elif ( i == 0 ) :\n                subset [ i % 2 ] [ j ] = False\n            elif ( arr [ i - 1 ] <= j ) :\n                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ]\n            else :\n                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ]\n    return subset [ n % 2 ] [ sum ]"}
{"id": "SUM_AREA_RECTANGLES_POSSIBLE_ARRAY", "code": "def MaxTotalRectangleArea ( a , n ) :\n    a = a [ : n ]\n    a.sort (  )\n    sum = 0\n    flag = False\n    len = 0\n    i = 0\n    while ( i < n - 1 ) :\n        if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) :\n            flag = True\n            len = a [ i + 1 ]\n            i = i + 1\n        elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) :\n            sum = sum + a [ i + 1 ] * len\n            flag = False\n            i = i + 1\n        i += 1\n    return sum"}
{"id": "SUM_BINOMIAL_COEFFICIENTS", "code": "def binomialCoeffSum ( n ) :\n    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        sum += C [ n ] [ i ]\n    return sum"}
{"id": "SUM_BINOMIAL_COEFFICIENTS_1", "code": "def binomialCoeffSum ( n ) :\n    return ( 1 << n )"}
{"id": "SUM_DIVISORS_1_N_1", "code": "def divisorSum ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        sum += int ( n / i ) * i\n    return int ( sum )"}
{"id": "SUM_FACTORS_NUMBER", "code": "def divSum ( n ) :\n    result = 0\n    for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :\n        if ( n % i == 0 ) :\n            if ( i == ( n / i ) ) :\n                result = result + i\n            else :\n                result = result + ( i + n // i )\n    return ( result + n + 1 )"}
{"id": "SUM_FIBONACCI_NUMBERS", "code": "def calculateSum ( n ) :\n    if ( n <= 0 ) :\n        return 0\n    fibo = [ 0 ] * ( n + 1 )\n    fibo [ 1 ] = 1\n    sm = fibo [ 0 ] + fibo [ 1 ]\n    for i in range ( 2 , n + 1 ) :\n        fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]\n        sm = sm + fibo [ i ]\n    return sm"}
{"id": "SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS", "code": "def kthgroupsum ( k ) :\n    cur = int ( ( k * ( k - 1 ) ) + 1 )\n    sum = 0\n    while k :\n        sum += cur\n        cur += 2\n        k = k - 1\n    return sum"}
{"id": "SUM_MANHATTAN_DISTANCES_PAIRS_POINTS", "code": "def distancesum ( x , y , n ) :\n    sum = 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) )\n    return sum"}
{"id": "SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS", "code": "def findSum ( n ) :\n    arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        for j in range ( n ) :\n            arr [ i ] [ j ] = abs ( i - j )\n    sum = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            sum += arr [ i ] [ j ]\n    return sum"}
{"id": "SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2", "code": "def findSum ( n ) :\n    n -= 1\n    sum = 0\n    sum += ( n * ( n + 1 ) ) / 2\n    sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6\n    return int ( sum )"}
{"id": "SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1", "code": "def findSum ( n ) :\n    ans = 0\n    temp = 0\n    for i in range ( 1 , n + 1 ) :\n        if temp < n :\n            temp = i - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans += i * num\n                else :\n                    ans += ( n - temp ) * num\n                temp += i\n                num += 1\n    return ans"}
{"id": "SUM_MIDDLE_ROW_COLUMN_MATRIX", "code": "def middlesum ( mat , n ) :\n    row_sum = 0\n    col_sum = 0\n    for i in range ( n ) :\n        row_sum += mat [ n // 2 ] [ i ]\n    print ( \"Sum of middle row = \" , row_sum )\n    for i in range ( n ) :\n        col_sum += mat [ i ] [ n // 2 ]\n    print ( \"Sum of middle column = \" , col_sum )"}
{"id": "SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING", "code": "def sumAtKthLevel ( tree , k ) :\n    level = - 1\n    sum = 0\n    n = len ( tree )\n    for i in range ( n ) :\n        if ( tree [ i ] == '(' ) :\n            level += 1\n        elif ( tree [ i ] == ')' ) :\n            level -= 1\n        else :\n            if ( level == k ) :\n                sum += ( ord ( tree [ i ] ) - ord ( '0' ) )\n    return sum"}
{"id": "SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1", "code": "def calculateSum ( n ) :\n    sum = 0\n    sum = 1 << n\n    return ( sum - 1 )"}
{"id": "SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER", "code": "def sumOfSubstrings ( num ) :\n    n = len ( num )\n    sumofdigit = [ ]\n    sumofdigit.append ( ord ( num [ 0 ] ) - ord('0') )\n    res = sumofdigit [ 0 ]\n    for i in range ( 1 , n ) :\n        numi = ord ( num [ i ] ) - ord ( '0' )\n        sumofdigit.append ( ( i + 1 ) + numi + 10 + sumofdigit [ i - 1 ] )\n        res += sumofdigit [ i ]\n    return res"}
{"id": "SUM_PAIRWISE_PRODUCTS", "code": "def findSum ( n ) :\n    sm = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( i , n + 1 ) :\n            sm = sm + i * j\n    return sm"}
{"id": "SUM_PAIRWISE_PRODUCTS_1", "code": "def findSum ( n ) :\n    multiTerms = n * ( n + 1 ) // 2\n    sm = multiTerms\n    for i in range ( 2 , n + 1 ) :\n        multiTerms = multiTerms - ( i - 1 )\n        sm = sm + multiTerms * i\n    return sm"}
{"id": "SUM_PAIRWISE_PRODUCTS_2", "code": "def findSum ( n ) :\n    return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24"}
{"id": "SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS", "code": "def sumOfSeries ( n ) :\n    return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) )"}
{"id": "SUM_SERIES_12_32_52_2N_12", "code": "def sumOfSeries ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 )\n    return sum"}
{"id": "SUM_SERIES_23_45_67_89_UPTO_N_TERMS", "code": "def seriesSum ( n ) :\n    i = 1\n    res = 0.0\n    sign = True\n    while ( n > 0 ) :\n        n = n - 1\n        if ( sign ) :\n            sign = False\n            res = res + ( i + 1 ) / ( i + 2 )\n            i = i + 2\n        else :\n            sign = True\n            res = res - ( i + 1 ) / ( i + 2 )\n            i = i + 2\n    return res"}
{"id": "SUM_SQUARES_BINOMIAL_COEFFICIENTS", "code": "def sumofsquare ( n ) :\n    C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )\n    return sum"}
{"id": "SUM_TWO_LARGE_NUMBERS", "code": "def findSum(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    for i in range(n1):\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = int(sum / 10)\n    for i in range(n1, n2):\n        sum = ((ord(str2[i]) - 48) + carry)\n        if sum < 0:\n            str += chr(sum % -10 + 48)\n        else:\n            str += chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n    if (carry):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str"}
{"id": "SWAP_BITS_IN_A_GIVEN_NUMBER", "code": "def swapBits ( x , p1 , p2 , n ) :\n    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )\n    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )\n    xor = ( set1 ^ set2 )\n    xor = ( xor << p1 ) | ( xor << p2 )\n    result = x ^ xor\n    return result"}
{"id": "SWAP_TWO_NIBBLES_BYTE", "code": "def swapNibbles ( x ) :\n    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )"}
{"id": "SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE", "code": "def swap ( xp , yp ) :\n    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\n    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\n    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]"}
{"id": "TEMPLE_OFFERINGS", "code": "def offeringNumber ( n , templeHeight ) :\n    sum = 0\n    for i in range ( n ) :\n        left = 0\n        right = 0\n        for j in range ( i - 1 , - 1 , - 1 ) :\n            if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) :\n                left += 1\n            else :\n                break\n        for j in range ( i + 1 , n ) :\n            if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) :\n                right += 1\n            else :\n                break\n        sum += max ( right , left ) + 1\n    return sum"}
{"id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS", "code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( \" Invalid Input \" )\n        return\n    first = arr [ 0 ]\n    for i in range ( 1 , arr_size ) :\n        if ( arr [ i ] > first ) :\n            first = arr [ i ]\n    second = - sys.maxsize\n    for i in range ( 0 , arr_size ) :\n        if ( arr [ i ] > second and arr [ i ] < first ) :\n            second = arr [ i ]\n    third = - sys.maxsize\n    for i in range ( 0 , arr_size ) :\n        if ( arr [ i ] > third and arr [ i ] < second ) :\n            third = arr [ i ]\n    print ( \"The Third Largest\" , \"element is\" , third )"}
{"id": "THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1", "code": "def thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( \" Invalid Input \" )\n        return\n    first = arr [ 0 ]\n    second = - sys.maxsize\n    third = - sys.maxsize\n    for i in range ( 1 , arr_size ) :\n        if ( arr [ i ] > first ) :\n            third = second\n            second = first\n            first = arr [ i ]\n        elif ( arr [ i ] > second ) :\n            third = second\n            second = arr [ i ]\n        elif ( arr [ i ] > third ) :\n            third = arr [ i ]\n    print ( \"The third Largest\" , \"element is\" , third )"}
{"id": "TILING_WITH_DOMINOES", "code": "def countWays ( n ) :\n    A = [ 0 ] * ( n + 1 )\n    B = [ 0 ] * ( n + 1 )\n    A [ 0 ] = 1\n    A [ 1 ] = 0\n    B [ 0 ] = 0\n    B [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]\n        B [ i ] = A [ i - 1 ] + B [ i - 2 ]\n    return A [ n ]"}
{"id": "TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1", "code": "def countNonDecreasing ( n ) :\n    N = 10\n    count = 1\n    for i in range ( 1 , n + 1 ) :\n        count = int ( count * ( N + i - 1 ) )\n        count = int ( count / i )\n    return count"}
{"id": "TRIANGULAR_MATCHSTICK_NUMBER", "code": "def numberOfSticks ( x ) :\n    return ( 3 * x * ( x + 1 ) ) / 2"}
{"id": "TRIANGULAR_NUMBERS", "code": "def isTriangular ( num ) :\n    if ( num < 0 ) :\n        return False\n    sum , n = 0 , 1\n    while ( sum <= num ) :\n        sum = sum + n\n        if ( sum == num ) :\n            return True\n        n += 1\n    return False"}
{"id": "TURN_OFF_THE_RIGHTMOST_SET_BIT", "code": "def fun ( n ) :\n    return n & ( n - 1 )"}
{"id": "UNIQUE_CELLS_BINARY_MATRIX", "code": "def countUnique ( mat , n , m ) :\n    rowsum = [ 0 ] * n\n    colsum = [ 0 ] * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( mat [ i ] [ j ] != 0 ) :\n                rowsum [ i ] += 1\n                colsum [ j ] += 1\n    uniquecount = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) :\n                uniquecount += 1\n    return uniquecount"}
{"id": "WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO", "code": "def xorZero ( str ) :\n    one_count = 0\n    zero_count = 0\n    n = len ( str )\n    for i in range ( 0 , n , 1 ) :\n        if ( str [ i ] == '1' ) :\n            one_count += 1\n        else :\n            zero_count += 1\n    if ( one_count % 2 == 0 ) :\n        return zero_count\n    return one_count"}
{"id": "WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS", "code": "def CountWays ( n ) :\n    table = [ 0 ] * ( n + 1 )\n    table [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        for j in range ( i , n + 1 ) :\n            table [ j ] += table [ j - i ]\n    return table [ n ]"}
{"id": "WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS", "code": "def countTransformation ( a , b ) :\n    n = len ( a )\n    m = len ( b )\n    if m == 0 :\n        return 1\n    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]\n    for i in range ( m ) :\n        for j in range ( i , n ) :\n            if i == 0 :\n                if j == 0 :\n                    if a [ j ] == b [ i ] :\n                        dp [ i ] [ j ] = 1\n                    else :\n                        dp [ i ] [ j ] = 0\n                elif a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n            else :\n                if a [ j ] == b [ i ] :\n                    dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] )\n                else :\n                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n    return dp [ m - 1 ] [ n - 1 ]"}
{"id": "WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3", "code": "def isMultipleOf3 ( n ) :\n    odd_count = 0\n    even_count = 0\n    if ( n < 0 ) :\n        n = - n\n    if ( n == 0 ) :\n        return 1\n    if ( n == 1 ) :\n        return 0\n    while ( n ) :\n        if ( n & 1 ) :\n            odd_count += 1\n        if ( n & 2 ) :\n            even_count += 1\n        n = n >> 2\n    return isMultipleOf3 ( abs ( odd_count - even_count ) )"}
{"id": "WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO", "code": "def isPowerOfTwo ( n ) :\n    if ( n == 0 ) :\n        return False\n    while ( n != 1 ) :\n        if ( n % 2 != 0 ) :\n            return False\n        n = n // 2\n    return True"}
{"id": "WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO_1", "code": "def isPowerOfTwo ( x ) :\n    return ( x and ( not ( x & ( x - 1 ) ) ) )"}
{"id": "ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION", "code": "def nearestSmallerEqFib ( n ) :\n    if ( n == 0 or n == 1 ) :\n        return n\n    f1 , f2 , f3 = 0 , 1 , 1\n    while ( f3 <= n ) :\n        f1 = f2 \n        f2 = f3 \n        f3 = f1 + f2 \n    return f2 "}
